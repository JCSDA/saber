/*
 * (C) Copyright 2021-2023 UCAR
 * (C) Copyright 2023 Meteorologisk Institutt
 *
 * This software is licensed under the terms of the Apache Licence Version 2.0
 * which can be obtained at http://www.apache.org/licenses/LICENSE-2.0.
 */

#pragma once

#include <omp.h>

#include <memory>
#include <sstream>
#include <string>
#include <vector>

#include "eckit/config/Configuration.h"

#include "oops/base/Geometry.h"
#include "oops/base/Increment.h"
#include "oops/base/IncrementEnsemble.h"
#include "oops/base/instantiateCovarFactory.h"
#include "oops/base/ModelSpaceCovarianceBase.h"
#include "oops/base/PostProcessor.h"
#include "oops/base/State.h"
#include "oops/base/StateWriter.h"
#include "oops/base/Variables.h"
#include "oops/mpi/mpi.h"
#include "oops/runs/Application.h"
#include "oops/util/abor1_cpp.h"
#include "oops/util/ConfigFunctions.h"
#include "oops/util/DateTime.h"
#include "oops/util/FieldSetHelpers.h"
#include "oops/util/Logger.h"
#include "oops/util/parameters/OptionalParameter.h"
#include "oops/util/parameters/Parameter.h"
#include "oops/util/parameters/Parameters.h"
#include "oops/util/parameters/RequiredParameter.h"

namespace saber {

// -----------------------------------------------------------------------------

/// \brief Top-level options taken by the ErrorCovarianceToolbox application.
template <typename MODEL> class ErrorCovarianceToolboxParameters :
  public oops::ApplicationParameters {
  OOPS_CONCRETE_PARAMETERS(ErrorCovarianceToolboxParameters, oops::ApplicationParameters)

 public:
  typedef oops::ModelSpaceCovarianceParametersWrapper<MODEL> CovarianceParameters_;
  typedef typename oops::Geometry<MODEL>::Parameters_        GeometryParameters_;
  typedef oops::StateParametersND<MODEL>                     StateParametersND_;
  typedef oops::State<MODEL>                                 State_;
  typedef oops::StateWriterParameters<State_>                StateWriterParameters_;
  typedef typename oops::Increment<MODEL>::WriteParameters_  IncrementWriterParameters_;

  /// Geometry parameters.
  oops::RequiredParameter<GeometryParameters_> geometry{"geometry", this};

  /// Background parameters.
  oops::RequiredParameter<StateParametersND_> background{"background", this};

  /// Background error covariance model.
  oops::RequiredParameter<CovarianceParameters_> backgroundError{"background error", this};

  /// Dirac location/variables parameters.
  oops::OptionalParameter<eckit::LocalConfiguration> dirac{"dirac", this};

  /// Diagnostic location/variables parameters.
  oops::OptionalParameter<eckit::LocalConfiguration> diagnostic{"diagnostic points", this};

  /// Where to write the output(s) of Dirac tests
  oops::OptionalParameter<StateWriterParameters_> outputDirac{"output dirac", this};

  /// Whether and where to write the perturbations generated by the randomization.
  oops::OptionalParameter<IncrementWriterParameters_> outputPerturbations{"output perturbations",
    this};

  /// Whether and where to write the states generated by the randomization.
  oops::OptionalParameter<StateWriterParameters_> outputStates{"output states", this};

  /// Where to write the output of randomized variance.
  oops::OptionalParameter<IncrementWriterParameters_> outputVariance{"output variance", this};
};

// -----------------------------------------------------------------------------

template <typename MODEL> class ErrorCovarianceToolbox : public oops::Application {
  typedef oops::ModelSpaceCovarianceBase<MODEL>           CovarianceBase_;
  typedef oops::CovarianceFactory<MODEL>                  CovarianceFactory_;
  typedef oops::ModelSpaceCovarianceParametersBase<MODEL> CovarianceParametersBase_;
  typedef oops::Geometry<MODEL>                           Geometry_;
  typedef oops::Increment<MODEL>                          Increment_;
  typedef oops::State<MODEL>                              State_;
  typedef oops::StateWriterParameters<State_>             StateWriterParameters_;
  typedef typename Increment_::WriteParameters_           IncrementWriterParameters_;
  typedef oops::Localization<MODEL>                       Localization_;
  typedef ErrorCovarianceToolboxParameters<MODEL>         ErrorCovarianceToolboxParameters_;

 public:
// -----------------------------------------------------------------------------
  explicit ErrorCovarianceToolbox(const eckit::mpi::Comm & comm = oops::mpi::world()) :
    Application(comm) {
    oops::instantiateCovarFactory<MODEL>();
  }
// -----------------------------------------------------------------------------
  virtual ~ErrorCovarianceToolbox() {}
// -----------------------------------------------------------------------------
  int execute(const eckit::Configuration & fullConfig, bool validate) const override {
    // Deserialize parameters
    ErrorCovarianceToolboxParameters_ params;
    if (validate) params.validate(fullConfig);
    params.deserialize(fullConfig);

    // Define number of subwindows
    const eckit::LocalConfiguration backgroundConfig(fullConfig, "background");
    size_t nslots = 1;
    if (backgroundConfig.has("states")) {
      std::vector<eckit::LocalConfiguration> confs;
      backgroundConfig.get("states", confs);
      nslots = confs.size();
    }

    // Define space and time communicators
    const eckit::mpi::Comm * commSpace = &this->getComm();
    const eckit::mpi::Comm * commTime = &oops::mpi::myself();
    if (nslots > 1) {
      size_t ntasks = this->getComm().size();
      ASSERT(ntasks % nslots == 0);
      size_t myrank = this->getComm().rank();
      size_t ntaskpslot = ntasks / nslots;
      size_t myslot = myrank / ntaskpslot;

      // Create a communicator for same sub-window, to be used for communications in space
      std::string sgeom = "comm_geom_" + std::to_string(myslot);
      char const *geomName = sgeom.c_str();
      commSpace = &this->getComm().split(myslot, geomName);
      ASSERT(commSpace->size() == ntaskpslot);

      // Create a communicator for same local area, to be used for communications in time
      size_t myarea = commSpace->rank();
      std::string stime = "comm_time_" + std::to_string(myarea);
      char const *timeName = stime.c_str();
      commTime = &this->getComm().split(myarea, timeName);
      ASSERT(commTime->size() == nslots);
    }

    // Get number of MPI tasks and OpenMP threads
    size_t ntasks = commSpace->size();
    size_t nthreads = 1;
#ifdef _OPENMP
    # pragma omp parallel
    {
      nthreads = omp_get_num_threads();
    }
#endif

    // Replace patterns in full configuration and deserialize parameters
    eckit::LocalConfiguration fullConfigUpdated(fullConfig);
    util::seekAndReplace(fullConfigUpdated, "_MPI_", std::to_string(ntasks));
    util::seekAndReplace(fullConfigUpdated, "_OMP_", std::to_string(nthreads));
    params.deserialize(fullConfigUpdated);

    // Setup geometry
    const Geometry_ geom(params.geometry, *commSpace, *commTime);

    // Setup background
    const State_ xx(geom, params.background);

    // Setup variables
    const oops::Variables vars = xx.variables();

    // Setup time
    util::DateTime time = xx.validTime();

    // Background error covariance parameters
    const CovarianceParametersBase_ & covarParams
      = params.backgroundError.value().covarianceParameters;

    // Dirac test
    const auto & diracParams = params.dirac.value();
    if (diracParams != boost::none) {
      // Setup Dirac field
      Increment_ dxi(geom, vars, time);
      dxi.dirac(*diracParams);
      oops::Log::test() << "Input Dirac increment:" << dxi << std::endl;

      // Test configuration
      eckit::LocalConfiguration testConf;

      // Add dirac configuration
      testConf.set("dirac", *diracParams);

      // Add diagnostic print configuration
      const auto & diagnostic = params.diagnostic.value();
      if (diagnostic != boost::none) {
        testConf.set("diagnostic points", *diagnostic);
      }

      // Dirac output parameters
      const auto & outputDirac = params.outputDirac.value();

      // Update parameters
      auto outputDiracUpdated(outputDirac->write);
      setMPI(outputDiracUpdated, ntasks);

      // Add output Dirac configuration
      eckit::LocalConfiguration outputConf(outputDiracUpdated.toConfiguration());
      testConf.set("output dirac", outputConf);

      // Apply B matrix components recursively
      std::string id;
      dirac(covarParams.toConfiguration(), testConf, id, xx, dxi);
    }

    const auto & randomizationSize = covarParams.randomizationSize.value();
    if ((diracParams == boost::none) || (randomizationSize != boost::none)) {
      // Background error covariance training
      std::unique_ptr<CovarianceBase_> Bmat(CovarianceFactory_::create(
                                            geom, vars, covarParams, xx, xx));

      // Randomization
      randomization(params, xx, Bmat, ntasks);
    }

    return 0;
  }
// -----------------------------------------------------------------------------
  void outputSchema(const std::string & outputPath) const override {
    ErrorCovarianceToolboxParameters_ params;
    params.outputSchema(outputPath);
  }
// -----------------------------------------------------------------------------
  void validateConfig(const eckit::Configuration & fullConfig) const override {
    ErrorCovarianceToolboxParameters_ params;
    params.validate(fullConfig);
  }
// -----------------------------------------------------------------------------
 private:
  std::string appname() const override {
    return "oops::ErrorCovarianceToolbox<" + MODEL::name() + ">";
  }
// -----------------------------------------------------------------------------
  void print_value_at_positions(const eckit::LocalConfiguration & diagConf,
                                const Increment_ & data) const {
    oops::Log::trace() << appname() << "::print_value_at_position starting" << std::endl;

    // Create diagnostic field
    Increment_ diagPoints(data);
    diagPoints.dirac(diagConf);

    // Get diagnostic values
    util::printDiagValues(data.geometry().timeComm(),
                          data.geometry().getComm(),
                          data.geometry().functionSpace(),
                          data.fieldSet(),
                          diagPoints.fieldSet());

    oops::Log::trace() << appname() << "::print_value_at_position done" << std::endl;
  }
// -----------------------------------------------------------------------------
  void dirac(const eckit::LocalConfiguration & covarConfig,
             const eckit::LocalConfiguration & testConfig,
             std::string & id,
             const State_ & xx,
             const Increment_ & dxi) const {
    // Define output increment
    Increment_ dxo(dxi, false);

    // Covariance
    std::unique_ptr<CovarianceBase_> Bmat(CovarianceFactory_::create(
        xx.geometry(), xx.variables(), covarConfig, xx, xx));

    // Multiply
    Bmat->multiply(dxi, dxo);

    // Update ID
    if (id != "") id.append("_");
    id.append(Bmat->covarianceModel());

    if (testConfig.has("diagnostic points")) {
      oops::Log::test() << "Covariance(" << id << ") diagnostics:" << std::endl;

      // Print variances
      oops::Log::test() << "- Variances at Dirac points:" << std::endl;
      print_value_at_positions(testConfig.getSubConfiguration("dirac"), dxo);

      // Print covariances
      const auto & diagnosticConfig = testConfig.getSubConfiguration("diagnostic points");
      if (!diagnosticConfig.empty()) {
        oops::Log::test() << "- Covariances at diagnostic points:" << std::endl;
        print_value_at_positions(diagnosticConfig, dxo);
      }
    }

    // Copy configuration
    eckit::LocalConfiguration outputBConf(testConfig.getSubConfiguration("output dirac"));

    // Seek and replace %id% with id, recursively
    util::seekAndReplace(outputBConf, "%id%", id);

    // Write output increment
    dxo.write(outputBConf);
    oops::Log::test() << "Covariance(" << id << ") * Increment:" << dxo << std::endl;

    // Look for hybrid or ensemble covariance models
    const std::string covarianceModel(covarConfig.getString("covariance model"));
    if (covarianceModel == "hybrid") {
      std::vector<eckit::LocalConfiguration> confs;
      covarConfig.get("components", confs);
      size_t componentIndex(1);
      for (const auto & conf : confs) {
        std::string idC(id + std::to_string(componentIndex));
        const eckit::LocalConfiguration componentConfig(conf, "covariance");
        dirac(componentConfig, testConfig, idC, xx, dxi);
        ++componentIndex;
      }
    }
    if (covarianceModel == "ensemble" && covarConfig.has("localization")) {
      // Localization configuration
      eckit::LocalConfiguration locConfig(covarConfig.getSubConfiguration("localization"));
      locConfig.set("date", xx.validTime().toString());

      // Define output increment
      Increment_ dxo(dxi);

      // Setup localization
      Localization_ Lmat(xx.geometry(), xx.variables(), locConfig);

      // Apply localization
      Lmat.multiply(dxo);

      // Update ID
      std::string idL(id);
      idL.append("_localization");

      if (testConfig.has("diagnostic points")) {
        const auto & diagnosticConfig = testConfig.getSubConfiguration("diagnostic points");
        if (!diagnosticConfig.empty()) {
          oops::Log::test() << "Localization(" << idL << ") diagnostics:" << std::endl;
          // Print localization
          oops::Log::test() << "- Localization at diagnostic points:" << std::endl;
          print_value_at_positions(diagnosticConfig, dxo);
        }
      }

      // Copy configuration
      eckit::LocalConfiguration outputLConf(testConfig.getSubConfiguration("output dirac"));

      // Seek and replace %id% with id, recursively
      util::seekAndReplace(outputLConf, "%id%", idL);

      // Write output increment
      dxo.write(outputLConf);
      oops::Log::test() << "Localization(" << id << ") * Increment:" << dxo << std::endl;
    }
  }
// -----------------------------------------------------------------------------
  void randomization(const ErrorCovarianceToolboxParameters_ & params,
                     const State_ & xx,
                     const std::unique_ptr<CovarianceBase_> & Bmat,
                     const size_t & ntasks) const {
    if (Bmat->randomizationSize() > 0) {
      // Create increments
      Increment_ dx(xx.geometry(), xx.variables(), xx.validTime());
      Increment_ dxsq(xx.geometry(), xx.variables(), xx.validTime());
      Increment_ variance(xx.geometry(), xx.variables(), xx.validTime());

      // Initialize variance
      variance.zero();

      // Create empty ensemble
      std::vector<Increment_> ens;

      // Output options
      const auto & outputPerturbations = params.outputPerturbations.value();
      const auto & outputStates = params.outputStates.value();
      const auto & outputVariance = params.outputVariance.value();

      for (size_t jm = 0; jm < Bmat->randomizationSize(); ++jm) {
        // Generate member
        Bmat->randomize(dx);

        if ((outputPerturbations != boost::none) || (outputStates != boost::none)) {
          // Save member
          ens.push_back(dx);
        }

        // Square perturbation
        dxsq = dx;
        dxsq.schur_product_with(dx);

        // Update variance
        variance += dxsq;
      }

      if ((outputPerturbations != boost::none) || (outputStates != boost::none)) {
        for (size_t jm = 0; jm < Bmat->randomizationSize(); ++jm) {
          oops::Log::test() << "Member " << jm << ": " << ens[jm] << std::endl;

          if (outputPerturbations != boost::none) {
            // Update parameters
            auto outputPerturbationsUpdated = *outputPerturbations;
            outputPerturbationsUpdated.setMember(jm+1);
            setMPI(outputPerturbationsUpdated, ntasks);

            // Write perturbation
            ens[jm].write(outputPerturbationsUpdated);
          }

          if (outputStates != boost::none) {
            // Update parameters
            auto outputStatesUpdated = outputStates->write;
            outputStatesUpdated.setMember(jm+1);
            setMPI(outputStatesUpdated, ntasks);

            // Add background state to perturbation
            State_ xp(xx);
            xp += ens[jm];

            // Write state
            xp.write(outputStatesUpdated);
          }
        }
      }

      if (outputVariance != boost::none) {
        if (Bmat->randomizationSize() > 1) {
          // Normalize variance
          double rk_norm = 1.0/static_cast<double>(Bmat->randomizationSize());
          variance *= rk_norm;
        }

        // Update parameters
        auto outputVarianceUpdated = *outputVariance;
        setMPI(outputVarianceUpdated, ntasks);

        // Write variance
        variance.write(outputVarianceUpdated);
        oops::Log::test() << "Randomized variance: " << variance << std::endl;
      }
    }
  }
// -----------------------------------------------------------------------------
  void setMPI(oops::WriteParametersBase & params,
              const int & mpi) const {
    oops::Log::trace() << appname() << "::setMPI starting" << std::endl;

    eckit::LocalConfiguration conf = params.toConfiguration();
    if (conf.has("mpi pattern")) {
      std::string mpiPattern = conf.getString("mpi pattern");
      util::seekAndReplace(conf, mpiPattern, std::to_string(mpi));
    }
    params.validateAndDeserialize(conf);

    oops::Log::trace() << appname() << "::setMPI done" << std::endl;
  }
// -----------------------------------------------------------------------------
};

}  // namespace saber
