#:include '../instrumentation.fypp'
!----------------------------------------------------------------------
! Module: tools_ssrfpack
!> SSRFPACK routines
! Source: https://dl.acm.org/doi/abs/10.1145/275323.275330
! Author: Robert Renka
! Original licensing: none
! Modified by Benjamin Menetrier for BUMP
! Licensing: this code is distributed under the CeCILL-C license
! Copyright 2015-... UCAR, CERFACS, METEO-FRANCE and IRIT
!----------------------------------------------------------------------
module tools_ssrfpack

use tools_const, only: zero,one,four,hundred,pi
use tools_kinds, only: kind_real
use tools_repro, only: eq,inf,sup,supeq,small
use tools_stripack
use type_mpl, only: mpl_type
@:use_probe()

implicit none

interface aplyr
   module procedure ssrfpack_aplyr
end interface
interface aplyrt
   module procedure ssrfpack_aplyrt
end interface
interface arcint
   module procedure ssrfpack_arcint
end interface
interface arcint_ori
   module procedure ssrfpack_arcint_ori
end interface
interface arclen
   module procedure ssrfpack_arclen
end interface
interface constr
   module procedure ssrfpack_constr
end interface
interface fval
   module procedure ssrfpack_fval
end interface
interface fval_ori
   module procedure ssrfpack_fval_ori
end interface
interface givens
   module procedure ssrfpack_givens
end interface
interface gradl
   module procedure ssrfpack_gradl
end interface
interface hval
   module procedure ssrfpack_hval
end interface
interface rotate
   module procedure ssrfpack_rotate
end interface
interface setup
   module procedure ssrfpack_setup
end interface

!private TODO
public !:: gradl,fval TODO

contains

SUBROUTINE ssrfpack_aplyr (X,Y,Z,CX,SX,CY,SY, XP,YP,ZP)
real(kind_real) ::  X, Y, Z, CX, SX, CY, SY, XP, YP, ZP
!
!***********************************************************
!
!                                              From SSRFPACK
!                                            Robert J. Renka
!                                  Dept. of Computer Science
!                                       Univ. of North Texas
!                                           renka@cs.unt.edu
!                                                   05/09/92
!
!   This subroutine applies the rotation R defined by Sub-
! routine CONSTR to the unit vector (X Y Z)**T, i,e. (X,Y,Z)
! is rotated to (XP,YP,ZP).  If (XP,YP,ZP) lies in the
! southern hemisphere (ZP < 0), (XP,YP) are set to the
! coordinates of the nearest point of the equator, ZP re-
! maining unchanged.
!
! On input:
!
!       X,Y,Z = Coordinates of a point on the unit sphere.
!
!       CX,SX,CY,SY = Elements of the rotation defined by
!                     Subroutine CONSTR.
!
! Input parameters are not altered except as noted below.
!
! On output:
!
!       XP,YP,ZP = Coordinates of the rotated point on the
!                  sphere unless ZP < 0, in which case
!                  (XP,YP,0) is the closest point of the
!                  equator to the rotated point.  Storage
!                  for XP, YP, and ZP may coincide with
!                  storage for X, Y, and Z, respectively,
!                  if the latter need not be saved.
!
! Modules required by APLYR:  None
!
! Intrinsic function called by APLYR:  SQRT
!
!***********************************************************
!
real(kind_real) ::  T
!
! Local parameter:
!
! T = Temporary variable
!
T = SX*Y + CX*Z
YP = CX*Y - SX*Z
ZP = SY*X + CY*T
XP = CY*X - SY*T
IF (ZP .GE. 0.) RETURN
!
! Move (XP,YP,ZP) to the equator.
!
T = SQRT(XP*XP + YP*YP)
IF (T .EQ. 0.) GO TO 1
XP = XP/T
YP = YP/T
RETURN
!
! Move the south pole to an arbitrary point of the equator.
!
    1 XP = 1.
YP = 0.
RETURN

end subroutine ssrfpack_aplyr







SUBROUTINE ssrfpack_aplyrt (G1P,G2P,CX,SX,CY,SY, G)
real(kind_real) ::  G1P, G2P, CX, SX, CY, SY, G(3)
!
!***********************************************************
!
!                                              From SSRFPACK
!                                            Robert J. Renka
!                                  Dept. of Computer Science
!                                       Univ. of North Texas
!                                           renka@cs.unt.edu
!                                                   05/09/92
!
!   This subroutine applies the inverse (transpose) of the
! rotation defined by Subroutine CONSTR to the vector
! (G1P G2P 0)**T, i.e., the gradient (G1P,G2P,0) in the rot-
! ated coordinate system is mapped to (G1,G2,G3) in the
! original coordinate system.
!
! On input:
!
!       G1P,G2P = X and Y components, respectively, of the
!                 gradient in the rotated coordinate system.
!
!       CX,SX,CY,SY = Elements of the rotation R constructed
!                     by Subroutine CONSTR.
!
! Input parameters are not altered by this routine.
!
! On output:
!
!       G = X, Y, and Z components (in that order) of the
!           inverse rotation applied to (G1P,G2P,0) --
!           gradient in the original coordinate system.
!
! Modules required by APLYRT:  None
!
!***********************************************************
!
real(kind_real) ::  T
!
! Local parameters:
!
! T = Temporary variable
!
T = SY*G1P
G(1) = CY*G1P
G(2) = CX*G2P - SX*T
G(3) = -SX*G2P - CX*T
RETURN
end subroutine ssrfpack_aplyrt








SUBROUTINE ssrfpack_arcint (P,P1,P2,F1,F2,G1,G2, F,G,GN)
real(kind_real) ::     P(3), P1(3), P2(3), F1, F2, G1(3), G2(3), &
    &         F, G(3), GN
!
!***********************************************************
!
!                                              From SSRFPACK
!                                            Robert J. Renka
!                                  Dept. of Computer Science
!                                       Univ. of North Texas
!                                           renka@cs.unt.edu
!                                                   11/21/96
!
!   Given 3 points P, P1, and P2 lying on a common geodesic
! of the unit sphere with P between P1 and P2, along with
! data values and gradients at P1 and P2, this subroutine
! computes an interpolated value F and a gradient vector G
! AT P.  F and the tangential component of G are taken to be
! the value and derivative (with respect to arc-length) of
! a Hermite interpolatory tension spline defined by the end-
! point values and tangential gradient components.  The nor-
! mal component of G is obtained by linear interpolation of
! the normal components of the gradients at P1 and P2.
!
! On input:
!
!       P = Cartesian coordinates of a point lying on the
!           arc defined by P1 and P2.  P(1)**2 + P(2)**2 +
!           P(3)**2 = 1.
!
!       P1,P2 = Coordinates of distinct points on the unit
!               sphere defining an arc with length less than
!               180 degrees.
!
!       F1,F2 = Data values associated with P1 and P2,
!               respectively.
!
!       G1,G2 = Gradient vectors associated with P1 and P2.
!               G1 and G2 are orthogonal to P1 and P2,
!               respectively.
!
! The above parameters are not altered by this routine.
!
!       G = Array of length 3.
!
! On output:
!
!       F = Interpolated value at P.
!
!       G = Interpolated gradient at P.
!
!       GN = Normal component of G with the direction
!            P1 X P2 taken to be positive.  The extrapola-
!            tion procedure requires this component.
!
!   For each vector V, V(1), V(2), and V(3) contain X, Y,
! and Z components, respectively.
!
! SSRFPACK modules required by ARCINT:  ARCLEN, SNHCSH
!
! Intrinsic functions called by ARCINT:  ABS, EXP, SQRT
!
!***********************************************************
!
INTEGER I, LUN
real(kind_real) ::     A, AL, B1, B2, CM, CMM, CM2, DUMMY, D1, D2, E, &
    &         EMS, E1, E2, GT, S, SB1, SB2, SIG, SINH, &
    &         SINH2, SM, SM2, TAU1, TAU2, TM, TM1, TM2, TP1, &
    &         TP2, TS, UN(3), UNORM,gttest
DATA    LUN/6/
!
! Local parameters:
!
! A =         Angle in radians (arc-length) between P1 and
!               P2
! AL =        Arc-length between P1 and P
! B1,B2 =     Local coordinates of P with respect to P1-P2
! CM,CMM =    Coshm(SIG) and Coshmm(SIG) -- refer to SNHCSH
! CM2 =       Coshm(SB2)
! DUMMY =     Dummy parameter for SNHCSH
! D1,D2 =     Scaled second differences
! E =         CM**2 - SM*Sinh = SIG*SM - 2*CMM (scaled by
!               2*EMS if SIG > .5)
! EMS =       Exp(-SIG)
! E1,E2 =     Exp(-SB1), Exp(-SB2)
! GT =        Tangential component of G -- component in the
!               direction UN X P
! I =         DO-loop index
! LUN =       Logical unit for error messages
! S =         Slope:  (F2-F1)/A
! SB1,SB2 =   SIG*B1, SIG*B2
! SINH2 =     Sinh(SB2)
! SM,SM2 =    Sinhm(SIG), Sinhm(SB2)
! TAU1,TAU2 = Tangential derivatives (components of G1,G2)
!               at P1 and P2
! TM =        1-EMS
! TM1,TM2 =   1-E1, 1-E2
! TP1,TP2 =   1+E1, 1+E2
! TS =        TM**2
! UN =        Unit normal to the plane of P, P1, and P2
! UNORM =     Euclidean norm of P1 X P2 -- used to normalize
!               UN
!
!
! Compute unit normal UN.
!
UN(1) = P1(2)*P2(3)-P1(3)*P2(2)
UN(2) = P1(3)*P2(1)-P1(1)*P2(3)
UN(3) = P1(1)*P2(2)-P1(2)*P2(1)
UNORM = SQRT(UN(1)*UN(1) + UN(2)*UN(2) + UN(3)*UN(3))
IF (UNORM .EQ. 0.) GO TO 2
UN = UN/UNORM
!
! Compute arc-lengths A, AL.
!
A = ARCLEN(P1,P2)
IF (A .EQ. 0.) GO TO 2
AL = ARCLEN(P1,P)
B2 = AL/A
B1 = 1. - B2

F = 0.
F = F+(1.-AL/A*B2*(1.+2.*B1))*F1
F = F+AL/A*B2*(1.+2.*B1)*F2
F = F+AL*(1.-B2*(1.+B1))*P2(1)/UNORM*G1(1)
F = F+AL*(1.-B2*(1.+B1))*P2(2)/UNORM*G1(2)
F = F+AL*(1.-B2*(1.+B1))*P2(3)/UNORM*G1(3)
F = F+AL*B2*B1*P1(1)/UNORM*G2(1)
F = F+AL*B2*B1*P1(2)/UNORM*G2(2)
F = F+AL*B2*B1*P1(3)/UNORM*G2(3)

G = 0.
G(1) = G(1)-(UN(2)*P(3)-UN(3)*P(2))*6.*B1*B2/A*F1
G(1) = G(1)+(UN(2)*P(3)-UN(3)*P(2))*6.*B1*B2/A*F2
G(1) = G(1)+(UN(1)*B1*UN(1)+(UN(2)*P(3)-UN(3)*P(2))*(1.0-B2-3.*B1*B2)*P2(1)/UNORM)*G1(1)
G(1) = G(1)+(UN(1)*B1*UN(2)+(UN(2)*P(3)-UN(3)*P(2))*(1.0-B2-3.*B1*B2)*P2(2)/UNORM)*G1(2)
G(1) = G(1)+(UN(1)*B1*UN(3)+(UN(2)*P(3)-UN(3)*P(2))*(1.0-B2-3.*B1*B2)*P2(3)/UNORM)*G1(3)
G(1) = G(1)+(UN(1)*B2*UN(1)+(UN(2)*P(3)-UN(3)*P(2))*(3.*B2*B1-B2)*P1(1)/UNORM)*G2(1)
G(1) = G(1)+(UN(1)*B2*UN(2)+(UN(2)*P(3)-UN(3)*P(2))*(3.*B2*B1-B2)*P1(2)/UNORM)*G2(2)
G(1) = G(1)+(UN(1)*B2*UN(3)+(UN(2)*P(3)-UN(3)*P(2))*(3.*B2*B1-B2)*P1(3)/UNORM)*G2(3)

G(2) = G(2)-(UN(3)*P(1)-UN(1)*P(3))*6.*B1*B2/A*F1
G(2) = G(2)+(UN(3)*P(1)-UN(1)*P(3))*6.*B1*B2/A*F2
G(2) = G(2)+(UN(2)*B1*UN(1)+(UN(3)*P(1)-UN(1)*P(3))*(1.0-B2-3.*B1*B2)*P2(1)/UNORM)*G1(1)
G(2) = G(2)+(UN(2)*B1*UN(2)+(UN(3)*P(1)-UN(1)*P(3))*(1.0-B2-3.*B1*B2)*P2(2)/UNORM)*G1(2)
G(2) = G(2)+(UN(2)*B1*UN(3)+(UN(3)*P(1)-UN(1)*P(3))*(1.0-B2-3.*B1*B2)*P2(3)/UNORM)*G1(3)
G(2) = G(2)+(UN(2)*B2*UN(1)+(UN(3)*P(1)-UN(1)*P(3))*(3.*B2*B1-B2)*P1(1)/UNORM)*G2(1)
G(2) = G(2)+(UN(2)*B2*UN(2)+(UN(3)*P(1)-UN(1)*P(3))*(3.*B2*B1-B2)*P1(2)/UNORM)*G2(2)
G(2) = G(2)+(UN(2)*B2*UN(3)+(UN(3)*P(1)-UN(1)*P(3))*(3.*B2*B1-B2)*P1(3)/UNORM)*G2(3)

G(3) = G(3)-(UN(1)*P(2)-UN(2)*P(1))*6.*B1*B2/A*F1
G(3) = G(3)+(UN(1)*P(2)-UN(2)*P(1))*6.*B1*B2/A*F2
G(3) = G(3)+(UN(3)*B1*UN(1)+(UN(1)*P(2)-UN(2)*P(1))*(1.0-B2-3.*B1*B2)*P2(1)/UNORM)*G1(1)
G(3) = G(3)+(UN(3)*B1*UN(2)+(UN(1)*P(2)-UN(2)*P(1))*(1.0-B2-3.*B1*B2)*P2(2)/UNORM)*G1(2)
G(3) = G(3)+(UN(3)*B1*UN(3)+(UN(1)*P(2)-UN(2)*P(1))*(1.0-B2-3.*B1*B2)*P2(3)/UNORM)*G1(3)
G(3) = G(3)+(UN(3)*B2*UN(1)+(UN(1)*P(2)-UN(2)*P(1))*(3.*B2*B1-B2)*P1(1)/UNORM)*G2(1)
G(3) = G(3)+(UN(3)*B2*UN(2)+(UN(1)*P(2)-UN(2)*P(1))*(3.*B2*B1-B2)*P1(2)/UNORM)*G2(2)
G(3) = G(3)+(UN(3)*B2*UN(3)+(UN(1)*P(2)-UN(2)*P(1))*(3.*B2*B1-B2)*P1(3)/UNORM)*G2(3)
RETURN
!
! P1 X P2 = 0.  Print an error message and terminate
!   processing.
!
    2 WRITE (LUN,100) (P1(I),I=1,3), (P2(I),I=1,3)
  100 FORMAT ('1','ERROR IN ARCINT -- P1 = ',2(F9.6,',  '), &
    &         F9.6/1X,19X,'P2 = ',2(F9.6,',  '),F9.6)
STOP
END SUBROUTINE ssrfpack_arcint






SUBROUTINE ssrfpack_arcint_ori (P,P1,P2,F1,F2,G1,G2, F,G,GN)
real(kind_real) ::     P(3), P1(3), P2(3), F1, F2, G1(3), G2(3), &
    &         F, G(3), GN
INTEGER I, LUN
real(kind_real) ::     A, AL, B1, B2, CM, CMM, CM2, DUMMY, D1, D2, E, &
    &         EMS, E1, E2, GT, S, SB1, SB2, SIG, SINH, &
    &         SINH2, SM, SM2, TAU1, TAU2, TM, TM1, TM2, TP1, &
    &         TP2, TS, UN(3), UNORM
DATA    LUN/6/
UN(1) = P1(2)*P2(3) - P1(3)*P2(2)
UN(2) = P1(3)*P2(1) - P1(1)*P2(3)
UN(3) = P1(1)*P2(2) - P1(2)*P2(1)
UNORM = SQRT(UN(1)*UN(1) + UN(2)*UN(2) + UN(3)*UN(3))
IF (UNORM .EQ. 0.) GO TO 2
!
! Normalize UN.
!
DO 1 I = 1,3
  UN(I) = UN(I)/UNORM
    1   CONTINUE
!
! Compute tangential derivatives at the endpoints:
!   TAU1 = (G1,UN X P1) = (G1,P2)/UNORM and
!   TAU2 = (G2,UN X P2) = -(G2,P1)/UNORM.
!
TAU1 = (G1(1)*P2(1) + G1(2)*P2(2) + G1(3)*P2(3))/UNORM
TAU2 =-(G2(1)*P1(1) + G2(2)*P1(2) + G2(3)*P1(3))/UNORM
!
! Compute arc-lengths A, AL.
!
A = ARCLEN(P1,P2)
IF (A .EQ. 0.) GO TO 2
AL = ARCLEN(P1,P)
!
! Compute local coordinates, slope, and second differences.
!
B2 = AL/A
B1 = 1. - B2
S = (F2-F1)/A
D1 = S - TAU1
D2 = TAU2 - S
!
! Hermite cubic interpolation.
!
  F = F1 + AL*(TAU1 + B2*(D1 + B1*(D1 - D2)))
  GT = TAU1 + B2*(D1 + D2 + 3.*B1*(D1 - D2))
!
! Compute GN.
!
GN = B1*(UN(1)*G1(1) + UN(2)*G1(2) + UN(3)*G1(3)) + &
    &      B2*(UN(1)*G2(1) + UN(2)*G2(2) + UN(3)*G2(3))
!
! Compute G = GT*(UN X P) + GN*UN.
!
G(1) = GT*(UN(2)*P(3) - UN(3)*P(2)) + GN*UN(1)
G(2) = GT*(UN(3)*P(1) - UN(1)*P(3)) + GN*UN(2)
G(3) = GT*(UN(1)*P(2) - UN(2)*P(1)) + GN*UN(3)
RETURN
!
! P1 X P2 = 0.  Print an error message and terminate
!   processing.
!
    2 WRITE (LUN,100) (P1(I),I=1,3), (P2(I),I=1,3)
  100 FORMAT ('1','ERROR IN ARCINT -- P1 = ',2(F9.6,',  '), &
    &         F9.6/1X,19X,'P2 = ',2(F9.6,',  '),F9.6)
STOP
END SUBROUTINE ssrfpack_arcint_ori



real(kind_real) FUNCTION ssrfpack_arclen(P,Q)
real(kind_real) ::  P(3), Q(3)
!
!***********************************************************
!
!                                              From SSRFPACK
!                                            Robert J. Renka
!                                  Dept. of Computer Science
!                                       Univ. of North Texas
!                                           renka@cs.unt.edu
!                                                   05/09/92
!
!   This function computes the arc-length (angle in radians)
! between a pair of points on the unit sphere.
!
! On input:
!
!       P,Q = Arrays of length 3 containing the X, Y, and Z
!             coordinates (in that order) of points on the
!             unit sphere.
!
! Input parameters are not altered by this function.
!
! On output:
!
!       ARCLEN = Angle in radians between the unit vectors
!                P and Q.  0 .LE. ARCLEN .LE. PI.
!
! Modules required by ARCLEN:  None
!
! Intrinsic functions called by ARCLEN:  ATAN, SQRT
!
!***********************************************************
!
INTEGER I
real(kind_real) ::     D
!
! Local parameters:
!
! D = Euclidean norm squared of P+Q
! I = DO-loop index
!
D = 0.
DO 1 I = 1,3
  D = D + (P(I) + Q(I))**2
    1   CONTINUE
IF (D .EQ. 0.) THEN
!
! P and Q are separated by 180 degrees.
!
  ssrfpack_arclen = 4.*ATAN(1.)
ELSEIF (D .GE. 4.) THEN
!
! P and Q coincide.
!
  ssrfpack_arclen = 0.
ELSE
  ssrfpack_arclen = 2.*ATAN(SQRT((4.-D)/D))
ENDIF
RETURN
END function ssrfpack_arclen





SUBROUTINE ssrfpack_constr (XK,YK,ZK, CX,SX,CY,SY)
real(kind_real) ::  XK, YK, ZK, CX, SX, CY, SY
!
!***********************************************************
!
!                                              From SSRFPACK
!                                            Robert J. Renka
!                                  Dept. of Computer Science
!                                       Univ. of North Texas
!                                           renka@cs.unt.edu
!                                                   05/09/92
!
!   This subroutine constructs the elements of a 3 by 3
! orthogonal matrix R which rotates a point (XK,YK,ZK) on
! the unit sphere to the north pole, i.e.,
!
!      (XK)     (CY  0 -SY)   (1   0   0)   (XK)     (0)
!  R * (YK)  =  ( 0  1   0) * (0  CX -SX) * (YK)  =  (0)
!      (ZK)     (SY  0  CY)   (0  SX  CX)   (ZK)     (1)
!
! On input:
!
!       XK,YK,ZK = Components of a unit vector to be
!                  rotated to (0,0,1).
!
! Input parameters are not altered by this routine.
!
! On output:
!
!       CX,SX,CY,SY = Elements of R:  CX,SX define a rota-
!                     tion about the X-axis and CY,SY define
!                     a rotation about the Y-axis.
!
! Modules required by CONSTR:  None
!
! Intrinsic function called by CONSTR:  SQRT
!
!***********************************************************
!
CY = SQRT(YK*YK + ZK*ZK)
SY = XK
IF (CY .NE. 0.) THEN
  CX = ZK/CY
  SX = YK/CY
ELSE
!
! (XK,YK,ZK) lies on the X-axis.
!
  CX = 1.
  SX = 0.
ENDIF
RETURN
END subroutine ssrfpack_constr







real(kind_real) FUNCTION ssrfpack_fval (B1,B2,B3,V1,V2,V3,F1,F2,F3,G1,G2, &
    &                     G3)
real(kind_real) ::  B1, B2, B3, V1(3), V2(3), V3(3), F1, F2, F3, &
    &      G1(3), G2(3), G3(3)
!
!***********************************************************
!
!                                              From SSRFPACK
!                                            Robert J. Renka
!                                  Dept. of Computer Science
!                                       Univ. of North Texas
!                                           renka@cs.unt.edu
!                                                   05/09/92
!
!   Given data values and gradients at the three vertices of
! a spherical triangle containing a point P, this routine
! computes the value of F at P where F interpolates the ver-
! tex data.  Along the triangle sides, the interpolatory
! function F is the Hermite interpolatory tension spline
! defined by the values and tangential gradient components
! at the endpoints, and the gradient component normal to the
! triangle side varies linearly with respect to arc-length
! between the normal gradient components at the endpoints.
! A first-order C-1 blending method is used on the underly-
! ing planar triangle.  Since values and gradients on an arc
! depend only on the vertex data, the method results in C-1
! continuity when used to interpolate over a triangulation.
!
!   The blending method consists of taking F(P) to be a
! weighted sum of the values at PP of three univariate Her-
! mite interpolatory tension splines defined on the line
! segments which join the vertices to the opposite sides and
! pass through PP:  the central projection of P onto the
! underlying planar triangle.  The tension factors for these
! splines are obtained by linear interpolation between the
! pair of tension factors associated with the triangle sides
! which join at the appropriate vertex.
!
! On input:
!
!       B1,B2,B3 = Barycentric coordinates of PP with re-
!                  spect to the (planar) underlying triangle
!                  (V1,V2,V3), where PP is the central
!                  projection of P onto this triangle.
!
!       V1,V2,V3 = Cartesian coordinates of the vertices of
!                  a spherical triangle containing P.  V3
!                  Left V1->V2.
!
!       F1,F2,F3 = Data values associated with the vertices.
!
!       G1,G2,G3 = Gradients associated with the vertices.
!                  Gi is orthogonal to Vi for i = 1,2,3.
!
! Input parameters are not altered by this function.
!
! On output:
!
!       FVAL = Interpolated value at P.
!
! Each vector V above contains X, Y, and Z components in
!   V(1), V(2), and V(3), respectively.
!
! SSRFPACK modules required by FVAL:  ARCINT, ARCLEN, HVAL
!
! Intrinsic function called by FVAL:  SQRT
!
!***********************************************************
!
INTEGER I
real(kind_real) ::     C1, C2, C3, DUM, F, G(3), &
    &         Q1(3), Q2(3), Q3(3), SIG, CSUM, S1, S2, S3, &
    &         U1(3), U2(3), U3(3), U1N, U2N, U3N, VAL

C1 = B2*B3
C2 = B3*B1
C3 = B1*B2
CSUM = C1 + C2 + C3
IF (CSUM .LE. 0.) THEN
!
! P coincides with a vertex.
!
  ssrfpack_fval = B1*F1 + B2*F2 + B3*F3
  RETURN
ENDIF
!
! Normalize C1, C2, and C3.
!
C1 = C1/CSUM
C2 = C2/CSUM
C3 = C3/CSUM
!
! Compute (S1,S2,S3), (U1,U2,U3) and (U1N,U2N,U3N).
!
S1 = B2 + B3
S2 = B3 + B1
S3 = B1 + B2
U1N = 0.
U2N = 0.
U3N = 0.
DO I = 1,3
  U1(I) = (B2*V2(I) + B3*V3(I))/S1
  U2(I) = (B3*V3(I) + B1*V1(I))/S2
  U3(I) = (B1*V1(I) + B2*V2(I))/S3
  U1N = U1N + U1(I)*U1(I)
  U2N = U2N + U2(I)*U2(I)
  U3N = U3N + U3(I)*U3(I)
ENDDO
!
! Compute Q1, Q2, and Q3.
!
U1N = SQRT(U1N)
U2N = SQRT(U2N)
U3N = SQRT(U3N)
DO I = 1,3
  Q1(I) = U1(I)/U1N
  Q2(I) = U2(I)/U2N
  Q3(I) = U3(I)/U3N
ENDDO

!
! Compute interpolated value (VAL) at P by looping on
!   triangle sides.
!
ssrfpack_fval = 0.

CALL ARCINT (Q1,V2,V3,F2,F3,G2,G3, F,G,DUM)
!
!   Add in the contribution.
!
ssrfpack_fval = ssrfpack_fval+C1*(1.-B1)**2*(1.+2.*B1)*F
ssrfpack_fval = ssrfpack_fval+C1*B1**2*(3.-2.*B1)*F1
ssrfpack_fval = ssrfpack_fval+C1*(1.-B1)*B1**2*U1(1)*G1(1)
ssrfpack_fval = ssrfpack_fval+C1*(1.-B1)*B1**2*U1(2)*G1(2)
ssrfpack_fval = ssrfpack_fval+C1*(1.-B1)*B1**2*U1(3)*G1(3)
ssrfpack_fval = ssrfpack_fval+C1*(1.-B1)**2*B1/U1N*V1(1)*G(1)
ssrfpack_fval = ssrfpack_fval+C1*(1.-B1)**2*B1/U1N*V1(2)*G(2)
ssrfpack_fval = ssrfpack_fval+C1*(1.-B1)**2*B1/U1N*V1(3)*G(3)
!
! Contribution from side opposite V2:
!
!   Compute value and gradient at Q2 by interpolating
!     between V3 and V1.
!
CALL ARCINT (Q2,V3,V1,F3,F1,G3,G1, F,G,DUM)
!
!   Add in the contribution.
!
ssrfpack_fval = ssrfpack_fval+C2*(1.-B2)**2*(1.+2.*B2)*F
ssrfpack_fval = ssrfpack_fval+C2*B2**2*(3.-2.*B2)*F2
ssrfpack_fval = ssrfpack_fval+C2*(1.-B2)*B2**2*U2(1)*G2(1)
ssrfpack_fval = ssrfpack_fval+C2*(1.-B2)*B2**2*U2(2)*G2(2)
ssrfpack_fval = ssrfpack_fval+C2*(1.-B2)*B2**2*U2(3)*G2(3)
ssrfpack_fval = ssrfpack_fval+C2*(1.-B2)**2*B2/U2N*V2(1)*G(1)
ssrfpack_fval = ssrfpack_fval+C2*(1.-B2)**2*B2/U2N*V2(2)*G(2)
ssrfpack_fval = ssrfpack_fval+C2*(1.-B2)**2*B2/U2N*V2(3)*G(3)
!
! Contribution from side opposite V3:
!
!   Compute interpolated value and gradient at Q3
!     by interpolating between V1 and V2.
!
CALL ARCINT (Q3,V1,V2,F1,F2,G1,G2, F,G,DUM)
!
!   Add in the final contribution.
!
ssrfpack_fval = ssrfpack_fval+C3*(1.-B3)**2*(1.+2.*B3)*F
ssrfpack_fval = ssrfpack_fval+C3*B3**2*(3.-2.*B3)*F3
ssrfpack_fval = ssrfpack_fval+C3*(1.-B3)*B3**2*U3(1)*G3(1)
ssrfpack_fval = ssrfpack_fval+C3*(1.-B3)*B3**2*U3(2)*G3(2)
ssrfpack_fval = ssrfpack_fval+C3*(1.-B3)*B3**2*U3(3)*G3(3)
ssrfpack_fval = ssrfpack_fval+C3*(1.-B3)**2*B3/U3N*V3(1)*G(1)
ssrfpack_fval = ssrfpack_fval+C3*(1.-B3)**2*B3/U3N*V3(2)*G(2)
ssrfpack_fval = ssrfpack_fval+C3*(1.-B3)**2*B3/U3N*V3(3)*G(3)

RETURN
END function ssrfpack_fval

real(kind_real) FUNCTION ssrfpack_fval_ori (B1,B2,B3,V1,V2,V3,F1,F2,F3,G1,G2, &
    &                     G3)
real(kind_real) ::  B1, B2, B3, V1(3), V2(3), V3(3), F1, F2, F3, &
    &      G1(3), G2(3), G3(3)
!
!***********************************************************
!
!                                              From SSRFPACK
!                                            Robert J. Renka
!                                  Dept. of Computer Science
!                                       Univ. of North Texas
!                                           renka@cs.unt.edu
!                                                   05/09/92
!
!   Given data values and gradients at the three vertices of
! a spherical triangle containing a point P, this routine
! computes the value of F at P where F interpolates the ver-
! tex data.  Along the triangle sides, the interpolatory
! function F is the Hermite interpolatory tension spline
! defined by the values and tangential gradient components
! at the endpoints, and the gradient component normal to the
! triangle side varies linearly with respect to arc-length
! between the normal gradient components at the endpoints.
! A first-order C-1 blending method is used on the underly-
! ing planar triangle.  Since values and gradients on an arc
! depend only on the vertex data, the method results in C-1
! continuity when used to interpolate over a triangulation.
!
!   The blending method consists of taking F(P) to be a
! weighted sum of the values at PP of three univariate Her-
! mite interpolatory tension splines defined on the line
! segments which join the vertices to the opposite sides and
! pass through PP:  the central projection of P onto the
! underlying planar triangle.  The tension factors for these
! splines are obtained by linear interpolation between the
! pair of tension factors associated with the triangle sides
! which join at the appropriate vertex.
!
! On input:
!
!       B1,B2,B3 = Barycentric coordinates of PP with re-
!                  spect to the (planar) underlying triangle
!                  (V1,V2,V3), where PP is the central
!                  projection of P onto this triangle.
!
!       V1,V2,V3 = Cartesian coordinates of the vertices of
!                  a spherical triangle containing P.  V3
!                  Left V1->V2.
!
!       F1,F2,F3 = Data values associated with the vertices.
!
!       G1,G2,G3 = Gradients associated with the vertices.
!                  Gi is orthogonal to Vi for i = 1,2,3.
!
! Input parameters are not altered by this function.
!
! On output:
!
!       FVAL = Interpolated value at P.
!
! Each vector V above contains X, Y, and Z components in
!   V(1), V(2), and V(3), respectively.
!
! SSRFPACK modules required by FVAL:  ARCINT, ARCLEN, HVAL
!
! Intrinsic function called by FVAL:  SQRT
!
!***********************************************************
!
INTEGER I
real(kind_real) ::     C1, C2, C3, DS, DUM, DV, F, G(3), &
    &         Q1(3), Q2(3), Q3(3), SIG, SUM, S1, S2, S3, &
    &         U1(3), U2(3), U3(3), U1N, U2N, U3N, VAL
!
! Local parameters:
!
! C1,C2,C3 =    Coefficients (weight functions) of partial
!                 interpolants.  C1 = 1 on the edge opposite
!                 V1 and C1 = 0 on the other edges.  Simi-
!                 larly for C2 and C3.  C1+C2+C3 = 1.
! DS =          Directional derivative (scaled by distnace)
!                 at U1, U2, or U3:  DS = (G,U1-V1)/U1N =
!                 -(G,V1)/U1N on side opposite V1, where G/
!                 U1N (plus an orthogonal component) is the
!                 projection of G onto the planar triangle
! DUM =         Dummy variable for calls to ARCINT
! DV =          Directional derivatives (scaled by distance)
!                 at a vertex:  D1 = (G1,U1-V1) = (G1,U1)
! F,G =         Value and gradient at Q1 Q2, or Q3 obtained
!                 by interpolation along one of the arcs of
!                 the spherical triangle
! I =           DO-loop index
! Q1,Q2,Q3 =    Central projections of U1, U2, and U3 onto
!                 the sphere and thus lying on an arc of the
!                 spherical triangle
! SIG =         Tension factor for a side-vertex (partial)
!                 interpolant:  obtained by linear interpo-
!                 lation applied to triangle side tensions
! SUM =         Quantity used to normalize C1, C2, and C3
! S1,S2,S3 =    Sums of pairs of barycentric coordinates:
!                 used to compute U1, U2, U3, and SIG
! U1,U2,U3 =    Points on the boundary of the planar trian-
!                 gle and lying on the lines containing PP
!                 and the vertices.  U1 is opposite V1, etc.
! U1N,U2N,U3N = Quantities used to compute Q1, Q2, and Q3
!                 (magnitudes of U1, U2, and U3)
! VAL =         Local variable used to accumulate the con-
!                 tributions to FVAL
!
!
! Compute weight functions C1, C2, and C3.
!
C1 = B2*B3
C2 = B3*B1
C3 = B1*B2
SUM = C1 + C2 + C3
IF (SUM .LE. 0.) THEN
!
! P coincides with a vertex.
!
  ssrfpack_fval_ori = B1*F1 + B2*F2 + B3*F3
  RETURN
ENDIF
!
! Normalize C1, C2, and C3.
!
C1 = C1/SUM
C2 = C2/SUM
C3 = C3/SUM
!
! Compute (S1,S2,S3), (U1,U2,U3) and (U1N,U2N,U3N).
!
S1 = B2 + B3
S2 = B3 + B1
S3 = B1 + B2
U1N = 0.
U2N = 0.
U3N = 0.
DO 1 I = 1,3
  U1(I) = (B2*V2(I) + B3*V3(I))/S1
  U2(I) = (B3*V3(I) + B1*V1(I))/S2
  U3(I) = (B1*V1(I) + B2*V2(I))/S3
  U1N = U1N + U1(I)*U1(I)
  U2N = U2N + U2(I)*U2(I)
  U3N = U3N + U3(I)*U3(I)
    1   CONTINUE
!
! Compute Q1, Q2, and Q3.
!
U1N = SQRT(U1N)
U2N = SQRT(U2N)
U3N = SQRT(U3N)
DO 2 I = 1,3
  Q1(I) = U1(I)/U1N
  Q2(I) = U2(I)/U2N
  Q3(I) = U3(I)/U3N
    2   CONTINUE
!
! Compute interpolated value (VAL) at P by looping on
!   triangle sides.
!
VAL = 0.
!
! Contribution from side opposite V1:
!
!   Compute value and gradient at Q1 by interpolating
!     between V2 and V3.
!
CALL ARCINT_ori (Q1,V2,V3,F2,F3,G2,G3, F,G,DUM)
!
!   Add in the contribution.
!
DV = G1(1)*U1(1) + G1(2)*U1(2) + G1(3)*U1(3)
DS = -(G(1)*V1(1) + G(2)*V1(2) + G(3)*V1(3))/U1N
VAL = VAL + C1*HVAL(B1,F1,F,DV,DS)
!
! Contribution from side opposite V2:
!
!   Compute value and gradient at Q2 by interpolating
!     between V3 and V1.
!
CALL ARCINT_ori (Q2,V3,V1,F3,F1,G3,G1, F,G,DUM)
!
!   Add in the contribution.
!
DV = G2(1)*U2(1) + G2(2)*U2(2) + G2(3)*U2(3)
DS = -(G(1)*V2(1) + G(2)*V2(2) + G(3)*V2(3))/U2N
VAL = VAL + C2*HVAL(B2,F2,F,DV,DS)
!
! Contribution from side opposite V3:
!
!   Compute interpolated value and gradient at Q3
!     by interpolating between V1 and V2.
!
CALL ARCINT_ori (Q3,V1,V2,F1,F2,G1,G2, F,G,DUM)
!
!   Add in the final contribution.
!
DV = G3(1)*U3(1) + G3(2)*U3(2) + G3(3)*U3(3)
DS = -(G(1)*V3(1) + G(2)*V3(2) + G(3)*V3(3))/U3N
ssrfpack_fval_ori = VAL + C3*HVAL(B3,F3,F,DV,DS)
RETURN
END function ssrfpack_fval_ori

SUBROUTINE ssrfpack_GIVENS ( A,B, C,S)
real(kind_real) ::  A, B, C, S
!
!***********************************************************
!
!                                              From SSRFPACK
!                                            Robert J. Renka
!                                  Dept. of Computer Science
!                                       Univ. of North Texas
!                                           renka@cs.unt.edu
!                                                   05/09/92
!
!   This subroutine constructs the Givens plane rotation,
!
!           ( C  S)
!       G = (     ) , where C*C + S*S = 1,
!           (-S  C)
!
! which zeros the second component of the vector (A,B)**T
! (transposed).  Subroutine ROTATE may be called to apply
! the transformation to a 2 by N matrix.
!
!   This routine is identical to Subroutine SROTG from the
! LINPACK BLAS (Basic Linear Algebra Subroutines).
!
! On input:
!
!       A,B = Components of the vector defining the rota-
!             tion.  These are overwritten by values R
!             and Z (described below) which define C and S.
!
! On output:
!
!       A = Signed Euclidean norm R of the input vector:
!           R = +/-SQRT(A*A + B*B)
!
!       B = Value Z such that:
!             C = SQRT(1-Z*Z) and S=Z if ABS(Z) .LE. 1, and
!             C = 1/Z and S = SQRT(1-C*C) if ABS(Z) > 1.
!
!       C = +/-(A/R) or 1 if R = 0.
!
!       S = +/-(B/R) or 0 if R = 0.
!
! Modules required by GIVENS:  None
!
! Intrinsic functions called by GIVENS:  ABS, SQRT
!
!***********************************************************
!
real(kind_real) ::  AA, BB, R, U, V
!
! Local parameters:
!
! AA,BB = Local copies of A and B
! R =     C*A + S*B = +/-SQRT(A*A+B*B)
! U,V =   Variables used to scale A and B for computing R
!
AA = A
BB = B
IF (ABS(AA) .GT. ABS(BB)) THEN
!
! ABS(A) > ABS(B).
!
  U = AA + AA
  V = BB/U
  R = SQRT(.25 + V*V) * U
  C = AA/R
  S = V * (C + C)
!
! Note that R has the sign of A, C > 0, and S has
!   SIGN(A)*SIGN(B).
!
  B = S
  A = R
ELSEIF (BB .NE. 0.) THEN
!
! ABS(A) .LE. ABS(B).
!
  U = BB + BB
  V = AA/U
!
! Store R in A.
!
  A = SQRT(.25 + V*V) * U
  S = BB/A
  C = V * (S + S)
!
! Note that R has the sign of B, S > 0, and C has
!   SIGN(A)*SIGN(B).
!
  B = 1.
  IF (C .NE. 0.) B = 1./C
ELSE
!
! A = B = 0.
!
  C = 1.
  S = 0.
ENDIF
RETURN
END subroutine ssrfpack_givens


SUBROUTINE ssrfpack_gradl (N,K,X,Y,Z,W,LIST,LPTR,LEND, G,IER)
INTEGER N, K, LIST(*), LPTR(*), LEND(N), IER
real(kind_real) ::     X(N), Y(N), Z(N), W(N), G(3)
!
!***********************************************************
!
!                                              From SSRFPACK
!                                            Robert J. Renka
!                                  Dept. of Computer Science
!                                       Univ. of North Texas
!                                           renka@cs.unt.edu
!                                                   07/24/96
!
!   Given a triangulation of a set of nodes on the unit
! sphere with their associated data values W, this routine
! estimates a gradient vector at node K as follows:  the
! coordinate system is rotated so that K becomes the north
! pole, node K and a set of nearby nodes are projected
! orthogonally onto the X-Y plane (in the new coordinate
! system), a quadratic is fitted in a weighted least squares
! sense to the data values at the projected nodes such that
! the value (associated with K) at (0,0) is interpolated, X
! and Y-partial derivative estimates DX and DY are computed
! by differentiating the quadratic at (0,0), and the esti-
! mated gradient G is obtained by rotating (DX,DY,0) back to
! the original coordinate system.  Note that G lies in the
! plane tangent to the sphere at node K, i.e., G is orthogo-
! nal to the unit vector represented by node K.  A Marquardt
! stabilization factor is used if necessary to ensure a
! well-conditioned least squares system, and a unique solu-
! tion exists unless the nodes are collinear.
!
! On input:
!
!       N = Number of nodes in the triangulation.  N .GE. 7.
!
!       K = Node at which the gradient is sought.  1 .LE. K
!           .LE. N.
!
!       X,Y,Z = Arrays containing the Cartesian coordinates
!               of the nodes.
!
!       W = Array containing the data values at the nodes.
!           W(I) is associated with (X(I),Y(I),Z(I)) for
!           I = 1,...,N.
!
!       LIST,LPTR,LEND = Data structure defining the trian-
!                        gulation.  Refer to STRIPACK
!                        Subroutine TRMESH.
!
! Input parameters are not altered by this routine.
!
! On output:
!
!       G = X, Y, and Z components (in that order) of the
!           estimated gradient at node K unless IER < 0.
!
!       IER = Error indicator:
!             IER .GE. 6 if no errors were encountered.
!                        IER contains the number of nodes
!                        (including K) used in the least
!                        squares fit.
!             IER = -1 if N or K is outside its valid range.
!             IER = -2 if the least squares system has no
!                      unique solution due to duplicate or
!                      collinear nodes.
!
! STRIPACK module required by GRADL:  GETNP
!
! SSRFPACK modules required by GRADL:  APLYR, APLYRT,
!                                        CONSTR, GIVENS,
!                                        ROTATE, SETUP
!
! Intrinsic functions called by GRADL:  ABS, MIN, REAL, SQRT
!
!***********************************************************
!
INTEGER   LMN, LMX
PARAMETER (LMN=10,  LMX=30)
INTEGER I, IERR, IM1, IP1, J, JP1, KK, L, LM1, LMAX, &
    &         LMIN, LNP, NN, NP, NPTS(LMX)
real(kind_real) ::     A(6,6), AV, AVSQ, C, CX, CY, DF, DMIN, DTOL, &
    &         DX, DY, RF, RIN, RTOL, S, SF, SUM, SX, SY, &
    &         WK, WT, XP, YP, ZP
!
DATA    RTOL/1.E-6/, DTOL/.01/, SF/1./
!
! Local parameters:
!
! A =         Transpose of the (upper triangle of the) aug-
!               mented regression matrix
! AV =        Root-mean-square distance (in the rotated
!               coordinate system) between the origin and
!               the nodes (other than K) in the least
!               squares fit.  The first 3 columns of A**T
!               are scaled by 1/AVSQ, the next 2 by 1/AV.
! AVSQ =      AV*AV:  accumulated in SUM
! C,S =       Components of the plane rotation used to
!               triangularize the regression matrix
! CX,SX =     Components of a plane rotation about the X-
!               axis which, together with CY and SY, define
!               a mapping from node K to the north pole
!               (0,0,1)
! CY,SY =     Components of a plane rotation about the Y-
!               axis
! DF =        Negative Z component (in the rotated coordi-
!               nate system) of an element NP of NPTS --
!               increasing function of the angular distance
!               between K and NP.  DF lies in the interval
!               (-1,1).
! DMIN =      Minimum of the magnitudes of the diagonal
!               elements of the triangularized regression
!               matrix
! DTOL =      Tolerance for detecting an ill-conditioned
!               system (DMIN is required to be at least
!               DTOL)
! DX,DY =     X and Y components of the estimated gradient
!               in the rotated coordinate system
! I,J =       Loop indexes
! IERR =      Error flag for calls to GETNP (not checked)
! IM1,IP1 =   I-1, I+1
! JP1 =       J+1
! KK =        Local copy of K
! L =         Number of columns of A**T to which a rotation
!               is applied
! LM1 =       LMIN-1
! LMIN,LMAX = Min(LMN,N), Min(LMX,N)
! LMN,LMX =   Minimum and maximum values of LNP for N
!               sufficiently large.  In most cases LMN-1
!               nodes are used in the fit.  7 .LE. LMN .LE.
!               LMX.
! LNP =       Length of NPTS or LMAX+1
! NN =        Local copy of N
! NP =        Element of NPTS to be added to the system
! NPTS =      Array containing the indexes of a sequence of
!               nodes ordered by angular distance from K.
!               NPTS(1)=K and the first LNP-1 elements of
!               NPTS are used in the least squares fit.
!               unless LNP = LMAX+1, NPTS(LNP) determines R
!               (see RIN).
! RF =        Value of DF associated with NPTS(LNP) unless
!               LNP = LMAX+1 (see RIN)
! RIN =       Inverse of a radius of influence R which
!               enters into WT:  R = 1+RF unless all ele-
!               ments of NPTS are used in the fit (LNP =
!               LMAX+1), in which case R is the distance
!               function associated with some point more
!               distant from K than NPTS(LMAX)
! RTOL =      Tolerance for determining LNP (and hence R):
!               if the increase in DF between two successive
!               elements of NPTS is less than RTOL, they are
!               treated as being the same distance from node
!               K and an additional node is added
! SF =        Marquardt stabilization factor used to damp
!               out the first 3 solution components (second
!               partials of the quadratic) when the system
!               is ill-conditioned.  Increasing SF results
!               in more damping (a more nearly linear fit).
! SUM =       Sum of squared Euclidean distances (in the
!               rotated coordinate system) between the
!               origin and the nodes used in the least
!               squares fit
! WK =        W(K) -- data value at node K
! WT =        Weight for the equation coreesponding to NP:
!               WT = (R-D)/(R*D) = 1/D - RIN, where D = 1-ZP
!               is associated with NP
! XP,YP,ZP =  Coordinates of NP in the rotated coordinate
!               system unless ZP < 0, in which case
!               (XP,YP,0) lies on the equator
!
NN = N
KK = K
WK = W(KK)
!
! Check for errors and initialize LMIN, LMAX.
!
IF (NN .LT. 7  .OR.  KK .LT. 1  .OR.  KK .GT. NN) &
    &    GO TO 13
LMIN = MIN(LMN,NN)
LMAX = MIN(LMX,NN)
!
! Compute NPTS, LNP, AVSQ, AV, and R.
!   Set NPTS to the closest LMIN-1 nodes to K.  DF contains
!   the negative Z component (in the rotated coordinate
!   system) of the new node on return from GETNP.
!
SUM = 0.
NPTS(1) = KK
LM1 = LMIN - 1
DO 1 LNP = 2,LM1
  CALL GETNP (X,Y,Z,LIST,LPTR,LEND,LNP, NPTS, DF,IERR)
  SUM = SUM + 1. - DF*DF
    1   CONTINUE
!
!   Add additional nodes to NPTS until the increase in
!     R = 1+RF is at least RTOL.
!
DO 2 LNP = LMIN,LMAX
  CALL GETNP (X,Y,Z,LIST,LPTR,LEND,LNP, NPTS, RF,IERR)
  IF (RF-DF .GE. RTOL) GO TO 3
  SUM = SUM + 1. - RF*RF
    2   CONTINUE
!
!   Use all LMAX nodes in the least squares fit.  R is
!     arbitrarily increased by 5 percent.
!
RF = 1.05*RF + .05
LNP = LMAX + 1
!
!   There are LNP-2 equations corresponding to nodes
!     NPTS(2),...,NPTS(LNP-1).
!
    3 AVSQ = SUM/REAL(LNP-2,kind_real)
AV = SQRT(AVSQ)
RIN = 1./(1.+RF)
!
! Construct the rotation.
!
CALL CONSTR (X(KK),Y(KK),Z(KK), CX,SX,CY,SY)
!
! Set up the first 5 equations of the augmented regression
!   matrix (transposed) as the columns of A, and zero out
!   the lower triangle (upper triangle of A) with Givens
!   rotations.
!
DO 5 I = 1,5
  NP = NPTS(I+1)
  CALL APLYR (X(NP),Y(NP),Z(NP),CX,SX,CY,SY, XP,YP,ZP)
  WT = 1./(1.-ZP) - RIN
  CALL SETUP (XP,YP,W(NP),WK,AV,AVSQ,WT, A(:,I))
  IF (I .EQ. 1) GO TO 5
  IM1 = I - 1
  DO 4 J = 1,IM1
    JP1 = J + 1
    L = 6 - J
    CALL GIVENS ( A(J,J),A(J,I), C,S)
    CALL ROTATE (L,C,S, A(JP1:JP1+L-1,J),A(JP1:JP1+L-1,I) )
    4     CONTINUE
    5   CONTINUE
!
! Add the additional equations to the system using
!   the last column of A.  I .LE. LNP.
!
I = 7
    6   IF (I .EQ. LNP) GO TO 8
  NP = NPTS(I)
  CALL APLYR (X(NP),Y(NP),Z(NP),CX,SX,CY,SY, XP,YP,ZP)
  WT = 1./(1.-ZP) - RIN
  CALL SETUP (XP,YP,W(NP),WK,AV,AVSQ,WT, A(:,6))
  DO 7 J = 1,5
    JP1 = J + 1
    L = 6 - J
    CALL GIVENS ( A(J,J),A(J,6), C,S)
    CALL ROTATE (L,C,S, A(JP1:JP1+L-1,J),A(JP1:JP1+L-1,6) )
    7     CONTINUE
  I = I + 1
  GO TO 6
!
! Test the system for ill-conditioning.
!
    8 DMIN = MIN( ABS(A(1,1)),ABS(A(2,2)),ABS(A(3,3)), &
    &             ABS(A(4,4)),ABS(A(5,5)) )
IF (DMIN .GE. DTOL) GO TO 12
IF (LNP .LE. LMAX) THEN
!
! Add another node to the system and increase R.
!   I = LNP.
!
  LNP = LNP + 1
  IF (LNP .LE. LMAX) CALL GETNP (X,Y,Z,LIST,LPTR,LEND, &
    &                                  LNP,NPTS, RF,IERR)
  RIN = 1./(1.05*(1.+RF))
  GO TO 6
ENDIF
!
! Stabilize the system by damping second partials.  Add
!   multiples of the first three unit vectors to the first
!   three equations.
!
DO 11 I = 1,3
  A(I,6) = SF
  IP1 = I + 1
  DO 9 J = IP1,6
    A(J,6) = 0.
    9     CONTINUE
  DO 10 J = I,5
    JP1 = J + 1
    L = 6 - J
    CALL GIVENS ( A(J,J),A(J,6), C,S)
    CALL ROTATE (L,C,S, A(JP1:JP1+L-1,J),A(JP1:JP1+L-1,6) )
   10     CONTINUE
   11   CONTINUE
!
! Test the linear portion of the stabilized system for
!   ill-conditioning.
!
DMIN = MIN( ABS(A(4,4)),ABS(A(5,5)) )
IF (DMIN .LT. DTOL) GO TO 14
!
! Solve the 2 by 2 triangular system for the estimated
!   partial derivatives.
!
   12 DY = A(6,5)/A(5,5)
DX = (A(6,4) - A(5,4)*DY)/A(4,4)/AV
DY = DY/AV
!
! Rotate the gradient (DX,DY,0) back into the original
!   coordinate system.
!
CALL APLYRT (DX,DY,CX,SX,CY,SY, G)
IER = LNP - 1
RETURN
!
! N or K is outside its valid range.
!
   13 IER = -1
RETURN
!
! No unique solution due to collinear nodes.
!
   14 IER = -2
RETURN
END subroutine ssrfpack_gradl

real(kind_real) FUNCTION ssrfpack_hval (B,H1,H2,HP1,HP2)
real(kind_real) ::  B, H1, H2, HP1, HP2
!
!***********************************************************
!
!                                              From SSRFPACK
!                                            Robert J. Renka
!                                  Dept. of Computer Science
!                                       Univ. of North Texas
!                                           renka@cs.unt.edu
!                                                   11/21/96
!
!   Given a line segment P1-P2 containing a point P, along
! with values and derivatives at the endpoints, this func-
! tion returns the value H(P), where H is the Hermite inter-
! polatory tension spline defined by the endpoint data.
!
! On input:
!
!       B = Local coordinate of P with respect to P1-P2:
!           P = B*P1 + (1-B)*P2, and thus B = d(P,P2)/
!           d(P1,P2), where d(P1,P2) is the distance between
!           P1 and P2.  B < 0 or B > 1 results in extrapola-
!           tion.
!
!       H1,H2 = Values interpolated at P1 and P2, respec-
!               tively.
!
!       HP1,HP2 = Products of d(P1,P2) with first order der-
!                 ivatives at P1 and P2, respectively.  HP1
!                 may, for example, be the scalar product of
!                 P2-P1 with a gradient at P1.
!
! Input parameters are not altered by this function.
!
! On output:
!
!       HVAL = Interpolated value H(P).
!
! SSRFPACK module required by HVAL:  SNHCSH
!
! Intrinsic functions called by HVAL:  ABS, EXP
!
!***********************************************************
!
real(kind_real) ::  B1, B2, CM, CM2, CMM, D1, D2, DUMMY, E, E1, E2, &
    &      EMS, S, SB1, SB2, SM, SM2, TM, TM1, TM2, TS
B1 = B
B2 = 1. - B1
!
! Compute slope S and second differences D1 and D2 scaled
!   by the separation between P1 and P2.
!
S = H2 - H1
D1 = S - HP1
D2 = HP2 - S
!
! Hermite cubic interpolation:
!
  ssrfpack_hval = H1 + B2*(HP1 + B2*(D1 + B1*(D1 - D2)))
RETURN
END function ssrfpack_hval

SUBROUTINE ssrfpack_rotate (N,C,S, X,Y )
INTEGER N
real(kind_real) ::     C, S, X(N), Y(N)
!
!***********************************************************
!
!                                              From SSRFPACK
!                                            Robert J. Renka
!                                  Dept. of Computer Science
!                                       Univ. of North Texas
!                                           renka@cs.unt.edu
!                                                   09/01/88
!
!                                                ( C  S)
!   This subroutine applies the Givens rotation  (     )  to
!                                                (-S  C)
!                    (X(1) ... X(N))
! the 2 by N matrix  (             ) .
!                    (Y(1) ... Y(N))
!
!   This routine is identical to Subroutine SROT from the
! LINPACK BLAS (Basic Linear Algebra Subroutines).
!
! On input:
!
!       N = Number of columns to be rotated.
!
!       C,S = Elements of the Givens rotation.  Refer to
!             Subroutine GIVENS.
!
! The above parameters are not altered by this routine.
!
!       X,Y = Arrays of length .GE. N containing the compo-
!             nents of the vectors to be rotated.
!
! On output:
!
!       X,Y = Arrays containing the rotated vectors (not
!             altered if N < 1).
!
! Modules required by ROTATE:  None
!
!***********************************************************
!
INTEGER I
real(kind_real) ::     XI, YI
!
DO 1 I = 1,N
  XI = X(I)
  YI = Y(I)
  X(I) = C*XI + S*YI
  Y(I) = -S*XI + C*YI
    1   CONTINUE
RETURN
END subroutine ssrfpack_rotate


SUBROUTINE ssrfpack_setup (XI,YI,WI,WK,S1,S2,WT, ROW)
real(kind_real) ::  XI, YI, WI, WK, S1, S2, WT, ROW(6)
!
!***********************************************************
!
!                                              From SSRFPACK
!                                            Robert J. Renka
!                                  Dept. of Computer Science
!                                       Univ. of North Texas
!                                           renka@cs.unt.edu
!                                                   05/09/92
!
!   This subroutine sets up the I-th row of an augmented
! regression matrix for a weighted least squares fit of a
! quadratic function Q(X,Y) to a set of data values Wi,
! where Q(0,0) = Wk.  The first 3 columns (quadratic terms)
! are scaled by 1/S2 and the fourth and fifth columns (lin-
! ear terms) are scaled by 1/S1.
!
! On input:
!
!       XI,YI = Coordinates of node I.
!
!       WI = Data value at node I.
!
!       WK = Data value interpolated by Q at the origin.
!
!       S1,S2 = Inverse scale factors.
!
!       WT = Weight factor corresponding to the I-th
!            equation.
!
!       ROW = Array of length 6.
!
! Input parameters are not altered by this routine.
!
! On output:
!
!       ROW = Array containing a row of the augmented re-
!             gression matrix.
!
! Modules required by SETUP:  None
!
!***********************************************************
!
real(kind_real) ::  W1, W2
!
! Local parameters:
!
! W1 = Weighted scale factor for the linear terms
! W2 = Weighted scale factor for the quadratic terms
!
W1 = WT/S1
W2 = WT/S2
ROW(1) = XI*XI*W2
ROW(2) = XI*YI*W2
ROW(3) = YI*YI*W2
ROW(4) = XI*W1
ROW(5) = YI*W1
ROW(6) = (WI-WK)*WT
RETURN
END subroutine ssrfpack_setup

end module tools_ssrfpack
