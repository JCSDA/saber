#:include '../instrumentation.fypp'
!----------------------------------------------------------------------
! Module: tools_ssrfpack
!> SSRFPACK routines
! Source: https://dl.acm.org/doi/abs/10.1145/275323.275330
! Author: Robert Renka
! Original licensing: none
! Modified by Benjamin Menetrier for BUMP
! Licensing: this code is distributed under the CeCILL-C license
! Copyright 2015-... UCAR, CERFACS, METEO-FRANCE and IRIT
!----------------------------------------------------------------------
module tools_ssrfpack

use tools_const, only: zero,one,four,hundred,pi
use tools_kinds, only: kind_real
use tools_repro, only: eq,inf,sup,supeq,small
use tools_stripack
use type_mpl, only: mpl_type
@:use_probe()

implicit none

interface aplyr
   module procedure ssrfpack_aplyr
end interface
interface arcint
   module procedure ssrfpack_arcint
end interface
interface arcint_ori
   module procedure ssrfpack_arcint_ori
end interface
interface arclen
   module procedure ssrfpack_arclen
end interface
interface constr
   module procedure ssrfpack_constr
end interface
interface fval
   module procedure ssrfpack_fval
end interface
interface fval_ori
   module procedure ssrfpack_fval_ori
end interface
interface givens
   module procedure ssrfpack_givens
end interface
interface hval
   module procedure ssrfpack_hval
end interface
interface rotate
   module procedure ssrfpack_rotate
end interface
interface setup
   module procedure ssrfpack_setup
end interface

!private TODO
public !:: fval TODO

contains

SUBROUTINE ssrfpack_aplyr (X,Y,Z,CX,SX,CY,SY, XP,YP,ZP)
real(kind_real) ::  X, Y, Z, CX, SX, CY, SY, XP, YP, ZP
!
!***********************************************************
!
!                                              From SSRFPACK
!                                            Robert J. Renka
!                                  Dept. of Computer Science
!                                       Univ. of North Texas
!                                           renka@cs.unt.edu
!                                                   05/09/92
!
!   This subroutine applies the rotation R defined by Sub-
! routine CONSTR to the unit vector (X Y Z)**T, i,e. (X,Y,Z)
! is rotated to (XP,YP,ZP).  If (XP,YP,ZP) lies in the
! southern hemisphere (ZP < 0), (XP,YP) are set to the
! coordinates of the nearest point of the equator, ZP re-
! maining unchanged.
!
! On input:
!
!       X,Y,Z = Coordinates of a point on the unit sphere.
!
!       CX,SX,CY,SY = Elements of the rotation defined by
!                     Subroutine CONSTR.
!
! Input parameters are not altered except as noted below.
!
! On output:
!
!       XP,YP,ZP = Coordinates of the rotated point on the
!                  sphere unless ZP < 0, in which case
!                  (XP,YP,0) is the closest point of the
!                  equator to the rotated point.  Storage
!                  for XP, YP, and ZP may coincide with
!                  storage for X, Y, and Z, respectively,
!                  if the latter need not be saved.
!
! Modules required by APLYR:  None
!
! Intrinsic function called by APLYR:  SQRT
!
!***********************************************************
!
real(kind_real) ::  T
!
! Local parameter:
!
! T = Temporary variable
!
T = SX*Y + CX*Z
YP = CX*Y - SX*Z
ZP = SY*X + CY*T
XP = CY*X - SY*T
IF (ZP .GE. 0.) RETURN
!
! Move (XP,YP,ZP) to the equator.
!
T = SQRT(XP*XP + YP*YP)
IF (T .EQ. 0.) GO TO 1
XP = XP/T
YP = YP/T
RETURN
!
! Move the south pole to an arbitrary point of the equator.
!
    1 XP = 1.
YP = 0.
RETURN

end subroutine ssrfpack_aplyr


SUBROUTINE ssrfpack_arcint(P,P1,P2,A,AL,BB1,BB2,UN,UNORM)
real(kind_real) ::     P(3), P1(3), P2(3), A, AL, BB1, BB2, UN(3), UNORM

UN(1) = P1(2)*P2(3)-P1(3)*P2(2)
UN(2) = P1(3)*P2(1)-P1(1)*P2(3)
UN(3) = P1(1)*P2(2)-P1(2)*P2(1)
UNORM = SQRT(UN(1)*UN(1) + UN(2)*UN(2) + UN(3)*UN(3))
!IF (UNORM .EQ. 0.) TODO: call abort
UN = UN/UNORM
A = ARCLEN(P1,P2)
!IF (A .EQ. 0.) TODO: call abort
AL = ARCLEN(P1,P)
BB2 = AL/A
BB1 = 1. - BB2

END SUBROUTINE ssrfpack_arcint



SUBROUTINE ssrfpack_arcint_ori (P,P1,P2,F1,F2,G1,G2, F,G,GN)
real(kind_real) ::     P(3), P1(3), P2(3), F1, F2, G1(3), G2(3), &
    &         F, G(3), GN
INTEGER I, LUN
real(kind_real) ::     A, AL, B1, B2, CM, CMM, CM2, DUMMY, D1, D2, E, &
    &         EMS, E1, E2, GT, S, SB1, SB2, SIG, SINH, &
    &         SINH2, SM, SM2, TAU1, TAU2, TM, TM1, TM2, TP1, &
    &         TP2, TS, UN(3), UNORM
DATA    LUN/6/
UN(1) = P1(2)*P2(3) - P1(3)*P2(2)
UN(2) = P1(3)*P2(1) - P1(1)*P2(3)
UN(3) = P1(1)*P2(2) - P1(2)*P2(1)
UNORM = SQRT(UN(1)*UN(1) + UN(2)*UN(2) + UN(3)*UN(3))
IF (UNORM .EQ. 0.) GO TO 2
!
! Normalize UN.
!
DO 1 I = 1,3
  UN(I) = UN(I)/UNORM
    1   CONTINUE
!
! Compute tangential derivatives at the endpoints:
!   TAU1 = (G1,UN X P1) = (G1,P2)/UNORM and
!   TAU2 = (G2,UN X P2) = -(G2,P1)/UNORM.
!
TAU1 = (G1(1)*P2(1) + G1(2)*P2(2) + G1(3)*P2(3))/UNORM
TAU2 =-(G2(1)*P1(1) + G2(2)*P1(2) + G2(3)*P1(3))/UNORM
!
! Compute arc-lengths A, AL.
!
A = ARCLEN(P1,P2)
IF (A .EQ. 0.) GO TO 2
AL = ARCLEN(P1,P)
!
! Compute local coordinates, slope, and second differences.
!
B2 = AL/A
B1 = 1. - B2
S = (F2-F1)/A
D1 = S - TAU1
D2 = TAU2 - S
!
! Hermite cubic interpolation.
!
  F = F1 + AL*(TAU1 + B2*(D1 + B1*(D1 - D2)))
  GT = TAU1 + B2*(D1 + D2 + 3.*B1*(D1 - D2))
!
! Compute GN.
!
GN = B1*(UN(1)*G1(1) + UN(2)*G1(2) + UN(3)*G1(3)) + &
    &      B2*(UN(1)*G2(1) + UN(2)*G2(2) + UN(3)*G2(3))
!
! Compute G = GT*(UN X P) + GN*UN.
!
G(1) = GT*(UN(2)*P(3) - UN(3)*P(2)) + GN*UN(1)
G(2) = GT*(UN(3)*P(1) - UN(1)*P(3)) + GN*UN(2)
G(3) = GT*(UN(1)*P(2) - UN(2)*P(1)) + GN*UN(3)
RETURN
!
! P1 X P2 = 0.  Print an error message and terminate
!   processing.
!
    2 WRITE (LUN,100) (P1(I),I=1,3), (P2(I),I=1,3)
  100 FORMAT ('1','ERROR IN ARCINT -- P1 = ',2(F9.6,',  '), &
    &         F9.6/1X,19X,'P2 = ',2(F9.6,',  '),F9.6)
STOP
END SUBROUTINE ssrfpack_arcint_ori

real(kind_real) FUNCTION ssrfpack_arclen(P,Q)
real(kind_real) ::  P(3), Q(3)
!
!***********************************************************
!
!                                              From SSRFPACK
!                                            Robert J. Renka
!                                  Dept. of Computer Science
!                                       Univ. of North Texas
!                                           renka@cs.unt.edu
!                                                   05/09/92
!
!   This function computes the arc-length (angle in radians)
! between a pair of points on the unit sphere.
!
! On input:
!
!       P,Q = Arrays of length 3 containing the X, Y, and Z
!             coordinates (in that order) of points on the
!             unit sphere.
!
! Input parameters are not altered by this function.
!
! On output:
!
!       ARCLEN = Angle in radians between the unit vectors
!                P and Q.  0 .LE. ARCLEN .LE. PI.
!
! Modules required by ARCLEN:  None
!
! Intrinsic functions called by ARCLEN:  ATAN, SQRT
!
!***********************************************************
!
INTEGER I
real(kind_real) ::     D
!
! Local parameters:
!
! D = Euclidean norm squared of P+Q
! I = DO-loop index
!
D = 0.
DO 1 I = 1,3
  D = D + (P(I) + Q(I))**2
    1   CONTINUE
IF (D .EQ. 0.) THEN
!
! P and Q are separated by 180 degrees.
!
  ssrfpack_arclen = 4.*ATAN(1.)
ELSEIF (D .GE. 4.) THEN
!
! P and Q coincide.
!
  ssrfpack_arclen = 0.
ELSE
  ssrfpack_arclen = 2.*ATAN(SQRT((4.-D)/D))
ENDIF
RETURN
END function ssrfpack_arclen





SUBROUTINE ssrfpack_constr (XK,YK,ZK, CX,SX,CY,SY)
real(kind_real) ::  XK, YK, ZK, CX, SX, CY, SY
!
!***********************************************************
!
!                                              From SSRFPACK
!                                            Robert J. Renka
!                                  Dept. of Computer Science
!                                       Univ. of North Texas
!                                           renka@cs.unt.edu
!                                                   05/09/92
!
!   This subroutine constructs the elements of a 3 by 3
! orthogonal matrix R which rotates a point (XK,YK,ZK) on
! the unit sphere to the north pole, i.e.,
!
!      (XK)     (CY  0 -SY)   (1   0   0)   (XK)     (0)
!  R * (YK)  =  ( 0  1   0) * (0  CX -SX) * (YK)  =  (0)
!      (ZK)     (SY  0  CY)   (0  SX  CX)   (ZK)     (1)
!
! On input:
!
!       XK,YK,ZK = Components of a unit vector to be
!                  rotated to (0,0,1).
!
! Input parameters are not altered by this routine.
!
! On output:
!
!       CX,SX,CY,SY = Elements of R:  CX,SX define a rota-
!                     tion about the X-axis and CY,SY define
!                     a rotation about the Y-axis.
!
! Modules required by CONSTR:  None
!
! Intrinsic function called by CONSTR:  SQRT
!
!***********************************************************
!
CY = SQRT(YK*YK + ZK*ZK)
SY = XK
IF (CY .NE. 0.) THEN
  CX = ZK/CY
  SX = YK/CY
ELSE
!
! (XK,YK,ZK) lies on the X-axis.
!
  CX = 1.
  SX = 0.
ENDIF
RETURN
END subroutine ssrfpack_constr







real(kind_real) FUNCTION ssrfpack_fval (B1,B2,B3,V1,V2,V3,F1,F2,F3,G1,G2, &
    &                     G3)
real(kind_real) ::  B1, B2, B3, V1(3), V2(3), V3(3), F1, F2, F3, &
    &      G1(3), G2(3), G3(3)
!
!***********************************************************
!
!                                              From SSRFPACK
!                                            Robert J. Renka
!                                  Dept. of Computer Science
!                                       Univ. of North Texas
!                                           renka@cs.unt.edu
!                                                   05/09/92
!
!   Given data values and gradients at the three vertices of
! a spherical triangle containing a point P, this routine
! computes the value of F at P where F interpolates the ver-
! tex data.  Along the triangle sides, the interpolatory
! function F is the Hermite interpolatory tension spline
! defined by the values and tangential gradient components
! at the endpoints, and the gradient component normal to the
! triangle side varies linearly with respect to arc-length
! between the normal gradient components at the endpoints.
! A first-order C-1 blending method is used on the underly-
! ing planar triangle.  Since values and gradients on an arc
! depend only on the vertex data, the method results in C-1
! continuity when used to interpolate over a triangulation.
!
!   The blending method consists of taking F(P) to be a
! weighted sum of the values at PP of three univariate Her-
! mite interpolatory tension splines defined on the line
! segments which join the vertices to the opposite sides and
! pass through PP:  the central projection of P onto the
! underlying planar triangle.  The tension factors for these
! splines are obtained by linear interpolation between the
! pair of tension factors associated with the triangle sides
! which join at the appropriate vertex.
!
! On input:
!
!       B1,B2,B3 = Barycentric coordinates of PP with re-
!                  spect to the (planar) underlying triangle
!                  (V1,V2,V3), where PP is the central
!                  projection of P onto this triangle.
!
!       V1,V2,V3 = Cartesian coordinates of the vertices of
!                  a spherical triangle containing P.  V3
!                  Left V1->V2.
!
!       F1,F2,F3 = Data values associated with the vertices.
!
!       G1,G2,G3 = Gradients associated with the vertices.
!                  Gi is orthogonal to Vi for i = 1,2,3.
!
! Input parameters are not altered by this function.
!
! On output:
!
!       FVAL = Interpolated value at P.
!
! Each vector V above contains X, Y, and Z components in
!   V(1), V(2), and V(3), respectively.
!
! SSRFPACK modules required by FVAL:  ARCINT, ARCLEN, HVAL
!
! Intrinsic function called by FVAL:  SQRT
!
!***********************************************************
!
INTEGER I
real(kind_real) ::     C1, C2, C3, DUM, G(3), &
    &         Q1(3), Q2(3), Q3(3), SIG, CSUM, S1, S2, S3, &
    &         U1(3), U2(3), U3(3), U1N, U2N, U3N, VAL, A,AL,BB1,BB2,UN(3),UNORM,v

C1 = B2*B3
C2 = B3*B1
C3 = B1*B2
CSUM = C1 + C2 + C3
IF (CSUM .LE. 0.) THEN
!
! P coincides with a vertex.
!
  ssrfpack_fval = B1*F1 + B2*F2 + B3*F3
  RETURN
ENDIF
!
! Normalize C1, C2, and C3.
!
C1 = C1/CSUM
C2 = C2/CSUM
C3 = C3/CSUM
!
! Compute (S1,S2,S3), (U1,U2,U3) and (U1N,U2N,U3N).
!
S1 = B2 + B3
S2 = B3 + B1
S3 = B1 + B2
U1N = 0.
U2N = 0.
U3N = 0.
DO I = 1,3
  U1(I) = (B2*V2(I) + B3*V3(I))/S1
  U2(I) = (B3*V3(I) + B1*V1(I))/S2
  U3(I) = (B1*V1(I) + B2*V2(I))/S3
  U1N = U1N + U1(I)*U1(I)
  U2N = U2N + U2(I)*U2(I)
  U3N = U3N + U3(I)*U3(I)
ENDDO
!
! Compute Q1, Q2, and Q3.
!
U1N = SQRT(U1N)
U2N = SQRT(U2N)
U3N = SQRT(U3N)
DO I = 1,3
  Q1(I) = U1(I)/U1N
  Q2(I) = U2(I)/U2N
  Q3(I) = U3(I)/U3N
ENDDO

!
! Compute interpolated value (VAL) at P by looping on
!   triangle sides.
!
v = 0.

CALL ARCINT (Q1,V2,V3,A,AL,BB1,BB2,UN,UNORM)

G = 0.




!
!   Add in the contribution.
!
v = v+C1*(1.-B1)**2*(1.+2.*B1)*(1.-AL/A*BB2*(1.+2.*BB1))*F2
v = v+C1*(1.-B1)**2*(1.+2.*B1)*AL/A*BB2*(1.+2.*BB1)*F3
v = v+C1*(1.-B1)**2*(1.+2.*B1)*AL*(1.-BB2*(1.+BB1))*V3(1)/UNORM*G2(1)
v = v+C1*(1.-B1)**2*(1.+2.*B1)*AL*(1.-BB2*(1.+BB1))*V3(2)/UNORM*G2(2)
v = v+C1*(1.-B1)**2*(1.+2.*B1)*AL*(1.-BB2*(1.+BB1))*V3(3)/UNORM*G2(3)
v = v+C1*(1.-B1)**2*(1.+2.*B1)*AL*BB2*BB1*V2(1)/UNORM*G3(1)
v = v+C1*(1.-B1)**2*(1.+2.*B1)*AL*BB2*BB1*V2(2)/UNORM*G3(2)
v = v+C1*(1.-B1)**2*(1.+2.*B1)*AL*BB2*BB1*V2(3)/UNORM*G3(3)
v = v+C1*B1**2*(3.-2.*B1)*F1
v = v+C1*(1.-B1)*B1**2*U1(1)*G1(1)
v = v+C1*(1.-B1)*B1**2*U1(2)*G1(2)
v = v+C1*(1.-B1)*B1**2*U1(3)*G1(3)
v = v-C1*(1.-B1)**2*B1/U1N*V1(1)*(UN(2)*Q1(3)-UN(3)*Q1(2))*6.*BB1*BB2/A*F2
v = v+C1*(1.-B1)**2*B1/U1N*V1(1)*(UN(2)*Q1(3)-UN(3)*Q1(2))*6.*BB1*BB2/A*F3
v = v+C1*(1.-B1)**2*B1/U1N*V1(1)*(UN(1)*BB1*UN(1)+(UN(2)*Q1(3)-UN(3)*Q1(2))*(1.0-BB2-3.*BB1*BB2)*V3(1)/UNORM)*G2(1)
v = v+C1*(1.-B1)**2*B1/U1N*V1(1)*(UN(1)*BB1*UN(2)+(UN(2)*Q1(3)-UN(3)*Q1(2))*(1.0-BB2-3.*BB1*BB2)*V3(2)/UNORM)*G2(2)
v = v+C1*(1.-B1)**2*B1/U1N*V1(1)*(UN(1)*BB1*UN(3)+(UN(2)*Q1(3)-UN(3)*Q1(2))*(1.0-BB2-3.*BB1*BB2)*V3(3)/UNORM)*G2(3)
v = v+C1*(1.-B1)**2*B1/U1N*V1(1)*(UN(1)*BB2*UN(1)+(UN(2)*Q1(3)-UN(3)*Q1(2))*(3.*BB2*BB1-BB2)*V2(1)/UNORM)*G3(1)
v = v+C1*(1.-B1)**2*B1/U1N*V1(1)*(UN(1)*BB2*UN(2)+(UN(2)*Q1(3)-UN(3)*Q1(2))*(3.*BB2*BB1-BB2)*V2(2)/UNORM)*G3(2)
v = v+C1*(1.-B1)**2*B1/U1N*V1(1)*(UN(1)*BB2*UN(3)+(UN(2)*Q1(3)-UN(3)*Q1(2))*(3.*BB2*BB1-BB2)*V2(3)/UNORM)*G3(3)
v = v-C1*(1.-B1)**2*B1/U1N*V1(2)*(UN(3)*Q1(1)-UN(1)*Q1(3))*6.*BB1*BB2/A*F2
v = v+C1*(1.-B1)**2*B1/U1N*V1(2)*(UN(3)*Q1(1)-UN(1)*Q1(3))*6.*BB1*BB2/A*F3
v = v+C1*(1.-B1)**2*B1/U1N*V1(2)*(UN(2)*BB1*UN(1)+(UN(3)*Q1(1)-UN(1)*Q1(3))*(1.0-BB2-3.*BB1*BB2)*V3(1)/UNORM)*G2(1)
v = v+C1*(1.-B1)**2*B1/U1N*V1(2)*(UN(2)*BB1*UN(2)+(UN(3)*Q1(1)-UN(1)*Q1(3))*(1.0-BB2-3.*BB1*BB2)*V3(2)/UNORM)*G2(2)
v = v+C1*(1.-B1)**2*B1/U1N*V1(2)*(UN(2)*BB1*UN(3)+(UN(3)*Q1(1)-UN(1)*Q1(3))*(1.0-BB2-3.*BB1*BB2)*V3(3)/UNORM)*G2(3)
v = v+C1*(1.-B1)**2*B1/U1N*V1(2)*(UN(2)*BB2*UN(1)+(UN(3)*Q1(1)-UN(1)*Q1(3))*(3.*BB2*BB1-BB2)*V2(1)/UNORM)*G3(1)
v = v+C1*(1.-B1)**2*B1/U1N*V1(2)*(UN(2)*BB2*UN(2)+(UN(3)*Q1(1)-UN(1)*Q1(3))*(3.*BB2*BB1-BB2)*V2(2)/UNORM)*G3(2)
v = v+C1*(1.-B1)**2*B1/U1N*V1(2)*(UN(2)*BB2*UN(3)+(UN(3)*Q1(1)-UN(1)*Q1(3))*(3.*BB2*BB1-BB2)*V2(3)/UNORM)*G3(3)
v = v-C1*(1.-B1)**2*B1/U1N*V1(3)*(UN(1)*Q1(2)-UN(2)*Q1(1))*6.*BB1*BB2/A*F2
v = v+C1*(1.-B1)**2*B1/U1N*V1(3)*(UN(1)*Q1(2)-UN(2)*Q1(1))*6.*BB1*BB2/A*F3
v = v+C1*(1.-B1)**2*B1/U1N*V1(3)*(UN(3)*BB1*UN(1)+(UN(1)*Q1(2)-UN(2)*Q1(1))*(1.0-BB2-3.*BB1*BB2)*V3(1)/UNORM)*G2(1)
v = v+C1*(1.-B1)**2*B1/U1N*V1(3)*(UN(3)*BB1*UN(2)+(UN(1)*Q1(2)-UN(2)*Q1(1))*(1.0-BB2-3.*BB1*BB2)*V3(2)/UNORM)*G2(2)
v = v+C1*(1.-B1)**2*B1/U1N*V1(3)*(UN(3)*BB1*UN(3)+(UN(1)*Q1(2)-UN(2)*Q1(1))*(1.0-BB2-3.*BB1*BB2)*V3(3)/UNORM)*G2(3)
v = v+C1*(1.-B1)**2*B1/U1N*V1(3)*(UN(3)*BB2*UN(1)+(UN(1)*Q1(2)-UN(2)*Q1(1))*(3.*BB2*BB1-BB2)*V2(1)/UNORM)*G3(1)
v = v+C1*(1.-B1)**2*B1/U1N*V1(3)*(UN(3)*BB2*UN(2)+(UN(1)*Q1(2)-UN(2)*Q1(1))*(3.*BB2*BB1-BB2)*V2(2)/UNORM)*G3(2)
v = v+C1*(1.-B1)**2*B1/U1N*V1(3)*(UN(3)*BB2*UN(3)+(UN(1)*Q1(2)-UN(2)*Q1(1))*(3.*BB2*BB1-BB2)*V2(3)/UNORM)*G3(3)

!
! Contribution from side opposite V2:
!
!   Compute value and gradient at Q2 by interpolating
!     between V3 and V1.
!
CALL ARCINT (Q2,V3,V1,A,AL,BB1,BB2,UN,UNORM)
!
!   Add in the contribution.
!
v = v+C2*(1.-B2)**2*(1.+2.*B2)*(1.-AL/A*BB2*(1.+2.*BB1))*F3
v = v+C2*(1.-B2)**2*(1.+2.*B2)*AL/A*BB2*(1.+2.*BB1)*F1
v = v+C2*(1.-B2)**2*(1.+2.*B2)*AL*(1.-BB2*(1.+BB1))*V1(1)/UNORM*G3(1)
v = v+C2*(1.-B2)**2*(1.+2.*B2)*AL*(1.-BB2*(1.+BB1))*V1(2)/UNORM*G3(2)
v = v+C2*(1.-B2)**2*(1.+2.*B2)*AL*(1.-BB2*(1.+BB1))*V1(3)/UNORM*G3(3)
v = v+C2*(1.-B2)**2*(1.+2.*B2)*AL*BB2*BB1*V3(1)/UNORM*G1(1)
v = v+C2*(1.-B2)**2*(1.+2.*B2)*AL*BB2*BB1*V3(2)/UNORM*G1(2)
v = v+C2*(1.-B2)**2*(1.+2.*B2)*AL*BB2*BB1*V3(3)/UNORM*G1(3)
v = v+C2*B2**2*(3.-2.*B2)*F2
v = v+C2*(1.-B2)*B2**2*U2(1)*G2(1)
v = v+C2*(1.-B2)*B2**2*U2(2)*G2(2)
v = v+C2*(1.-B2)*B2**2*U2(3)*G2(3)
v = v-C2*(1.-B2)**2*B2/U2N*V2(1)*(UN(2)*Q2(3)-UN(3)*Q2(2))*6.*BB1*BB2/A*F3
v = v+C2*(1.-B2)**2*B2/U2N*V2(1)*(UN(2)*Q2(3)-UN(3)*Q2(2))*6.*BB1*BB2/A*F1
v = v+C2*(1.-B2)**2*B2/U2N*V2(1)*(UN(1)*BB1*UN(1)+(UN(2)*Q2(3)-UN(3)*Q2(2))*(1.0-BB2-3.*BB1*BB2)*V1(1)/UNORM)*G3(1)
v = v+C2*(1.-B2)**2*B2/U2N*V2(1)*(UN(1)*BB1*UN(2)+(UN(2)*Q2(3)-UN(3)*Q2(2))*(1.0-BB2-3.*BB1*BB2)*V1(2)/UNORM)*G3(2)
v = v+C2*(1.-B2)**2*B2/U2N*V2(1)*(UN(1)*BB1*UN(3)+(UN(2)*Q2(3)-UN(3)*Q2(2))*(1.0-BB2-3.*BB1*BB2)*V1(3)/UNORM)*G3(3)
v = v+C2*(1.-B2)**2*B2/U2N*V2(1)*(UN(1)*BB2*UN(1)+(UN(2)*Q2(3)-UN(3)*Q2(2))*(3.*BB2*BB1-BB2)*V3(1)/UNORM)*G1(1)
v = v+C2*(1.-B2)**2*B2/U2N*V2(1)*(UN(1)*BB2*UN(2)+(UN(2)*Q2(3)-UN(3)*Q2(2))*(3.*BB2*BB1-BB2)*V3(2)/UNORM)*G1(2)
v = v+C2*(1.-B2)**2*B2/U2N*V2(1)*(UN(1)*BB2*UN(3)+(UN(2)*Q2(3)-UN(3)*Q2(2))*(3.*BB2*BB1-BB2)*V3(3)/UNORM)*G1(3)
v = v-C2*(1.-B2)**2*B2/U2N*V2(2)*(UN(3)*Q2(1)-UN(1)*Q2(3))*6.*BB1*BB2/A*F3
v = v+C2*(1.-B2)**2*B2/U2N*V2(2)*(UN(3)*Q2(1)-UN(1)*Q2(3))*6.*BB1*BB2/A*F1
v = v+C2*(1.-B2)**2*B2/U2N*V2(2)*(UN(2)*BB1*UN(1)+(UN(3)*Q2(1)-UN(1)*Q2(3))*(1.0-BB2-3.*BB1*BB2)*V1(1)/UNORM)*G3(1)
v = v+C2*(1.-B2)**2*B2/U2N*V2(2)*(UN(2)*BB1*UN(2)+(UN(3)*Q2(1)-UN(1)*Q2(3))*(1.0-BB2-3.*BB1*BB2)*V1(2)/UNORM)*G3(2)
v = v+C2*(1.-B2)**2*B2/U2N*V2(2)*(UN(2)*BB1*UN(3)+(UN(3)*Q2(1)-UN(1)*Q2(3))*(1.0-BB2-3.*BB1*BB2)*V1(3)/UNORM)*G3(3)
v = v+C2*(1.-B2)**2*B2/U2N*V2(2)*(UN(2)*BB2*UN(1)+(UN(3)*Q2(1)-UN(1)*Q2(3))*(3.*BB2*BB1-BB2)*V3(1)/UNORM)*G1(1)
v = v+C2*(1.-B2)**2*B2/U2N*V2(2)*(UN(2)*BB2*UN(2)+(UN(3)*Q2(1)-UN(1)*Q2(3))*(3.*BB2*BB1-BB2)*V3(2)/UNORM)*G1(2)
v = v+C2*(1.-B2)**2*B2/U2N*V2(2)*(UN(2)*BB2*UN(3)+(UN(3)*Q2(1)-UN(1)*Q2(3))*(3.*BB2*BB1-BB2)*V3(3)/UNORM)*G1(3)
v = v-C2*(1.-B2)**2*B2/U2N*V2(3)*(UN(1)*Q2(2)-UN(2)*Q2(1))*6.*BB1*BB2/A*F3
v = v+C2*(1.-B2)**2*B2/U2N*V2(3)*(UN(1)*Q2(2)-UN(2)*Q2(1))*6.*BB1*BB2/A*F1
v = v+C2*(1.-B2)**2*B2/U2N*V2(3)*(UN(3)*BB1*UN(1)+(UN(1)*Q2(2)-UN(2)*Q2(1))*(1.0-BB2-3.*BB1*BB2)*V1(1)/UNORM)*G3(1)
v = v+C2*(1.-B2)**2*B2/U2N*V2(3)*(UN(3)*BB1*UN(2)+(UN(1)*Q2(2)-UN(2)*Q2(1))*(1.0-BB2-3.*BB1*BB2)*V1(2)/UNORM)*G3(2)
v = v+C2*(1.-B2)**2*B2/U2N*V2(3)*(UN(3)*BB1*UN(3)+(UN(1)*Q2(2)-UN(2)*Q2(1))*(1.0-BB2-3.*BB1*BB2)*V1(3)/UNORM)*G3(3)
v = v+C2*(1.-B2)**2*B2/U2N*V2(3)*(UN(3)*BB2*UN(1)+(UN(1)*Q2(2)-UN(2)*Q2(1))*(3.*BB2*BB1-BB2)*V3(1)/UNORM)*G1(1)
v = v+C2*(1.-B2)**2*B2/U2N*V2(3)*(UN(3)*BB2*UN(2)+(UN(1)*Q2(2)-UN(2)*Q2(1))*(3.*BB2*BB1-BB2)*V3(2)/UNORM)*G1(2)
v = v+C2*(1.-B2)**2*B2/U2N*V2(3)*(UN(3)*BB2*UN(3)+(UN(1)*Q2(2)-UN(2)*Q2(1))*(3.*BB2*BB1-BB2)*V3(3)/UNORM)*G1(3)

!
! Contribution from side opposite V3:
!
!   Compute interpolated value and gradient at Q3
!     by interpolating between V1 and V2.
!
CALL ARCINT (Q3,V1,V2,A,AL,BB1,BB2,UN,UNORM)
!
!   Add in the final contribution.
!
v = v+C3*(1.-B3)**2*(1.+2.*B3)*(1.-AL/A*BB2*(1.+2.*BB1))*F1
v = v+C3*(1.-B3)**2*(1.+2.*B3)*AL/A*BB2*(1.+2.*BB1)*F2
v = v+C3*(1.-B3)**2*(1.+2.*B3)*AL*(1.-BB2*(1.+BB1))*V2(1)/UNORM*G1(1)
v = v+C3*(1.-B3)**2*(1.+2.*B3)*AL*(1.-BB2*(1.+BB1))*V2(2)/UNORM*G1(2)
v = v+C3*(1.-B3)**2*(1.+2.*B3)*AL*(1.-BB2*(1.+BB1))*V2(3)/UNORM*G1(3)
v = v+C3*(1.-B3)**2*(1.+2.*B3)*AL*BB2*BB1*V1(1)/UNORM*G2(1)
v = v+C3*(1.-B3)**2*(1.+2.*B3)*AL*BB2*BB1*V1(2)/UNORM*G2(2)
v = v+C3*(1.-B3)**2*(1.+2.*B3)*AL*BB2*BB1*V1(3)/UNORM*G2(3)
v = v+C3*B3**2*(3.-2.*B3)*F3
v = v+C3*(1.-B3)*B3**2*U3(1)*G3(1)
v = v+C3*(1.-B3)*B3**2*U3(2)*G3(2)
v = v+C3*(1.-B3)*B3**2*U3(3)*G3(3)
v = v-C3*(1.-B3)**2*B3/U3N*V3(1)*(UN(2)*Q3(3)-UN(3)*Q3(2))*6.*BB1*BB2/A*F1
v = v+C3*(1.-B3)**2*B3/U3N*V3(1)*(UN(2)*Q3(3)-UN(3)*Q3(2))*6.*BB1*BB2/A*F2
v = v+C3*(1.-B3)**2*B3/U3N*V3(1)*(UN(1)*BB1*UN(1)+(UN(2)*Q3(3)-UN(3)*Q3(2))*(1.0-BB2-3.*BB1*BB2)*V2(1)/UNORM)*G1(1)
v = v+C3*(1.-B3)**2*B3/U3N*V3(1)*(UN(1)*BB1*UN(2)+(UN(2)*Q3(3)-UN(3)*Q3(2))*(1.0-BB2-3.*BB1*BB2)*V2(2)/UNORM)*G1(2)
v = v+C3*(1.-B3)**2*B3/U3N*V3(1)*(UN(1)*BB1*UN(3)+(UN(2)*Q3(3)-UN(3)*Q3(2))*(1.0-BB2-3.*BB1*BB2)*V2(3)/UNORM)*G1(3)
v = v+C3*(1.-B3)**2*B3/U3N*V3(1)*(UN(1)*BB2*UN(1)+(UN(2)*Q3(3)-UN(3)*Q3(2))*(3.*BB2*BB1-BB2)*V1(1)/UNORM)*G2(1)
v = v+C3*(1.-B3)**2*B3/U3N*V3(1)*(UN(1)*BB2*UN(2)+(UN(2)*Q3(3)-UN(3)*Q3(2))*(3.*BB2*BB1-BB2)*V1(2)/UNORM)*G2(2)
v = v+C3*(1.-B3)**2*B3/U3N*V3(1)*(UN(1)*BB2*UN(3)+(UN(2)*Q3(3)-UN(3)*Q3(2))*(3.*BB2*BB1-BB2)*V1(3)/UNORM)*G2(3)
v = v-C3*(1.-B3)**2*B3/U3N*V3(2)*(UN(3)*Q3(1)-UN(1)*Q3(3))*6.*BB1*BB2/A*F1
v = v+C3*(1.-B3)**2*B3/U3N*V3(2)*(UN(3)*Q3(1)-UN(1)*Q3(3))*6.*BB1*BB2/A*F2
v = v+C3*(1.-B3)**2*B3/U3N*V3(2)*(UN(2)*BB1*UN(1)+(UN(3)*Q3(1)-UN(1)*Q3(3))*(1.0-BB2-3.*BB1*BB2)*V2(1)/UNORM)*G1(1)
v = v+C3*(1.-B3)**2*B3/U3N*V3(2)*(UN(2)*BB1*UN(2)+(UN(3)*Q3(1)-UN(1)*Q3(3))*(1.0-BB2-3.*BB1*BB2)*V2(2)/UNORM)*G1(2)
v = v+C3*(1.-B3)**2*B3/U3N*V3(2)*(UN(2)*BB1*UN(3)+(UN(3)*Q3(1)-UN(1)*Q3(3))*(1.0-BB2-3.*BB1*BB2)*V2(3)/UNORM)*G1(3)
v = v+C3*(1.-B3)**2*B3/U3N*V3(2)*(UN(2)*BB2*UN(1)+(UN(3)*Q3(1)-UN(1)*Q3(3))*(3.*BB2*BB1-BB2)*V1(1)/UNORM)*G2(1)
v = v+C3*(1.-B3)**2*B3/U3N*V3(2)*(UN(2)*BB2*UN(2)+(UN(3)*Q3(1)-UN(1)*Q3(3))*(3.*BB2*BB1-BB2)*V1(2)/UNORM)*G2(2)
v = v+C3*(1.-B3)**2*B3/U3N*V3(2)*(UN(2)*BB2*UN(3)+(UN(3)*Q3(1)-UN(1)*Q3(3))*(3.*BB2*BB1-BB2)*V1(3)/UNORM)*G2(3)
v = v-C3*(1.-B3)**2*B3/U3N*V3(3)*(UN(1)*Q3(2)-UN(2)*Q3(1))*6.*BB1*BB2/A*F1
v = v+C3*(1.-B3)**2*B3/U3N*V3(3)*(UN(1)*Q3(2)-UN(2)*Q3(1))*6.*BB1*BB2/A*F2
v = v+C3*(1.-B3)**2*B3/U3N*V3(3)*(UN(3)*BB1*UN(1)+(UN(1)*Q3(2)-UN(2)*Q3(1))*(1.0-BB2-3.*BB1*BB2)*V2(1)/UNORM)*G1(1)
v = v+C3*(1.-B3)**2*B3/U3N*V3(3)*(UN(3)*BB1*UN(2)+(UN(1)*Q3(2)-UN(2)*Q3(1))*(1.0-BB2-3.*BB1*BB2)*V2(2)/UNORM)*G1(2)
v = v+C3*(1.-B3)**2*B3/U3N*V3(3)*(UN(3)*BB1*UN(3)+(UN(1)*Q3(2)-UN(2)*Q3(1))*(1.0-BB2-3.*BB1*BB2)*V2(3)/UNORM)*G1(3)
v = v+C3*(1.-B3)**2*B3/U3N*V3(3)*(UN(3)*BB2*UN(1)+(UN(1)*Q3(2)-UN(2)*Q3(1))*(3.*BB2*BB1-BB2)*V1(1)/UNORM)*G2(1)
v = v+C3*(1.-B3)**2*B3/U3N*V3(3)*(UN(3)*BB2*UN(2)+(UN(1)*Q3(2)-UN(2)*Q3(1))*(3.*BB2*BB1-BB2)*V1(2)/UNORM)*G2(2)
v = v+C3*(1.-B3)**2*B3/U3N*V3(3)*(UN(3)*BB2*UN(3)+(UN(1)*Q3(2)-UN(2)*Q3(1))*(3.*BB2*BB1-BB2)*V1(3)/UNORM)*G2(3)

ssrfpack_fval = v

RETURN
END function ssrfpack_fval

real(kind_real) FUNCTION ssrfpack_fval_ori (B1,B2,B3,V1,V2,V3,F1,F2,F3,G1,G2, &
    &                     G3)
real(kind_real) ::  B1, B2, B3, V1(3), V2(3), V3(3), F1, F2, F3, &
    &      G1(3), G2(3), G3(3)
!
!***********************************************************
!
!                                              From SSRFPACK
!                                            Robert J. Renka
!                                  Dept. of Computer Science
!                                       Univ. of North Texas
!                                           renka@cs.unt.edu
!                                                   05/09/92
!
!   Given data values and gradients at the three vertices of
! a spherical triangle containing a point P, this routine
! computes the value of F at P where F interpolates the ver-
! tex data.  Along the triangle sides, the interpolatory
! function F is the Hermite interpolatory tension spline
! defined by the values and tangential gradient components
! at the endpoints, and the gradient component normal to the
! triangle side varies linearly with respect to arc-length
! between the normal gradient components at the endpoints.
! A first-order C-1 blending method is used on the underly-
! ing planar triangle.  Since values and gradients on an arc
! depend only on the vertex data, the method results in C-1
! continuity when used to interpolate over a triangulation.
!
!   The blending method consists of taking F(P) to be a
! weighted sum of the values at PP of three univariate Her-
! mite interpolatory tension splines defined on the line
! segments which join the vertices to the opposite sides and
! pass through PP:  the central projection of P onto the
! underlying planar triangle.  The tension factors for these
! splines are obtained by linear interpolation between the
! pair of tension factors associated with the triangle sides
! which join at the appropriate vertex.
!
! On input:
!
!       B1,B2,B3 = Barycentric coordinates of PP with re-
!                  spect to the (planar) underlying triangle
!                  (V1,V2,V3), where PP is the central
!                  projection of P onto this triangle.
!
!       V1,V2,V3 = Cartesian coordinates of the vertices of
!                  a spherical triangle containing P.  V3
!                  Left V1->V2.
!
!       F1,F2,F3 = Data values associated with the vertices.
!
!       G1,G2,G3 = Gradients associated with the vertices.
!                  Gi is orthogonal to Vi for i = 1,2,3.
!
! Input parameters are not altered by this function.
!
! On output:
!
!       FVAL = Interpolated value at P.
!
! Each vector V above contains X, Y, and Z components in
!   V(1), V(2), and V(3), respectively.
!
! SSRFPACK modules required by FVAL:  ARCINT, ARCLEN, HVAL
!
! Intrinsic function called by FVAL:  SQRT
!
!***********************************************************
!
INTEGER I
real(kind_real) ::     C1, C2, C3, DS, DUM, DV, F, G(3), &
    &         Q1(3), Q2(3), Q3(3), SIG, SUM, S1, S2, S3, &
    &         U1(3), U2(3), U3(3), U1N, U2N, U3N, VAL
!
! Local parameters:
!
! C1,C2,C3 =    Coefficients (weight functions) of partial
!                 interpolants.  C1 = 1 on the edge opposite
!                 V1 and C1 = 0 on the other edges.  Simi-
!                 larly for C2 and C3.  C1+C2+C3 = 1.
! DS =          Directional derivative (scaled by distnace)
!                 at U1, U2, or U3:  DS = (G,U1-V1)/U1N =
!                 -(G,V1)/U1N on side opposite V1, where G/
!                 U1N (plus an orthogonal component) is the
!                 projection of G onto the planar triangle
! DUM =         Dummy variable for calls to ARCINT
! DV =          Directional derivatives (scaled by distance)
!                 at a vertex:  D1 = (G1,U1-V1) = (G1,U1)
! F,G =         Value and gradient at Q1 Q2, or Q3 obtained
!                 by interpolation along one of the arcs of
!                 the spherical triangle
! I =           DO-loop index
! Q1,Q2,Q3 =    Central projections of U1, U2, and U3 onto
!                 the sphere and thus lying on an arc of the
!                 spherical triangle
! SIG =         Tension factor for a side-vertex (partial)
!                 interpolant:  obtained by linear interpo-
!                 lation applied to triangle side tensions
! SUM =         Quantity used to normalize C1, C2, and C3
! S1,S2,S3 =    Sums of pairs of barycentric coordinates:
!                 used to compute U1, U2, U3, and SIG
! U1,U2,U3 =    Points on the boundary of the planar trian-
!                 gle and lying on the lines containing PP
!                 and the vertices.  U1 is opposite V1, etc.
! U1N,U2N,U3N = Quantities used to compute Q1, Q2, and Q3
!                 (magnitudes of U1, U2, and U3)
! VAL =         Local variable used to accumulate the con-
!                 tributions to FVAL
!
!
! Compute weight functions C1, C2, and C3.
!
C1 = B2*B3
C2 = B3*B1
C3 = B1*B2
SUM = C1 + C2 + C3
IF (SUM .LE. 0.) THEN
!
! P coincides with a vertex.
!
  ssrfpack_fval_ori = B1*F1 + B2*F2 + B3*F3
  RETURN
ENDIF
!
! Normalize C1, C2, and C3.
!
C1 = C1/SUM
C2 = C2/SUM
C3 = C3/SUM
!
! Compute (S1,S2,S3), (U1,U2,U3) and (U1N,U2N,U3N).
!
S1 = B2 + B3
S2 = B3 + B1
S3 = B1 + B2
U1N = 0.
U2N = 0.
U3N = 0.
DO 1 I = 1,3
  U1(I) = (B2*V2(I) + B3*V3(I))/S1
  U2(I) = (B3*V3(I) + B1*V1(I))/S2
  U3(I) = (B1*V1(I) + B2*V2(I))/S3
  U1N = U1N + U1(I)*U1(I)
  U2N = U2N + U2(I)*U2(I)
  U3N = U3N + U3(I)*U3(I)
    1   CONTINUE
!
! Compute Q1, Q2, and Q3.
!
U1N = SQRT(U1N)
U2N = SQRT(U2N)
U3N = SQRT(U3N)
DO 2 I = 1,3
  Q1(I) = U1(I)/U1N
  Q2(I) = U2(I)/U2N
  Q3(I) = U3(I)/U3N
    2   CONTINUE
!
! Compute interpolated value (VAL) at P by looping on
!   triangle sides.
!
VAL = 0.
!
! Contribution from side opposite V1:
!
!   Compute value and gradient at Q1 by interpolating
!     between V2 and V3.
!
CALL ARCINT_ori (Q1,V2,V3,F2,F3,G2,G3, F,G,DUM)
!
!   Add in the contribution.
!
DV = G1(1)*U1(1) + G1(2)*U1(2) + G1(3)*U1(3)
DS = -(G(1)*V1(1) + G(2)*V1(2) + G(3)*V1(3))/U1N
VAL = VAL + C1*HVAL(B1,F1,F,DV,DS)
!
! Contribution from side opposite V2:
!
!   Compute value and gradient at Q2 by interpolating
!     between V3 and V1.
!
CALL ARCINT_ori (Q2,V3,V1,F3,F1,G3,G1, F,G,DUM)
!
!   Add in the contribution.
!
DV = G2(1)*U2(1) + G2(2)*U2(2) + G2(3)*U2(3)
DS = -(G(1)*V2(1) + G(2)*V2(2) + G(3)*V2(3))/U2N
VAL = VAL + C2*HVAL(B2,F2,F,DV,DS)
!
! Contribution from side opposite V3:
!
!   Compute interpolated value and gradient at Q3
!     by interpolating between V1 and V2.
!
CALL ARCINT_ori (Q3,V1,V2,F1,F2,G1,G2, F,G,DUM)
!
!   Add in the final contribution.
!
DV = G3(1)*U3(1) + G3(2)*U3(2) + G3(3)*U3(3)
DS = -(G(1)*V3(1) + G(2)*V3(2) + G(3)*V3(3))/U3N
ssrfpack_fval_ori = VAL + C3*HVAL(B3,F3,F,DV,DS)
RETURN
END function ssrfpack_fval_ori

SUBROUTINE ssrfpack_GIVENS ( A,B, C,S)
real(kind_real) ::  A, B, C, S
!
!***********************************************************
!
!                                              From SSRFPACK
!                                            Robert J. Renka
!                                  Dept. of Computer Science
!                                       Univ. of North Texas
!                                           renka@cs.unt.edu
!                                                   05/09/92
!
!   This subroutine constructs the Givens plane rotation,
!
!           ( C  S)
!       G = (     ) , where C*C + S*S = 1,
!           (-S  C)
!
! which zeros the second component of the vector (A,B)**T
! (transposed).  Subroutine ROTATE may be called to apply
! the transformation to a 2 by N matrix.
!
!   This routine is identical to Subroutine SROTG from the
! LINPACK BLAS (Basic Linear Algebra Subroutines).
!
! On input:
!
!       A,B = Components of the vector defining the rota-
!             tion.  These are overwritten by values R
!             and Z (described below) which define C and S.
!
! On output:
!
!       A = Signed Euclidean norm R of the input vector:
!           R = +/-SQRT(A*A + B*B)
!
!       B = Value Z such that:
!             C = SQRT(1-Z*Z) and S=Z if ABS(Z) .LE. 1, and
!             C = 1/Z and S = SQRT(1-C*C) if ABS(Z) > 1.
!
!       C = +/-(A/R) or 1 if R = 0.
!
!       S = +/-(B/R) or 0 if R = 0.
!
! Modules required by GIVENS:  None
!
! Intrinsic functions called by GIVENS:  ABS, SQRT
!
!***********************************************************
!
real(kind_real) ::  AA, BB, R, U, V
!
! Local parameters:
!
! AA,BB = Local copies of A and B
! R =     C*A + S*B = +/-SQRT(A*A+B*B)
! U,V =   Variables used to scale A and B for computing R
!
AA = A
BB = B
IF (ABS(AA) .GT. ABS(BB)) THEN
!
! ABS(A) > ABS(B).
!
  U = AA + AA
  V = BB/U
  R = SQRT(.25 + V*V) * U
  C = AA/R
  S = V * (C + C)
!
! Note that R has the sign of A, C > 0, and S has
!   SIGN(A)*SIGN(B).
!
  B = S
  A = R
ELSEIF (BB .NE. 0.) THEN
!
! ABS(A) .LE. ABS(B).
!
  U = BB + BB
  V = AA/U
!
! Store R in A.
!
  A = SQRT(.25 + V*V) * U
  S = BB/A
  C = V * (S + S)
!
! Note that R has the sign of B, S > 0, and C has
!   SIGN(A)*SIGN(B).
!
  B = 1.
  IF (C .NE. 0.) B = 1./C
ELSE
!
! A = B = 0.
!
  C = 1.
  S = 0.
ENDIF
RETURN
END subroutine ssrfpack_givens

real(kind_real) FUNCTION ssrfpack_hval (B,H1,H2,HP1,HP2)
real(kind_real) ::  B, H1, H2, HP1, HP2
!
!***********************************************************
!
!                                              From SSRFPACK
!                                            Robert J. Renka
!                                  Dept. of Computer Science
!                                       Univ. of North Texas
!                                           renka@cs.unt.edu
!                                                   11/21/96
!
!   Given a line segment P1-P2 containing a point P, along
! with values and derivatives at the endpoints, this func-
! tion returns the value H(P), where H is the Hermite inter-
! polatory tension spline defined by the endpoint data.
!
! On input:
!
!       B = Local coordinate of P with respect to P1-P2:
!           P = B*P1 + (1-B)*P2, and thus B = d(P,P2)/
!           d(P1,P2), where d(P1,P2) is the distance between
!           P1 and P2.  B < 0 or B > 1 results in extrapola-
!           tion.
!
!       H1,H2 = Values interpolated at P1 and P2, respec-
!               tively.
!
!       HP1,HP2 = Products of d(P1,P2) with first order der-
!                 ivatives at P1 and P2, respectively.  HP1
!                 may, for example, be the scalar product of
!                 P2-P1 with a gradient at P1.
!
! Input parameters are not altered by this function.
!
! On output:
!
!       HVAL = Interpolated value H(P).
!
! SSRFPACK module required by HVAL:  SNHCSH
!
! Intrinsic functions called by HVAL:  ABS, EXP
!
!***********************************************************
!
real(kind_real) ::  B1, B2, CM, CM2, CMM, D1, D2, DUMMY, E, E1, E2, &
    &      EMS, S, SB1, SB2, SM, SM2, TM, TM1, TM2, TS
B1 = B
B2 = 1. - B1
!
! Compute slope S and second differences D1 and D2 scaled
!   by the separation between P1 and P2.
!
S = H2 - H1
D1 = S - HP1
D2 = HP2 - S
!
! Hermite cubic interpolation:
!
  ssrfpack_hval = H1 + B2*(HP1 + B2*(D1 + B1*(D1 - D2)))
RETURN
END function ssrfpack_hval

SUBROUTINE ssrfpack_rotate (N,C,S, X,Y )
INTEGER N
real(kind_real) ::     C, S, X(N), Y(N)
!
!***********************************************************
!
!                                              From SSRFPACK
!                                            Robert J. Renka
!                                  Dept. of Computer Science
!                                       Univ. of North Texas
!                                           renka@cs.unt.edu
!                                                   09/01/88
!
!                                                ( C  S)
!   This subroutine applies the Givens rotation  (     )  to
!                                                (-S  C)
!                    (X(1) ... X(N))
! the 2 by N matrix  (             ) .
!                    (Y(1) ... Y(N))
!
!   This routine is identical to Subroutine SROT from the
! LINPACK BLAS (Basic Linear Algebra Subroutines).
!
! On input:
!
!       N = Number of columns to be rotated.
!
!       C,S = Elements of the Givens rotation.  Refer to
!             Subroutine GIVENS.
!
! The above parameters are not altered by this routine.
!
!       X,Y = Arrays of length .GE. N containing the compo-
!             nents of the vectors to be rotated.
!
! On output:
!
!       X,Y = Arrays containing the rotated vectors (not
!             altered if N < 1).
!
! Modules required by ROTATE:  None
!
!***********************************************************
!
INTEGER I
real(kind_real) ::     XI, YI
!
DO 1 I = 1,N
  XI = X(I)
  YI = Y(I)
  X(I) = C*XI + S*YI
  Y(I) = -S*XI + C*YI
    1   CONTINUE
RETURN
END subroutine ssrfpack_rotate


SUBROUTINE ssrfpack_setup (XI,YI,WI,WK,S1,S2,WT, ROW)
real(kind_real) ::  XI, YI, WI, WK, S1, S2, WT, ROW(6)
!
!***********************************************************
!
!                                              From SSRFPACK
!                                            Robert J. Renka
!                                  Dept. of Computer Science
!                                       Univ. of North Texas
!                                           renka@cs.unt.edu
!                                                   05/09/92
!
!   This subroutine sets up the I-th row of an augmented
! regression matrix for a weighted least squares fit of a
! quadratic function Q(X,Y) to a set of data values Wi,
! where Q(0,0) = Wk.  The first 3 columns (quadratic terms)
! are scaled by 1/S2 and the fourth and fifth columns (lin-
! ear terms) are scaled by 1/S1.
!
! On input:
!
!       XI,YI = Coordinates of node I.
!
!       WI = Data value at node I.
!
!       WK = Data value interpolated by Q at the origin.
!
!       S1,S2 = Inverse scale factors.
!
!       WT = Weight factor corresponding to the I-th
!            equation.
!
!       ROW = Array of length 6.
!
! Input parameters are not altered by this routine.
!
! On output:
!
!       ROW = Array containing a row of the augmented re-
!             gression matrix.
!
! Modules required by SETUP:  None
!
!***********************************************************
!
real(kind_real) ::  W1, W2
!
! Local parameters:
!
! W1 = Weighted scale factor for the linear terms
! W2 = Weighted scale factor for the quadratic terms
!
W1 = WT/S1
W2 = WT/S2
ROW(1) = XI*XI*W2
ROW(2) = XI*YI*W2
ROW(3) = YI*YI*W2
ROW(4) = XI*W1
ROW(5) = YI*W1
ROW(6) = (WI-WK)*WT
RETURN
END subroutine ssrfpack_setup

end module tools_ssrfpack
