#:include '../generics.fypp'
!----------------------------------------------------------------------
! Module: tools_repro
!> Reproducibility functions
! Author: Benjamin Menetrier
! Licensing: this code is distributed under the CeCILL-C license
! Copyright 2015-... UCAR, CERFACS, METEO-FRANCE and IRIT
!----------------------------------------------------------------------
module tools_repro

use tools_const, only: pi
use tools_kinds, only: kind_int,kind_real
use type_mpl, only: mpl_type

implicit none

logical :: repro = .true.                  !< Reproducibility flag
real(kind_real),parameter :: rth = 1.0e-12 !< Reproducibility threshold

interface eq
  #:for dtype,ftype in types_irl
     module procedure eq_${dtype}$
  #:endfor
end interface
interface inf
  #:for dtype,ftype in types_ir
     module procedure inf_${dtype}$
  #:endfor
end interface
interface infeq
  #:for dtype,ftype in types_ir
     module procedure infeq_${dtype}$
  #:endfor
end interface
interface sup
  #:for dtype,ftype in types_ir
     module procedure sup_${dtype}$
  #:endfor
end interface
interface supeq
  #:for dtype,ftype in types_ir
     module procedure supeq_${dtype}$
  #:endfor
end interface

private
public :: repro,rth
public :: eq,inf,infeq,sup,supeq,indist,small

contains

#:for dtype,ftype in types_irl
!----------------------------------------------------------------------
! Function: eq_${dtype}$
!> Equal test for ${dtype}$
!----------------------------------------------------------------------
function eq_${dtype}$(x,y) result(test)

implicit none

! Passed variables
${ftype}$,intent(in) :: x !< First real
${ftype}$,intent(in) :: y !< Second real

! Returned variable
logical :: test

#{if dtype == 'int'}# test = (x==y) #{endif}#
#:if dtype == 'real'
   if (repro) then
      test = indist(x,y)
   else
      test = .not.(abs(x-y)>0.0)
   end if
#:endif
#{if dtype == 'logical'}# test = (x.eqv.y) #{endif}#

end function eq_${dtype}$
#:endfor

#:for dtype,ftype in types_ir
!----------------------------------------------------------------------
! Function: inf_${dtype}$
!> Inferior test for ${dtype}$
!----------------------------------------------------------------------
function inf_${dtype}$(x,y) result(test)

implicit none

! Passed variables
${ftype}$,intent(in) :: x !< First real
${ftype}$,intent(in) :: y !< Second real

! Returned variable
logical :: test

test = (x<y)
#{if dtype == 'real'}# if (repro) test = test.and.(.not.indist(x,y)) #{endif}#

end function inf_${dtype}$
#:endfor

#:for dtype,ftype in types_ir
!----------------------------------------------------------------------
! Function: infeq_${dtype}$
!> Inferior or equal test for ${dtype}$
!----------------------------------------------------------------------
function infeq_${dtype}$(x,y) result(test)

implicit none

! Passed variables
${ftype}$,intent(in) :: x !< First real
${ftype}$,intent(in) :: y !< Second real

! Returned variable
logical :: test

test = inf(x,y).or.eq(x,y)

end function infeq_${dtype}$
#:endfor

#:for dtype,ftype in types_ir
!----------------------------------------------------------------------
! Function: sup_${dtype}$
!> Superior test for ${dtype}$
!----------------------------------------------------------------------
function sup_${dtype}$(x,y) result(test)

implicit none

! Passed variables
${ftype}$,intent(in) :: x !< First real
${ftype}$,intent(in) :: y !< Second real

! Returned variable
logical :: test

test = (x>y)
#{if dtype == 'real'}# if (repro) test = test.and.(.not.indist(x,y)) #{endif}#

end function sup_${dtype}$
#:endfor

#:for dtype,ftype in types_ir
!----------------------------------------------------------------------
! Function: supeq_${dtype}$
!> Superior or equal test for ${dtype}$
!----------------------------------------------------------------------
function supeq_${dtype}$(x,y) result(test)

implicit none

! Passed variables
${ftype}$,intent(in) :: x !< First real
${ftype}$,intent(in) :: y !< Second real

! Returned variable
logical :: test

test = sup(x,y).or.eq(x,y)

end function supeq_${dtype}$
#:endfor

!----------------------------------------------------------------------
! Function: indist
!> Indistiguishability test
!----------------------------------------------------------------------
function indist(x,y) result(test)

implicit none

! Passed variables
real(kind_real),intent(in) :: x !< First real
real(kind_real),intent(in) :: y !< Second real

! Returned variable
logical :: test

test = .false.
if (repro) then
      if ((abs(x)>0.0).or.(abs(y)>0.0)) then
      test = abs(x-y)<rth*(abs(x+y))
   else
      test = .true.
   end if
end if

end function indist

!----------------------------------------------------------------------
! Function: small
!> Small value test
!----------------------------------------------------------------------
function small(x,y) result(test)

implicit none

! Passed variables
real(kind_real),intent(in) :: x !< First real
real(kind_real),intent(in) :: y !< Second real

! Returned variable
logical :: test

test = .false.
if (repro) test = abs(x)<rth*abs(y)

end function small

end module tools_repro
