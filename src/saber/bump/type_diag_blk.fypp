#:include '../instrumentation.fypp'
!----------------------------------------------------------------------
! Module: type_diag_blk
!> Diagnostic block derived type
! Author: Benjamin Menetrier
! Licensing: this code is distributed under the CeCILL-C license
! Copyright 2015-... UCAR, CERFACS, METEO-FRANCE and IRIT
!----------------------------------------------------------------------
module type_diag_blk

!$ use omp_lib
use tools_const, only: zero,hundredth,tenth,half,one,two,five,ten
use tools_fit, only: fast_fit,ver_fill
use tools_func, only: fit_diag,vert_interp_size,vert_interp_setup,vert_interp
use tools_kinds, only: kind_real,huge_real
use tools_netcdf, only: define_grp,put_att,define_var,put_var
use tools_repro, only: inf,sup
use type_avg_blk, only: avg_blk_type
use type_bpar, only: bpar_type
use type_geom, only: geom_type
use type_minim, only: minim_type
use type_mpl, only: mpl_type
use type_nam, only: nam_type
@:use_probe()
use type_samp, only: samp_type

implicit none

integer,parameter :: nsc = 50                !< Number of iterations for the scaling optimization
real(kind_real),parameter :: maxfactor = two !< Maximum factor for diagnostics with respect to the origin

! Diagnostic block derived type
type diag_blk_type
   integer :: ic2a                                !< Local index
   integer :: ib                                  !< Block index
   character(len=1024) :: prefix                  !< Prefix

   real(kind_real),allocatable :: raw(:,:,:)      !< Raw diagnostic
   real(kind_real),allocatable :: valid(:,:,:)    !< Number of valid couples
   real(kind_real),allocatable :: coef_ens(:)     !< Ensemble coefficient
   real(kind_real) :: coef_sta                    !< Static coefficient
   real(kind_real),allocatable :: fit(:,:,:)      !< Fit
   real(kind_real),allocatable :: fit_rh(:)       !< Horizontal fit support radius
   real(kind_real),allocatable :: fit_rv(:)       !< Vertical fit support radius
   real(kind_real),allocatable :: distv(:,:)      !< Reduced vertical distance
contains
   procedure :: alloc => diag_blk_alloc
   procedure :: dealloc => diag_blk_dealloc
   procedure :: write => diag_blk_write
   procedure :: normalization => diag_blk_normalization
   procedure :: fitting => diag_blk_fitting
   procedure :: localization => diag_blk_localization
   procedure :: hybridization => diag_blk_hybridization
   procedure :: dualens => diag_blk_dualens
end type diag_blk_type

private
public :: diag_blk_type

contains

!----------------------------------------------------------------------
! Subroutine: diag_blk_alloc
!> Allocation
!----------------------------------------------------------------------
subroutine diag_blk_alloc(diag_blk,mpl,nam,geom,bpar,samp,ic2a,ib,prefix)

implicit none

! Passed variables
class(diag_blk_type),intent(inout) :: diag_blk !< Diagnostic block
type(mpl_type),intent(inout) :: mpl            !< MPI data
type(nam_type),intent(in) :: nam               !< Namelist
type(geom_type),intent(in) :: geom             !< Geometry
type(bpar_type),intent(in) :: bpar             !< Block parameters
type(samp_type),intent(in) :: samp             !< Sampling
integer,intent(in) :: ic2a                     !< Local index
integer,intent(in) :: ib                       !< Block index
character(len=*),intent(in) :: prefix          !< Block prefix

! Local variables
integer :: il0,jl0r,jl0
real(kind_real) :: vunit(geom%nl0)

! Set name
@:set_name(diag_blk_alloc)

! Probe in
@:probe_in()

! Set attributes
diag_blk%ic2a = ic2a
diag_blk%ib = ib
diag_blk%prefix = prefix

! Allocation
if ((ic2a==0).or.nam%local_diag) then
   allocate(diag_blk%raw(bpar%nc3(ib),bpar%nl0r(ib),geom%nl0))
   allocate(diag_blk%valid(bpar%nc3(ib),bpar%nl0r(ib),geom%nl0))
   allocate(diag_blk%coef_ens(geom%nl0))
   allocate(diag_blk%fit(bpar%nc3(ib),bpar%nl0r(ib),geom%nl0))
   allocate(diag_blk%fit_rh(geom%nl0))
   allocate(diag_blk%fit_rv(geom%nl0))
   allocate(diag_blk%distv(bpar%nl0r(ib),geom%nl0))
end if

! Initialization
diag_blk%coef_sta = mpl%msv%valr
if ((ic2a==0).or.nam%local_diag) then
   diag_blk%raw = mpl%msv%valr
   diag_blk%valid = mpl%msv%valr
   diag_blk%coef_ens = mpl%msv%valr
   diag_blk%fit = mpl%msv%valr
   diag_blk%fit_rh = mpl%msv%valr
   diag_blk%fit_rv = mpl%msv%valr
end if

! Vertical distance
if (((ic2a==0).or.nam%local_diag)) then
   if (ic2a==0) then
      vunit = geom%vunitavg
   else
      vunit = samp%vunit_c2a(ic2a,:)
   end if
   do il0=1,geom%nl0
      do jl0r=1,bpar%nl0r(ib)
         jl0 = bpar%l0rl0b_to_l0(jl0r,il0,ib)
         diag_blk%distv(jl0r,il0) = abs(vunit(il0)-vunit(jl0))
      end do
   end do
end if

! Probe out
@:probe_out()

end subroutine diag_blk_alloc

!----------------------------------------------------------------------
! Subroutine: diag_blk_dealloc
!> Release memory
!----------------------------------------------------------------------
subroutine diag_blk_dealloc(diag_blk)

implicit none

! Passed variables
class(diag_blk_type),intent(inout) :: diag_blk !< Diagnostic block

! Set name
@:set_name(diag_blk_dealloc)

! Probe in
@:probe_in()

! Release memory
if (allocated(diag_blk%raw)) deallocate(diag_blk%raw)
if (allocated(diag_blk%valid)) deallocate(diag_blk%valid)
if (allocated(diag_blk%coef_ens)) deallocate(diag_blk%coef_ens)
if (allocated(diag_blk%fit)) deallocate(diag_blk%fit)
if (allocated(diag_blk%fit_rh)) deallocate(diag_blk%fit_rh)
if (allocated(diag_blk%fit_rv)) deallocate(diag_blk%fit_rv)
if (allocated(diag_blk%distv)) deallocate(diag_blk%distv)

! Probe out
@:probe_out()

end subroutine diag_blk_dealloc

!----------------------------------------------------------------------
! Subroutine: diag_blk_write
!> Write
!----------------------------------------------------------------------
subroutine diag_blk_write(diag_blk,mpl,geom,bpar,ncid,nc3_id,nl0r_id,nl0_1_id,nl0_2_id)

implicit none

! Passed variables
class(diag_blk_type),intent(inout) :: diag_blk !< Diagnostic block
type(mpl_type),intent(inout) :: mpl            !< MPI data
type(geom_type),intent(in) :: geom             !< Geometry
type(bpar_type),intent(in) :: bpar             !< Block parameters
integer,intent(in) :: ncid                     !< NetCDF ID
integer,intent(in) :: nc3_id                   !< NetCDF ID
integer,intent(in) :: nl0r_id                  !< NetCDF ID
integer,intent(in) :: nl0_1_id                 !< NetCDF ID
integer,intent(in) :: nl0_2_id                 !< NetCDF ID

! Local variables
integer :: grpid
integer :: raw_id,valid_id,coef_ens_id,raw_zs_id,l0rl0_to_l0_id
integer :: fit_id,fit_zs_id,fit_rh_id,fit_rv_id
integer :: il0,jl0r,jl0

! Set name
@:set_name(diag_blk_write)

! Probe in
@:probe_in()

! Associate
associate(ib=>diag_blk%ib,ic2a=>diag_blk%ic2a)

! Define group
grpid = define_grp(mpl,ncid,diag_blk%prefix)

! Define variables
if (mpl%msv%isanynot(diag_blk%raw)) then
   raw_id = define_var(mpl,grpid,'raw','real',(/nc3_id,nl0r_id,nl0_1_id/))
   valid_id = define_var(mpl,grpid,'valid','real',(/nc3_id,nl0r_id,nl0_1_id/))
   if (bpar%nl0rmax/=geom%nl0) raw_zs_id = define_var(mpl,grpid,'raw_zs','real',(/nl0_2_id,nl0_1_id/))
   l0rl0_to_l0_id = define_var(mpl,grpid,'l0rl0_to_l0','int',(/nl0r_id,nl0_1_id/))
end if
if (mpl%msv%isanynot(diag_blk%coef_ens)) coef_ens_id = define_var(mpl,grpid,'coef_ens','real',(/nl0_1_id/))
if (mpl%msv%isanynot(diag_blk%fit)) then
   fit_id = define_var(mpl,grpid,'fit','real',(/nc3_id,nl0r_id,nl0_1_id/))
   if (bpar%nl0rmax/=geom%nl0) fit_zs_id = define_var(mpl,grpid,'fit_zs','real',(/nl0_2_id,nl0_1_id/))
   fit_rh_id = define_var(mpl,grpid,'fit_rh','real',(/nl0_1_id/))
   fit_rv_id = define_var(mpl,grpid,'fit_rv','real',(/nl0_1_id/))
end if

! Write variables
if (mpl%msv%isanynot(diag_blk%raw)) then
   call put_var(mpl,grpid,raw_id,diag_blk%raw)
   call put_var(mpl,grpid,valid_id,diag_blk%valid)
   if (bpar%nl0rmax/=geom%nl0) then
      do il0=1,geom%nl0
         do jl0r=1,bpar%nl0rmax
            jl0 = bpar%l0rl0b_to_l0(jl0r,il0,ib)
            call put_var(mpl,grpid,raw_zs_id,diag_blk%raw(1,jl0r,il0),(/jl0,il0/))
         end do
      end do
   end if
   call put_var(mpl,grpid,l0rl0_to_l0_id,bpar%l0rl0b_to_l0(1:bpar%nl0r(ib),:,ib))
end if
if (mpl%msv%isanynot(diag_blk%coef_ens)) call put_var(mpl,grpid,coef_ens_id,diag_blk%coef_ens)
if (mpl%msv%isnot(diag_blk%coef_sta)) call put_att(mpl,grpid,'coef_sta',diag_blk%coef_sta)
if (mpl%msv%isanynot(diag_blk%fit)) then
   call put_var(mpl,grpid,fit_id,diag_blk%fit)
   if (bpar%nl0rmax/=geom%nl0) then
      do il0=1,geom%nl0
         do jl0r=1,bpar%nl0rmax
            jl0 = bpar%l0rl0b_to_l0(jl0r,il0,ib)
            call put_var(mpl,grpid,fit_zs_id,diag_blk%fit(1,jl0r,il0),(/jl0,il0/))
          end do
        end do
    end if
    call put_var(mpl,grpid,fit_rh_id,diag_blk%fit_rh)
    call put_var(mpl,grpid,fit_rv_id,diag_blk%fit_rv)
end if

! End associate
end associate

! Probe out
@:probe_out()

end subroutine diag_blk_write

!----------------------------------------------------------------------
! Subroutine: diag_blk_normalization
!> Compute diagnostic block normalization
!----------------------------------------------------------------------
subroutine diag_blk_normalization(diag_blk,geom,bpar)

implicit none

! Passed variables
class(diag_blk_type),intent(inout) :: diag_blk !< Diagnostic block
type(geom_type),intent(in) :: geom             !< Geometry
type(bpar_type),intent(in) :: bpar             !< Block parameters

! Local variables
integer :: il0,jl0rz

! Set name
@:set_name(diag_blk_normalization)

! Probe in
@:probe_in()

! Associate
associate(ib=>diag_blk%ib)

! Get diagonal values
do il0=1,geom%nl0
   jl0rz = bpar%il0rz(il0,ib)
   diag_blk%coef_ens(il0) = diag_blk%raw(1,jl0rz,il0)
end do

! End associate
end associate

! Probe out
@:probe_out()

end subroutine diag_blk_normalization

!----------------------------------------------------------------------
! Subroutine: diag_blk_fitting
!> Compute a fit of a raw function
!----------------------------------------------------------------------
subroutine diag_blk_fitting(diag_blk,mpl,nam,geom,bpar,coef)

implicit none

! Passed variables
class(diag_blk_type),intent(inout) :: diag_blk !< Diagnostic block
type(mpl_type),intent(inout) :: mpl            !< MPI data
type(nam_type),intent(in) :: nam               !< Namelist
type(geom_type),intent(in) :: geom             !< Geometry
type(bpar_type),intent(in) :: bpar             !< Block parameters
logical,intent(in),optional :: coef            !< Coefficient estimation flag

! Local variables
integer :: il0,jl0rz,nl0r,ix,il1,nl1,ilev2d
integer,allocatable :: il0_interp(:),il1inf(:),il1sup(:)
real(kind_real) :: m2(geom%nl0)
real(kind_real),allocatable :: rawv(:),rinf(:),rsup(:),coef_ens_l1(:),fit_rh_l1(:),fit_rv_l1(:)
logical :: var2d,lcoef,lrh,lrv
type(minim_type) :: minim

! Set name
@:set_name(diag_blk_fitting)

! Probe in
@:probe_in()

! Associate
associate(ic2a=>diag_blk%ic2a,ib=>diag_blk%ib)

! Initialization
diag_blk%fit_rh = mpl%msv%valr
diag_blk%fit_rv = mpl%msv%valr
diag_blk%fit = mpl%msv%valr

! Check for 2D variable
do il0=1,geom%nl0
   ! Get zero separation level
   jl0rz = bpar%il0rz(il0,ib)

   ! Get value at zero separation
   m2(il0) = diag_blk%raw(1,jl0rz,il0)
end do
if ((count(m2>zero)==1).and.(trim(nam%lev2d)=='first').and.(m2(1)>zero)) then
   var2d = .true.
   ilev2d = 1
   diag_blk%fit_rv(ilev2d) = zero
elseif ((count(m2>zero)==1).and.(trim(nam%lev2d)=='last').and.(m2(geom%nl0)>zero)) then
   var2d = .true.
   ilev2d = geom%nl0
   diag_blk%fit_rv(ilev2d) = zero
else
   var2d = .false.
end if

! Number of effective levels
if (var2d) then
   nl0r = 1
else
   nl0r = bpar%nl0r(ib)
end if

! Count interpolation levels
if (var2d) then
   nl1 = 1
else
   call vert_interp_size(geom%nl0,nam%fit_dl0,nl1)
end if

! Allocation
if (.not.var2d) allocate(rawv(nl0r))
allocate(il0_interp(nl1))
allocate(il1inf(geom%nl0))
allocate(il1sup(geom%nl0))
allocate(rinf(geom%nl0))
allocate(rsup(geom%nl0))
allocate(coef_ens_l1(nl1))
allocate(fit_rh_l1(nl1))
allocate(fit_rv_l1(nl1))

! Get interpolation levels and weights
if (var2d) then
   il0_interp(1) = ilev2d
   il1inf = 1
   il1sup = 1
   rinf = zero
   rsup = zero
   rsup(ilev2d) = one
else
   call vert_interp_setup(geom%nl0,nam%fit_dl0,nl1,il0_interp,il1inf,il1sup,rinf,rsup)
end if

! Initialization
coef_ens_l1 = diag_blk%coef_ens(il0_interp)

! Hooke parameters
minim%hooke_rho = half
minim%hooke_tol = 1.0e-4_kind_real
minim%hooke_itermax = 10

do il1=1,nl1
   ! Index
   il0 = il0_interp(il1)

   ! Get zero separation level and min/max levels
   jl0rz = bpar%il0rz(il0,ib)

   ! Horizontal fast fit
   call fast_fit(mpl,nam%nc3,1,geom%disth,diag_blk%raw(:,jl0rz,il0),fit_rh_l1(il1))

   ! Vertical fast fit
   if (var2d.or.(nl0r==1)) then
      fit_rv_l1(il1) = zero
   else
      rawv = diag_blk%raw(1,:,il0)
      call fast_fit(mpl,nl0r,jl0rz,diag_blk%distv(:,il0),rawv,fit_rv_l1(il1))
   end if

   if (mpl%msv%isnot(coef_ens_l1(il1)).and.mpl%msv%isnot(fit_rh_l1(il1)).and.mpl%msv%isnot(fit_rv_l1(il1))) then
      ! Optimization parameters
      lcoef = (coef_ens_l1(il1)>zero)
      if (present(coef)) lcoef = coef
      lrh = (fit_rh_l1(il1)>zero)
      lrv = (fit_rv_l1(il1)>zero)

      ! Allocation
      minim%nx = 0
      if (lcoef) minim%nx = minim%nx+1
      if (lrh) minim%nx = minim%nx+1
      if (lrv) minim%nx = minim%nx+1
      minim%ny = nam%nc3*nl0r
      allocate(minim%x(minim%nx))
      allocate(minim%guess(minim%nx))
      allocate(minim%binf(minim%nx))
      allocate(minim%bsup(minim%nx))
      allocate(minim%obs(minim%ny))
      allocate(minim%disth(nam%nc3))
      allocate(minim%distv(nl0r))

      ! Fill guess and bounds
      ix = 0
      if (lcoef) then
         ix = ix+1
         minim%guess(ix) = coef_ens_l1(il1)
         minim%binf(ix) = tenth*minim%guess(ix)
         minim%bsup(ix) = ten*minim%guess(ix)
      end if
      if (lrh) then
         ix = ix+1
         minim%guess(ix) = fit_rh_l1(il1)
         minim%binf(ix) = tenth*minim%guess(ix)
         minim%bsup(ix) = ten*minim%guess(ix)
      end if
      if (lrv) then
         ix = ix+1
         minim%guess(ix) = fit_rv_l1(il1)
         minim%binf(ix) = tenth*minim%guess(ix)
         minim%bsup(ix) = ten*minim%guess(ix)
      end if

      ! Fill obs
      if (var2d) then
         minim%obs = diag_blk%raw(:,bpar%il0rz(il0,ib),il0)
      else
         minim%obs = reshape(diag_blk%raw(:,:,il0),(/minim%ny/))
      end if
      minim%cost_function = 'fit_diag'
      minim%nc3 = nam%nc3
      minim%nl0r = nl0r
      minim%disth = geom%disth
      minim%distv = diag_blk%distv(:,il0)
      minim%lcoef = lcoef
      minim%lrh = lrh
      minim%lrv = lrv

      ! Compute fit
      call minim%compute(mpl)

      ! Apply bounds
      minim%x = max(minim%binf,min(minim%x,minim%bsup))

      ! Get parameters
      ix = 0
      if (lcoef) then
         ix = ix+1
         coef_ens_l1(il1) = minim%x(ix)
      elseif (.not.present(coef)) then
         coef_ens_l1(il1) = mpl%msv%valr
      end if
      if (lrh) then
         ix = ix+1
         fit_rh_l1(il1) = minim%x(ix)
      else
         fit_rh_l1(il1) = mpl%msv%valr
      end if
      if (lrv) then
         ix = ix+1
         fit_rv_l1(il1) = minim%x(ix)
      elseif (.not.(var2d.or.(nl0r==1))) then
         fit_rv_l1(il1) = mpl%msv%valr
      end if

      ! Release memory
      deallocate(minim%x)
      deallocate(minim%guess)
      deallocate(minim%binf)
      deallocate(minim%bsup)
      deallocate(minim%obs)
      deallocate(minim%disth)
      deallocate(minim%distv)
   else
      ! Set to missing values
      coef_ens_l1(il1) = mpl%msv%valr
      fit_rh_l1(il1) = mpl%msv%valr
      fit_rv_l1(il1) = mpl%msv%valr
   end if
end do

! Interpolate parameters
call vert_interp(mpl,nl1,coef_ens_l1,geom%nl0,il1inf,il1sup,rinf,rsup,diag_blk%coef_ens)
call vert_interp(mpl,nl1,fit_rh_l1,geom%nl0,il1inf,il1sup,rinf,rsup,diag_blk%fit_rh)
call vert_interp(mpl,nl1,fit_rv_l1,geom%nl0,il1inf,il1sup,rinf,rsup,diag_blk%fit_rv)

! Release memory
if (.not.var2d) deallocate(rawv)
deallocate(il0_interp)
deallocate(il1inf)
deallocate(il1sup)
deallocate(rinf)
deallocate(rsup)
deallocate(coef_ens_l1)
deallocate(fit_rh_l1)
deallocate(fit_rv_l1)

! End associate
end associate

! Probe out
@:probe_out()

end subroutine diag_blk_fitting

!----------------------------------------------------------------------
! Subroutine: diag_blk_localization
!> Diag_blk localization
!----------------------------------------------------------------------
subroutine diag_blk_localization(diag_blk,mpl,geom,bpar,avg_blk)

implicit none

! Passed variables
class(diag_blk_type),intent(inout) :: diag_blk !< Diagnostic block (localization)
type(mpl_type),intent(inout) :: mpl            !< MPI data
type(geom_type),intent(in) :: geom             !< Geometry
type(bpar_type),intent(in) :: bpar             !< Block parameters
type(avg_blk_type),intent(in) :: avg_blk       !< Averaged statistics block

! Local variables
integer :: il0,jl0r,jc3

! Set name
@:set_name(diag_blk_localization)

! Probe in
@:probe_in()

! Associate
associate(ib=>diag_blk%ib)

!$omp parallel do schedule(static) private(il0,jl0r,jc3) shared(geom,bpar,diag_blk,avg_blk)
do il0=1,geom%nl0
   do jl0r=1,bpar%nl0r(ib)
      do jc3=1,bpar%nc3(ib)
         if (mpl%msv%isnot(avg_blk%m11asysq(jc3,jl0r,il0)).and.mpl%msv%isnot(avg_blk%m11sq(jc3,jl0r,il0))) then
            ! Compute localization
            diag_blk%raw(jc3,jl0r,il0) = avg_blk%m11asysq(jc3,jl0r,il0)/avg_blk%m11sq(jc3,jl0r,il0)
            diag_blk%valid(jc3,jl0r,il0) = avg_blk%nc1a(jc3,jl0r,il0)
         else
            ! Missing value
            diag_blk%raw(jc3,jl0r,il0) = mpl%msv%valr
            diag_blk%valid(jc3,jl0r,il0) = mpl%msv%valr
         end if
      end do
   end do
end do
!$omp end parallel do

! Hybrid weight
diag_blk%coef_sta = mpl%msv%valr

! End associate
end associate

! Probe out
@:probe_out()

end subroutine diag_blk_localization

!----------------------------------------------------------------------
! Subroutine: diag_blk_hybridization
!> Diag_blk hybridization
!----------------------------------------------------------------------
subroutine diag_blk_hybridization(diag_blk,mpl,nam,geom,bpar,avg_blk)

implicit none

! Passed variables
class(diag_blk_type),intent(inout) :: diag_blk !< Diagnostic block (localization)
type(mpl_type),intent(inout) :: mpl            !< MPI data
type(nam_type),intent(in) :: nam               !< Namelist
type(geom_type),intent(in) :: geom             !< Geometry
type(bpar_type),intent(in) :: bpar             !< Block parameters
type(avg_blk_type),intent(in) :: avg_blk       !< Averaged statistics block

! Local variables
integer :: il0,jl0r,jl0,jc3,iv
real(kind_real) :: wgt,a,bc,d,e,f,num_ens,num_sta,num,den

! Set name
@:set_name(diag_blk_hybridization)

! Probe in
@:probe_in()

! Associate
associate(ib=>diag_blk%ib)

if (nam%forced_radii) then
   ! Compute forced localization function
   iv = bpar%b_to_v1(ib)
   do il0=1,geom%nl0
      ! Compute fit
      call fit_diag(mpl,nam%nc3,bpar%nl0r(ib),geom%disth,diag_blk%distv(:,il0), &
 & one,nam%rh(il0,iv),nam%rv(il0,iv),diag_blk%raw(:,:,il0))
   end do
   diag_blk%valid = mpl%msv%valr

   ! Compute hybrid weights
   a = zero
   bc = zero
   d = zero
   e = zero
   f = zero
   do il0=1,geom%nl0
      do jl0r=1,bpar%nl0r(ib)
         jl0 = bpar%l0rl0b_to_l0(jl0r,il0,ib)
         do jc3=1,bpar%nc3(ib)
            if (mpl%msv%isnot(avg_blk%m11asysq(jc3,jl0r,il0)).and.mpl%msv%isnot(avg_blk%m11sq(jc3,jl0r,il0)) &
 & .and.mpl%msv%isnot(avg_blk%m11sta(jc3,jl0r,il0)).and.mpl%msv%isnot(avg_blk%stasq(jc3,jl0r,il0))) then
               wgt = geom%disth(jc3)*diag_blk%distv(jl0,il0)/real(bpar%nl0r(ib)+bpar%nc3(ib),kind_real)
               a = a+wgt*diag_blk%raw(jc3,jl0r,il0)**2*avg_blk%m11sq(jc3,jl0r,il0)
               bc = bc+wgt*diag_blk%raw(jc3,jl0r,il0)*avg_blk%m11sta(jc3,jl0r,il0)
               d = d+wgt*avg_blk%stasq(jc3,jl0r,il0)
               e = e+wgt*diag_blk%raw(jc3,jl0r,il0)*avg_blk%m11asysq(jc3,jl0r,il0)
               f = f+wgt*avg_blk%m11sta(jc3,jl0r,il0)
            end if
         end do
      end do
   end do
   num_ens = e*d-bc*f
   num_sta = a*f-e*bc
   den = a*d-bc**2
   if ((num_ens>zero).and.(num_sta>zero).and.(den>zero)) then
      ! Valid numerators and denominator
      diag_blk%coef_ens = num_ens/den
      diag_blk%coef_sta = num_sta/den
   else
      ! Missing values
      diag_blk%coef_ens = mpl%msv%valr
      diag_blk%coef_sta = mpl%msv%valr
   end if
else
   ! Compute raw hybridization
   num = zero
   den = zero
   do il0=1,geom%nl0
      do jl0r=1,bpar%nl0r(ib)
         jl0 = bpar%l0rl0b_to_l0(jl0r,il0,ib)
         do jc3=1,bpar%nc3(ib)
            if (mpl%msv%isnot(avg_blk%m11asysq(jc3,jl0r,il0)).and.mpl%msv%isnot(avg_blk%m11sq(jc3,jl0r,il0)) &
 & .and.mpl%msv%isnot(avg_blk%m11sta(jc3,jl0r,il0)).and.mpl%msv%isnot(avg_blk%stasq(jc3,jl0r,il0))) then
               wgt = geom%disth(jc3)*diag_blk%distv(jl0,il0)/real(bpar%nl0r(ib)+bpar%nc3(ib),kind_real)
               num = num+wgt*(one-avg_blk%m11asysq(jc3,jl0r,il0)/avg_blk%m11sq(jc3,jl0r,il0))*avg_blk%m11sta(jc3,jl0r,il0)
               den = den+wgt*(avg_blk%stasq(jc3,jl0r,il0)-avg_blk%m11sta(jc3,jl0r,il0)**2/avg_blk%m11sq(jc3,jl0r,il0))
            end if
         end do
      end do
   end do
   if ((num>zero).and.(den>zero)) then
      ! Valid numerator and denominator
      diag_blk%coef_sta = num/den

      !$omp parallel do schedule(static) private(il0,jl0r,jc3) shared(geom,bpar,diag_blk)
      do il0=1,geom%nl0
         do jl0r=1,bpar%nl0r(ib)
            do jc3=1,bpar%nc3(ib)
               if (mpl%msv%isnot(avg_blk%m11asysq(jc3,jl0r,il0)).and.mpl%msv%isnot(diag_blk%coef_sta) &
 & .and.mpl%msv%isnot(avg_blk%m11sta(jc3,jl0r,il0)).and.mpl%msv%isnot(avg_blk%m11sq(jc3,jl0r,il0))) then
                  ! Compute localization
                  diag_blk%raw(jc3,jl0r,il0) = (avg_blk%m11asysq(jc3,jl0r,il0)-diag_blk%coef_sta &
 & *avg_blk%m11sta(jc3,jl0r,il0))/avg_blk%m11sq(jc3,jl0r,il0)
                  diag_blk%valid(jc3,jl0r,il0) = avg_blk%nc1a(jc3,jl0r,il0)

                  ! Lower bound
                  if (diag_blk%raw(jc3,jl0r,il0)<zero) then
                     diag_blk%raw(jc3,jl0r,il0) = mpl%msv%valr
                     diag_blk%valid(jc3,jl0r,il0) = mpl%msv%valr
                  end if
               else
                  ! Missing value
                  diag_blk%raw(jc3,jl0r,il0) = mpl%msv%valr
                  diag_blk%valid(jc3,jl0r,il0) = mpl%msv%valr
               end if
            end do
         end do
      end do
      !$omp end parallel do
   else
      ! Missing values
      diag_blk%coef_sta = mpl%msv%valr
      diag_blk%raw = mpl%msv%valr
   end if
end if

! End associate
end associate

! Probe out
@:probe_out()

end subroutine diag_blk_hybridization

!----------------------------------------------------------------------
! Subroutine: diag_blk_dualens
!> Diag_blk dualens
!----------------------------------------------------------------------
subroutine diag_blk_dualens(diag_blk,mpl,geom,bpar,avg_blk,avg_lr_blk,diag_lr_blk)

implicit none

! Passed variables
class(diag_blk_type),intent(inout) :: diag_blk   !< Diagnostic block (localization)
type(mpl_type),intent(inout) :: mpl              !< MPI data
type(geom_type),intent(in) :: geom               !< Geometry
type(bpar_type),intent(in) :: bpar               !< Block parameters
type(avg_blk_type),intent(in) :: avg_blk         !< Averaged statistics block
type(avg_blk_type),intent(in) :: avg_lr_blk      !< LR averaged statistics block
type(diag_blk_type),intent(inout) :: diag_lr_blk !< Diagnostic block (LR localization)

! Local variables
integer :: il0,jl0r,jc3
real(kind_real),allocatable :: num(:),num_lr(:),den(:)

! Set name
@:set_name(diag_blk_dualens)

! Probe in
@:probe_in()

! Associate
associate(ib=>diag_blk%ib)

! Allocation
allocate(num(bpar%nc3(ib)))
allocate(num_lr(bpar%nc3(ib)))
allocate(den(bpar%nc3(ib)))

! Compute raw dual-ensemble hybridization
do il0=1,geom%nl0
   do jl0r=1,bpar%nl0r(ib)
      do jc3=1,bpar%nc3(ib)
         if (mpl%msv%isnot(avg_blk%m11asysq(jc3,jl0r,il0)).and.mpl%msv%isnot(avg_blk%m11sq(jc3,jl0r,il0)) &
 & .and.mpl%msv%isnot(avg_blk%m11lrm11asy(jc3,jl0r,il0)).and.mpl%msv%isnot(avg_blk%m11lrm11(jc3,jl0r,il0)) &
 & .and.mpl%msv%isnot(avg_lr_blk%m11sq(jc3,jl0r,il0)).and.mpl%msv%isnot(avg_blk%m11lrm11asy(jc3,jl0r,il0))) then
            num(jc3) = avg_blk%m11asysq(jc3,jl0r,il0)*avg_lr_blk%m11sq(jc3,jl0r,il0) &
 & -avg_blk%m11lrm11asy(jc3,jl0r,il0)*avg_blk%m11lrm11(jc3,jl0r,il0)
            num_lr(jc3) = avg_blk%m11lrm11asy(jc3,jl0r,il0)*avg_blk%m11sq(jc3,jl0r,il0) &
 & -avg_blk%m11asysq(jc3,jl0r,il0)*avg_blk%m11lrm11(jc3,jl0r,il0)
            den(jc3) = avg_blk%m11sq(jc3,jl0r,il0)*avg_lr_blk%m11sq(jc3,jl0r,il0)-avg_blk%m11lrm11(jc3,jl0r,il0)**2
            if ((num(jc3)>zero).and.(den(jc3)>zero)) then
               ! Compute localization
               diag_blk%raw(jc3,jl0r,il0) = num(jc3)/den(jc3)
               diag_lr_blk%raw(jc3,jl0r,il0) = num_lr(jc3)/den(jc3)
               diag_blk%valid(jc3,jl0r,il0) = avg_blk%nc1a(jc3,jl0r,il0)
               diag_lr_blk%valid(jc3,jl0r,il0) = avg_blk%nc1a(jc3,jl0r,il0)
            else
               ! Missing value
               diag_blk%raw(jc3,jl0r,il0) = mpl%msv%valr
               diag_lr_blk%raw(jc3,jl0r,il0) = mpl%msv%valr
               diag_blk%valid(jc3,jl0r,il0) = mpl%msv%valr
               diag_lr_blk%valid(jc3,jl0r,il0) = mpl%msv%valr
            end if
         end if
      end do
   end do
end do

! Hybrid weight
diag_blk%coef_sta = mpl%msv%valr

! Release memory
deallocate(num)
deallocate(num_lr)
deallocate(den)

! End associate
end associate

! Probe out
@:probe_out()

end subroutine diag_blk_dualens

end module type_diag_blk
