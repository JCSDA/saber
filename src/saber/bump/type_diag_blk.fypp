#:include '../instrumentation.fypp'
!----------------------------------------------------------------------
! Module: type_diag_blk
!> Diagnostic block derived type
! Author: Benjamin Menetrier
! Licensing: this code is distributed under the CeCILL-C license
! Copyright 2015-... UCAR, CERFACS, METEO-FRANCE and IRIT
!----------------------------------------------------------------------
module type_diag_blk

!$ use omp_lib
use tools_const, only: zero,hundredth,tenth,half,one,two,three,five,seven,ten
use tools_fit, only: fast_fit
use tools_fftw, only: hor_sqrt
use tools_func, only: vert_interp_size,vert_interp_setup,vert_interp,fit_diag_sqrt,fit_diag,fit_diag_full
use tools_gc99, only: nl,inldef
use tools_kinds, only: kind_real,huge_real
use tools_netcdf, only: define_grp,put_att,define_var,put_var
use tools_repro, only: inf,sup
use tools_wrfda
use type_avg_blk, only: avg_blk_type
use type_bpar, only: bpar_type
use type_geom, only: geom_type
use type_mpl, only: mpl_type
use type_nam, only: nam_type
@:use_probe()
use type_samp, only: samp_type

implicit none

integer,parameter :: ad_n = 5                      !< Minimum number of points to optimize anti-diagonal vertical fit
real(kind_real),parameter :: ad_th = 0.3_kind_real !< Threshold to optimize anti-diagonal vertical fit

! Diagnostic block derived type
type diag_blk_type
   integer :: ic2a                                     !< Local index
   integer :: ib                                       !< Block index
   character(len=1024) :: prefix                       !< Prefix

   real(kind_real),allocatable :: raw(:,:,:)           !< Raw diagnostic
   real(kind_real),allocatable :: valid(:,:,:)         !< Number of valid couples
   real(kind_real),allocatable :: coef_ens(:)          !< Ensemble coefficient
   real(kind_real) :: coef_sta                         !< Static coefficient

   real(kind_real),allocatable :: fit(:,:,:)           !< Fit
   real(kind_real),allocatable :: fit_rh(:)            !< Horizontal support radius
   real(kind_real),allocatable :: fit_pkh(:)           !< Horizontal peakness
   real(kind_real),allocatable :: fit_rv(:)            !< Vertical support radius
   real(kind_real),allocatable :: fit_pkv(:)           !< Vertical peakness
   real(kind_real),allocatable :: fit_nlv(:)           !< Vertical negative lobe parameter
   real(kind_real),allocatable :: vunit(:)             !< Vertical unit
   real(kind_real),allocatable :: distv(:,:)           !< Reduced vertical distance

   real(kind_real),allocatable :: raw_hor_sqrt(:,:)    !< Raw diagnostic horizontal square-root
   real(kind_real),allocatable :: raw_hor_sqrt_norm(:) !< Raw diagnostic horizontal square-root normalization
   real(kind_real),allocatable :: raw_zs_sqrt(:,:)     !< Raw diagnostic at zero separation square-root
   real(kind_real),allocatable :: raw_zs_sqrt_norm(:)  !< Raw diagnostic at zero separation square-root normalization
   real(kind_real),allocatable :: fit_hor_sqrt(:,:)    !< Fit horizontal square-root
   real(kind_real),allocatable :: fit_zs_sqrt(:,:)     !< Fit at zero separation square-root
contains
   procedure :: alloc => diag_blk_alloc
   procedure :: dealloc => diag_blk_dealloc
   procedure :: write => diag_blk_write
   procedure :: normalization => diag_blk_normalization
   procedure :: fitting => diag_blk_fitting
   procedure :: localization => diag_blk_localization
   procedure :: hybridization => diag_blk_hybridization
   procedure :: dualens => diag_blk_dualens
end type diag_blk_type

private
public :: diag_blk_type

contains

!----------------------------------------------------------------------
! Subroutine: diag_blk_alloc
!> Allocation
!----------------------------------------------------------------------
subroutine diag_blk_alloc(diag_blk,mpl,nam,geom,bpar,samp,ic2a,ib,prefix)

implicit none

! Passed variables
class(diag_blk_type),intent(inout) :: diag_blk !< Diagnostic block
type(mpl_type),intent(inout) :: mpl            !< MPI data
type(nam_type),intent(in) :: nam               !< Namelist
type(geom_type),intent(in) :: geom             !< Geometry
type(bpar_type),intent(in) :: bpar             !< Block parameters
type(samp_type),intent(in) :: samp             !< Sampling
integer,intent(in) :: ic2a                     !< Local index
integer,intent(in) :: ib                       !< Block index
character(len=*),intent(in) :: prefix          !< Block prefix

! Local variables
integer :: il0,jl0r,jl0

! Set name
@:set_name(diag_blk_alloc)

! Probe in
@:probe_in()

! Set attributes
diag_blk%ic2a = ic2a
diag_blk%ib = ib
diag_blk%prefix = prefix

! Allocation
if ((ic2a==0).or.nam%local_diag) then
   allocate(diag_blk%raw(bpar%nc3(ib),bpar%nl0r(ib),geom%nl0))
   allocate(diag_blk%valid(bpar%nc3(ib),bpar%nl0r(ib),geom%nl0))
   allocate(diag_blk%coef_ens(geom%nl0))
   allocate(diag_blk%fit(bpar%nc3(ib),bpar%nl0r(ib),geom%nl0))
   allocate(diag_blk%fit_rh(geom%nl0))
   allocate(diag_blk%fit_pkh(geom%nl0))
   allocate(diag_blk%fit_rv(geom%nl0))
   allocate(diag_blk%fit_pkv(geom%nl0))
   allocate(diag_blk%fit_nlv(geom%nl0))
   allocate(diag_blk%vunit(geom%nl0))
   allocate(diag_blk%distv(bpar%nl0r(ib),geom%nl0))
   if (nam%diag_sqrt) then
      allocate(diag_blk%raw_hor_sqrt(bpar%nc3(ib),geom%nl0))
      allocate(diag_blk%raw_hor_sqrt_norm(geom%nl0))
      allocate(diag_blk%raw_zs_sqrt(bpar%nl0r(ib),geom%nl0))
      allocate(diag_blk%raw_zs_sqrt_norm(geom%nl0))
      allocate(diag_blk%fit_hor_sqrt(bpar%nc3(ib),geom%nl0))
      allocate(diag_blk%fit_zs_sqrt(bpar%nl0r(ib),geom%nl0))
   end if
end if

! Initialization
if ((ic2a==0).or.nam%local_diag) then
   diag_blk%raw = mpl%msv%valr
   diag_blk%valid = mpl%msv%valr
   diag_blk%coef_ens = mpl%msv%valr
   diag_blk%coef_sta = mpl%msv%valr
   diag_blk%fit = mpl%msv%valr
   diag_blk%fit_rh = mpl%msv%valr
   diag_blk%fit_pkh = mpl%msv%valr
   diag_blk%fit_rv = mpl%msv%valr
   diag_blk%fit_pkv = mpl%msv%valr
   diag_blk%fit_nlv = mpl%msv%valr
   if (nam%diag_sqrt) then
      diag_blk%raw_hor_sqrt = mpl%msv%valr
      diag_blk%raw_hor_sqrt_norm = mpl%msv%valr
      diag_blk%raw_zs_sqrt = mpl%msv%valr
      diag_blk%raw_zs_sqrt_norm = mpl%msv%valr
      diag_blk%fit_hor_sqrt = mpl%msv%valr
      diag_blk%fit_zs_sqrt = mpl%msv%valr
   end if
end if

! Vertical unit and distance
if ((ic2a==0).or.nam%local_diag) then
   if (ic2a==0) then
      diag_blk%vunit = geom%vunitavg
   else
      diag_blk%vunit = samp%vunit_c2a(ic2a,:)
   end if
   do il0=1,geom%nl0
      do jl0r=1,bpar%nl0r(ib)
         jl0 = bpar%l0rl0b_to_l0(jl0r,il0,ib)
         diag_blk%distv(jl0r,il0) = abs(diag_blk%vunit(il0)-diag_blk%vunit(jl0))
      end do
   end do
end if

! Probe out
@:probe_out()

end subroutine diag_blk_alloc

!----------------------------------------------------------------------
! Subroutine: diag_blk_dealloc
!> Release memory
!----------------------------------------------------------------------
subroutine diag_blk_dealloc(diag_blk)

implicit none

! Passed variables
class(diag_blk_type),intent(inout) :: diag_blk !< Diagnostic block

! Set name
@:set_name(diag_blk_dealloc)

! Probe in
@:probe_in()

! Release memory
if (allocated(diag_blk%raw)) deallocate(diag_blk%raw)
if (allocated(diag_blk%valid)) deallocate(diag_blk%valid)
if (allocated(diag_blk%coef_ens)) deallocate(diag_blk%coef_ens)
if (allocated(diag_blk%fit)) deallocate(diag_blk%fit)
if (allocated(diag_blk%fit_rh)) deallocate(diag_blk%fit_rh)
if (allocated(diag_blk%fit_pkh)) deallocate(diag_blk%fit_pkh)
if (allocated(diag_blk%fit_rv)) deallocate(diag_blk%fit_rv)
if (allocated(diag_blk%fit_pkv)) deallocate(diag_blk%fit_pkv)
if (allocated(diag_blk%fit_nlv)) deallocate(diag_blk%fit_nlv)
if (allocated(diag_blk%vunit)) deallocate(diag_blk%vunit)
if (allocated(diag_blk%distv)) deallocate(diag_blk%distv)
if (allocated(diag_blk%raw_hor_sqrt)) deallocate(diag_blk%raw_hor_sqrt)
if (allocated(diag_blk%raw_hor_sqrt_norm)) deallocate(diag_blk%raw_hor_sqrt_norm)
if (allocated(diag_blk%raw_zs_sqrt)) deallocate(diag_blk%raw_zs_sqrt)
if (allocated(diag_blk%raw_zs_sqrt_norm)) deallocate(diag_blk%raw_zs_sqrt_norm)
if (allocated(diag_blk%fit_hor_sqrt)) deallocate(diag_blk%fit_hor_sqrt)
if (allocated(diag_blk%fit_zs_sqrt)) deallocate(diag_blk%fit_zs_sqrt)

! Probe out
@:probe_out()

end subroutine diag_blk_dealloc

!----------------------------------------------------------------------
! Subroutine: diag_blk_write
!> Write
!----------------------------------------------------------------------
subroutine diag_blk_write(diag_blk,mpl,nam,geom,bpar,ncid,nc3_id,nl0r_id,nl0_1_id,nl0_2_id)

implicit none

! Passed variables
class(diag_blk_type),intent(inout) :: diag_blk !< Diagnostic block
type(mpl_type),intent(inout) :: mpl            !< MPI data
type(nam_type),intent(in) :: nam               !< Namelist
type(geom_type),intent(in) :: geom             !< Geometry
type(bpar_type),intent(in) :: bpar             !< Block parameters
integer,intent(in) :: ncid                     !< NetCDF ID
integer,intent(in) :: nc3_id                   !< NetCDF ID
integer,intent(in) :: nl0r_id                  !< NetCDF ID
integer,intent(in) :: nl0_1_id                 !< NetCDF ID
integer,intent(in) :: nl0_2_id                 !< NetCDF ID

! Local variables
integer :: grpid
integer :: raw_id,raw_hor_id,raw_zs_id,valid_id,coef_ens_id,l0rl0_to_l0_id
integer :: fit_id,fit_hor_id,fit_zs_id,fit_rh_id,fit_pkh_id,fit_rv_id,fit_pkv_id,fit_nlv_id
integer :: raw_hor_sqrt_id,raw_hor_sqrt_norm_id,raw_zs_sqrt_id,raw_zs_sqrt_norm_id,fit_hor_sqrt_id,fit_zs_sqrt_id
integer :: il0,jl0r,jl0,jl0rz

! Set name
@:set_name(diag_blk_write)

! Probe in
@:probe_in()

! Associate
associate(ib=>diag_blk%ib,ic2a=>diag_blk%ic2a)

! Define group
grpid = define_grp(mpl,ncid,diag_blk%prefix)

! Define variables
if (mpl%msv%isanynot(diag_blk%raw)) then
   raw_id = define_var(mpl,grpid,'raw','real',(/nc3_id,nl0r_id,nl0_1_id/))
   raw_hor_id = define_var(mpl,grpid,'raw_hor','real',(/nc3_id,nl0_1_id/))
   raw_zs_id = define_var(mpl,grpid,'raw_zs','real',(/nl0_2_id,nl0_1_id/))
   valid_id = define_var(mpl,grpid,'valid','real',(/nc3_id,nl0r_id,nl0_1_id/))
   l0rl0_to_l0_id = define_var(mpl,grpid,'l0rl0_to_l0','int',(/nl0r_id,nl0_1_id/))
   if (nam%diag_sqrt) then
      raw_hor_sqrt_id = define_var(mpl,grpid,'raw_hor_sqrt','real',(/nc3_id,nl0_1_id/))
      raw_hor_sqrt_norm_id = define_var(mpl,grpid,'raw_hor_sqrt_norm','real',(/nl0_1_id/))
      raw_zs_sqrt_id = define_var(mpl,grpid,'raw_zs_sqrt','real',(/nl0_2_id,nl0_1_id/))
      raw_zs_sqrt_norm_id = define_var(mpl,grpid,'raw_zs_sqrt_norm','real',(/nl0_1_id/))
   end if
end if
if (mpl%msv%isanynot(diag_blk%coef_ens)) coef_ens_id = define_var(mpl,grpid,'coef_ens','real',(/nl0_1_id/))
if (mpl%msv%isanynot(diag_blk%fit)) then
   fit_id = define_var(mpl,grpid,'fit','real',(/nc3_id,nl0r_id,nl0_1_id/))
   fit_hor_id = define_var(mpl,grpid,'fit_hor','real',(/nc3_id,nl0_1_id/))
   fit_zs_id = define_var(mpl,grpid,'fit_zs','real',(/nl0_2_id,nl0_1_id/))
   fit_rh_id = define_var(mpl,grpid,'fit_rh','real',(/nl0_1_id/))
   fit_pkh_id = define_var(mpl,grpid,'fit_pkh','real',(/nl0_1_id/))
   fit_rv_id = define_var(mpl,grpid,'fit_rv','real',(/nl0_1_id/))
   fit_pkv_id = define_var(mpl,grpid,'fit_pkv','real',(/nl0_1_id/))
   fit_nlv_id = define_var(mpl,grpid,'fit_nlv','real',(/nl0_1_id/))
   if (nam%diag_sqrt) then
      fit_hor_sqrt_id = define_var(mpl,grpid,'fit_hor_sqrt','real',(/nc3_id,nl0_1_id/))
      fit_zs_sqrt_id = define_var(mpl,grpid,'fit_zs_sqrt','real',(/nl0_2_id,nl0_1_id/))
   end if
end if

! Write variables
if (mpl%msv%isanynot(diag_blk%raw)) then
   call put_var(mpl,grpid,raw_id,diag_blk%raw)
   do il0=1,geom%nl0
      jl0rz = bpar%il0rz(il0,ib)
      call put_var(mpl,grpid,raw_hor_id,diag_blk%raw(:,jl0rz,il0),(/1,il0/))
   end do
   do il0=1,geom%nl0
      do jl0r=1,bpar%nl0rmax
         jl0 = bpar%l0rl0b_to_l0(jl0r,il0,ib)
         call put_var(mpl,grpid,raw_zs_id,diag_blk%raw(1,jl0r,il0),(/jl0,il0/))
      end do
   end do
   call put_var(mpl,grpid,valid_id,diag_blk%valid)
   call put_var(mpl,grpid,l0rl0_to_l0_id,bpar%l0rl0b_to_l0(1:bpar%nl0r(ib),:,ib))
   if (nam%diag_sqrt) then
      call put_var(mpl,grpid,raw_hor_sqrt_id,diag_blk%raw_hor_sqrt)
      call put_var(mpl,grpid,raw_hor_sqrt_norm_id,diag_blk%raw_hor_sqrt_norm)
      do il0=1,geom%nl0
         do jl0r=1,bpar%nl0rmax
            jl0 = bpar%l0rl0b_to_l0(jl0r,il0,ib)
            call put_var(mpl,grpid,raw_zs_sqrt_id,diag_blk%raw_zs_sqrt(jl0r,il0),(/jl0,il0/))
         end do
      end do
      call put_var(mpl,grpid,raw_zs_sqrt_norm_id,diag_blk%raw_zs_sqrt_norm)
   end if
end if
if (mpl%msv%isanynot(diag_blk%coef_ens)) call put_var(mpl,grpid,coef_ens_id,diag_blk%coef_ens)
if (mpl%msv%isnot(diag_blk%coef_sta)) call put_att(mpl,grpid,'coef_sta',diag_blk%coef_sta)
if (mpl%msv%isanynot(diag_blk%fit)) then
   call put_var(mpl,grpid,fit_id,diag_blk%fit)
   do il0=1,geom%nl0
      jl0rz = bpar%il0rz(il0,ib)
      call put_var(mpl,grpid,fit_hor_id,diag_blk%fit(:,jl0rz,il0),(/1,il0/))
   end do
   do il0=1,geom%nl0
      do jl0r=1,bpar%nl0rmax
         jl0 = bpar%l0rl0b_to_l0(jl0r,il0,ib)
         call put_var(mpl,grpid,fit_zs_id,diag_blk%fit(1,jl0r,il0),(/jl0,il0/))
      end do
   end do
   call put_var(mpl,grpid,fit_rh_id,diag_blk%fit_rh)
   call put_var(mpl,grpid,fit_pkh_id,diag_blk%fit_pkh)
   call put_var(mpl,grpid,fit_rv_id,diag_blk%fit_rv)
   call put_var(mpl,grpid,fit_pkv_id,diag_blk%fit_pkv)
   call put_var(mpl,grpid,fit_nlv_id,diag_blk%fit_nlv)
   if (nam%diag_sqrt) then
      call put_var(mpl,grpid,fit_hor_sqrt_id,diag_blk%fit_hor_sqrt)
      do il0=1,geom%nl0
         do jl0r=1,bpar%nl0rmax
            jl0 = bpar%l0rl0b_to_l0(jl0r,il0,ib)
            call put_var(mpl,grpid,fit_zs_sqrt_id,diag_blk%fit_zs_sqrt(jl0r,il0),(/jl0,il0/))
         end do
      end do
   end if
end if

! End associate
end associate

! Probe out
@:probe_out()

end subroutine diag_blk_write

!----------------------------------------------------------------------
! Subroutine: diag_blk_normalization
!> Compute diagnostic block normalization
!----------------------------------------------------------------------
subroutine diag_blk_normalization(diag_blk,geom,bpar)

implicit none

! Passed variables
class(diag_blk_type),intent(inout) :: diag_blk !< Diagnostic block
type(geom_type),intent(in) :: geom             !< Geometry
type(bpar_type),intent(in) :: bpar             !< Block parameters

! Local variables
integer :: il0,jl0rz

! Set name
@:set_name(diag_blk_normalization)

! Probe in
@:probe_in()

! Associate
associate(ib=>diag_blk%ib)

! Get diagonal values
do il0=1,geom%nl0
   jl0rz = bpar%il0rz(il0,ib)
   diag_blk%coef_ens(il0) = diag_blk%raw(1,jl0rz,il0)
end do

! End associate
end associate

! Probe out
@:probe_out()

end subroutine diag_blk_normalization

!----------------------------------------------------------------------
! Subroutine: diag_blk_fitting
!> Compute a fit of a raw function
!----------------------------------------------------------------------
subroutine diag_blk_fitting(diag_blk,mpl,nam,geom,bpar)

implicit none

! Passed variables
class(diag_blk_type),intent(inout) :: diag_blk !< Diagnostic block
type(mpl_type),intent(inout) :: mpl            !< MPI data
type(nam_type),intent(in) :: nam               !< Namelist
type(geom_type),intent(in) :: geom             !< Geometry
type(bpar_type),intent(in) :: bpar             !< Block parameters

! Local variables
integer :: il0,jl0rz,nl0r,il1,nl1,ilev2d,jl0r,jl0,jc3,nl0ad,il0ad,nnmax,dil0,tmp(1),il0adz
integer,allocatable :: il0_interp(:),il1inf(:),il1sup(:)
real(kind_real) :: m2(geom%nl0),fit_rv,fit_pkv,fit_nlv,dummy
real(kind_real),allocatable :: rawv(:),distv(:),rinf(:),rsup(:)
real(kind_real),allocatable :: fit_rh_l1(:),fit_pkh_l1(:),fit_rv_l1(:),fit_pkv_l1(:),fit_nlv_l1(:)
real(kind_real),allocatable :: rawv_full(:,:),evec(:,:),eval(:)
logical :: var2d
logical,allocatable :: filled(:)

! Set name
@:set_name(diag_blk_fitting)

! Probe in
@:probe_in()

! Associate
associate(ic2a=>diag_blk%ic2a,ib=>diag_blk%ib)

! Check for 2D variable
do il0=1,geom%nl0
   ! Get zero separation level
   jl0rz = bpar%il0rz(il0,ib)

   ! Get value at zero separation
   m2(il0) = diag_blk%raw(1,jl0rz,il0)
end do
if ((count(m2>zero)==1).and.(trim(nam%lev2d)=='first').and.(m2(1)>zero)) then
   var2d = .true.
   ilev2d = 1
   diag_blk%fit_rv(ilev2d) = zero
   diag_blk%fit_pkv(ilev2d) = zero
   diag_blk%fit_nlv(ilev2d) = zero
elseif ((count(m2>zero)==1).and.(trim(nam%lev2d)=='last').and.(m2(geom%nl0)>zero)) then
   var2d = .true.
   ilev2d = geom%nl0
   diag_blk%fit_rv(ilev2d) = zero
   diag_blk%fit_pkv(ilev2d) = zero
   diag_blk%fit_nlv(ilev2d) = zero
else
   var2d = .false.
end if

! Number of effective levels
if (var2d) then
   nl0r = 1
else
   nl0r = bpar%nl0r(ib)
end if

! Count interpolation levels
if (var2d) then
   nl1 = 1
else
   call vert_interp_size(geom%nl0,nam%fit_dl0,nl1)
end if

! Allocation
allocate(il0_interp(nl1))
allocate(il1inf(geom%nl0))
allocate(il1sup(geom%nl0))
allocate(rinf(geom%nl0))
allocate(rsup(geom%nl0))

! Get interpolation levels and weights
if (var2d) then
   il0_interp(1) = ilev2d
   il1inf = 1
   il1sup = 1
   rinf = zero
   rsup = zero
   rsup(ilev2d) = one
else
   call vert_interp_setup(geom%nl0,nam%fit_dl0,nl1,il0_interp,il1inf,il1sup,rinf,rsup)
end if

! Allocation
allocate(fit_rh_l1(nl1))
allocate(fit_pkh_l1(nl1))

! Horizontal fit
do il1=1,nl1
   ! Index
   il0 = il0_interp(il1)

   ! Get zero separation level and min/max levels
   jl0rz = bpar%il0rz(il0,ib)

   ! Fast fit
   call fast_fit(mpl,bpar%nc3(ib),1,geom%disth,'hor',diag_blk%raw(:,jl0rz,il0),nam%peakness,.false.,fit_rh_l1(il1), &
 & fit_pkh_l1(il1),dummy)
end do

! Interpolate horizontal parameters
call vert_interp(mpl,nl1,fit_rh_l1,geom%nl0,il1inf,il1sup,rinf,rsup,diag_blk%fit_rh)
call vert_interp(mpl,nl1,fit_pkh_l1,geom%nl0,il1inf,il1sup,rinf,rsup,diag_blk%fit_pkh)

! Release memory
deallocate(fit_rh_l1)
deallocate(fit_pkh_l1)

if (nl0r==1) then
   ! No vertical fit
   diag_blk%fit_rv = zero
   diag_blk%fit_pkv = zero
   diag_blk%fit_nlv = zero
else
   ! Allocation
   allocate(fit_rv_l1(nl1))
   allocate(fit_pkv_l1(nl1))
   allocate(fit_nlv_l1(nl1))
   allocate(filled(nl1))

   ! Vertical fit, level by level
   do il1=1,nl1
      ! Index
      il0 = il0_interp(il1)

      ! Get zero separation level and min/max levels
      jl0rz = bpar%il0rz(il0,ib)

      ! Anti-diagonal raw diagnostic size
      nl0ad = 0
      do dil0=-geom%nl0,geom%nl0
         if ((il0+dil0>=1).and.(il0+dil0<=geom%nl0).and.(il0-dil0>=1).and.(il0-dil0<=geom%nl0)) then
            if (any(bpar%l0rl0b_to_l0(:,il0+dil0,ib)==il0-dil0)) nl0ad = nl0ad+1
         end if
      end do

      ! Allocation
      allocate(rawv(nl0ad))
      allocate(distv(nl0ad))

      ! Fill anti-diagonal raw diagnostic and distance
      il0ad = 0
      do dil0=-geom%nl0,geom%nl0
         if ((il0+dil0>=1).and.(il0+dil0<=geom%nl0).and.(il0-dil0>=1).and.(il0-dil0<=geom%nl0)) then
            do jl0r=1,nl0r
               if (bpar%l0rl0b_to_l0(jl0r,il0+dil0,ib)==il0-dil0) then
                  il0ad = il0ad+1
                  rawv(il0ad) = diag_blk%raw(1,jl0r,il0+dil0)
                  distv(il0ad) = diag_blk%distv(jl0r,il0+dil0)
                  if (dil0==0) il0adz = il0ad
               end if
            end do
         end if
      end do

      ! Threshold on anti-diagonal raw diagnostic minimum
      if ((nl0ad>ad_n).and.(minval(rawv)<ad_th)) then
         call fast_fit(mpl,nl0ad,il0adz,distv,'ver',rawv,nam%peakness,nam%negative_lobe,fit_rv_l1(il1),fit_pkv_l1(il1), &
 & fit_nlv_l1(il1))
         filled(il1) = .true.
      else
         ! Level to fill with its nearest neighbor
         filled(il1) = .false.
      end if

      ! Release memory
      deallocate(rawv)
      deallocate(distv)
   end do

   ! Fill border values with nearest neighbor
   if (.not.any(filled)) call mpl%abort('${subr}$','no level was filled correctly')
   do il1=1,nl1
      if (.not.filled(il1)) then
         tmp = minloc(abs(diag_blk%vunit(il0_interp)-diag_blk%vunit(il0_interp(il1))),mask=filled)
         fit_rv_l1(il1) = fit_rv_l1(tmp(1))
         fit_pkv_l1(il1) = fit_pkv_l1(tmp(1))
         fit_nlv_l1(il1) = fit_nlv_l1(tmp(1))
      end if
   end do

   ! Interpolate vertical parameters
   call vert_interp(mpl,nl1,fit_rv_l1,geom%nl0,il1inf,il1sup,rinf,rsup,diag_blk%fit_rv)
   call vert_interp(mpl,nl1,fit_pkv_l1,geom%nl0,il1inf,il1sup,rinf,rsup,diag_blk%fit_pkv)
   call vert_interp(mpl,nl1,fit_nlv_l1,geom%nl0,il1inf,il1sup,rinf,rsup,diag_blk%fit_nlv)

   ! Release memory
   deallocate(fit_rv_l1)
   deallocate(fit_pkv_l1)
   deallocate(fit_nlv_l1)
   deallocate(filled)
end if

! Release memory
deallocate(il0_interp)
deallocate(il1inf)
deallocate(il1sup)
deallocate(rinf)
deallocate(rsup)

if (nam%diag_sqrt) then
   ! Compute horizontal square-roots
   do il0=1,geom%nl0
      ! Get zero separation level and min/max levels
      jl0rz = bpar%il0rz(il0,ib)

      ! Raw
      call hor_sqrt(mpl,bpar%nc3(ib),diag_blk%raw(:,jl0rz,il0),diag_blk%raw_hor_sqrt(:,il0))

      ! Normalize
      diag_blk%raw_hor_sqrt_norm(il0) = diag_blk%raw_hor_sqrt(1,il0)
      diag_blk%raw_hor_sqrt(:,il0) = diag_blk%raw_hor_sqrt(:,il0)/diag_blk%raw_hor_sqrt_norm(il0)

      ! Fit
      call fit_diag_sqrt(mpl,bpar%nc3(ib),geom%disth(1:bpar%nc3(ib)),diag_blk%fit_rh(il0),diag_blk%fit_pkh(il0), &
 & nl(inldef),diag_blk%fit_hor_sqrt(:,il0))
   end do

   ! Allocation
   allocate(rawv_full(geom%nl0,geom%nl0))
   allocate(evec(geom%nl0,geom%nl0))
   allocate(eval(geom%nl0))

   ! Full raw vertical matrix
   rawv_full = zero
   do il0=1,geom%nl0
      do jl0r=1,nl0r
         jl0 = bpar%l0rl0b_to_l0(jl0r,il0,ib)
         rawv_full(jl0,il0) = diag_blk%raw(1,jl0r,il0)
         rawv_full(il0,jl0) = diag_blk%raw(1,jl0r,il0)
      end do
   end do

   ! EOF decomposition
   call da_eof_decomposition(mpl,geom%nl0,rawv_full,evec,eval)

   ! Eigenvalues square-root
   eval = max(eval,zero)
   eval = sqrt(eval)

   ! Full raw vertical matrix square-root
   call da_eof_recomposition(geom%nl0,geom%nl0,evec,eval,rawv_full)

   do il0=1,geom%nl0
      ! Get zero separation level and min/max levels
      jl0rz = bpar%il0rz(il0,ib)

      do jl0r=1,nl0r
         ! Index
         jl0 = bpar%l0rl0b_to_l0(jl0r,il0,ib)

         ! Raw
         diag_blk%raw_zs_sqrt(jl0r,il0) = rawv_full(jl0,il0)

         ! Fit
!         fit_rv = TODO
!         fit_pkv = TODO
!         call fit_diag_sqrt(mpl,nl0r,diag_blk%distv(:,il0),fit_rv,fit_pkv,diag_blk%fit_zs_sqrt(:,il0))
      end do

      ! Normalization
      diag_blk%raw_zs_sqrt_norm(il0) = diag_blk%raw_zs_sqrt(jl0rz,il0)
      diag_blk%raw_zs_sqrt(:,il0) = diag_blk%raw_zs_sqrt(:,il0)/diag_blk%raw_zs_sqrt_norm(il0)
   end do
end if

! End associate
end associate

! Probe out
@:probe_out()

end subroutine diag_blk_fitting

!----------------------------------------------------------------------
! Subroutine: diag_blk_localization
!> Diag_blk localization
!----------------------------------------------------------------------
subroutine diag_blk_localization(diag_blk,mpl,geom,bpar,avg_blk)

implicit none

! Passed variables
class(diag_blk_type),intent(inout) :: diag_blk !< Diagnostic block (localization)
type(mpl_type),intent(inout) :: mpl            !< MPI data
type(geom_type),intent(in) :: geom             !< Geometry
type(bpar_type),intent(in) :: bpar             !< Block parameters
type(avg_blk_type),intent(in) :: avg_blk       !< Averaged statistics block

! Local variables
integer :: il0,jl0r,jc3

! Set name
@:set_name(diag_blk_localization)

! Probe in
@:probe_in()

! Associate
associate(ib=>diag_blk%ib)

!$omp parallel do schedule(static) private(il0,jl0r,jc3) shared(geom,bpar,diag_blk,avg_blk)
do il0=1,geom%nl0
   do jl0r=1,bpar%nl0r(ib)
      do jc3=1,bpar%nc3(ib)
         if (mpl%msv%isnot(avg_blk%m11asysq(jc3,jl0r,il0)).and.mpl%msv%isnot(avg_blk%m11sq(jc3,jl0r,il0))) then
            ! Compute localization
            diag_blk%raw(jc3,jl0r,il0) = avg_blk%m11asysq(jc3,jl0r,il0)/avg_blk%m11sq(jc3,jl0r,il0)
            diag_blk%valid(jc3,jl0r,il0) = avg_blk%nc1a(jc3,jl0r,il0)
         else
            ! Missing value
            diag_blk%raw(jc3,jl0r,il0) = mpl%msv%valr
            diag_blk%valid(jc3,jl0r,il0) = mpl%msv%valr
         end if
      end do
   end do
end do
!$omp end parallel do

! Hybrid weight
diag_blk%coef_sta = mpl%msv%valr

! End associate
end associate

! Probe out
@:probe_out()

end subroutine diag_blk_localization

!----------------------------------------------------------------------
! Subroutine: diag_blk_hybridization
!> Diag_blk hybridization
!----------------------------------------------------------------------
subroutine diag_blk_hybridization(diag_blk,mpl,nam,geom,bpar,avg_blk)

implicit none

! Passed variables
class(diag_blk_type),intent(inout) :: diag_blk !< Diagnostic block (localization)
type(mpl_type),intent(inout) :: mpl            !< MPI data
type(nam_type),intent(in) :: nam               !< Namelist
type(geom_type),intent(in) :: geom             !< Geometry
type(bpar_type),intent(in) :: bpar             !< Block parameters
type(avg_blk_type),intent(in) :: avg_blk       !< Averaged statistics block

! Local variables
integer :: il0,jl0r,jl0,jc3,iv
real(kind_real) :: wgt,a,bc,d,e,f,num_ens,num_sta,num,den
real(kind_real) :: nam_coef(geom%nl0),nam_nlv(geom%nl0)

! Set name
@:set_name(diag_blk_hybridization)

! Probe in
@:probe_in()

! Associate
associate(ib=>diag_blk%ib)

if (nam%forced_radii) then
   ! Compute forced localization function
   iv = bpar%b_to_v1(ib)
   nam_coef = one
   nam_nlv = nl(inldef)
   call fit_diag_full(mpl,bpar%nc3(ib),bpar%nl0r(ib),geom%nl0,bpar%l0rl0b_to_l0(:,:,ib), &
 & geom%disth,diag_blk%distv,nam_coef,nam%rh(1:geom%nl0,iv),nam%pkh(1:geom%nl0,iv),nam%rv(1:geom%nl0,iv),nam%pkv(1:geom%nl0,iv), &
 & nam_nlv,diag_blk%raw)
   diag_blk%valid = mpl%msv%valr

   ! Compute hybrid weights
   a = zero
   bc = zero
   d = zero
   e = zero
   f = zero
   do il0=1,geom%nl0
      do jl0r=1,bpar%nl0r(ib)
         jl0 = bpar%l0rl0b_to_l0(jl0r,il0,ib)
         do jc3=1,bpar%nc3(ib)
            if (mpl%msv%isnot(avg_blk%m11asysq(jc3,jl0r,il0)).and.mpl%msv%isnot(avg_blk%m11sq(jc3,jl0r,il0)) &
 & .and.mpl%msv%isnot(avg_blk%m11sta(jc3,jl0r,il0)).and.mpl%msv%isnot(avg_blk%stasq(jc3,jl0r,il0))) then
               wgt = geom%disth(jc3)*diag_blk%distv(jl0,il0)/real(bpar%nl0r(ib)+bpar%nc3(ib),kind_real)
               a = a+wgt*diag_blk%raw(jc3,jl0r,il0)**2*avg_blk%m11sq(jc3,jl0r,il0)
               bc = bc+wgt*diag_blk%raw(jc3,jl0r,il0)*avg_blk%m11sta(jc3,jl0r,il0)
               d = d+wgt*avg_blk%stasq(jc3,jl0r,il0)
               e = e+wgt*diag_blk%raw(jc3,jl0r,il0)*avg_blk%m11asysq(jc3,jl0r,il0)
               f = f+wgt*avg_blk%m11sta(jc3,jl0r,il0)
            end if
         end do
      end do
   end do
   num_ens = e*d-bc*f
   num_sta = a*f-e*bc
   den = a*d-bc**2
   if ((num_ens>zero).and.(num_sta>zero).and.(den>zero)) then
      ! Valid numerators and denominator
      diag_blk%coef_ens = num_ens/den
      diag_blk%coef_sta = num_sta/den
   else
      ! Missing values
      diag_blk%coef_ens = mpl%msv%valr
      diag_blk%coef_sta = mpl%msv%valr
   end if
else
   ! Compute raw hybridization
   num = zero
   den = zero
   do il0=1,geom%nl0
      do jl0r=1,bpar%nl0r(ib)
         jl0 = bpar%l0rl0b_to_l0(jl0r,il0,ib)
         do jc3=1,bpar%nc3(ib)
            if (mpl%msv%isnot(avg_blk%m11asysq(jc3,jl0r,il0)).and.mpl%msv%isnot(avg_blk%m11sq(jc3,jl0r,il0)) &
 & .and.mpl%msv%isnot(avg_blk%m11sta(jc3,jl0r,il0)).and.mpl%msv%isnot(avg_blk%stasq(jc3,jl0r,il0))) then
               wgt = geom%disth(jc3)*diag_blk%distv(jl0,il0)/real(bpar%nl0r(ib)+bpar%nc3(ib),kind_real)
               num = num+wgt*(one-avg_blk%m11asysq(jc3,jl0r,il0)/avg_blk%m11sq(jc3,jl0r,il0))*avg_blk%m11sta(jc3,jl0r,il0)
               den = den+wgt*(avg_blk%stasq(jc3,jl0r,il0)-avg_blk%m11sta(jc3,jl0r,il0)**2/avg_blk%m11sq(jc3,jl0r,il0))
            end if
         end do
      end do
   end do
   if ((num>zero).and.(den>zero)) then
      ! Valid numerator and denominator
      diag_blk%coef_sta = num/den

      !$omp parallel do schedule(static) private(il0,jl0r,jc3) shared(geom,bpar,diag_blk)
      do il0=1,geom%nl0
         do jl0r=1,bpar%nl0r(ib)
            do jc3=1,bpar%nc3(ib)
               if (mpl%msv%isnot(avg_blk%m11asysq(jc3,jl0r,il0)).and.mpl%msv%isnot(diag_blk%coef_sta) &
 & .and.mpl%msv%isnot(avg_blk%m11sta(jc3,jl0r,il0)).and.mpl%msv%isnot(avg_blk%m11sq(jc3,jl0r,il0))) then
                  ! Compute localization
                  diag_blk%raw(jc3,jl0r,il0) = (avg_blk%m11asysq(jc3,jl0r,il0)-diag_blk%coef_sta &
 & *avg_blk%m11sta(jc3,jl0r,il0))/avg_blk%m11sq(jc3,jl0r,il0)
                  diag_blk%valid(jc3,jl0r,il0) = avg_blk%nc1a(jc3,jl0r,il0)

                  ! Lower bound
                  if (diag_blk%raw(jc3,jl0r,il0)<zero) then
                     diag_blk%raw(jc3,jl0r,il0) = mpl%msv%valr
                     diag_blk%valid(jc3,jl0r,il0) = mpl%msv%valr
                  end if
               else
                  ! Missing value
                  diag_blk%raw(jc3,jl0r,il0) = mpl%msv%valr
                  diag_blk%valid(jc3,jl0r,il0) = mpl%msv%valr
               end if
            end do
         end do
      end do
      !$omp end parallel do
   else
      ! Missing values
      diag_blk%coef_sta = mpl%msv%valr
      diag_blk%raw = mpl%msv%valr
   end if
end if

! End associate
end associate

! Probe out
@:probe_out()

end subroutine diag_blk_hybridization

!----------------------------------------------------------------------
! Subroutine: diag_blk_dualens
!> Diag_blk dualens
!----------------------------------------------------------------------
subroutine diag_blk_dualens(diag_blk,mpl,geom,bpar,avg_blk,avg_lr_blk,diag_lr_blk)

implicit none

! Passed variables
class(diag_blk_type),intent(inout) :: diag_blk   !< Diagnostic block (localization)
type(mpl_type),intent(inout) :: mpl              !< MPI data
type(geom_type),intent(in) :: geom               !< Geometry
type(bpar_type),intent(in) :: bpar               !< Block parameters
type(avg_blk_type),intent(in) :: avg_blk         !< Averaged statistics block
type(avg_blk_type),intent(in) :: avg_lr_blk      !< LR averaged statistics block
type(diag_blk_type),intent(inout) :: diag_lr_blk !< Diagnostic block (LR localization)

! Local variables
integer :: il0,jl0r,jc3
real(kind_real),allocatable :: num(:),num_lr(:),den(:)

! Set name
@:set_name(diag_blk_dualens)

! Probe in
@:probe_in()

! Associate
associate(ib=>diag_blk%ib)

! Allocation
allocate(num(bpar%nc3(ib)))
allocate(num_lr(bpar%nc3(ib)))
allocate(den(bpar%nc3(ib)))

! Compute raw dual-ensemble hybridization
do il0=1,geom%nl0
   do jl0r=1,bpar%nl0r(ib)
      do jc3=1,bpar%nc3(ib)
         if (mpl%msv%isnot(avg_blk%m11asysq(jc3,jl0r,il0)).and.mpl%msv%isnot(avg_blk%m11sq(jc3,jl0r,il0)) &
 & .and.mpl%msv%isnot(avg_blk%m11lrm11asy(jc3,jl0r,il0)).and.mpl%msv%isnot(avg_blk%m11lrm11(jc3,jl0r,il0)) &
 & .and.mpl%msv%isnot(avg_lr_blk%m11sq(jc3,jl0r,il0)).and.mpl%msv%isnot(avg_blk%m11lrm11asy(jc3,jl0r,il0))) then
            num(jc3) = avg_blk%m11asysq(jc3,jl0r,il0)*avg_lr_blk%m11sq(jc3,jl0r,il0) &
 & -avg_blk%m11lrm11asy(jc3,jl0r,il0)*avg_blk%m11lrm11(jc3,jl0r,il0)
            num_lr(jc3) = avg_blk%m11lrm11asy(jc3,jl0r,il0)*avg_blk%m11sq(jc3,jl0r,il0) &
 & -avg_blk%m11asysq(jc3,jl0r,il0)*avg_blk%m11lrm11(jc3,jl0r,il0)
            den(jc3) = avg_blk%m11sq(jc3,jl0r,il0)*avg_lr_blk%m11sq(jc3,jl0r,il0)-avg_blk%m11lrm11(jc3,jl0r,il0)**2
            if ((num(jc3)>zero).and.(den(jc3)>zero)) then
               ! Compute localization
               diag_blk%raw(jc3,jl0r,il0) = num(jc3)/den(jc3)
               diag_lr_blk%raw(jc3,jl0r,il0) = num_lr(jc3)/den(jc3)
               diag_blk%valid(jc3,jl0r,il0) = avg_blk%nc1a(jc3,jl0r,il0)
               diag_lr_blk%valid(jc3,jl0r,il0) = avg_blk%nc1a(jc3,jl0r,il0)
            else
               ! Missing value
               diag_blk%raw(jc3,jl0r,il0) = mpl%msv%valr
               diag_lr_blk%raw(jc3,jl0r,il0) = mpl%msv%valr
               diag_blk%valid(jc3,jl0r,il0) = mpl%msv%valr
               diag_lr_blk%valid(jc3,jl0r,il0) = mpl%msv%valr
            end if
         end if
      end do
   end do
end do

! Hybrid weight
diag_blk%coef_sta = mpl%msv%valr

! Release memory
deallocate(num)
deallocate(num_lr)
deallocate(den)

! End associate
end associate

! Probe out
@:probe_out()

end subroutine diag_blk_dualens

end module type_diag_blk
