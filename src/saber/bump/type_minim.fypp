#:include '../instrumentation.fypp'
!----------------------------------------------------------------------
! Module: type_minim
!> Minimization data derived type
! Author: Benjamin Menetrier
! Licensing: this code is distributed under the CeCILL-C license
! Copyright 2015-... UCAR, CERFACS, METEO-FRANCE and IRIT
!----------------------------------------------------------------------
module type_minim

use tools_const, only: zero,hundredth,tenth,half,one,two,ten,hundred
use tools_fit, only: ver_smooth
use tools_func, only: fit_diag,fit_lct
use tools_kinds, only: kind_real
use tools_repro, only: rth,eq,inf,infeq,sup
use type_mpl, only: mpl_type
@:use_probe()

implicit none

! Minimization data derived type
type minim_type
   ! Minimizer data
   real(kind_real) :: hooke_rho               !< Convergence parameter for the Hooke algorithm
   real(kind_real) :: hooke_tol               !< Tolerance for the Hooke algorithm
   integer :: hooke_itermax                   !< Maximum number of iteration for the Hooke algorithm

   ! Generic data
   integer :: nx                              !< Control vector size
   integer :: ny                              !< Function output size
   real(kind_real),allocatable :: x(:)        !< Control vector
   real(kind_real),allocatable :: guess(:)    !< Control vector guess
   real(kind_real),allocatable :: binf(:)     !< Control vector lower bound
   real(kind_real),allocatable :: bsup(:)     !< Control vector upper bound
   real(kind_real),allocatable :: obs(:)      !< Observation
   character(len=1024) :: cost_function       !< Cost function
   real(kind_real) :: f_guess                 !< Guess cost
   real(kind_real) :: f_min                   !< Minimum cost

   ! Common data
   integer :: nc3                             !< Number of classes
   integer :: nl0r                            !< Effective number of levels

   ! Specific data (fit)
   real(kind_real),allocatable :: disth(:)    !< Horizontal distance
   real(kind_real),allocatable :: distv(:)    !< Vertical distance
   logical :: lcoef                           !< Diagonal coefficient flag
   logical :: lrh                             !< Horizontal support radius flag
   logical :: lrv                             !< Vertical support radius flag

   ! Specific data (LCT)
   integer :: nscales                         !< Number of LCT scales
   logical,allocatable :: lct_diag(:)         !< Diagonal LCT flag
   real(kind_real),allocatable :: dxsq(:,:)   !< Zonal separation squared
   real(kind_real),allocatable :: dysq(:,:)   !< Meridian separation squared
   real(kind_real),allocatable :: dxdy(:,:)   !< Zonal x meridional separation product
   real(kind_real),allocatable :: dzsq(:,:)   !< Vertical separation squared
   logical,allocatable :: dmask(:,:)          !< Mask
contains
   procedure :: compute => minim_compute
   procedure :: cost => minim_cost
   procedure :: cost_fit_diag => minim_cost_fit_diag
   procedure :: cost_fit_lct => minim_cost_fit_lct
   procedure :: hooke => minim_hooke
   procedure :: best_nearby => minim_best_nearby
   procedure :: vt_dir => minim_vt_dir
   procedure :: vt_inv => minim_vt_inv
end type minim_type

private
public :: minim_type

contains

!----------------------------------------------------------------------
! subroutine: minim_compute
!> Minimize ensuring bounds constraints
!----------------------------------------------------------------------
subroutine minim_compute(minim,mpl)

implicit none

! Passed variables
class(minim_type),intent(inout) :: minim !< Minimization data
type(mpl_type),intent(inout) :: mpl      !< MPI data

! Set name
@:set_name(minim_compute)

! Probe in
@:probe_in()

! Check
if (minim%nx<=0) call mpl%abort('${subr}$','nx should be positive to minimize')
if (minim%ny<=0) call mpl%abort('${subr}$','nx should be positive to minimize')

! Initialization
call minim%vt_inv(mpl,minim%guess)

! Initial cost
call minim%cost(mpl,minim%guess,minim%f_guess)

! Hooke algorithm
call minim%hooke(mpl,minim%guess)

! Final cost
call minim%cost(mpl,minim%x,minim%f_min)

! Check improvement
if (minim%f_min>minim%f_guess) minim%x = minim%guess

! Direct transform
call minim%vt_dir(minim%x)

! Probe out
@:probe_out()

end subroutine minim_compute

!----------------------------------------------------------------------
! Subroutine: minim_cost
!> Compute cost function
!----------------------------------------------------------------------
subroutine minim_cost(minim,mpl,x,f)

implicit none

! Passed variables
class(minim_type),intent(in) :: minim     !< Minimization data
type(mpl_type),intent(inout) :: mpl       !< MPI data
real(kind_real),intent(in) :: x(minim%nx) !< Control vector
real(kind_real),intent(out) :: f          !< Cost function value

! Set name
@:set_name(minim_cost)

! Probe in
@:probe_in()

select case (trim(minim%cost_function))
case ('fit_diag')
   call minim%cost_fit_diag(mpl,x,f)
case ('fit_lct')
   call minim%cost_fit_lct(mpl,x,f)
case default
   call mpl%abort('${subr}$','wrong cost function')
end select

! Probe out
@:probe_out()

end subroutine minim_cost

!----------------------------------------------------------------------
! Subroutine: minim_cost_fit_diag
!> Diagnosic fit function cost
!----------------------------------------------------------------------
subroutine minim_cost_fit_diag(minim,mpl,x,f)

implicit none

! Passed variables
class(minim_type),intent(in) :: minim     !< Minimization data
type(mpl_type),intent(inout) :: mpl       !< MPI data
real(kind_real),intent(in) :: x(minim%nx) !< Control vector
real(kind_real),intent(out) :: f          !< Cost function value

! Local variables
integer :: ix
real(kind_real) :: coef,fit_rh,fit_pk,fit_rv,fit_nld
real(kind_real) :: fit(minim%nc3,minim%nl0r)
real(kind_real) :: xtmp(minim%nx),fit_pack(minim%ny)

! Set name
@:set_name(minim_cost_fit_diag)

! Probe in
@:probe_in()

! Renormalize
xtmp = x
call minim%vt_dir(xtmp)

! Get data
ix = 0
if (minim%lcoef) then
   ix = ix+1
   coef = xtmp(ix)
else
   coef = one
end if
if (minim%lrh) then
   ix = ix+1
   fit_rh = xtmp(ix)
   ix = ix+1
   fit_pk = xtmp(ix)
else
   fit_rh = zero
   fit_pk = zero
end if
if (minim%lrv) then
   ix = ix+1
   fit_rv = xtmp(ix)
   ix = ix+1
   fit_nld = xtmp(ix)
else
   fit_rv = zero
   fit_nld = zero
end if

! Compute function
call fit_diag(mpl,minim%nc3,minim%nl0r,minim%disth,minim%distv,coef,fit_rh,fit_pk,fit_rv,fit_nld,fit)

! Pack
fit_pack = reshape(fit,(/minim%ny/))

! Observations penalty
f = sum((fit_pack-minim%obs)**2,mask=mpl%msv%isnot(minim%obs).and.mpl%msv%isnot(fit_pack))

! Probe out
@:probe_out()

end subroutine minim_cost_fit_diag

!----------------------------------------------------------------------
! Function: minim_cost_fit_lct
!> LCT fit function cost
!----------------------------------------------------------------------
subroutine minim_cost_fit_lct(minim,mpl,x,f)

implicit none

! Passed variables
class(minim_type),intent(in) :: minim     !< Minimization data
type(mpl_type),intent(inout) :: mpl       !< MPI data
real(kind_real),intent(in) :: x(minim%nx) !< Control vector
real(kind_real),intent(out) :: f          !< Cost function value

! Local variables
integer :: iscales,ix
real(kind_real) :: fit(minim%nc3,minim%nl0r),D(4,minim%nscales)
real(kind_real) :: xtmp(minim%nx),fit_pack(minim%ny),coef(minim%nscales)

! Set name
@:set_name(minim_cost_fit_lct)

! Probe in
@:probe_in()

! Renormalize
xtmp = x
call minim%vt_dir(xtmp)

! Compute function
ix = 0
do iscales=1,minim%nscales
   D(1:2,iscales) = xtmp(ix+1:ix+2)
   ix = ix+2
   if (minim%nl0r>1) then
      D(3,iscales) = xtmp(ix+1)
      ix = ix+1
   else
      D(3,iscales) = zero
   end if
   if (minim%lct_diag(iscales)) then
      D(4,iscales) = zero
   else
      D(4,iscales) = xtmp(ix+1)
      ix = ix+1
   end if
end do

! Coefficient
if (minim%nscales>1) then
   do iscales=1,minim%nscales-1
      coef(iscales) = xtmp(ix+1)
      ix = ix+1
   end do
   coef(minim%nscales) = one-sum(coef(1:minim%nscales-1))
else
   coef(1) = one
end if
call fit_lct(mpl,minim%nc3,minim%nl0r,minim%dxsq,minim%dysq,minim%dxdy,minim%dzsq,minim%dmask,minim%nscales, &
 & D,coef,fit)

! Pack
fit_pack = reshape(fit,(/minim%ny/))

! Observations penalty
f = sum((fit_pack-minim%obs)**2,mask=mpl%msv%isnot(minim%obs).and.mpl%msv%isnot(fit_pack))

! Probe out
@:probe_out()

end subroutine minim_cost_fit_lct

!----------------------------------------------------------------------
! Subroutine: minim_hooke
!> Seeks a minimizer of a scalar function of several variables
! Author: ALGOL original by Arthur Kaupe, C version by Mark Johnson, FORTRAN90 version by John Burkardt
!----------------------------------------------------------------------
subroutine minim_hooke(minim,mpl,guess)

implicit none

! Passed variables
class(minim_type),intent(inout) :: minim      !< Minimization data
type(mpl_type),intent(inout) :: mpl           !< MPI data
real(kind_real),intent(in) :: guess(minim%nx) !< Guess

! Local variables
integer :: funevals,i,iters,keep
real(kind_real) :: fbefore,newf,steplength,tmp
real(kind_real) :: delta(minim%nx),newx(minim%nx)

! Set name
@:set_name(minim_hooke)

! Probe in
@:probe_in()

! Initialization
newx = guess
minim%x = guess
do i=1,minim%nx
   if (minim%bsup(i)>minim%binf(i)) then
      if (sup(abs(guess(i)),rth)) then
         delta(i) = minim%hooke_rho*abs(guess(i))
      else
         delta(i) = minim%hooke_rho
      end if
   end if
end do
funevals = 0
steplength = minim%hooke_rho
iters = 0
call minim%cost(mpl,newx,fbefore)
funevals = funevals+1
newf = fbefore

! Iterative search
do while ((iters<minim%hooke_itermax).and.inf(minim%hooke_tol,steplength))
   ! Update iteration
   iters = iters+1

   ! Find best new point, one coordinate at a time
   newx = minim%x
   call minim%best_nearby(mpl,delta,newx,fbefore,funevals,newf)

   ! If we made some improvements, pursue that direction
   keep = 1

   do while (inf(newf,fbefore).and.(keep==1))
      do i=1,minim%nx
         if (minim%bsup(i)>minim%binf(i)) then
            ! Arrange the sign of delta
            if (sup(newx(i),minim%x(i))) then
               delta(i) = abs(delta(i))
            else
               delta(i) = -abs(delta(i))
            end if

            ! Now, move further in this direction.
            tmp = minim%x(i)
            minim%x(i) = newx(i)
            newx(i) = newx(i)+newx(i)-tmp
         end if
      end do

      ! Update
      fbefore = newf
      call minim%best_nearby(mpl,delta,newx,fbefore,funevals,newf)

      ! If the further (optimistic) move was bad...
      if (inf(fbefore,newf)) exit

      ! Make sure that the differences between the new and the old points
      ! are due to actual displacements; beware of roundoff errors that
      ! might cause NEWF<FBEFORE.
      keep = 0

      do i=1,minim%nx
         if (minim%bsup(i)>minim%binf(i)) then
            if (inf(half*abs(delta(i)),abs(newx(i)-minim%x(i)))) then
               keep = 1
               exit
            end if
         end if
      end do
   end do

   if (infeq(minim%hooke_tol,steplength).and.infeq(fbefore,newf)) then
      steplength = steplength*minim%hooke_rho
      delta = delta*minim%hooke_rho
   end if
end do

! Probe out
@:probe_out()

end subroutine minim_hooke

!----------------------------------------------------------------------
! Subroutine: minim_best_nearby
!> Looks for a better nearby point, one coordinate at a time
! Author: ALGOL original by Arthur Kaupe, C version by Mark Johnson, FORTRAN90 version by John Burkardt
!----------------------------------------------------------------------
subroutine minim_best_nearby(minim,mpl,delta,point,prevbest,funevals,minf)

implicit none

! Passed variables
class(minim_type),intent(inout) :: minim         !< Minimization data
type(mpl_type),intent(inout) :: mpl              !< MPI data
real(kind_real),intent(inout) :: delta(minim%nx) !< Step
real(kind_real),intent(inout) :: point(minim%nx) !< Point
real(kind_real),intent(in) :: prevbest           !< Best existing cost
integer,intent(inout) :: funevals                !< Number of evaluations
real(kind_real),intent(out) :: minf              !< Minimum cost

! Local variables
integer :: i
real(kind_real) :: ftmp
real(kind_real) :: z(minim%nx)

! Set name
@:set_name(minim_best_nearby)

! Probe in
@:probe_in()

! Initialization
minf = prevbest
z = point

do i=1,minim%nx
   if (minim%bsup(i)>minim%binf(i)) then
      z(i) = point(i)+delta(i)
      call minim%cost(mpl,z,ftmp)
      funevals = funevals+1
      if (inf(ftmp,minf)) then
         minf = ftmp
      else
         delta(i) = -delta(i)
         z(i) = point(i)+delta(i)
         call minim%cost(mpl,z,ftmp)
         funevals = funevals+1
         if (inf(ftmp,minf)) then
            minf = ftmp
         else
            z(i) = point(i)
         end if
      end if
   end if
end do

! Update
point = z

! Probe out
@:probe_out()

end subroutine minim_best_nearby

!----------------------------------------------------------------------
! Subroutine: vt_dir
!> Direct variable transform
!----------------------------------------------------------------------
subroutine minim_vt_dir(minim,x)

implicit none

! Passed variables
class(minim_type),intent(in) :: minim        !< Minimization data
real(kind_real),intent(inout) :: x(minim%nx) !< Vector

! Set name
@:set_name(minim_vt_dir)

! Probe in
@:probe_in()

! Linear expansion of the hyperbolic tangent of the variable
x = minim%binf+half*(one+tanh(x))*(minim%bsup-minim%binf)

! Probe out
@:probe_out()

end subroutine minim_vt_dir

!----------------------------------------------------------------------
! Subroutine: vt_inv
!> Inverse variable transform
!----------------------------------------------------------------------
subroutine minim_vt_inv(minim,mpl,x)

implicit none

! Passed variables
class(minim_type),intent(in) :: minim        !< Minimization data
type(mpl_type),intent(inout) :: mpl          !< MPI data
real(kind_real),intent(inout) :: x(minim%nx) !< Vector

! Local variables
integer :: ix

! Set name
@:set_name(minim_vt_inv)

! Probe in
@:probe_in()

! Inverse hyperbolic tangent of the linearly bounded variable
if (any((x<minim%binf).or.(x>minim%bsup))) call mpl%abort('${subr}$','variable out of bounds in vt_inv')
do ix=1,minim%nx
   if (sup(minim%bsup(ix),minim%binf(ix))) then
      x(ix) = atanh(two*(x(ix)-minim%binf(ix))/(minim%bsup(ix)-minim%binf(ix))-one)
   else
      x(ix) = zero
   end if
end do

! Probe out
@:probe_out()

end subroutine minim_vt_inv

end module type_minim
