#:include '../instrumentation.fypp'
!----------------------------------------------------------------------
! Module: type_bump
!> BUMP derived type
! Author: Benjamin Menetrier
! Licensing: this code is distributed under the CeCILL-C license
! Copyright 2015-... UCAR, CERFACS, METEO-FRANCE and IRIT
!----------------------------------------------------------------------
module type_bump

use atlas_module, only: atlas_field,atlas_fieldset,atlas_integer,atlas_real,atlas_functionspace
use fckit_configuration_module, only: fckit_configuration
use fckit_mpi_module, only: fckit_mpi_comm,fckit_mpi_sum,fckit_mpi_min,fckit_mpi_max
use tools_const, only: zero,one,thousand,req,reqkm,deg2rad,rad2deg
use tools_func, only: fletcher32,sphere_dist,zss_maxval,zss_minval
use tools_gc99, only: fit_setup,fit_dealloc
use tools_kinds,only: kind_real
use tools_netcdf, only: registry
use tools_repro,only: repro,rth
use type_bpar, only: bpar_type
use type_cmat, only: cmat_type
use type_cv, only: cv_type
use type_ens, only: ens_type
use type_fieldset, only: fieldset_type
use type_geom, only: geom_type
use type_hdiag, only: hdiag_type
use type_mom, only: mom_type
use type_mpl, only: mpl_type
use type_nam, only: nam_type
use type_nicas, only: nicas_type
@:use_probe()
use type_rng, only: rng_type
use type_samp, only: samp_type
use type_var, only: var_type
use type_vbal, only: vbal_type
use type_wind, only: wind_type

implicit none

integer,parameter :: dmsvali = -999                     !< Default missing value for integers
real(kind_real),parameter :: dmsvalr = -999.0_kind_real !< Default missing value for reals
logical :: copy_ensemble = .false.                      !< Deep copy of ensemble members

! BUMP derived type
type bump_type
   ! Derived types
   type(bpar_type) :: bpar   !< Block parameters
   type(cmat_type) :: cmat   !< C matrix
   type(ens_type) :: ens1    !< First ensemble
   type(ens_type) :: ens1u   !< First ensemble, unbalanced
   type(ens_type) :: ens2    !< Second ensemble
   type(geom_type) :: geom   !< Geometry
   type(hdiag_type) :: hdiag !< Hybrid diagnostics
   type(mom_type) :: mom1    !< Moments (first ensemble)
   type(mom_type) :: mom2    !< Moments (second ensemble)
   type(mpl_type) :: mpl     !< MPI data
   type(nam_type) :: nam     !< Namelist
   type(nicas_type) :: nicas !< NICAS data
   type(rng_type) :: rng     !< Random number generator
   type(samp_type) :: samp   !< Sampling
   type(var_type) :: var     !< Variance
   type(vbal_type) :: vbal   !< Vertical balance
   type(wind_type) :: wind   !< Wind

   ! Dummy variable
   logical :: dummy_logical  !< Dummy variable
contains
   procedure :: bump_create
   procedure :: bump_create_deprecated_atlas
   generic :: create => bump_create,bump_create_deprecated_atlas
   procedure :: setup => bump_setup
   procedure :: add_member => bump_add_member
   procedure :: update_vbal_cov => bump_update_vbal_cov
   procedure :: update_var => bump_update_var
   procedure :: update_mom => bump_update_mom
   procedure :: run_drivers => bump_run_drivers
   procedure :: apply_vbal => bump_apply_vbal
   procedure :: apply_vbal_inv => bump_apply_vbal_inv
   procedure :: apply_vbal_ad => bump_apply_vbal_ad
   procedure :: apply_vbal_inv_ad => bump_apply_vbal_inv_ad
   procedure :: apply_stddev => bump_apply_stddev
   procedure :: apply_stddev_inv => bump_apply_stddev_inv
   procedure :: bump_apply_nicas
   procedure :: bump_apply_nicas_deprecated_atlas
   generic :: apply_nicas => bump_apply_nicas,bump_apply_nicas_deprecated_atlas
   procedure :: get_cv_size => bump_get_cv_size
   procedure :: bump_apply_nicas_sqrt
   procedure :: bump_apply_nicas_sqrt_deprecated_atlas
   generic :: apply_nicas_sqrt => bump_apply_nicas_sqrt,bump_apply_nicas_sqrt_deprecated_atlas
   procedure :: apply_nicas_sqrt_ad => bump_apply_nicas_sqrt_ad
   procedure :: randomize => bump_randomize
   procedure :: psichi_to_uv => bump_psichi_to_uv
   procedure :: psichi_to_uv_ad => bump_psichi_to_uv_ad
   procedure :: get_parameter => bump_get_parameter
   procedure :: copy_to_field => bump_copy_to_field
   procedure :: test_get_parameter => bump_test_get_parameter
   procedure :: bump_set_parameter
   procedure :: bump_set_parameter_deprecated_atlas
   generic :: set_parameter => bump_set_parameter,bump_set_parameter_deprecated_atlas
   procedure :: copy_from_field => bump_copy_from_field
   procedure :: test_set_parameter => bump_test_set_parameter
   procedure :: test_apply_interfaces => bump_test_apply_interfaces
   procedure :: partial_dealloc => bump_partial_dealloc
   procedure :: dealloc => bump_dealloc
   final :: bump_dummy_final
end type bump_type

private
public :: bump_type

contains

!----------------------------------------------------------------------
! Subroutine: bump_create
!> Create
!----------------------------------------------------------------------
subroutine bump_create(bump,comm,afunctionspace,fieldset,conf,grid,universe_rad)

implicit none

! Passed variables
class(bump_type),intent(inout) :: bump                  !< BUMP
type(fckit_mpi_comm),intent(in) :: comm                 !< FCKIT MPI communicator wrapper
type(atlas_functionspace),intent(in) :: afunctionspace  !< ATLAS function space
type(fieldset_type),intent(in) :: fieldset              !< Fieldset containing geometry elements
type(fckit_configuration),intent(in) :: conf            !< FCKIT configuration
type(fckit_configuration),intent(in) :: grid            !< FCKIT grid configuration
type(fieldset_type),intent(in),optional :: universe_rad !< Fieldset optionally containing universe radius

! Local variables
integer :: lmsvali, llunit
real(kind_real) :: lmsvalr

! Set name
@:set_name(bump_create)

! Get instance
@:get_instance(bump)

! Probe in
@:probe_in()

! Initialize namelist
call bump%nam%init(comm%size())

! Read grid configuration
call bump%nam%from_conf(comm,grid)

! Read configuration
call bump%nam%from_conf(comm,conf)

! Set missing values
lmsvali = dmsvali
lmsvalr = dmsvalr
if (conf%has('msvali')) call conf%get_or_die('msvali',lmsvali)
if (conf%has('msvalr')) call conf%get_or_die('msvalr',lmsvalr)

! Set log unit
llunit = lmsvali
if (conf%has('lunit')) call conf%get_or_die('lunit',llunit)

! Setup BUMP
if (present(universe_rad)) then
   call bump%setup(comm,afunctionspace,fieldset,lunit=llunit,msvali=lmsvali,msvalr=lmsvalr,universe_rad=universe_rad)
else
   call bump%setup(comm,afunctionspace,fieldset,lunit=llunit,msvali=lmsvali,msvalr=lmsvalr)
end if

! Probe out
@:probe_out()

end subroutine bump_create

!----------------------------------------------------------------------
! Subroutine: bump_create_deprecated_atlas
!> Create (deprecated)
!----------------------------------------------------------------------
subroutine bump_create_deprecated_atlas(bump,comm,afunctionspace,afieldset,conf,grid,universe_rad)

implicit none

! Passed variables
class(bump_type),intent(inout) :: bump                  !< BUMP
type(fckit_mpi_comm),intent(in) :: comm                 !< FCKIT MPI communicator wrapper
type(atlas_functionspace),intent(in) :: afunctionspace  !< ATLAS function space
type(atlas_fieldset),intent(in) :: afieldset            !< ATLAS fieldset containing geometry elements
type(fckit_configuration),intent(in) :: conf            !< FCKIT configuration
type(fckit_configuration),intent(in) :: grid            !< FCKIT grid configuration
type(fieldset_type),intent(in),optional :: universe_rad !< Fieldset optionally containing universe radius

! Local variables
type(fieldset_type) :: fieldset

! Set name
@:set_name(bump_create_deprecated_atlas)

! Get instance
@:get_instance(bump)

! Probe in
@:probe_in()

! ATLAS fieldset to fieldset
fieldset = atlas_fieldset(afieldset%c_ptr())

! Call fieldset interface
if (present(universe_rad)) then
   call bump%create(comm,afunctionspace,fieldset,conf,grid,universe_rad=universe_rad)
else
   call bump%create(comm,afunctionspace,fieldset,conf,grid)
end if

! Probe out
@:probe_out()

end subroutine bump_create_deprecated_atlas

!----------------------------------------------------------------------
! Subroutine: bump_setup
!> Setup
!----------------------------------------------------------------------
subroutine bump_setup(bump,f_comm,afunctionspace,fieldset,lunit,msvali,msvalr,universe_rad)

implicit none

! Passed variables
class(bump_type),intent(inout) :: bump                  !< BUMP
type(fckit_mpi_comm),intent(in) :: f_comm               !< FCKIT MPI communicator wrapper
type(atlas_functionspace),intent(in) :: afunctionspace  !< ATLAS functionspace
type(fieldset_type),intent(in),optional :: fieldset     !< Fieldset containing geometry elements
integer,intent(in),optional :: lunit                    !< Listing unit
integer,intent(in),optional :: msvali                   !< Missing value for integers
real(kind_real),intent(in),optional :: msvalr           !< Missing value for reals
type(fieldset_type),intent(in),optional :: universe_rad !< Fieldset optionally containing universe radius

! Local variables
integer :: iv,il0,color,sc
real(kind_real) :: urmax
real(kind_real),pointer :: ptr_1(:),ptr_2(:,:)
character(len=1024) :: cname
type(atlas_field) :: afield

! Set name
@:set_name(bump_setup)

! Get instance
@:get_instance(bump)

! Probe in
@:probe_in()

! Initialize MPL
call bump%mpl%init(f_comm)

! Set missing values
bump%mpl%msv%vali = dmsvali
bump%mpl%msv%valr = dmsvalr
if (present(msvali)) bump%mpl%msv%vali = msvali
if (present(msvalr)) bump%mpl%msv%valr = msvalr

! Initialize listing
bump%mpl%lunit = bump%mpl%msv%vali
if (present(lunit)) bump%mpl%lunit = lunit
if ((.not.bump%mpl%main).and.bump%mpl%msv%is(bump%mpl%lunit)) bump%mpl%lunit = 10+bump%mpl%myproc
bump%mpl%verbosity = bump%nam%verbosity
if (bump%nam%colorlog) then
   bump%mpl%black = char(27)//'[0;0m'
   bump%mpl%green = char(27)//'[0;32m'
   bump%mpl%peach = char(27)//'[1;91m'
   bump%mpl%aqua = char(27)//'[1;36m'
   bump%mpl%purple = char(27)//'[1;35m'
   bump%mpl%err = char(27)//'[0;37;41;1m'
   bump%mpl%wng = char(27)//'[0;37;42;1m'
else
   bump%mpl%black = ' '
   bump%mpl%green = ' '
   bump%mpl%peach = ' '
   bump%mpl%aqua = ' '
   bump%mpl%purple = ' '
   bump%mpl%err = ' '
   bump%mpl%wng = ' '
end if

! Header
write(bump%mpl%info,'(a)') '-------------------------------------------------------------------'
call bump%mpl%flush
write(bump%mpl%info,'(a)') '--- You are running the BUMP library ------------------------------'
call bump%mpl%flush
@:print_bump_instance()

! Write parallel setup
write(bump%mpl%info,'(a)') '-------------------------------------------------------------------'
call bump%mpl%flush
write(bump%mpl%info,'(a,i3,a,i2,a)') '--- Parallelization with ',bump%mpl%nproc,' MPI tasks and ', &
 & bump%mpl%nthread,' OpenMP threads'
call bump%mpl%flush

if (present(universe_rad)) then
   if (universe_rad%size()>0) then
      ! Set universe radius
      write(bump%mpl%info,'(a)') '-------------------------------------------------------------------'
      call bump%mpl%flush
      write(bump%mpl%info,'(a)') '--- Set universe radius'
      call bump%mpl%flush

      ! Initialization
      urmax = zero

      do iv=1,bump%nam%nv
         ! Get field
         afield = universe_rad%field(bump%nam%variables(iv))

         ! Get data maximum
         if (afield%rank()==1) then
            call afield%data(ptr_1)
            urmax = max(urmax,zss_maxval(ptr_1,mask=bump%mpl%msv%isnot(ptr_1)))
         elseif (afield%rank()==2) then
            call afield%data(ptr_2)
            do il0=1,size(ptr_2,1)
               if ((bump%nam%min_lev(iv)<=il0).and.(il0<=bump%nam%max_lev(iv))) &
 & urmax = max(urmax,zss_maxval(ptr_2(il0,:),mask=bump%mpl%msv%isnot(ptr_2(il0,:))))
            end do
         else
            call bump%mpl%abort('${subr}$','cannot get universe radius for this field rank')
         end if
      end do

      ! Get global maximum
      call bump%mpl%f_comm%allreduce(urmax,bump%nam%universe_rad,fckit_mpi_max())
      write(bump%mpl%info,'(a7,a,f10.2,a)') '','Universe radius: ',bump%nam%universe_rad/thousand,' km'
      call bump%mpl%flush
   end if
end if

! Check namelist parameters
write(bump%mpl%info,'(a)') '-------------------------------------------------------------------'
call bump%mpl%flush
write(bump%mpl%info,'(a)') '--- Check namelist parameters'
call bump%mpl%flush
call bump%nam%check(bump%mpl)
call bump%nam%write(bump%mpl)

! Set I/O parameters
write(bump%mpl%info,'(a)') '-------------------------------------------------------------------'
call bump%mpl%flush
write(bump%mpl%info,'(a)') '--- Set I/O parameters'
call bump%mpl%flush

! Allocation
allocate(bump%mpl%pioproc(bump%mpl%nproc))

! Set I/O parameters
bump%mpl%datadir = bump%nam%datadir
bump%mpl%parallel_io = bump%nam%parallel_io
bump%mpl%nprocio = bump%nam%nprocio
bump%mpl%pioproc = .false.
if (bump%mpl%parallel_io) then
   bump%mpl%pioproc(1:min(bump%mpl%nprocio,bump%mpl%nproc)) = .true.
else
   bump%mpl%pioproc(bump%mpl%rootproc) = .true.
end if
if (bump%mpl%main) call system_clock(sc)
call bump%mpl%f_comm%broadcast(sc,bump%mpl%rootproc-1)
if (bump%mpl%pioproc(bump%mpl%myproc)) then
   color = 1
   write(cname,'(a,i12.12)') trim(bump%mpl%f_comm%name())//'_'//trim(bump%nam%prefix)//'_io_',sc
else
   color = 0
   write(cname,'(a,i12.12)') trim(bump%mpl%f_comm%name())//'_'//trim(bump%nam%prefix)//'_no_io_',sc
endif
bump%mpl%f_comm_io = bump%mpl%f_comm%split(color,cname)

! Set reproducibility parameters
write(bump%mpl%info,'(a)') '-------------------------------------------------------------------'
call bump%mpl%flush
write(bump%mpl%info,'(a)') '--- Set reproducibility parameters'
call bump%mpl%flush
repro = bump%nam%repro
rth = bump%nam%rth

! Initialize random number generator
write(bump%mpl%info,'(a)') '-------------------------------------------------------------------'
call bump%mpl%flush
write(bump%mpl%info,'(a)') '--- Initialize random number generator'
call bump%mpl%flush
call bump%rng%init(bump%mpl,bump%nam)

! Initialize allocation flags
bump%cmat%allocated = .false.
bump%nicas%allocated = .false.

! Initialize geometry
write(bump%mpl%info,'(a)') '-------------------------------------------------------------------'
call bump%mpl%flush
write(bump%mpl%info,'(a)') '--- Initialize geometry'
call bump%mpl%flush
if (present(fieldset)) then
   call bump%geom%setup(bump%mpl,bump%rng,bump%nam,afunctionspace,fieldset)
else
   call bump%geom%setup(bump%mpl,bump%rng,bump%nam,afunctionspace)
end if
if (bump%nam%default_seed) call bump%rng%reseed(bump%mpl)

! Initialize block parameters
write(bump%mpl%info,'(a)') '-------------------------------------------------------------------'
call bump%mpl%flush
write(bump%mpl%info,'(a)') '--- Initialize block parameters'
call bump%mpl%flush
call bump%bpar%alloc(bump%nam,bump%geom)
call bump%bpar%init(bump%mpl,bump%nam,bump%geom)

if (bump%nam%ens1_ne>0) then
   ! Initialize ensemble 1
   write(bump%mpl%info,'(a)') '-------------------------------------------------------------------'
   call bump%mpl%flush
   write(bump%mpl%info,'(a)') '--- Initialize ensemble 1'
   call bump%mpl%flush
   call bump%ens1%set_att(bump%nam%ens1_ne,bump%nam%ens1_nsub)
end if

if (bump%nam%ens2_ne>0) then
   ! Initialize ensemble 2
   write(bump%mpl%info,'(a)') '-------------------------------------------------------------------'
   call bump%mpl%flush
   write(bump%mpl%info,'(a)') '--- Initialize ensemble 2'
   call bump%mpl%flush
   call bump%ens2%set_att(bump%nam%ens2_ne,bump%nam%ens2_nsub)
end if

! Probe out
@:probe_out()

end subroutine bump_setup

!----------------------------------------------------------------------
! Subroutine: bump_add_member
!> Add member into bump%ens[1,2]
!----------------------------------------------------------------------
subroutine bump_add_member(bump,fieldset,ie,iens)

implicit none

! Passed variables
class(bump_type),intent(inout) :: bump     !< BUMP
type(fieldset_type),intent(in) :: fieldset !< Fieldset
integer,intent(in) :: ie                   !< Member index
integer,intent(in) :: iens                 !< Ensemble number

! Set name
@:set_name(bump_add_member)

! Get instance
@:get_instance(bump)

! Probe in
@:probe_in()

! Check ensemble number
if ((iens/=1).and.(iens/=2)) call bump%mpl%abort('${subr}$','wrong ensemble number')

if (iens==1) then
   if (.not.bump%ens1%loaded) call bump%ens1%alloc(bump%nam%ens1_ne,bump%nam%ens1_nsub)
   if (copy_ensemble) then
      ! Copy ATLAS fields
      call bump%ens1%mem(ie)%init(bump%mpl,fieldset,bump%geom%gmask_mga,bump%nam%variables(1:bump%nam%nv),bump%nam%lev2d, &
    & copy=.true.)
   else
      ! Pass ATLAS fields
      call bump%ens1%mem(ie)%init(bump%mpl,fieldset,bump%geom%gmask_mga,bump%nam%variables(1:bump%nam%nv),bump%nam%lev2d, &
    & pass=.true.)
   end if
   bump%ens1%loaded = .true.

   ! Print norm
!   write(bump%mpl%info,'(a,i6,a)') 'Ensemble 1 member ',ie,': '
!   call bump%mpl%flush
!   call bump%ens1%mem(ie)%print(bump%mpl)
elseif (iens==2) then
   if (.not.bump%ens2%loaded) call bump%ens2%alloc(bump%nam%ens2_ne,bump%nam%ens2_nsub)
   if (copy_ensemble) then
      ! Copy ATLAS fields
      call bump%ens2%mem(ie)%init(bump%mpl,fieldset,bump%geom%gmask_mga,bump%nam%variables(1:bump%nam%nv),bump%nam%lev2d, &
    & copy=.true.)
   else
      ! Pass ATLAS fields
      call bump%ens2%mem(ie)%init(bump%mpl,fieldset,bump%geom%gmask_mga,bump%nam%variables(1:bump%nam%nv),bump%nam%lev2d, &
    & pass=.true.)
   end if
   bump%ens2%loaded = .true.

   ! Print norm
!   write(bump%mpl%info,'(a,i6,a)') 'Ensemble 2 member ',ie,': '
!   call bump%mpl%flush
!   call bump%ens2%mem(ie)%print(bump%mpl)
end if

! Probe out
@:probe_out()

end subroutine bump_add_member

!----------------------------------------------------------------------
! Subroutine: bump_update_vbal_cov
!> Update vertical covariances, one member at a time
!----------------------------------------------------------------------
subroutine bump_update_vbal_cov(bump,fieldset,ie)

implicit none

! Passed variables
class(bump_type),intent(inout) :: bump        !< BUMP
type(fieldset_type),intent(inout) :: fieldset !< Fieldset
integer,intent(in) :: ie                      !< Member index

! Local variable
real(kind_real) :: fld_c0a(bump%geom%nc0a,bump%geom%nl0,bump%nam%nv)

! Set name
@:set_name(bump_update_vbal_cov)

! Get instance index
@:get_instance(bump)

! Probe in
@:probe_in()

if (ie==1) then
   ! Setup sampling
   write(bump%mpl%info,'(a)') '-------------------------------------------------------------------'
   call bump%mpl%flush
   write(bump%mpl%info,'(a)') '--- Setup sampling'
   call bump%mpl%flush
   call bump%samp%setup(bump%mpl,bump%rng,bump%nam,bump%geom)
   if (bump%nam%default_seed) call bump%rng%reseed(bump%mpl)
end if

! Set fieldset metadata
call fieldset%set_metadata(bump%mpl,bump%geom%gmask_mga,bump%nam%variables(1:bump%nam%nv),bump%nam%lev2d)

! Fieldset to Fortran on subset Sc0
call bump%geom%fieldset_to_c0(bump%mpl,bump%nam,fieldset,fld_c0a)

! Update vertical covariances
call bump%vbal%cov_update(bump%mpl,bump%nam,bump%geom,bump%bpar,bump%samp,fld_c0a,ie)

! Probe out
@:probe_out()

end subroutine bump_update_vbal_cov

!----------------------------------------------------------------------
! Subroutine: bump_update_var
!> Update variance, one member at a time
!----------------------------------------------------------------------
subroutine bump_update_var(bump,fieldset,ie)

implicit none

! Passed variables
class(bump_type),intent(inout) :: bump        !< BUMP
type(fieldset_type),intent(inout) :: fieldset !< Fieldset
integer,intent(in) :: ie                      !< Member index

! Local variable
real(kind_real) :: fld_c0a(bump%geom%nc0a,bump%geom%nl0,bump%nam%nv)

! Set name
@:set_name(bump_update_var)

! Get instance index
@:get_instance(bump)

! Probe in
@:probe_in()

! Set fieldset metadata
call fieldset%set_metadata(bump%mpl,bump%geom%gmask_mga,bump%nam%variables(1:bump%nam%nv),bump%nam%lev2d)

! Fieldset to Fortran on subset Sc0
call bump%geom%fieldset_to_c0(bump%mpl,bump%nam,fieldset,fld_c0a)

! Update variance
call bump%var%update(bump%mpl,bump%rng,bump%nam,bump%geom,bump%bpar,fld_c0a,ie)
if (bump%nam%default_seed) call bump%rng%reseed(bump%mpl)

! Probe out
@:probe_out()

end subroutine bump_update_var

!----------------------------------------------------------------------
! Subroutine: bump_update_mom
!> Update moments, one member at a time
!----------------------------------------------------------------------
subroutine bump_update_mom(bump,fieldset,ie)

implicit none

! Passed variables
class(bump_type),intent(inout) :: bump        !< BUMP
type(fieldset_type),intent(inout) :: fieldset !< Fieldset
integer,intent(in) :: ie                      !< Member index

! Local variable
real(kind_real) :: fld_c0a(bump%geom%nc0a,bump%geom%nl0,bump%nam%nv)

! Set name
@:set_name(bump_update_mom)

! Get instance index
@:get_instance(bump)

! Probe in
@:probe_in()

if (ie==1) then
   ! Setup sampling
   write(bump%mpl%info,'(a)') '-------------------------------------------------------------------'
   call bump%mpl%flush
   write(bump%mpl%info,'(a)') '--- Setup sampling'
   call bump%mpl%flush
   call bump%samp%setup(bump%mpl,bump%rng,bump%nam,bump%geom)
   if (bump%nam%default_seed) call bump%rng%reseed(bump%mpl)
end if

! Set fieldset metadata
call fieldset%set_metadata(bump%mpl,bump%geom%gmask_mga,bump%nam%variables(1:bump%nam%nv),bump%nam%lev2d)

! Fieldset to Fortran on subset Sc0
call bump%geom%fieldset_to_c0(bump%mpl,bump%nam,fieldset,fld_c0a)

! Update moments
call bump%mom1%update(bump%mpl,bump%nam,bump%geom,bump%bpar,bump%samp,'mom_1',fld_c0a,ie)

! Probe out
@:probe_out()

end subroutine bump_update_mom

!----------------------------------------------------------------------
! Subroutine: bump_run_drivers
!> Run drivers
!----------------------------------------------------------------------
subroutine bump_run_drivers(bump)

implicit none

! Passed variables
class(bump_type),intent(inout) :: bump !< BUMP

! Set name
@:set_name(bump_run_drivers)

! Get instance
@:get_instance(bump)

! Probe in
@:probe_in()

if (bump%nam%ens1_ne>0.and.bump%ens1%loaded) then
   ! Compute mean for ensemble 1
   write(bump%mpl%info,'(a)') '-------------------------------------------------------------------'
   call bump%mpl%flush
   write(bump%mpl%info,'(a)') '--- Compute mean for ensemble 1'
   call bump%mpl%flush
   call bump%ens1%compute_mean(bump%mpl,bump%nam,bump%geom)
end if

if (bump%nam%ens2_ne>0.and.bump%ens2%loaded) then
   ! Compute mean for ensemble 2
   write(bump%mpl%info,'(a)') '-------------------------------------------------------------------'
   call bump%mpl%flush
   write(bump%mpl%info,'(a)') '--- Compute mean for ensemble 2'
   call bump%mpl%flush
   call bump%ens2%compute_mean(bump%mpl,bump%nam,bump%geom)
end if

if (bump%nam%new_normality) then
   ! Run normality tests
   write(bump%mpl%info,'(a)') '-------------------------------------------------------------------'
   call bump%mpl%flush
   write(bump%mpl%info,'(a)') '--- Run normality tests'
   call bump%mpl%flush
   call bump%ens1%normality(bump%mpl,bump%nam,bump%geom)
end if

if (bump%nam%new_vbal_cov.or.bump%nam%load_vbal_cov.or.(bump%nam%new_vbal.and.(.not.bump%nam%update_vbal_cov)) &
 & .or.bump%nam%load_vbal.or.bump%nam%new_mom.or.bump%nam%load_mom) then
   ! Setup sampling
   write(bump%mpl%info,'(a)') '-------------------------------------------------------------------'
   call bump%mpl%flush
   write(bump%mpl%info,'(a)') '--- Setup sampling'
   call bump%mpl%flush
   call bump%samp%setup(bump%mpl,bump%rng,bump%nam,bump%geom,bump%ens1)
   if (bump%nam%default_seed) call bump%rng%reseed(bump%mpl)
end if

if (bump%nam%new_vbal_cov) then
   ! Run vertical covariance driver
   write(bump%mpl%info,'(a)') '-------------------------------------------------------------------'
   call bump%mpl%flush
   write(bump%mpl%info,'(a)') '--- Run vertical covariances driver'
   call bump%mpl%flush
   call bump%vbal%cov_run(bump%mpl,bump%nam,bump%geom,bump%bpar,bump%samp,bump%ens1)
elseif (bump%nam%load_vbal_cov) then
   ! Read vertical balance
   write(bump%mpl%info,'(a)') '-------------------------------------------------------------------'
   call bump%mpl%flush
   write(bump%mpl%info,'(a)') '--- Read vertical covariances'
   call bump%mpl%flush
   if (bump%nam%load_samp_local) then
      call bump%vbal%cov_read_local(bump%mpl,bump%nam,bump%geom,bump%bpar,bump%samp,bump%nam%ens1_nsub)
   elseif (bump%nam%load_samp_global) then
      call bump%vbal%cov_read_global(bump%mpl,bump%nam,bump%geom,bump%bpar,bump%samp,bump%nam%ens1_nsub)
   end if
end if

if (bump%nam%new_vbal) then
   ! Run vertical balance driver
   write(bump%mpl%info,'(a)') '-------------------------------------------------------------------'
   call bump%mpl%flush
   write(bump%mpl%info,'(a)') '--- Run vertical balance driver'
   call bump%mpl%flush
   call bump%vbal%run_vbal(bump%mpl,bump%nam,bump%geom,bump%bpar,bump%samp,bump%ens1,bump%ens1u)
elseif (bump%nam%load_vbal) then
   ! Read vertical balance
   write(bump%mpl%info,'(a)') '-------------------------------------------------------------------'
   call bump%mpl%flush
   write(bump%mpl%info,'(a)') '--- Read vertical balance'
   call bump%mpl%flush
   if (bump%nam%load_samp_local) then
      call bump%vbal%read_local(bump%mpl,bump%nam,bump%geom,bump%bpar,bump%samp)
   elseif (bump%nam%load_samp_global) then
      call bump%vbal%read_global(bump%mpl,bump%nam,bump%geom,bump%bpar,bump%samp)
   end if
end if

if (bump%nam%new_vbal.or.bump%nam%load_vbal) then
   ! Run vertical balance tests driver
   write(bump%mpl%info,'(a)') '-------------------------------------------------------------------'
   call bump%mpl%flush
   write(bump%mpl%info,'(a)') '--- Run vertical balance tests driver'
   call bump%mpl%flush
   call bump%vbal%run_vbal_tests(bump%mpl,bump%rng,bump%nam,bump%geom,bump%bpar)
   if (bump%nam%default_seed) call bump%rng%reseed(bump%mpl)
end if

if (bump%nam%new_var.or.bump%nam%load_var.or.(bump%var%bump_m2_counter>0)) then
   ! Run variance driver
   write(bump%mpl%info,'(a)') '-------------------------------------------------------------------'
   call bump%mpl%flush
   write(bump%mpl%info,'(a)') '--- Run variance driver'
   call bump%mpl%flush
   call bump%var%run_var(bump%mpl,bump%rng,bump%nam,bump%geom,bump%bpar,bump%ens1)
   if (bump%nam%default_seed) call bump%rng%reseed(bump%mpl)
end if

if (bump%nam%new_mom) then
   ! Compute sample moments
   write(bump%mpl%info,'(a)') '-------------------------------------------------------------------'
   call bump%mpl%flush
   write(bump%mpl%info,'(a)') '--- Compute sample moments'
   call bump%mpl%flush

   ! Compute ensemble 1 sample moments
   write(bump%mpl%info,'(a7,a)') '','Ensemble 1:'
   call bump%mpl%flush
   call bump%mom1%compute(bump%mpl,bump%nam,bump%geom,bump%bpar,bump%samp,bump%ens1,'mom_1')

   select case(trim(bump%nam%method))
   case ('hyb-rnd','dual-ens')
      ! Compute ensemble 2 sample moments
      write(bump%mpl%info,'(a7,a)') '','Ensemble 2:'
      call bump%mpl%flush
      call bump%mom2%compute(bump%mpl,bump%nam,bump%geom,bump%bpar,bump%samp,bump%ens2,'mom_2')
   end select
elseif (bump%nam%load_mom) then
   ! Load sample moments
   write(bump%mpl%info,'(a)') '-------------------------------------------------------------------'
   call bump%mpl%flush
   write(bump%mpl%info,'(a)') '--- Load sample moments'
   call bump%mpl%flush

   ! Load ensemble 1 sample moments
   write(bump%mpl%info,'(a7,a)') '','Ensemble 1'
   call bump%mpl%flush
   call bump%mom1%read(bump%mpl,bump%nam,bump%geom,bump%bpar,bump%samp,bump%ens1,'mom_1')

   select case(trim(bump%nam%method))
   case ('hyb-rnd','dual-ens')
      ! Load ensemble 2 sample moments
      write(bump%mpl%info,'(a7,a)') '','Ensemble 2'
      call bump%mpl%flush
      call bump%mom2%read(bump%mpl,bump%nam,bump%geom,bump%bpar,bump%samp,bump%ens2,'mom_2')
   end select
end if

if (bump%nam%new_hdiag) then
   ! Run HDIAG driver
   write(bump%mpl%info,'(a)') '-------------------------------------------------------------------'
   call bump%mpl%flush
   write(bump%mpl%info,'(a)') '--- Run HDIAG driver'
   call bump%mpl%flush
   call bump%hdiag%run_hdiag(bump%mpl,bump%nam,bump%geom,bump%bpar,bump%samp,bump%mom1,bump%mom2)

   ! Copy HDIAG into C matrix
   write(bump%mpl%info,'(a)') '-------------------------------------------------------------------'
   call bump%mpl%flush
   write(bump%mpl%info,'(a)') '--- Copy HDIAG into C matrix'
   call bump%mpl%flush
   call bump%cmat%from_hdiag(bump%mpl,bump%nam,bump%geom,bump%bpar,bump%samp,bump%hdiag)

   ! Release memory
   call bump%hdiag%dealloc
end if

if (bump%nam%forced_radii) then
   ! Copy namelist support radii into C matrix
   write(bump%mpl%info,'(a)') '-------------------------------------------------------------------'
   call bump%mpl%flush
   write(bump%mpl%info,'(a)') '--- Copy namelist support radii into C matrix'
   call bump%mpl%flush
   call bump%cmat%from_nam(bump%mpl,bump%nam,bump%geom,bump%bpar)
end if

if (bump%cmat%allocated.or.bump%nam%new_nicas) then
   ! Get C matrix from BUMP interface
   write(bump%mpl%info,'(a)') '-------------------------------------------------------------------'
   call bump%mpl%flush
   write(bump%mpl%info,'(a)') '--- Get C matrix from BUMP interface'
   call bump%mpl%flush
   call bump%cmat%from_bump(bump%mpl,bump%geom,bump%bpar)

   ! Setup C matrix sampling
   write(bump%mpl%info,'(a)') '-------------------------------------------------------------------'
   call bump%mpl%flush
   write(bump%mpl%info,'(a)') '--- Setup C matrix sampling'
   call bump%mpl%flush
   call bump%cmat%setup_sampling(bump%mpl,bump%nam,bump%geom,bump%bpar)
end if

if (bump%nam%new_nicas.or.bump%nam%load_nicas_global) then
   ! Run NICAS driver
   write(bump%mpl%info,'(a)') '-------------------------------------------------------------------'
   call bump%mpl%flush
   write(bump%mpl%info,'(a)') '--- Run NICAS driver'
   call bump%mpl%flush
   call bump%nicas%run_nicas(bump%mpl,bump%rng,bump%nam,bump%geom,bump%bpar,bump%cmat)
   if (bump%nam%default_seed) call bump%rng%reseed(bump%mpl)
elseif (bump%nam%load_nicas_local) then
   ! Read NICAS parameters
   write(bump%mpl%info,'(a)') '-------------------------------------------------------------------'
   call bump%mpl%flush
   write(bump%mpl%info,'(a)') '--- Read local NICAS parameters'
   call bump%mpl%flush
   call bump%nicas%read_local(bump%mpl,bump%nam,bump%geom,bump%bpar)
end if

! Release memory (partial)
call bump%cmat%partial_dealloc

if (bump%nam%new_nicas.or.bump%nam%load_nicas_local.or.bump%nam%load_nicas_global) then
   ! Run NICAS tests driver
   write(bump%mpl%info,'(a)') '-------------------------------------------------------------------'
   call bump%mpl%flush
   write(bump%mpl%info,'(a)') '--- Run NICAS tests driver'
   call bump%mpl%flush
   call bump%nicas%run_nicas_tests(bump%mpl,bump%rng,bump%nam,bump%geom,bump%bpar,bump%ens1)
   if (bump%nam%default_seed) call bump%rng%reseed(bump%mpl)
end if

if (bump%nam%new_wind.or.bump%nam%load_wind_local) then
   ! Run psi/chi to u/v driver
   write(bump%mpl%info,'(a)') '-------------------------------------------------------------------'
   call bump%mpl%flush
   write(bump%mpl%info,'(a)') '--- Run psi/chi to u/v driver'
   call bump%mpl%flush
   call bump%wind%setup(bump%mpl,bump%rng,bump%nam,bump%geom)
end if

! Probe out
@:probe_out()

end subroutine bump_run_drivers

!----------------------------------------------------------------------
! Subroutine: bump_apply_vbal
!> Vertical balance application
!----------------------------------------------------------------------
subroutine bump_apply_vbal(bump,fieldset)

implicit none

! Passed variables
class(bump_type),intent(inout) :: bump        !< BUMP
type(fieldset_type),intent(inout) :: fieldset !< Fieldset

! Local variable
real(kind_real) :: fld_c0a(bump%geom%nc0a,bump%geom%nl0,bump%nam%nv)

! Set name
@:set_name(bump_apply_vbal)

! Get instance
@:get_instance(bump)

! Probe in
@:probe_in()

! Set fieldset metadata
call fieldset%set_metadata(bump%mpl,bump%geom%gmask_mga,bump%nam%variables(1:bump%nam%nv),bump%nam%lev2d)

! Fieldset to Fortran on subset Sc0
call bump%geom%fieldset_to_c0(bump%mpl,bump%nam,fieldset,fld_c0a)

! Apply vertical balance
call bump%vbal%apply(bump%nam,bump%geom,bump%bpar,fld_c0a)

! Fortran array on subset Sc0 to fieldset
call bump%geom%c0_to_fieldset(bump%mpl,bump%nam,fld_c0a,fieldset)

! Probe out
@:probe_out()

end subroutine bump_apply_vbal

!----------------------------------------------------------------------
! Subroutine: bump_apply_vbal_inv
!> Vertical balance application, inverse
!----------------------------------------------------------------------
subroutine bump_apply_vbal_inv(bump,fieldset)

implicit none

! Passed variables
class(bump_type),intent(inout) :: bump        !< BUMP
type(fieldset_type),intent(inout) :: fieldset !< Fieldset

! Local variable
real(kind_real) :: fld_c0a(bump%geom%nc0a,bump%geom%nl0,bump%nam%nv)

! Set name
@:set_name(bump_apply_vbal_inv)

! Get instance
@:get_instance(bump)

! Probe in
@:probe_in()

! Set fieldset metadata
call fieldset%set_metadata(bump%mpl,bump%geom%gmask_mga,bump%nam%variables(1:bump%nam%nv),bump%nam%lev2d)

! Fieldset to Fortran on subset Sc0
call bump%geom%fieldset_to_c0(bump%mpl,bump%nam,fieldset,fld_c0a)

! Apply vertical balance, inverse
call bump%vbal%apply_inv(bump%nam,bump%geom,bump%bpar,fld_c0a)

! Fortran array on subset Sc0 to fieldset
call bump%geom%c0_to_fieldset(bump%mpl,bump%nam,fld_c0a,fieldset)

! Probe out
@:probe_out()

end subroutine bump_apply_vbal_inv

!----------------------------------------------------------------------
! Subroutine: bump_apply_vbal_ad
!> Vertical balance application, adjoint
!----------------------------------------------------------------------
subroutine bump_apply_vbal_ad(bump,fieldset)

implicit none

! Passed variables
class(bump_type),intent(inout) :: bump        !< BUMP
type(fieldset_type),intent(inout) :: fieldset !< Fieldset

! Local variable
real(kind_real) :: fld_c0a(bump%geom%nc0a,bump%geom%nl0,bump%nam%nv)

! Set name
@:set_name(bump_apply_vbal_ad)

! Get instance
@:get_instance(bump)

! Probe in
@:probe_in()

! Set fieldset metadata
call fieldset%set_metadata(bump%mpl,bump%geom%gmask_mga,bump%nam%variables(1:bump%nam%nv),bump%nam%lev2d)

! Fieldset to Fortran on subset Sc0
call bump%geom%fieldset_to_c0(bump%mpl,bump%nam,fieldset,fld_c0a)

! Apply vertical balance, adjoint
call bump%vbal%apply_ad(bump%nam,bump%geom,bump%bpar,fld_c0a)

! Fortran array on subset Sc0 to fieldset
call bump%geom%c0_to_fieldset(bump%mpl,bump%nam,fld_c0a,fieldset)

! Probe out
@:probe_out()

end subroutine bump_apply_vbal_ad

!----------------------------------------------------------------------
! Subroutine: bump_apply_vbal_inv_ad
!> Vertical balance application, inverse adjoint
!----------------------------------------------------------------------
subroutine bump_apply_vbal_inv_ad(bump,fieldset)

implicit none

! Passed variables
class(bump_type),intent(inout) :: bump        !< BUMP
type(fieldset_type),intent(inout) :: fieldset !< Fieldset

! Local variable
real(kind_real) :: fld_c0a(bump%geom%nc0a,bump%geom%nl0,bump%nam%nv)

! Set name
@:set_name(bump_apply_vbal_inv_ad)

! Get instance
@:get_instance(bump)

! Probe in
@:probe_in()

! Set fieldset metadata
call fieldset%set_metadata(bump%mpl,bump%geom%gmask_mga,bump%nam%variables(1:bump%nam%nv),bump%nam%lev2d)

! Fieldset to Fortran on subset Sc0
call bump%geom%fieldset_to_c0(bump%mpl,bump%nam,fieldset,fld_c0a)

! Apply vertical balance, inverse adjoint
call bump%vbal%apply_inv_ad(bump%nam,bump%geom,bump%bpar,fld_c0a)

! Fortran array on subset Sc0 to fieldset
call bump%geom%c0_to_fieldset(bump%mpl,bump%nam,fld_c0a,fieldset)

! Probe out
@:probe_out()

end subroutine bump_apply_vbal_inv_ad

!----------------------------------------------------------------------
! Subroutine: bump_apply_stddev
!> Standard-deviation application
!----------------------------------------------------------------------
subroutine bump_apply_stddev(bump,fieldset)

implicit none

! Passed variables
class(bump_type),intent(inout) :: bump        !< BUMP
type(fieldset_type),intent(inout) :: fieldset !< Fieldset

! Local variable
real(kind_real) :: fld_c0a(bump%geom%nc0a,bump%geom%nl0,bump%nam%nv)

! Set name
@:set_name(bump_apply_stddev)

! Get instance
@:get_instance(bump)

! Probe in
@:probe_in()

! Set fieldset metadata
call fieldset%set_metadata(bump%mpl,bump%geom%gmask_mga,bump%nam%variables(1:bump%nam%nv),bump%nam%lev2d)

! Fieldset to Fortran on subset Sc0
call bump%geom%fieldset_to_c0(bump%mpl,bump%nam,fieldset,fld_c0a)

! Apply standard-deviation
call bump%var%apply_sqrt(bump%mpl,bump%nam,bump%geom,fld_c0a)

! Fortran array on subset Sc0 to fieldset
call bump%geom%c0_to_fieldset(bump%mpl,bump%nam,fld_c0a,fieldset)

! Probe out
@:probe_out()

end subroutine bump_apply_stddev

!----------------------------------------------------------------------
! Subroutine: bump_apply_stddev_inv
!> Standard-deviation application, inverse
!----------------------------------------------------------------------
subroutine bump_apply_stddev_inv(bump,fieldset)

implicit none

! Passed variables
class(bump_type),intent(inout) :: bump        !< BUMP
type(fieldset_type),intent(inout) :: fieldset !< Fieldset

! Local variable
real(kind_real) :: fld_c0a(bump%geom%nc0a,bump%geom%nl0,bump%nam%nv)

! Set name
@:set_name(bump_apply_stddev_inv)

! Get instance
@:get_instance(bump)

! Probe in
@:probe_in()

! Set fieldset metadata
call fieldset%set_metadata(bump%mpl,bump%geom%gmask_mga,bump%nam%variables(1:bump%nam%nv),bump%nam%lev2d)

! Fieldset to Fortran on subset Sc0
call bump%geom%fieldset_to_c0(bump%mpl,bump%nam,fieldset,fld_c0a)

! Apply standard-deviation
call bump%var%apply_sqrt_inv(bump%mpl,bump%nam,bump%geom,fld_c0a)

! Fortran array on subset Sc0 to fieldset
call bump%geom%c0_to_fieldset(bump%mpl,bump%nam,fld_c0a,fieldset)

! Probe out
@:probe_out()

end subroutine bump_apply_stddev_inv

!----------------------------------------------------------------------
! Subroutine: bump_apply_nicas
!> NICAS application
!----------------------------------------------------------------------
subroutine bump_apply_nicas(bump,fieldset)

implicit none

! Passed variables
class(bump_type),intent(inout) :: bump        !< BUMP
type(fieldset_type),intent(inout) :: fieldset !< Fieldset

! Local variable
integer :: ic0a,il0,iv
real(kind_real) :: fld_c0a(bump%geom%nc0a,bump%geom%nl0,bump%nam%nv)

! Set name
@:set_name(bump_apply_nicas)

! Get instance
@:get_instance(bump)

! Probe in
@:probe_in()

! Set fieldset metadata
call fieldset%set_metadata(bump%mpl,bump%geom%gmask_mga,bump%nam%variables(1:bump%nam%nv),bump%nam%lev2d)

! Fieldset to Fortran on subset Sc0
call bump%geom%fieldset_to_c0(bump%mpl,bump%nam,fieldset,fld_c0a)

! Apply NICAS
call bump%nicas%apply(bump%mpl,bump%nam,bump%geom,bump%bpar,fld_c0a)

! Fortran array on subset Sc0 to fieldset
call bump%geom%c0_to_fieldset(bump%mpl,bump%nam,fld_c0a,fieldset)

! Probe out
@:probe_out()

end subroutine bump_apply_nicas

!----------------------------------------------------------------------
! Subroutine: bump_apply_nicas_deprecated_atlas
!> NICAS application (deprecated
!----------------------------------------------------------------------
subroutine bump_apply_nicas_deprecated_atlas(bump,afieldset)

implicit none

! Passed variables
class(bump_type),intent(inout) :: bump          !< BUMP
type(atlas_fieldset),intent(inout) :: afieldset !< ATLAS fieldset

! Local variables
type(fieldset_type) :: fieldset

! Set name
@:set_name(bump_apply_nicas_deprecated_atlas)

! Get instance
@:get_instance(bump)

! Probe in
@:probe_in()

! ATLAS fieldset to fieldset
fieldset = atlas_fieldset(afieldset%c_ptr())

! Call fieldset interface
call bump%apply_nicas(fieldset)

! Probe out
@:probe_out()

end subroutine bump_apply_nicas_deprecated_atlas

!----------------------------------------------------------------------
! Subroutine: bump_get_cv_size
!> Get control variable size
!----------------------------------------------------------------------
subroutine bump_get_cv_size(bump,n)

implicit none

! Passed variables
class(bump_type),intent(inout) :: bump !< BUMP
integer,intent(out) :: n               !< Control variable size

! Local variables
type(cv_type) :: cv

! Set name
@:set_name(bump_get_cv_size)

! Get instance
@:get_instance(bump)

! Probe in
@:probe_in()

! Allocate control variable
call bump%nicas%alloc_cv(bump%mpl,bump%bpar,cv,getsizeonly=.true.)

! Copy size
n = cv%n

! Probe out
@:probe_out()

end subroutine bump_get_cv_size

!----------------------------------------------------------------------
! Subroutine: bump_apply_nicas_sqrt
!> NICAS square-root application
!----------------------------------------------------------------------
subroutine bump_apply_nicas_sqrt(bump,pcv,fieldset)

implicit none

! Passed variables
class(bump_type),intent(inout) :: bump        !< BUMP
real(kind_real),intent(in) :: pcv(:)          !< Packed control variable
type(fieldset_type),intent(inout) :: fieldset !< Fieldset

! Local variable
integer :: ic0a,il0,iv
real(kind_real) :: fld_c0a(bump%geom%nc0a,bump%geom%nl0,bump%nam%nv)
type(cv_type) :: cv

! Set name
@:set_name(bump_apply_nicas_sqrt)

! Get instance
@:get_instance(bump)

! Probe in
@:probe_in()

! Allocation
call bump%nicas%alloc_cv(bump%mpl,bump%bpar,cv)

! Check dimension
if (size(pcv)==cv%n) then
   ! Unpack control variable
   call cv%unpack(pcv)
else
   call bump%mpl%abort('${subr}$','wrong control variable size')
end if

! Apply NICAS square-root
call bump%nicas%apply_sqrt(bump%mpl,bump%nam,bump%geom,bump%bpar,cv,fld_c0a)

! Set missing unmasked values to zero
do iv=1,bump%nam%nv
   do il0=1,bump%geom%nl0
      do ic0a=1,bump%geom%nc0a
         if (bump%mpl%msv%is(fld_c0a(ic0a,il0,iv)).and.(.not.bump%geom%gmask_c0a(ic0a,il0))) fld_c0a(ic0a,il0,iv) = zero
      end do
   end do
end do

! Set fieldset metadata
call fieldset%set_metadata(bump%mpl,bump%geom%gmask_mga,bump%nam%variables(1:bump%nam%nv),bump%nam%lev2d)

! Fortran array on subset Sc0 to fieldset
call bump%geom%c0_to_fieldset(bump%mpl,bump%nam,fld_c0a,fieldset)

! Probe out
@:probe_out()

end subroutine bump_apply_nicas_sqrt

!----------------------------------------------------------------------
! Subroutine: bump_apply_nicas_sqrt_deprecated_atlas
!> NICAS square-root application (deprecated)
!----------------------------------------------------------------------
subroutine bump_apply_nicas_sqrt_deprecated_atlas(bump,pcv,afieldset)

implicit none

! Passed variables
class(bump_type),intent(inout) :: bump          !< BUMP
real(kind_real),intent(in) :: pcv(:)            !< Packed control variable
type(atlas_fieldset),intent(inout) :: afieldset !< ATLAS Fieldset

! Local variables
type(fieldset_type) :: fieldset

! Set name
@:set_name(bump_apply_nicas_sqrt_deprecated_atlas)

! Get instance
@:get_instance(bump)

! Probe in
@:probe_in()

! ATLAS fieldset to fieldset
fieldset = atlas_fieldset(afieldset%c_ptr())

! Call fieldset interface
call bump%apply_nicas_sqrt(pcv,fieldset)

! Probe out
@:probe_out()

end subroutine bump_apply_nicas_sqrt_deprecated_atlas

!----------------------------------------------------------------------
! Subroutine: bump_apply_nicas_sqrt_ad
!> NICAS square-root adjoint application
!----------------------------------------------------------------------
subroutine bump_apply_nicas_sqrt_ad(bump,fieldset,pcv)

implicit none

! Passed variables
class(bump_type),intent(inout) :: bump        !< BUMP
type(fieldset_type),intent(inout) :: fieldset !< Fieldset
real(kind_real),intent(inout) :: pcv(:)       !< Packed control variable

! Local variables
real(kind_real) :: fld_c0a(bump%geom%nc0a,bump%geom%nl0,bump%nam%nv)
type(cv_type) :: cv

! Set name
@:set_name(bump_apply_nicas_sqrt_ad)

! Get instance
@:get_instance(bump)

! Probe in
@:probe_in()

! Set fieldset metadata
call fieldset%set_metadata(bump%mpl,bump%geom%gmask_mga,bump%nam%variables(1:bump%nam%nv),bump%nam%lev2d)

! Fieldset to Fortran on subset Sc0
call bump%geom%fieldset_to_c0(bump%mpl,bump%nam,fieldset,fld_c0a)

! Apply NICAS square-root adjoint
call bump%nicas%apply_sqrt_ad(bump%mpl,bump%nam,bump%geom,bump%bpar,fld_c0a,cv)

! Check dimension
if (size(pcv)==cv%n) then
   ! Pack control variable
   call cv%pack(pcv)
else
   call bump%mpl%abort('${subr}$','wrong control variable size')
end if

! Probe out
@:probe_out()

end subroutine bump_apply_nicas_sqrt_ad

!----------------------------------------------------------------------
! Subroutine: bump_randomize
!> NICAS randomization
!----------------------------------------------------------------------
subroutine bump_randomize(bump,fieldset)

implicit none

! Passed variables
class(bump_type),intent(inout) :: bump        !< BUMP
type(fieldset_type),intent(inout) :: fieldset !< Fieldset

! Local variable
real(kind_real) :: fld_c0a(bump%geom%nc0a,bump%geom%nl0,bump%nam%nv)
type(cv_type) :: cv

! Set name
@:set_name(bump_randomize)

! Get instance
@:get_instance(bump)

! Probe in
@:probe_in()

! Generate random control vector
call bump%nicas%random_cv(bump%mpl,bump%rng,bump%bpar,cv)

! Apply NICAS square-root
call bump%nicas%apply_sqrt(bump%mpl,bump%nam,bump%geom,bump%bpar,cv,fld_c0a)

! Set fieldset metadata
call fieldset%set_metadata(bump%mpl,bump%geom%gmask_mga,bump%nam%variables(1:bump%nam%nv),bump%nam%lev2d)

! Fortran array on subset Sc0 to fieldset
call bump%geom%c0_to_fieldset(bump%mpl,bump%nam,fld_c0a,fieldset)

! Probe out
@:probe_out()

end subroutine bump_randomize

!----------------------------------------------------------------------
! Subroutine: bump_psichi_to_uv
!> psi/chi to u/v transform
!----------------------------------------------------------------------
subroutine bump_psichi_to_uv(bump,fieldset)

implicit none

! Passed variables
class(bump_type),intent(inout) :: bump        !< BUMP
type(fieldset_type),intent(inout) :: fieldset !< Fieldset

! Local variable
integer :: iv,iv_psi,iv_chi,iv_ua,iv_va
real(kind_real) :: fld_c0a(bump%geom%nc0a,bump%geom%nl0,bump%nam%nv)
type(atlas_field) :: afield

! Set name
@:set_name(bump_psichi_to_uv)

! Get instance
@:get_instance(bump)

! Probe in
@:probe_in()

! Add u/v variables in fieldset
afield = bump%geom%afunctionspace_mg%create_field(name=bump%nam%wind_zonal,kind=atlas_real(kind_real), &
 & levels=bump%geom%nl0)
call fieldset%add(afield)
afield = bump%geom%afunctionspace_mg%create_field(name=bump%nam%wind_meridional,kind=atlas_real(kind_real), &
 & levels=bump%geom%nl0)
call fieldset%add(afield)

! Set fieldsets metadata
call fieldset%set_metadata(bump%mpl,bump%geom%gmask_mga,bump%nam%variables(1:bump%nam%nv),bump%nam%lev2d)

! Fieldset to Fortran on subset Sc0
call bump%geom%fieldset_to_c0(bump%mpl,bump%nam,fieldset,fld_c0a)

! Get psi/chi/ua/va indices
do iv=1,bump%nam%nv
   if (bump%nam%variables(iv)==bump%nam%wind_streamfunction) iv_psi = iv
   if (bump%nam%variables(iv)==bump%nam%wind_velocity_potential) iv_chi = iv
   if (bump%nam%variables(iv)==bump%nam%wind_zonal) iv_ua = iv
   if (bump%nam%variables(iv)==bump%nam%wind_meridional) iv_va = iv
end do

! Transform psi/chi to u/v
call bump%wind%psichi_to_uv(bump%mpl,bump%geom,fld_c0a(:,:,iv_psi),fld_c0a(:,:,iv_chi), &
 & fld_c0a(:,:,iv_ua),fld_c0a(:,:,iv_va))

! Fortran array on subset Sc0 to fieldset
call bump%geom%c0_to_fieldset(bump%mpl,bump%nam,fld_c0a,fieldset)

! Probe out
@:probe_out()

end subroutine bump_psichi_to_uv

!----------------------------------------------------------------------
! Subroutine: bump_psichi_to_uv_ad
!> psi/chi to u/v transform, adjoint
!----------------------------------------------------------------------
subroutine bump_psichi_to_uv_ad(bump,fieldset)

implicit none

! Passed variables
class(bump_type),intent(inout) :: bump        !< BUMP
type(fieldset_type),intent(inout) :: fieldset !< Fieldset

! Local variable
integer :: iv,iv_psi,iv_chi,iv_ua,iv_va
real(kind_real) :: fld_c0a(bump%geom%nc0a,bump%geom%nl0,bump%nam%nv)
type(atlas_field) :: afield

! Set name
@:set_name(bump_psichi_to_uv_ad)

! Get instance
@:get_instance(bump)

! Probe in
@:probe_in()

! Add u/v variables in fieldset
afield = bump%geom%afunctionspace_mg%create_field(name=bump%nam%wind_streamfunction,kind=atlas_real(kind_real), &
 & levels=bump%geom%nl0)
call fieldset%add(afield)
afield = bump%geom%afunctionspace_mg%create_field(name=bump%nam%wind_velocity_potential,kind=atlas_real(kind_real), &
 & levels=bump%geom%nl0)
call fieldset%add(afield)

! Set fieldsets metadata
call fieldset%set_metadata(bump%mpl,bump%geom%gmask_mga,bump%nam%variables(1:bump%nam%nv),bump%nam%lev2d)

! Fieldset to Fortran on subset Sc0
call bump%geom%fieldset_to_c0(bump%mpl,bump%nam,fieldset,fld_c0a)

! Get psi/chi/ua/va indices
do iv=1,bump%nam%nv
   if (bump%nam%variables(iv)==bump%nam%wind_zonal) iv_ua = iv
   if (bump%nam%variables(iv)==bump%nam%wind_meridional) iv_va = iv
   if (bump%nam%variables(iv)==bump%nam%wind_streamfunction) iv_psi = iv
   if (bump%nam%variables(iv)==bump%nam%wind_velocity_potential) iv_chi = iv
end do

! Transform psi/chi to u/v adjoint
call bump%wind%psichi_to_uv_ad(bump%mpl,bump%geom,fld_c0a(:,:,iv_ua),fld_c0a(:,:,iv_va), &
 & fld_c0a(:,:,iv_psi),fld_c0a(:,:,iv_chi))

! Fortran array on subset Sc0 to fieldset
call bump%geom%c0_to_fieldset(bump%mpl,bump%nam,fld_c0a,fieldset)

! Probe out
@:probe_out()

end subroutine bump_psichi_to_uv_ad

!----------------------------------------------------------------------
! Subroutine: bump_get_parameter
!> Get a parameter
!----------------------------------------------------------------------
subroutine bump_get_parameter(bump,param,fieldset)

implicit none

! Passed variables
class(bump_type),intent(inout) :: bump        !< BUMP
character(len=*),intent(in) :: param          !< Parameter
type(fieldset_type),intent(inout) :: fieldset !< Fieldset

! Local variables
integer :: ib,iv,jv
real(kind_real) :: fld_mga(bump%geom%nmga,bump%geom%nl0,bump%nam%nv)

! Set name
@:set_name(bump_get_parameter)

! Get instance
@:get_instance(bump)

! Probe in
@:probe_in()

write(bump%mpl%info,'(a7,a,a)') '','Get ',trim(param)
call bump%mpl%flush

! Initialization
fld_mga = bump%mpl%msv%valr

! Get parameter
select case (trim(param))
case ('cor_rh','cor_pkh','cor_rv','cor_pkv','cor_nlv','loc_coef','loc_rh','loc_rv','hyb_coef','nicas_norm')
   select case (trim(bump%nam%strategy))
   case ('specific_univariate','specific_multivariate')
      do ib=1,bump%bpar%nb
         ! Get indices
         iv = bump%bpar%b_to_v1(ib)
         jv = bump%bpar%b_to_v2(ib)

         ! Copy to field
         if (iv==jv) call bump%copy_to_field(param,ib,fld_mga(:,:,iv))
      end do
   case ('common','common_weighted')
      ! Set common index
      ib = bump%bpar%nbe

      do iv=1,bump%nam%nv
         ! Copy to field
         call bump%copy_to_field(param,ib,fld_mga(:,:,iv))
      end do
   end select
case default
   do ib=1,bump%bpar%nb
      ! Get indices
      iv = bump%bpar%b_to_v1(ib)
      jv = bump%bpar%b_to_v2(ib)

      ! Copy to field
      if (iv==jv) call bump%copy_to_field(param,ib,fld_mga(:,:,iv))
   end do
end select

! Set fieldset metadata
call fieldset%set_metadata(bump%mpl,bump%geom%gmask_mga,bump%nam%variables(1:bump%nam%nv),bump%nam%lev2d)

! Fortran array to fieldset
call fieldset%from_array(bump%mpl,fld_mga)

! Probe out
@:probe_out()

end subroutine bump_get_parameter

!----------------------------------------------------------------------
! Subroutine: bump_copy_to_field
!> Copy to field
!----------------------------------------------------------------------
subroutine bump_copy_to_field(bump,param,ib,fld_mga)

implicit none

! Passed variables
class(bump_type),intent(inout) :: bump                               !< BUMP
character(len=*),intent(in) :: param                                 !< Parameter
integer,intent(in) :: ib                                             !< Block index
real(kind_real),intent(out) :: fld_mga(bump%geom%nmga,bump%geom%nl0) !< Field

! Local variables
integer :: iscales,ie,imga,il0,iv
real(kind_real) :: tmp
real(kind_real),allocatable :: real_array(:,:)
logical :: found

! Set name
@:set_name(bump_copy_to_field)

! Get instance
@:get_instance(bump)

! Probe in
@:probe_in()

! Initialization
found = .false.

! Select parameter from geom
select case (trim(param))
case ('lon')
   iv = bump%bpar%b_to_v1(ib)
   if (.not.allocated(bump%geom%lon_c0a)) call bump%mpl%abort('${subr}$',trim(param)//' is not allocated')
   allocate(real_array(bump%geom%nc0a,bump%geom%nl0))
   do il0=1,bump%geom%nl0
      real_array(:,il0) = bump%geom%lon_c0a
   end do
   call bump%geom%copy_c0a_to_mga(bump%mpl,real_array,fld_mga)
   do il0=1,bump%geom%nl0
      do imga=1,bump%geom%nmga
         if (bump%mpl%msv%isnot(fld_mga(imga,il0))) fld_mga(imga,il0) = fld_mga(imga,il0)*rad2deg
      end do
   end do
   deallocate(real_array)
   found = .true.
case ('lat')
   iv = bump%bpar%b_to_v1(ib)
   if (.not.allocated(bump%geom%lat_c0a)) call bump%mpl%abort('${subr}$',trim(param)//' is not allocated')
   allocate(real_array(bump%geom%nc0a,bump%geom%nl0))
   do il0=1,bump%geom%nl0
      real_array(:,il0) = bump%geom%lat_c0a
   end do
   call bump%geom%copy_c0a_to_mga(bump%mpl,real_array,fld_mga)
   do il0=1,bump%geom%nl0
      do imga=1,bump%geom%nmga
         if (bump%mpl%msv%isnot(fld_mga(imga,il0))) fld_mga(imga,il0) = fld_mga(imga,il0)*rad2deg
      end do
   end do
   deallocate(real_array)
   found = .true.
case ('area')
   iv = bump%bpar%b_to_v1(ib)
   if (.not.allocated(bump%geom%area_c0a)) call bump%mpl%abort('${subr}$',trim(param)//' is not allocated')
   allocate(real_array(bump%geom%nc0a,bump%geom%nl0))
   do il0=1,bump%geom%nl0
      real_array(:,il0) = bump%geom%area_c0a
   end do
   call bump%geom%copy_c0a_to_mga(bump%mpl,real_array,fld_mga)
   do il0=1,bump%geom%nl0
      do imga=1,bump%geom%nmga
         if (bump%mpl%msv%isnot(fld_mga(imga,il0))) fld_mga(imga,il0) = fld_mga(imga,il0)*req**2
      end do
   end do
   deallocate(real_array)
   found = .true.
case ('vunit')
   iv = bump%bpar%b_to_v1(ib)
   if (.not.allocated(bump%geom%vunit_c0a)) call bump%mpl%abort('${subr}$',trim(param)//' is not allocated')
   call bump%geom%copy_c0a_to_mga(bump%mpl,bump%geom%vunit_c0a,fld_mga)
   found = .true.
end select

! Select parameter from var
select case (trim(param))
case ('stddev')
   iv = bump%bpar%b_to_v1(ib)
   if (.not.allocated(bump%var%m2sqrt)) call bump%mpl%abort('${subr}$',trim(param)//' is not allocated')
   call bump%geom%copy_c0a_to_mga(bump%mpl,bump%var%m2sqrt(:,:,iv),fld_mga)
   found = .true.
case ('var')
   iv = bump%bpar%b_to_v1(ib)
   if (.not.allocated(bump%var%m2)) call bump%mpl%abort('${subr}$',trim(param)//' is not allocated')
   call bump%geom%copy_c0a_to_mga(bump%mpl,bump%var%m2(:,:,iv),fld_mga)
   found = .true.
case ('m4')
   iv = bump%bpar%b_to_v1(ib)
   if (.not.allocated(bump%var%m4)) call bump%mpl%abort('${subr}$',trim(param)//' is not allocated')
   call bump%geom%copy_c0a_to_mga(bump%mpl,bump%var%m4(:,:,iv),fld_mga)
   found = .true.
end select

! Select parameter from cmat
select case (trim(param))
case ('cor_rh')
   if (.not.allocated(bump%cmat%blk(ib)%rh)) call bump%mpl%abort('${subr}$',trim(param)//' is not allocated')
   call bump%geom%copy_c0a_to_mga(bump%mpl,bump%cmat%blk(ib)%rh,fld_mga)
   do il0=1,bump%geom%nl0
      do imga=1,bump%geom%nmga
         if (bump%mpl%msv%isnot(fld_mga(imga,il0))) fld_mga(imga,il0) = fld_mga(imga,il0)*req
      end do
   end do
   found = .true.
case ('cor_pkh')
   if (.not.allocated(bump%cmat%blk(ib)%pkh)) call bump%mpl%abort('${subr}$',trim(param)//' is not allocated')
   call bump%geom%copy_c0a_to_mga(bump%mpl,bump%cmat%blk(ib)%pkh,fld_mga)
   found = .true.
case ('cor_rv')
   if (.not.allocated(bump%cmat%blk(ib)%rv)) call bump%mpl%abort('${subr}$',trim(param)//' is not allocated')
   call bump%geom%copy_c0a_to_mga(bump%mpl,bump%cmat%blk(ib)%rv,fld_mga)
   found = .true.
case ('cor_pkv')
   if (.not.allocated(bump%cmat%blk(ib)%pkv)) call bump%mpl%abort('${subr}$',trim(param)//' is not allocated')
   call bump%geom%copy_c0a_to_mga(bump%mpl,bump%cmat%blk(ib)%pkv,fld_mga)
   found = .true.
case ('cor_nlv')
   if (.not.allocated(bump%cmat%blk(ib)%nlv)) call bump%mpl%abort('${subr}$',trim(param)//' is not allocated')
   call bump%geom%copy_c0a_to_mga(bump%mpl,bump%cmat%blk(ib)%nlv,fld_mga)
   found = .true.
case ('loc_coef')
   if (.not.allocated(bump%cmat%blk(ib)%coef_ens)) call bump%mpl%abort('${subr}$', &
 & trim(param)//' is not allocated')
   call bump%geom%copy_c0a_to_mga(bump%mpl,bump%cmat%blk(ib)%coef_ens,fld_mga)
   found = .true.
case ('loc_rh')
   if (.not.allocated(bump%cmat%blk(ib)%rh)) call bump%mpl%abort('${subr}$',trim(param)//' is not allocated')
   call bump%geom%copy_c0a_to_mga(bump%mpl,bump%cmat%blk(ib)%rh,fld_mga)
   do il0=1,bump%geom%nl0
      do imga=1,bump%geom%nmga
         if (bump%mpl%msv%isnot(fld_mga(imga,il0))) fld_mga(imga,il0) = fld_mga(imga,il0)*req
      end do
   end do
   found = .true.
case ('loc_rv')
   if (.not.allocated(bump%cmat%blk(ib)%rv)) call bump%mpl%abort('${subr}$',trim(param)//' is not allocated')
   call bump%geom%copy_c0a_to_mga(bump%mpl,bump%cmat%blk(ib)%rv,fld_mga)
   found = .true.
case ('hyb_coef')
   if (.not.allocated(bump%cmat%blk(ib)%coef_sta)) call bump%mpl%abort('${subr}$', &
 & trim(param)//' is not allocated')
   call bump%geom%copy_c0a_to_mga(bump%mpl,bump%cmat%blk(ib)%coef_sta,fld_mga)
   found = .true.
end select

! Select parameter from ens1u
if (param(1:min(6,len(param)))=='ens1u_') then
   read(param(7:12),'(i6.6)') ie
   if (ie>size(bump%ens1u%mem)) call bump%mpl%abort('${subr}$',trim(param)//' has fewer members')
   iv = bump%bpar%b_to_v1(ib)
   call bump%ens1u%mem(ie)%to_array(bump%mpl,iv,fld_mga)
   found = .true.
end if

! Select parameter from nicas
select case (trim(param))
case ('nicas_norm')
   if (.not.allocated(bump%nicas%blk(ib)%norm)) call bump%mpl%abort('${subr}$',trim(param)//' is not allocated')
   call bump%geom%copy_c0a_to_mga(bump%mpl,bump%nicas%blk(ib)%norm,fld_mga)
   found = .true.
end select

! Check that parameters was found
if (.not.found) call bump%mpl%abort('${subr}$','parameter '//trim(param)//' not found')

! Probe out
@:probe_out()

end subroutine bump_copy_to_field

!----------------------------------------------------------------------
! Subroutine: bump_test_get_parameter
!> Test get_parameter
!----------------------------------------------------------------------
subroutine bump_test_get_parameter(bump)

implicit none

! Passed variables
class(bump_type),intent(inout) :: bump !< BUMP

! Local variables
type(fieldset_type) :: fieldset

! Set name
@:set_name(bump_test_get_parameter)

! Get instance
@:get_instance(bump)

! Probe in
@:probe_in()

! Create fieldset
call fieldset%init(bump%mpl,bump%geom%afunctionspace_mg,bump%geom%gmask_mga,bump%nam%variables(1:bump%nam%nv),bump%nam%lev2d)

! Get parameter
if (bump%nam%check_get_param_stddev) then
   call bump%get_parameter('stddev',fieldset)
   call bump%get_parameter('m2',fieldset)
   call bump%get_parameter('m4',fieldset)
elseif (bump%nam%check_get_param_cor) then
   call bump%get_parameter('cor_rh',fieldset)
   call bump%get_parameter('cor_rv',fieldset)
elseif (bump%nam%check_get_param_hyb) then
   call bump%get_parameter('loc_coef',fieldset)
   call bump%get_parameter('loc_rh',fieldset)
   call bump%get_parameter('loc_rv',fieldset)
   call bump%get_parameter('hyb_coef',fieldset)
end if

! Release memory
call fieldset%final()

! Probe out
@:probe_out()

end subroutine bump_test_get_parameter

!----------------------------------------------------------------------
! Subroutine: bump_set_parameter
!> Set a parameter
!----------------------------------------------------------------------
subroutine bump_set_parameter(bump,param,fieldset)

implicit none

! Passed variables
class(bump_type),intent(inout) :: bump        !< BUMP
character(len=*),intent(in) :: param          !< Parameter
type(fieldset_type),intent(inout) :: fieldset !< Fieldset

! Local variables
integer :: ib,iv,jv
real(kind_real) :: fld_mga(bump%geom%nmga,bump%geom%nl0,bump%nam%nv)

! Set name
@:set_name(bump_set_parameter)

! Get instance
@:get_instance(bump)

! Probe in
@:probe_in()

! Set fieldset metadata
call fieldset%set_metadata(bump%mpl,bump%geom%gmask_mga,bump%nam%variables(1:bump%nam%nv),bump%nam%lev2d)

! Fieldset to Fortran array
call fieldset%to_array(bump%mpl,fld_mga)

write(bump%mpl%info,'(a7,a,a)') '','Set ',trim(param)
call bump%mpl%flush

! Counter
select case (trim(param))
case ('var')
   bump%var%bump_m2_counter = bump%var%bump_m2_counter+1
case ('m4')
   bump%var%bump_m4_counter = bump%var%bump_m4_counter+1
end select

! Fields
select case (trim(param))
case ('cor_rh','cor_rv','loc_coef','loc_rh','loc_rv','hyb_coef','nicas_norm')
   select case (trim(bump%nam%strategy))
   case ('specific_univariate','specific_multivariate')
      do ib=1,bump%bpar%nb
         ! Get indices
         iv = bump%bpar%b_to_v1(ib)
         jv = bump%bpar%b_to_v2(ib)

         ! Copy to field
         if (iv==jv) call bump%copy_from_field(param,ib,fld_mga(:,:,iv))
      end do
   case ('common','common_weighted')
      ! Set common index
      ib = bump%bpar%nbe

      do iv=1,bump%nam%nv
         ! Copy to field
         call bump%copy_from_field(param,ib,fld_mga(:,:,iv))
      end do
   end select
case default
   do ib=1,bump%bpar%nb
      ! Get indices
      iv = bump%bpar%b_to_v1(ib)
      jv = bump%bpar%b_to_v2(ib)

      ! Copy to field
      if (iv==jv) call bump%copy_from_field(param,ib,fld_mga(:,:,iv))
   end do
end select

! Probe out
@:probe_out()

end subroutine bump_set_parameter

!----------------------------------------------------------------------
! Subroutine: bump_set_parameter_deprecated_atlas
!> Set a parameter (deprecated)
!----------------------------------------------------------------------
subroutine bump_set_parameter_deprecated_atlas(bump,param,afieldset)

implicit none

! Passed variables
class(bump_type),intent(inout) :: bump         !< BUMP
character(len=*),intent(in) :: param            !< Parameter
type(atlas_fieldset),intent(inout) :: afieldset !< ATLAS fieldset

! Local variables
type(fieldset_type) :: fieldset

! Set name
@:set_name(bump_set_parameter_deprecated_atlas)

! Get instance
@:get_instance(bump)

! Probe in
@:probe_in()

! ATLAS fieldset to fieldset
fieldset = atlas_fieldset(afieldset%c_ptr())

! Call fieldset interface
call bump%set_parameter(param,fieldset)

! Probe out
@:probe_out()

end subroutine bump_set_parameter_deprecated_atlas

!----------------------------------------------------------------------
! Subroutine: bump_copy_from_field
!> Copy from field
!----------------------------------------------------------------------
subroutine bump_copy_from_field(bump,param,ib,fld_mga)

implicit none

! Passed variables
class(bump_type),intent(inout) :: bump                              !< BUMP
character(len=*),intent(in) :: param                                !< Parameter
integer,intent(in) :: ib                                            !< Block index
real(kind_real),intent(in) :: fld_mga(bump%geom%nmga,bump%geom%nl0) !< Field

! Local variables
integer :: ic0a,il0,iv
real(kind_real) :: fld_c0a(bump%geom%nc0a,bump%geom%nl0)
logical :: found

! Set name
@:set_name(bump_copy_from_field)

! Get instance
@:get_instance(bump)

! Probe in
@:probe_in()

! Initialization
found = .false.

! Check allocation / parameter existence
select case (trim(param))
case ('stddev','var','m4')
case ('cor_rh','cor_pkh','cor_rv','cor_pkv','cor_nlv','loc_coef','loc_rh','loc_rv','hyb_coef')
   if (.not.allocated(bump%cmat%blk)) allocate(bump%cmat%blk(bump%bpar%nbe))
case ('nicas_norm')
   if (.not.allocated(bump%nicas%blk)) allocate(bump%nicas%blk(bump%bpar%nbe))
case default
   call bump%mpl%abort('${subr}$','parameter '//trim(param)//' not yet implemented')
end select

! Select parameter from var
select case (trim(param))
case ('stddev')
   if (.not.allocated(bump%var%m2sqrt)) allocate(bump%var%m2sqrt(bump%geom%nc0a,bump%geom%nl0,bump%nam%nv))
   iv = bump%bpar%b_to_v1(ib)
   call bump%geom%copy_mga_to_c0a(bump%mpl,fld_mga,bump%var%m2sqrt(:,:,iv))
   found = .true.
case ('var')
   if (.not.allocated(bump%var%bump_m2)) then
      allocate(bump%var%bump_m2(bump%geom%nc0a,bump%geom%nl0,bump%nam%nv))
      bump%var%bump_m2 = zero
   end if
   iv = bump%bpar%b_to_v1(ib)
   call bump%geom%copy_mga_to_c0a(bump%mpl,fld_mga,fld_c0a)
   bump%var%bump_m2(:,:,iv) = bump%var%bump_m2(:,:,iv)+fld_c0a
   found = .true.
case ('m4')
   if (.not.allocated(bump%var%bump_m4)) then
      allocate(bump%var%bump_m4(bump%geom%nc0a,bump%geom%nl0,bump%nam%nv))
      bump%var%bump_m4 = zero
   end if
   iv = bump%bpar%b_to_v1(ib)
   call bump%geom%copy_mga_to_c0a(bump%mpl,fld_mga,fld_c0a)
   bump%var%bump_m4(:,:,iv) = bump%var%bump_m4(:,:,iv)+fld_c0a
   found = .true.
end select

! Select parameter from cmat
select case (trim(param))
case ('cor_rh')
   if (.not.allocated(bump%cmat%blk(ib)%bump_rh)) allocate(bump%cmat%blk(ib)%bump_rh(bump%geom%nc0a,bump%geom%nl0))
   call bump%geom%copy_mga_to_c0a(bump%mpl,fld_mga,bump%cmat%blk(ib)%bump_rh)
   do il0=1,bump%geom%nl0
      do ic0a=1,bump%geom%nc0a
         if (bump%mpl%msv%isnot(bump%cmat%blk(ib)%bump_rh(ic0a,il0))) &
 & bump%cmat%blk(ib)%bump_rh(ic0a,il0) = bump%cmat%blk(ib)%bump_rh(ic0a,il0)/req
      end do
   end do
   found = .true.
case ('cor_pkh')
   if (.not.allocated(bump%cmat%blk(ib)%bump_pkh)) allocate(bump%cmat%blk(ib)%bump_pkh(bump%geom%nc0a,bump%geom%nl0))
   call bump%geom%copy_mga_to_c0a(bump%mpl,fld_mga,bump%cmat%blk(ib)%bump_pkh)
   found = .true.
case ('cor_rv')
   if (.not.allocated(bump%cmat%blk(ib)%bump_rv)) allocate(bump%cmat%blk(ib)%bump_rv(bump%geom%nc0a,bump%geom%nl0))
   call bump%geom%copy_mga_to_c0a(bump%mpl,fld_mga,bump%cmat%blk(ib)%bump_rv)
   found = .true.
case ('cor_pkv')
   if (.not.allocated(bump%cmat%blk(ib)%bump_pkv)) allocate(bump%cmat%blk(ib)%bump_pkv(bump%geom%nc0a,bump%geom%nl0))
   call bump%geom%copy_mga_to_c0a(bump%mpl,fld_mga,bump%cmat%blk(ib)%bump_pkv)
   found = .true.
case ('cor_nlv')
   if (.not.allocated(bump%cmat%blk(ib)%bump_nlv)) allocate(bump%cmat%blk(ib)%bump_nlv(bump%geom%nc0a,bump%geom%nl0))
   call bump%geom%copy_mga_to_c0a(bump%mpl,fld_mga,bump%cmat%blk(ib)%bump_nlv)
   found = .true.
case ('loc_coef')
   if (.not.allocated(bump%cmat%blk(ib)%bump_coef_ens)) allocate(bump%cmat%blk(ib)%bump_coef_ens(bump%geom%nc0a,bump%geom%nl0))
   call bump%geom%copy_mga_to_c0a(bump%mpl,fld_mga,bump%cmat%blk(ib)%bump_coef_ens)
   found = .true.
case ('loc_rh')
   if (.not.allocated(bump%cmat%blk(ib)%bump_rh)) allocate(bump%cmat%blk(ib)%bump_rh(bump%geom%nc0a,bump%geom%nl0))
   call bump%geom%copy_mga_to_c0a(bump%mpl,fld_mga,bump%cmat%blk(ib)%bump_rh)
   do il0=1,bump%geom%nl0
      do ic0a=1,bump%geom%nc0a
         if (bump%mpl%msv%isnot(bump%cmat%blk(ib)%bump_rh(ic0a,il0))) &
 & bump%cmat%blk(ib)%bump_rh(ic0a,il0) = bump%cmat%blk(ib)%bump_rh(ic0a,il0)/req
      end do
   end do
   found = .true.
case ('loc_rv')
   if (.not.allocated(bump%cmat%blk(ib)%bump_rv)) allocate(bump%cmat%blk(ib)%bump_rv(bump%geom%nc0a,bump%geom%nl0))
   call bump%geom%copy_mga_to_c0a(bump%mpl,fld_mga,bump%cmat%blk(ib)%bump_rv)
   found = .true.
case ('hyb_coef')
   if (.not.allocated(bump%cmat%blk(ib)%bump_coef_sta)) allocate(bump%cmat%blk(ib)%bump_coef_sta(bump%geom%nc0a,bump%geom%nl0))
   call bump%geom%copy_mga_to_c0a(bump%mpl,fld_mga,bump%cmat%blk(ib)%bump_coef_sta)
   found = .true.
end select

! Select parameter from nicas
select case (trim(param))
case ('nicas_norm')
   if (.not.allocated(bump%nicas%blk(ib)%norm)) allocate(bump%nicas%blk(ib)%norm(bump%geom%nc0a,bump%geom%nl0))
   call bump%geom%copy_mga_to_c0a(bump%mpl,fld_mga,bump%nicas%blk(ib)%norm)
   found = .true.
end select

! Check that parameters was found
if (.not.found) call bump%mpl%abort('${subr}$','parameter '//trim(param)//' not found')

! Probe out
@:probe_out()

end subroutine bump_copy_from_field

!----------------------------------------------------------------------
! Subroutine: bump_test_set_parameter
!> Test set_parameter
!----------------------------------------------------------------------
subroutine bump_test_set_parameter(bump)

implicit none

! Passed variables
class(bump_type),intent(inout) :: bump !< BUMP

! Local variables
integer :: ic0a,il0,iv
real(kind_real) :: fld_min,fld_max
real(kind_real) :: fld_c0a(bump%geom%nc0a,bump%geom%nl0,bump%nam%nv)
type(fieldset_type) :: fieldset,fieldset_req,fieldset_reqsq,fieldset_vert,fieldset_vertsq

! Set name
@:set_name(bump_test_set_parameter)

! Get instance
@:get_instance(bump)

! Probe in
@:probe_in()

! Initialization
do iv=1,bump%nam%nv
   do il0=1,bump%geom%nl0
      do ic0a=1,bump%geom%nc0a
         fld_c0a(ic0a,il0,iv) = abs(real(fletcher32((/bump%geom%lon_c0a(ic0a),bump%geom%lat_c0a(ic0a),real(iv,kind_real), &
 & real(il0,kind_real)/)),kind_real))
      end do
   end do
end do
call bump%mpl%f_comm%allreduce(zss_minval(fld_c0a),fld_min,fckit_mpi_min())
call bump%mpl%f_comm%allreduce(zss_maxval(fld_c0a),fld_max,fckit_mpi_max())
fld_c0a = fld_c0a/abs(fld_max-fld_min)

! Create fieldset
call fieldset%init(bump%mpl,bump%geom%afunctionspace_mg,bump%geom%gmask_mga,bump%nam%variables(1:bump%nam%nv),bump%nam%lev2d)
call fieldset_req%init(bump%mpl,bump%geom%afunctionspace_mg,bump%geom%gmask_mga,bump%nam%variables(1:bump%nam%nv),bump%nam%lev2d)
call fieldset_reqsq%init(bump%mpl,bump%geom%afunctionspace_mg,bump%geom%gmask_mga,bump%nam%variables(1:bump%nam%nv),bump%nam%lev2d)
call fieldset_vert%init(bump%mpl,bump%geom%afunctionspace_mg,bump%geom%gmask_mga,bump%nam%variables(1:bump%nam%nv),bump%nam%lev2d)
call fieldset_vertsq%init(bump%mpl,bump%geom%afunctionspace_mg,bump%geom%gmask_mga,bump%nam%variables(1:bump%nam%nv),bump%nam%lev2d)

! Fortran array on subset Sc0 to fieldset
call bump%geom%c0_to_fieldset(bump%mpl,bump%nam,fld_c0a,fieldset)
call bump%geom%c0_to_fieldset(bump%mpl,bump%nam,fld_c0a*req,fieldset_req)
call bump%geom%c0_to_fieldset(bump%mpl,bump%nam,fld_c0a*req**2,fieldset_reqsq)
call bump%geom%c0_to_fieldset(bump%mpl,bump%nam,(one+fld_c0a)*(maxval(bump%geom%vunitavg)-minval(bump%geom%vunitavg)),fieldset_vert)
call bump%geom%c0_to_fieldset(bump%mpl,bump%nam,((one+fld_c0a)*(maxval(bump%geom%vunitavg)-minval(bump%geom%vunitavg)))**2, &
 & fieldset_vertsq)

! Set parameter
if (bump%nam%check_set_param_cor) then
   call bump%set_parameter('cor_rh',fieldset_req)
   call bump%set_parameter('cor_rv',fieldset_vert)
elseif (bump%nam%check_set_param_hyb) then
   call bump%set_parameter('loc_coef',fieldset)
   call bump%set_parameter('loc_rh',fieldset_req)
   call bump%set_parameter('loc_rv',fieldset_vert)
   call bump%set_parameter('hyb_coef',fieldset)
end if

! Release memory
call fieldset%final()
call fieldset_req%final()
call fieldset_reqsq%final()
call fieldset_vert%final()
call fieldset_vertsq%final()

! Probe out
@:probe_out()

end subroutine bump_test_set_parameter

!----------------------------------------------------------------------
! Subroutine: bump_test_apply_interfaces
!> Test BUMP apply interfaces
!----------------------------------------------------------------------
subroutine bump_test_apply_interfaces(bump)

implicit none

! Passed variables
class(bump_type),intent(inout) :: bump !< BUMP

! Local variables
integer :: n
real(kind_real),allocatable :: fld_c0a(:,:,:),pcv(:)
type(fieldset_type) :: fieldset

! Set name
@:set_name(bump_test_apply_interfaces)

! Get instance
@:get_instance(bump)

! Probe in
@:probe_in()

! Test apply_vbal
if (bump%nam%check_apply_vbal) then
   write(bump%mpl%info,'(a7,a)') '','Test apply_vbal'
   call bump%mpl%flush

   ! Allocation
   allocate(fld_c0a(bump%geom%nc0a,bump%geom%nl0,bump%nam%nv))

   ! Initialization
   call bump%rng%rand(zero,one,fld_c0a)

   ! Create fieldset
   call fieldset%init(bump%mpl,bump%geom%afunctionspace_mg,bump%geom%gmask_mga,bump%nam%variables(1:bump%nam%nv),bump%nam%lev2d)

   ! Fortran array on subset Sc0 to fieldset
   call bump%geom%c0_to_fieldset(bump%mpl,bump%nam,fld_c0a,fieldset)

   ! Calls
   call bump%apply_vbal(fieldset)
   call bump%apply_vbal_inv(fieldset)
   call bump%apply_vbal_ad(fieldset)
   call bump%apply_vbal_inv_ad(fieldset)

   ! Release memory
   deallocate(fld_c0a)
   call fieldset%final()
end if

! Test apply_stddev
if (bump%nam%check_apply_stddev) then
   write(bump%mpl%info,'(a7,a)') '','Test apply_stddev'
   call bump%mpl%flush

   ! Allocation
   allocate(fld_c0a(bump%geom%nc0a,bump%geom%nl0,bump%nam%nv))

   ! Initialization
   call bump%rng%rand(zero,one,fld_c0a)

   ! Create fieldset
   call fieldset%init(bump%mpl,bump%geom%afunctionspace_mg,bump%geom%gmask_mga,bump%nam%variables(1:bump%nam%nv),bump%nam%lev2d)

   ! Fortran array on subset Sc0 to fieldset
   call bump%geom%c0_to_fieldset(bump%mpl,bump%nam,fld_c0a,fieldset)

   ! Calls
   call bump%apply_stddev(fieldset)
   call bump%apply_stddev_inv(fieldset)

   ! Release memory
   deallocate(fld_c0a)
   call fieldset%final()
end if

! Test apply_nicas
if (bump%nam%check_apply_nicas) then
   write(bump%mpl%info,'(a7,a)') '','Test apply_nicas'
   call bump%mpl%flush

   ! Get control variable size
   call bump%get_cv_size(n)

   ! Allocation
   allocate(fld_c0a(bump%geom%nc0a,bump%geom%nl0,bump%nam%nv))
   allocate(pcv(n))

   ! Initialization
   call bump%rng%rand(zero,one,fld_c0a)

   ! Create fieldset
   call fieldset%init(bump%mpl,bump%geom%afunctionspace_mg,bump%geom%gmask_mga,bump%nam%variables(1:bump%nam%nv),bump%nam%lev2d)

   ! Fortran array on subset Sc0 to fieldset
   call bump%geom%c0_to_fieldset(bump%mpl,bump%nam,fld_c0a,fieldset)

   ! Calls
   call bump%apply_nicas(fieldset)
   call bump%apply_nicas_sqrt(pcv,fieldset)
   call bump%apply_nicas_sqrt_ad(fieldset,pcv)
   call bump%randomize(fieldset)

   ! Release memory
   deallocate(fld_c0a)
   deallocate(pcv)
   call fieldset%final()
end if

! Probe out
@:probe_out()

end subroutine bump_test_apply_interfaces

!----------------------------------------------------------------------
! Subroutine: bump_partial_dealloc
!> Release memory (partial)
!----------------------------------------------------------------------
subroutine bump_partial_dealloc(bump)

implicit none

! Passed variables
class(bump_type),intent(inout) :: bump !< BUMP

! Set name
@:set_name(bump_partial_dealloc)

! Get instance
@:get_instance(bump)

! Probe in
@:probe_in()

! Release memory
call fit_dealloc
call bump%cmat%partial_dealloc
call bump%ens1%dealloc
call bump%ens1u%dealloc
call bump%ens2%dealloc
call bump%geom%partial_dealloc
call bump%hdiag%dealloc
call bump%mom1%dealloc
call bump%mom2%dealloc
call bump%nicas%partial_dealloc
call bump%samp%dealloc
call bump%var%partial_dealloc
call bump%vbal%partial_dealloc

! Probe out
@:probe_out()

end subroutine bump_partial_dealloc

!----------------------------------------------------------------------
! Subroutine: bump_dealloc
!> Release memory (full)
!----------------------------------------------------------------------
subroutine bump_dealloc(bump)

implicit none

! Passed variables
class(bump_type),intent(inout) :: bump !< BUMP

! Set name
@:set_name(bump_dealloc)

! Get instance
@:get_instance(bump)

! Execution stats
@:execution_stats()

! Number of open NetCDF files
write(bump%mpl%info,'(a)') '-------------------------------------------------------------------'
call bump%mpl%flush
write(bump%mpl%info,'(a)') '--- NetCDF I/O report'
call bump%mpl%flush
call registry%report(bump%mpl)

! Release memory
call bump%bpar%dealloc
call bump%cmat%dealloc
call bump%ens1%dealloc
call bump%ens1u%dealloc
call bump%ens2%dealloc
call bump%geom%dealloc
call bump%hdiag%dealloc
call bump%mom1%dealloc
call bump%mom2%dealloc
call bump%nicas%dealloc
call bump%samp%dealloc
call bump%var%dealloc
call bump%vbal%dealloc

! Execution stats
@:execution_stats()

! Release probe instance
@:probe_dealloc()

end subroutine bump_dealloc

!----------------------------------------------------------------------
! Subroutine: bump_dummy_final
!> Dummy finalization
!----------------------------------------------------------------------
subroutine bump_dummy_final(bump)

implicit none

! Passed variables
type(bump_type),intent(inout) :: bump !< BUMP

! Set name
@:set_name(bump_dummy_final)

! Get instance
@:get_instance(bump)

! Probe in
@:probe_in()

! Dummy action to avoid compiler warning
bump%dummy_logical = .false.

! Probe out
@:probe_out()

end subroutine bump_dummy_final

end module type_bump
