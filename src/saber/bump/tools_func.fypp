#:include '../instrumentation.fypp'
#:include '../generics.fypp'
!----------------------------------------------------------------------
! Module: tools_func
!> Usual functions
! Author: Benjamin Menetrier
! Licensing: this code is distributed under the CeCILL-C license
! Copyright 2015-... UCAR, CERFACS, METEO-FRANCE and IRIT
!----------------------------------------------------------------------
module tools_func

use atlas_module, only: atlas_geometry
use iso_c_binding
use tools_asa007, only: cholesky,syminv
use tools_const, only: zero,hundredth,tenth,half,quarter,one,two,three,four,five,eight,ten,thousand,pi,deg2rad,rad2deg
use tools_gc99, only: fit_func,fit_func_sqrt
use tools_kinds, only: kind_short,kind_int,kind_real,huge_int,huge_real
use tools_qsort, only: qsort
use tools_repro, only: rth,inf,sup,infeq,small,eq
use tools_wrfda, only: da_eof_decomposition
use type_mpl, only: mpl_type
@:use_probe()

implicit none

real(kind_real),parameter :: gc2gau = 0.28_kind_real  !< GC99 support radius to Gaussian Daley length-scale (empirical)
real(kind_real),parameter :: gau2gc = one/gc2gau      !< Gaussian Daley length-scale to GC99 support radius (empirical)
real(kind_real),parameter :: Dmin = 1.0e-12_kind_real !< Minimum tensor diagonal value
real(kind_real),parameter :: condmax = thousand       !< Maximum tensor conditioning number
integer,parameter :: M = 0                            !< Number of implicit iteration for the Matern function (-1: GC99, 0: Gaussian, >0: Matern)

interface
   function c_fletcher32(n,var) bind(c,name='fletcher32') result(hash)
   use iso_c_binding, only: c_int16_t,c_int32_t
   integer(c_int32_t) :: n
   integer(c_int16_t) :: var(*)
   integer(c_int32_t) :: hash
   end function c_fletcher32
end interface
interface fletcher32
   module procedure func_fletcher32
end interface
interface lonlatmod
   module procedure func_lonlatmod
end interface
interface gridhash
   module procedure func_gridhash
end interface
interface independent_levels
   module procedure func_independent_levels
end interface
interface sphere_dist
   module procedure func_sphere_dist
end interface
interface cart_dist
   module procedure func_cart_dist
end interface
interface lonlat2xyz
   module procedure func_lonlat2xyz
end interface
interface xyz2lonlat
   module procedure func_xyz2lonlat
end interface
interface vector_product
   module procedure func_vector_product
end interface
interface det
   module procedure func_det
end interface
interface inside
   module procedure func_inside
end interface
interface order_cc
   module procedure func_order_cc
end interface
interface add
   module procedure func_add
end interface
interface divide
   module procedure func_divide
end interface
interface vert_interp_size
   module procedure func_vert_interp_size
end interface
interface vert_interp_setup
   module procedure func_vert_interp_setup
end interface
interface vert_interp
   module procedure func_vert_interp
end interface
interface fit_diag_sqrt
   module procedure func_fit_diag_sqrt
end interface
interface fit_diag
   module procedure func_fit_diag
end interface
interface fit_diag_full
   module procedure func_fit_diag_full
end interface
interface fit_lct
   module procedure func_fit_lct
end interface
interface lct_d2h
   module procedure func_lct_d2h
end interface
interface lct_h2r
   module procedure func_lct_h2r
end interface
interface lct_r2d
   module procedure func_lct_r2d
end interface
interface check_cond
   module procedure func_check_cond
end interface
interface matern
   module procedure func_matern
end interface
interface cholesky
   module procedure func_cholesky
end interface
interface syminv
   module procedure func_syminv
end interface
interface histogram
   module procedure func_histogram
end interface
interface cx_to_cxa
   module procedure func_cx_to_cxa
end interface
interface cx_to_proc
   module procedure func_cx_to_proc
end interface
interface cx_to_cxu
   module procedure func_cx_to_cxu
end interface
interface convert_i2l
   module procedure func_convert_i2l_r0
#:for rank in ranks_1234
   module procedure func_convert_i2l_r${rank}$
#:endfor
end interface
interface convert_l2i
   module procedure func_convert_l2i_r0
#:for rank in ranks_1234
   module procedure func_convert_l2i_r${rank}$
#:endfor
end interface
interface zss_maxval
   #:for dtype in dtypes_ir
      #:for rank in ranks_123456
         module procedure func_zss_maxval_${dtype}$_r${rank}$
      #:endfor
   #:endfor
end interface
interface zss_minval
   #:for dtype in dtypes_ir
      #:for rank in ranks_123456
         module procedure func_zss_minval_${dtype}$_r${rank}$
      #:endfor
   #:endfor
end interface
interface zss_sum
   #:for dtype in dtypes_ir
      #:for rank in ranks_123456
         module procedure func_zss_sum_${dtype}$_r${rank}$
      #:endfor
   #:endfor
end interface
interface zss_count
   #:for rank in ranks_123456
      module procedure func_zss_count_r${rank}$
   #:endfor
end interface

private
public :: gc2gau,gau2gc,Dmin,M
public :: fletcher32,lonlatmod,gridhash,independent_levels,sphere_dist,cart_dist,lonlat2xyz,xyz2lonlat,vector_product,det, &
 & inside,order_cc,add,divide,vert_interp_size,vert_interp_setup,vert_interp,fit_diag_sqrt,fit_diag,fit_diag_full,fit_lct, &
 & lct_d2h,lct_h2r,lct_r2d,check_cond,cholesky,syminv,histogram,cx_to_cxa,cx_to_proc,cx_to_cxu,convert_i2l, &
 & convert_l2i,zss_maxval,zss_minval,zss_sum,zss_count

contains

!----------------------------------------------------------------------
! Function: func_fletcher32
!> Fletcher-32 checksum algorithm
!----------------------------------------------------------------------
function func_fletcher32(var) result(value)

implicit none

! Passed variables
real(kind_real),intent(in) :: var(:) !< Variable

! Returned variable
integer :: value

! Local values
integer(c_int32_t) :: array_size
integer(c_int16_t),allocatable :: array(:)

! Set name
@:set_name(func_fletcher32)

! Probe in
@:probe_in()

! Allocation
allocate(array(size(var)))

! Initialization
array = transfer(var,(/0_kind_short/))
array_size  = size(array)

! Call C function
value = c_fletcher32(array_size,array)

! Release memory
deallocate(array)

! Probe out
@:probe_out()

end function func_fletcher32

!----------------------------------------------------------------------
! Subroutine: func_lonlatmod
!> Set latitude between -pi/2 and pi/2 and longitude between -pi and pi
!----------------------------------------------------------------------
subroutine func_lonlatmod(lon,lat)

implicit none

! Passed variables
real(kind_real),intent(inout) :: lon !< Longitude [radians]
real(kind_real),intent(inout) :: lat !< Latitude [radians]

! Set name
@:set_name(func_lonlatmod)

! Probe in
@:probe_in()

! Check latitude bounds
if (lat>half*pi) then
   lat = pi-lat
   lon = lon+pi
elseif (lat<-half*pi) then
   lat = -pi-lat
   lon = lon+pi
end if

! Check longitude bounds
if (lon>pi) then
   lon = lon-two*pi
elseif (lon<-pi) then
   lon = lon+two*pi
end if

! Same zero longitude for poles
if (abs(lat)>(half-1.0e-6_kind_real)*pi) lon = zero

! Probe out
@:probe_out()

end subroutine func_lonlatmod

!----------------------------------------------------------------------
! Subroutine: func_gridhash
!> Compute grid hash profile
!----------------------------------------------------------------------
subroutine func_gridhash(ncx,nlx,lon_cx,lat_cx,mask_cx,grid_hash)

implicit none

! Passed variables
integer,intent(in) :: ncx                 !< Number of points
integer,intent(in) :: nlx                 !< Number of levels
real(kind_real),intent(in) :: lon_cx(ncx) !< Longitude [radians]
real(kind_real),intent(in) :: lat_cx(ncx) !< Latitude [radians]
logical,intent(in) :: mask_cx(ncx,nlx)    !< Mask
integer,intent(out) :: grid_hash(0:nlx)   !< Grid hash profile

! Local variables
integer :: ilx,ncx_eff,icx_eff,icx
real(kind_real),allocatable :: lonlat(:)

! Set name
@:set_name(func_grid_hash)

! Probe in
@:probe_in()

do ilx=1,nlx
   ! Count points in the mask
   ncx_eff = count(mask_cx(:,ilx))

   if (ncx_eff>0) then
      ! Allocation
      allocate(lonlat(2*ncx_eff))

      ! Copy lonlat
      icx_eff = 0
      do icx=1,ncx
         if (mask_cx(icx,ilx)) then
            icx_eff = icx_eff+1
            lonlat(icx_eff) = lon_cx(icx)
            icx_eff = icx_eff+1
            lonlat(icx_eff) = lat_cx(icx)
         end if
      end do

      ! Compute hash
      grid_hash(ilx) = fletcher32(lonlat)

      ! Release memory
      deallocate(lonlat)
   else
      grid_hash(ilx) = 0
   end if
end do

! Final grid hash
grid_hash(0) = fletcher32(real(grid_hash(1:nlx),kind_real))

! Probe out
@:probe_out()

end subroutine func_gridhash

!----------------------------------------------------------------------
! Subroutine: func_independent_levels
!> Compute independent levels
!----------------------------------------------------------------------
subroutine func_independent_levels(mpl,nlx,grid_hash,nlxi,lx_to_lxi,lxi_to_lx,ifmt)

implicit none

! Passed variables
type(mpl_type),intent(inout) :: mpl   !< MPI data
integer,intent(in) :: nlx             !< Number of levels
integer,intent(in) :: grid_hash(nlx)  !< Grid hash profile
integer,intent(out) :: nlxi           !< Number of independent levels
integer,intent(out) :: lx_to_lxi(nlx) !< Levels to independent levels
integer,intent(out) :: lxi_to_lx(nlx) !< Independent levels to levels
integer,intent(in) :: ifmt            !< Indentation

! Local variables
integer :: ilx,ilxi,jlx,jlxi,n
integer :: proc_to_grid_hash(mpl%nproc),grid_hash_glb(nlx)
character(len=1024) :: cfmt

! Set name
@:set_name(func_independent_levels)

! Probe in
@:probe_in()

! Compute global hash value
do ilx=1,nlx
   call mpl%f_comm%allgather(grid_hash(ilx),proc_to_grid_hash)
   grid_hash_glb(ilx) = fletcher32(real(proc_to_grid_hash,kind_real))
end do

! Count independent levels
nlxi = 1
do ilx=2,nlx
   if (all(grid_hash_glb(1:ilx-1)/=grid_hash_glb(ilx))) nlxi = nlxi+1
end do

! Initialization
lxi_to_lx = mpl%msv%vali

! Get independent level
ilx = 1
ilxi = 1
lx_to_lxi(ilx) = ilxi
lxi_to_lx(ilxi) = ilx
do ilx=2,nlx
   if (all(grid_hash_glb(1:ilx-1)/=grid_hash_glb(ilx))) then
      ! New independent level
      ilxi = ilxi+1
      lx_to_lxi(ilx) = ilxi
      lxi_to_lx(ilxi) = ilx
   else
      ! Similar level
      do jlx=1,ilx-1
         if (grid_hash_glb(jlx)==grid_hash_glb(ilx)) then
            jlxi = lx_to_lxi(jlx)
            lx_to_lxi(ilx) = jlxi
            exit
         end if
      end do
   end if
end do

! Print levels
write(cfmt,'(a,i2.2,a)') '(a',ifmt,',a)'
write(mpl%info,trim(cfmt)) '','Compute independent levels: '
call mpl%flush(.false.)
do ilxi=1,nlxi
   ilx = lxi_to_lx(ilxi)
   n = count(lx_to_lxi==ilxi)
   if (n<10) then
      cfmt = '(i3,a,i1,a)'
   elseif (n<100) then
      cfmt = '(i3,a,i2,a)'
   else
      cfmt = '(i3,a,i3,a)'
   end if
   write(mpl%info,trim(cfmt)) ilx,'[',n,'] '
   call mpl%flush(.false.)
end do
write(mpl%info,'(a)') ''
call mpl%flush

! Probe out
@:probe_out()

end subroutine func_independent_levels

!----------------------------------------------------------------------
! Subroutine: func_cart_dist
!> Compute the cartesian distance between two points
!----------------------------------------------------------------------
subroutine func_cart_dist(x_i,y_i,z_i,x_f,y_f,z_f,dist)

implicit none

! Passed variable
real(kind_real),intent(in) :: x_i   !< Initial point X coordinate
real(kind_real),intent(in) :: y_i   !< Initial point Y coordinate
real(kind_real),intent(in) :: z_i   !< Initial point Z coordinate
real(kind_real),intent(in) :: x_f   !< Final point X coordinate
real(kind_real),intent(in) :: y_f   !< Final point Y coordinate
real(kind_real),intent(in) :: z_f   !< Final point Z coordinate
real(kind_real),intent(out) :: dist !< Great-circle distance

! Set name
@:set_name(func_cart_dist)

! Probe in
@:probe_in()

! Compute distance
dist = sqrt((x_f-x_i)**2+(y_f-y_i)**2+(z_f-z_i)**2)

! Probe out
@:probe_out()

end subroutine func_cart_dist

!----------------------------------------------------------------------
! Subroutine: func_sphere_dist
!> Compute the great-circle distance between two points
!----------------------------------------------------------------------
subroutine func_sphere_dist(lon_i,lat_i,lon_f,lat_f,dist)

implicit none

! Passed variable
real(kind_real),intent(in) :: lon_i !< Initial point longitude [radians]
real(kind_real),intent(in) :: lat_i !< Initial point latitude [radians]
real(kind_real),intent(in) :: lon_f !< Final point longitude [radians]
real(kind_real),intent(in) :: lat_f !< Final point latitude [radians]
real(kind_real),intent(out) :: dist !< Great-circle distance

! Local variables
type(atlas_geometry) :: ageometry

! Set name
@:set_name(func_sphere_dist)

! Probe in
@:probe_in()

! Create ATLAS geometry
ageometry = atlas_geometry('UnitSphere')

! Compute distance
dist = ageometry%distance(lon_i*rad2deg,lat_i*rad2deg,lon_f*rad2deg,lat_f*rad2deg)

! Probe out
@:probe_out()

end subroutine func_sphere_dist

!----------------------------------------------------------------------
! Subroutine: func_lonlat2xyz
!> Convert longitude/latitude to cartesian coordinates
!----------------------------------------------------------------------
subroutine func_lonlat2xyz(mpl,lon,lat,x,y,z)

implicit none

! Passed variables
type(mpl_type),intent(inout) :: mpl !< MPI data
real(kind_real),intent(in) :: lon   !< Longitude [radians]
real(kind_real),intent(in) :: lat   !< Latitude [radians]
real(kind_real),intent(out) :: x    !< X coordinate
real(kind_real),intent(out) :: y    !< Y coordinate
real(kind_real),intent(out) :: z    !< Z coordinate

! Local variables
type(atlas_geometry) :: ageometry

! Set name
@:set_name(func_lonlat2xyz)

! Probe in
@:probe_in()

if (mpl%msv%isnot(lat).and.mpl%msv%isnot(lon)) then
   ! Check longitude/latitude
   if (inf(lon,-pi).and.sup(lon,pi)) call mpl%abort('${subr}$','wrong longitude')
   if (inf(lat,-half*pi).and.sup(lat,-half*pi)) call mpl%abort('${subr}$','wrong latitude')

   ! Create ATLAS geometry
   ageometry = atlas_geometry('UnitSphere')

   ! Convert to x/y/z
   call ageometry%lonlat2xyz(lon*rad2deg,lat*rad2deg,x,y,z)
else
   ! Missing values
   x = mpl%msv%valr
   y = mpl%msv%valr
   z = mpl%msv%valr
end if

! Probe out
@:probe_out()

end subroutine func_lonlat2xyz

!----------------------------------------------------------------------
! Subroutine: func_xyz2lonlat
!> Convert longitude/latitude to cartesian coordinates
!----------------------------------------------------------------------
subroutine func_xyz2lonlat(mpl,x,y,z,lon,lat)

implicit none

! Passed variables
type(mpl_type),intent(in) :: mpl   !< MPI data
real(kind_real),intent(in) :: x    !< X coordinate
real(kind_real),intent(in) :: y    !< Y coordinate
real(kind_real),intent(in) :: z    !< Z coordinate
real(kind_real),intent(out) :: lon !< Longitude [radians]
real(kind_real),intent(out) :: lat !< Latitude [radians]

! Local variables
type(atlas_geometry) :: ageometry

! Set name
@:set_name(func_xyz2lonlat)

! Probe in
@:probe_in()

if (mpl%msv%isnot(x).and.mpl%msv%isnot(y).and.mpl%msv%isnot(z)) then
   ! Create ATLAS geometry
   ageometry = atlas_geometry('UnitSphere')

   ! Convert to lon/lat
   call ageometry%xyz2lonlat(x,y,z,lon,lat)

   ! Copy coordinates
   lon = lon*deg2rad
   lat = lat*deg2rad
else
   ! Missing values
   lon = mpl%msv%valr
   lat = mpl%msv%valr
end if

! Probe out
@:probe_out()

end subroutine func_xyz2lonlat

!----------------------------------------------------------------------
! Subroutine: func_vector_product
!> Compute normalized vector product
!----------------------------------------------------------------------
subroutine func_vector_product(v1,v2,vp)

implicit none

! Passed variables
real(kind_real),intent(in) :: v1(3)  !< First vector
real(kind_real),intent(in) :: v2(3)  !< Second vector
real(kind_real),intent(out) :: vp(3) !< Vector product

! Local variable
real(kind_real) :: r

! Set name
@:set_name(func_vector_product)

! Probe in
@:probe_in()

! Vector product
vp(1) = v1(2)*v2(3)-v1(3)*v2(2)
vp(2) = v1(3)*v2(1)-v1(1)*v2(3)
vp(3) = v1(1)*v2(2)-v1(2)*v2(1)

! Normalization
r = sqrt(sum(vp**2))
if (r>rth) then
   vp = vp/r
else
   vp = zero
end if

! Probe out
@:probe_out()

end subroutine func_vector_product

!----------------------------------------------------------------------
! Subroutine: func_det
!> Compute determinant (vector triple product)
!----------------------------------------------------------------------
subroutine func_det(v1,v2,v3,p,cflag)

implicit none

! Passed variables
real(kind_real),intent(in) :: v1(3) !< First vector
real(kind_real),intent(in) :: v2(3) !< Second vector
real(kind_real),intent(in) :: v3(3) !< Third vector
real(kind_real),intent(out) :: p    !< Determinant
logical,intent(out) :: cflag        !< Confidence flag

! Local variable
integer :: i
real(kind_real) :: terms(6)

! Set name
@:set_name(func_det)

! Probe in
@:probe_in()

! Terms
terms(1) = v1(2)*v2(3)*v3(1)
terms(2) = -v1(3)*v2(2)*v3(1)
terms(3) = v1(3)*v2(1)*v3(2)
terms(4) = -v1(1)*v2(3)*v3(2)
terms(5) = v1(1)*v2(2)*v3(3)
terms(6) = -v1(2)*v2(1)*v3(3)

! Sum
p = sum(terms)

! Confidence flag
cflag = .true.
do i=1,6
   if ((abs(terms(i))>zero).and.small(p,terms(i))) cflag = .false.
end do

! Probe out
@:probe_out()

end subroutine func_det

!----------------------------------------------------------------------
! Subroutine: func_inside
!> Find whether a point is inside the hull boundaries or not
!----------------------------------------------------------------------
subroutine func_inside(mpl,vbnd,lon,lat,inside_hull)

implicit none

! Passed variables
type(mpl_type),intent(inout) :: mpl     !< MPI data
real(kind_real),intent(in) :: vbnd(:,:) !< Boundary coordinates
real(kind_real),intent(in) :: lon       !< Longitude
real(kind_real),intent(in) :: lat       !< Latitude
logical,intent(out) :: inside_hull      !< True if the point is inside the hull

! Local variables
integer :: i,inext
real(kind_real) :: vp(3),v1(3),v2(3),cp(3),cd(3)

! Set name
@:set_name(func_inside)

! Probe in
@:probe_in()

! Transform to cartesian coordinates
call lonlat2xyz(mpl,lon,lat,vp(1),vp(2),vp(3))

! Initialization
inside_hull = .true.

do i=1,size(vbnd,2)
   ! Index
   if (i<size(vbnd,2)) then
      inext = i+1
   else
      inext = 1
   end if

   ! Cross-product
   v1 = vbnd(:,inext)-vbnd(:,i)
   v2 = vp-vbnd(:,i)
   call vector_product(v1,v2,cp)

   ! Centroid
   cd = (vp+vbnd(:,i)+vbnd(:,inext))/three

   ! Compare the directions
   if (inf(sum(cp*cd),zero)) then
      inside_hull = .false.
      exit
   end if
end do

! Probe out
@:probe_out()

end subroutine func_inside

!----------------------------------------------------------------------
! Subroutine: func_order_cc
!> Order points in counter-clockwise order with respect to a central point
!----------------------------------------------------------------------
subroutine func_order_cc(mpl,lon,lat,n,x,y,z,order,diff)

implicit none

! Passed variables
type(mpl_type),intent(inout) :: mpl             !< MPI data
real(kind_real),intent(in) :: lon               !< Longitude of the central point
real(kind_real),intent(in) :: lat               !< Latitude of the central point
integer :: n                                    !< Number of points
real(kind_real),intent(in) :: x(n)              !< List of X-coordinates
real(kind_real),intent(in) :: y(n)              !< List of Y-coordinates
real(kind_real),intent(in) :: z(n)              !< List of Z-coordinates
integer,intent(out) :: order(n)                 !< Counter-clockwise order
real(kind_real),intent(out),optional :: diff(n) !< Angles differences

! Local variable
integer :: i
real(kind_real) :: rvec(3),costheta,sintheta,p(3),rvecxv(3),v(3),list(n)
real(kind_real),allocatable :: list_save(:)

! Set name
@:set_name(func_order_cc)

! Probe in
@:probe_in()

! Rotation vector in cartesian coordinates
call lonlat2xyz(mpl,lon-half*pi,zero,rvec(1),rvec(2),rvec(3))

! Rotation angle
costheta = cos(half*pi-lat)
sintheta = sin(half*pi-lat)

! Compute angle
do i=1,n
   ! Rodrigues' rotation
   p = (/x(i),y(i),z(i)/)
   call vector_product(rvec,p,rvecxv)
   v = p*costheta+rvecxv*sintheta+rvec*sum(rvec*p)*(one-costheta)

   ! Angle
   list(i) = atan2(v(2),v(1))
end do

if (present(diff)) then
   ! Allocation
   allocate(list_save(n))

   ! Copy
   list_save = list
end if

! Sort angles in counter-clockwise order
call qsort(n,list,order)

if (present(diff)) then
   ! Get angles differences
   diff(order(1)) = list_save(order(1))-list_save(order(n))+two*pi
   do i=2,n
      diff(order(i)) = list_save(order(i))-list_save(order(i-1))
   end do

   ! Release memory
   deallocate(list_save)
end if

! Probe out
@:probe_out()

end subroutine func_order_cc

!----------------------------------------------------------------------
! Subroutine: func_add
!> Check if value missing and add if not missing
!----------------------------------------------------------------------
subroutine func_add(mpl,val,cumul,num,wgt)

implicit none

! Passed variables
type(mpl_type),intent(in) :: mpl           !< MPI data
real(kind_real),intent(in) :: val          !< Value to add
real(kind_real),intent(inout) :: cumul     !< Cumul
real(kind_real),intent(inout) :: num       !< Number of values
real(kind_real),intent(in),optional :: wgt !< Weight

! Local variables
real(kind_real) :: lwgt

! Set name
@:set_name(func_add)

! Probe in
@:probe_in()

! Initialize weight
lwgt = one
if (present(wgt)) lwgt = wgt

! Add value to cumul
if (mpl%msv%isnot(val)) then
   cumul = cumul+lwgt*val
   num = num+lwgt
end if

! Probe out
@:probe_out()

end subroutine func_add

!----------------------------------------------------------------------
! Subroutine: func_divide
!> Check if value missing and divide if not missing
!----------------------------------------------------------------------
subroutine func_divide(mpl,val,num)

implicit none

! Passed variables
type(mpl_type),intent(in) :: mpl     !< MPI data
real(kind_real),intent(inout) :: val !< Value to divide
real(kind_real),intent(in) :: num    !< Divider

! Set name
@:set_name(func_divide)

! Probe in
@:probe_in()

! Divide cumul by num
if (abs(num)>zero) then
   val = val/num
else
   val = mpl%msv%valr
end if

! Probe out
@:probe_out()

end subroutine func_divide

!----------------------------------------------------------------------
! Subroutine: func_vert_interp_size
!> Count vertical interpolation levels
!----------------------------------------------------------------------
subroutine func_vert_interp_size(nl0,dl0,nl1)

implicit none

! Passed variables
integer,intent(in) :: nl0     !< Number of levels
integer,intent(in) :: dl0     !< Level delta
integer,intent(out) :: nl1    !< Number of interpolation levels

! Local variables
integer :: il0_prev,il0,dl0_tmp

! Set name
@:set_name(func_vert_interp_size)

! Probe in
@:probe_in()

! Initialization
nl1 = 1
il0_prev = 1

! Loop over levels
do il0=2,nl0
   dl0_tmp = il0-il0_prev
   if (dl0_tmp==dl0) then
      il0_prev = il0
      nl1 = nl1+1
   end if
end do

! Probe out
@:probe_out()

end subroutine func_vert_interp_size

!----------------------------------------------------------------------
! Subroutine: func_vert_interp_setup
!> Setup vertical interpolation levels and weights
!----------------------------------------------------------------------
subroutine func_vert_interp_setup(nl0,dl0,nl1,il0_interp,il1inf,il1sup,rinf,rsup)

implicit none

! Passed variables
integer,intent(in) :: nl0                !< Number of levels
integer,intent(in) :: dl0                !< Level delta
integer,intent(in) :: nl1                !< Number of interpolation levels
integer,intent(out) :: il0_interp(nl1)   !< Interpolation levels
integer,intent(out) :: il1inf(nl0)       !< Inferior interpolation levels
integer,intent(out) :: il1sup(nl0)       !< Superior interpolation levels
real(kind_real),intent(out) :: rinf(nl0) !< Inferior interpolation weights
real(kind_real),intent(out) :: rsup(nl0) !< Superior interpolation weights

! Local variables
integer :: il0,il0_prev,jl0,dl0_tmp,il0_inf,il0_sup
integer :: il1,il1_inf,il1_sup

! Set name
@:set_name(func_vert_interp_setup)

! Probe in
@:probe_in()

! Initialization
il1 = 1
il0_interp(il1) = 1
il0_prev = 1
il0_sup = 1

! Loop over levels
do il0=2,nl0
   dl0_tmp = il0-il0_prev
   if (dl0_tmp==dl0) then
      il0_prev = il0
      il1 = il1+1
      il0_interp(il1) = il0
   end if
end do

! Loop over interpolation levels
do il1_inf=1,nl1
   il1_sup = min(il1_inf+1,nl1)
   il0_inf = il0_sup
   il0_sup = min(il0_inf+dl0,nl0)
   do jl0=il0_inf,il0_sup
      if (il0_inf==il0_sup) then
         il1inf(jl0) = il1_inf
         rinf(jl0) = one
         il1sup(jl0) = il1_sup
         rsup(jl0) = zero
      else
         il1inf(jl0) = il1_inf
         rinf(jl0) = real(il0_sup-jl0,kind_real)/real(il0_sup-il0_inf,kind_real)
         il1sup(jl0) = il1_sup
         rsup(jl0) = real(jl0-il0_inf,kind_real)/real(il0_sup-il0_inf,kind_real)
      end if
   end do
end do

! Probe out
@:probe_out()

end subroutine func_vert_interp_setup

!----------------------------------------------------------------------
! Subroutine: func_vert_interp
!> Apply vertical interpolation
!----------------------------------------------------------------------
subroutine func_vert_interp(mpl,nl1,data_l1,nl0,il1inf,il1sup,rinf,rsup,data_l0)

implicit none

! Passed variables
type(mpl_type),intent(inout) :: mpl         !< MPI data
integer,intent(in) :: nl1                   !< Number of interpolation levels
real(kind_real),intent(in) :: data_l1(nl1)  !< Input data
integer,intent(in) :: nl0                   !< Number of levels
integer,intent(in) :: il1inf(nl0)           !< Inferior interpolation levels
integer,intent(in) :: il1sup(nl0)           !< Superior interpolation levels
real(kind_real),intent(in) :: rinf(nl0)     !< Inferior interpolation weights
real(kind_real),intent(in) :: rsup(nl0)     !< Superior interpolation weights
real(kind_real),intent(out) :: data_l0(nl0) !< Output data

! Local variables
integer :: il0

! Set name
@:set_name(func_vert_interp)

! Probe in
@:probe_in()

! Interpolate
do il0=1,nl0
   if (mpl%msv%isnot(data_l1(il1inf(il0))).and.mpl%msv%isnot(data_l1(il1sup(il0)))) then
      data_l0(il0) = rinf(il0)*data_l1(il1inf(il0))+rsup(il0)*data_l1(il1sup(il0))
   else
      data_l0(il0) = mpl%msv%valr
   end if
end do

! Probe out
@:probe_out()

end subroutine func_vert_interp

!----------------------------------------------------------------------
! Subroutine: func_fit_diag_sqrt
!> Compute diagnostic fit function square-root
!----------------------------------------------------------------------
subroutine func_fit_diag_sqrt(mpl,n,iz,dist,fit_r,fit_pk,fit)

implicit none

! Passed variables
type(mpl_type),intent(inout) :: mpl   !< MPI data
integer,intent(in) :: n               !< Vector size
integer,intent(in) :: iz              !< Zero separation index
real(kind_real),intent(in) :: dist(n) !< Distance
real(kind_real),intent(in) :: fit_r   !< Support radius
real(kind_real),intent(in) :: fit_pk  !< Peakness
real(kind_real),intent(out) :: fit(n) !< Fit

! Local variables
integer :: i
real(kind_real) :: nd(n)

! Set name
@:set_name(func_fit_diag_sqrt)

! Probe in
@:probe_in()

if (mpl%msv%is(fit_r).or.mpl%msv%is(fit_pk)) then
   ! Set to missing values if no value available
   fit = mpl%msv%valr
else
   ! Normalized distance
   do i=1,n
      if (fit_r>zero) then
         nd(i) = abs(dist(i)-dist(iz))/fit_r
      elseif (i/=iz) then
         nd(i) = one
      else
         nd(i) = zero
      end if
   end do

   ! Unitary fit function
   do i=1,n
      fit(i) = fit_func_sqrt(mpl,nd(i),fit_pk)
   end do
end if

! Probe out
@:probe_out()

end subroutine func_fit_diag_sqrt

!----------------------------------------------------------------------
! Subroutine: func_fit_diag
!> Compute diagnostic fit function
!----------------------------------------------------------------------
subroutine func_fit_diag(mpl,n,iz,dist,dir,fit_r,fit_pk,fit)

implicit none

! Passed variables
type(mpl_type),intent(inout) :: mpl   !< MPI data
integer,intent(in) :: n               !< Vector size
integer,intent(in) :: iz              !< Zero separation index
real(kind_real),intent(in) :: dist(n) !< Distance
character(len=*),intent(in) :: dir    !< Direction
real(kind_real),intent(in) :: fit_r   !< Support radius
real(kind_real),intent(in) :: fit_pk  !< Peakness
real(kind_real),intent(out) :: fit(n) !< Fit

! Local variables
integer :: i
real(kind_real) :: nd(n)

! Set name
@:set_name(func_fit_diag)

! Probe in
@:probe_in()

if (mpl%msv%is(fit_r).or.mpl%msv%is(fit_pk)) then
   ! Set to missing values if no value available
   fit = mpl%msv%valr
else
   ! Normalized distance
   do i=1,n
      if (fit_r>zero) then
         nd(i) = abs(dist(i)-dist(iz))/fit_r
      elseif (i/=iz) then
         nd(i) = one
      else
         nd(i) = zero
      end if
   end do

   ! Unitary fit function
   do i=1,n
      fit(i) = fit_func(mpl,dir,nd(i),fit_pk)
   end do
end if

! Probe out
@:probe_out()

end subroutine func_fit_diag

!----------------------------------------------------------------------
! Subroutine: func_fit_diag_full
!> Compute diagnostic fit function, full profile
!----------------------------------------------------------------------
subroutine func_fit_diag_full(mpl,nc3,nl0r,nl0,l0rl0_to_l0,disth,distv,coef,rh,pkh,rv,pkv,fit)

implicit none

! Passed variables
type(mpl_type),intent(inout) :: mpl              !< MPI data
integer,intent(in) :: nc3                        !< Number of classes
integer,intent(in) :: nl0r                       !< Effective number of levels
integer,intent(in) :: nl0                        !< Number of levels
integer,intent(in) :: l0rl0_to_l0(nl0r,nl0)      !< Effective level to level
real(kind_real),intent(in) :: disth(nc3)         !< Horizontal distance
real(kind_real),intent(in) :: distv(nl0r,nl0)    !< Vertical distance
real(kind_real),intent(in) :: coef(nl0)          !< Diagonal coefficient
real(kind_real),intent(in) :: rh(nl0)            !< Horizontal support radius
real(kind_real),intent(in) :: pkh(nl0)           !< Horizontal peakness
real(kind_real),intent(in) :: rv(nl0)            !< Vertical support radius
real(kind_real),intent(in) :: pkv(nl0)           !< Vertical peakness
real(kind_real),intent(out) :: fit(nc3,nl0r,nl0) !< Fit

! Local variables
integer :: il0,jl0r,jl0,jc3
real(kind_real) :: vnd,hnd,ver_fit,hor_fit,rh_eff,pkh_eff,rv_eff,pkv_eff

! Set name
@:set_name(func_fit_diag_full)

! Probe in
@:probe_in()

do il0=1,nl0
   do jl0r=1,nl0r
      ! Level index
      jl0 = l0rl0_to_l0(jl0r,il0)

      ! Averaged horizontal support radius
      if (mpl%msv%isnot(rh(il0)).and.mpl%msv%isnot(rh(jl0))) then
         rh_eff = sqrt(half*(rh(il0)**2+rh(jl0)**2))
      else
         rh_eff = zero
      end if

      ! Averaged horizontal peakness
      if (mpl%msv%isnot(pkh(il0)).and.mpl%msv%isnot(pkh(jl0))) then
         pkh_eff = half*(pkh(il0)+pkh(jl0))
      else
         pkh_eff = zero
      end if

      ! Averaged vertical support radius
      if (mpl%msv%isnot(rv(il0)).and.mpl%msv%isnot(rv(jl0))) then
         rv_eff = sqrt(half*(rv(il0)**2+rv(jl0)**2))
      else
         rv_eff = zero
      end if

      ! Averaged vertical peakness
      if (mpl%msv%isnot(pkv(il0)).and.mpl%msv%isnot(pkv(jl0))) then
         pkv_eff = half*(pkv(il0)+pkv(jl0))
      else
         pkv_eff = zero
      end if

      ! Vertical normalized distance
      if (rv_eff>zero) then
         vnd = distv(jl0r,il0)/rv_eff
      elseif (il0/=jl0) then
         vnd = one
      else
         vnd = zero
      end if

      ! Vertical component
      ver_fit = fit_func(mpl,'ver',vnd,pkv_eff)

      do jc3=1,nc3
         ! Horizontal normalized distance
         if (rh_eff>zero) then
            hnd = disth(jc3)/rh_eff
         elseif (jc3/=1) then
            hnd = one
         else
            hnd = zero
         end if

         ! Horizontal component
         hor_fit = fit_func(mpl,'hor',hnd,pkh_eff)

         ! Fit function
         fit(jc3,jl0r,il0) = hor_fit*ver_fit
      end do
   end do
end do

! Diagonal coefficient
do il0=1,nl0
   do jl0r=1,nl0r
      jl0 = l0rl0_to_l0(jl0r,il0)
      fit(:,jl0r,il0) = fit(:,jl0r,il0)*sqrt(coef(il0)*coef(jl0))
   end do
end do

! Set to missing values if no value available
do il0=1,nl0
   if (mpl%msv%is(coef(il0)).or.mpl%msv%is(rh(il0)).or.mpl%msv%is(pkh(il0)).or.mpl%msv%is(rv(il0)) &
 & .or.mpl%msv%is(pkv(il0))) fit(:,:,il0) = mpl%msv%valr
   do jl0r=1,nl0r
      jl0 = l0rl0_to_l0(jl0r,il0)
      if (mpl%msv%is(coef(jl0)).or.mpl%msv%is(rh(jl0)).or.mpl%msv%is(pkh(jl0)).or.mpl%msv%is(rv(jl0)) &
 & .or.mpl%msv%is(pkv(jl0))) fit(:,jl0r,il0) = mpl%msv%valr
   end do
end do

! Probe out
@:probe_out()

end subroutine func_fit_diag_full

!----------------------------------------------------------------------
! Subroutine: func_fit_lct
!> LCT fit
!----------------------------------------------------------------------
subroutine func_fit_lct(mpl,nc3,nl0r,dxsq,dysq,dxdy,dzsq,dmask,nscales,D,coef,fit)

implicit none

! Passed variables
type(mpl_type),intent(inout) :: mpl           !< MPI data
integer,intent(in) :: nc3                     !< Number of classes
integer,intent(in) :: nl0r                    !< Number of levels
real(kind_real),intent(in) :: dxsq(nc3,nl0r)  !< Zonal separation squared
real(kind_real),intent(in) :: dysq(nc3,nl0r)  !< Meridian separation squared
real(kind_real),intent(in) :: dxdy(nc3,nl0r)  !< Zonal x meridian separations product
real(kind_real),intent(in) :: dzsq(nc3,nl0r)  !< Vertical separation squared
logical,intent(in) :: dmask(nc3,nl0r)         !< Mask
integer,intent(in) :: nscales                 !< Number of LCT scales
real(kind_real),intent(in) :: D(4,nscales)    !< LCT components
real(kind_real),intent(in) :: coef(nscales)   !< LCT coefficients
real(kind_real),intent(out) :: fit(nc3,nl0r)  !< Fit

! Local variables
integer :: jl0r,jc3,iscales
real(kind_real) :: Dcoef(nscales),D11,D22,D33,D12,H11,H22,H33,H12,rsq,distnorm

! Set name
@:set_name(func_fit_lct)

! Probe in
@:probe_in()

! Initialization
fit = mpl%msv%valr

! Coefficients
Dcoef = max(Dmin,min(coef,one))
Dcoef = Dcoef/sum(Dcoef)
do iscales=1,nscales
   ! Ensure positive-definiteness of D
   D11 = max(Dmin,D(1,iscales))
   D22 = max(Dmin,D(2,iscales))
   if (nl0r>1) then
      D33 = D(3,iscales)
   else
      D33 = zero
   end if
   D12 = sqrt(D11*D22)*max(-one+Dmin,min(D(4,iscales),one-Dmin))

   ! Inverse D to get H
   call lct_d2h(mpl,D11,D22,D33,D12,H11,H22,H33,H12)

   ! Homogeneous anisotropic approximation
   do jl0r=1,nl0r
      do jc3=1,nc3
         if (dmask(jc3,jl0r)) then
            ! Initialization
            if (iscales==1) fit(jc3,jl0r) = zero

            ! Squared distance
            rsq = H11*dxsq(jc3,jl0r)+H22*dysq(jc3,jl0r)+H33*dzsq(jc3,jl0r)+two*H12*dxdy(jc3,jl0r)

            if (M==-1) then
               ! Gaspari-Cohn 1999 function
               distnorm = sqrt(rsq)*gc2gau
               fit(jc3,jl0r) = fit(jc3,jl0r)+Dcoef(iscales)*fit_func(mpl,'hor',distnorm,zero) ! TODO: non-zero horizontal peakness
            elseif (M==0) then
               ! Gaussian function
               if (rsq<40.0_kind_real) fit(jc3,jl0r) = fit(jc3,jl0r)+Dcoef(iscales)*exp(-half*rsq)
            else
               ! Matern function
               fit(jc3,jl0r) = fit(jc3,jl0r)+Dcoef(iscales)*matern(mpl,M,sqrt(rsq))
            end if
         end if
      end do
   end do
end do

! Probe out
@:probe_out()

end subroutine func_fit_lct

!----------------------------------------------------------------------
! Subroutine: func_lct_d2h
!> From D (Daley tensor) to H (local correlation tensor)
!----------------------------------------------------------------------
subroutine func_lct_d2h(mpl,D11,D22,D33,D12,H11,H22,H33,H12)

implicit none

! Passed variables
type(mpl_type),intent(inout) :: mpl!< MPI data
real(kind_real),intent(in) :: D11  !< Daley tensor component 11
real(kind_real),intent(in) :: D22  !< Daley tensor component 22
real(kind_real),intent(in) :: D33  !< Daley tensor component 33
real(kind_real),intent(in) :: D12  !< Daley tensor component 12
real(kind_real),intent(out) :: H11 !< Local correlation tensor component 11
real(kind_real),intent(out) :: H22 !< Local correlation tensor component 22
real(kind_real),intent(out) :: H33 !< Local correlation tensor component 33
real(kind_real),intent(out) :: H12 !< Local correlation tensor component 12

! Local variables
real(kind_real) :: det

! Set name
@:set_name(func_lct_d2h)

! Probe in
@:probe_in()

if (mpl%msv%isnot(D11).and.mpl%msv%isnot(D22).and.mpl%msv%isnot(D33).and.mpl%msv%isnot(D12)) then
   ! Compute horizontal determinant
   det = D11*D22-D12**2

   ! Inverse D to get H
   if (det>zero) then
      H11 = D22/det
      H22 = D11/det
      H12 = -D12/det
   else
      call mpl%abort('${subr}$','non-invertible tensor')
   end if
   if (D33>zero) then
      H33 = one/D33
   else
      H33 = zero
   end if
else
   ! Missing values
   H11 = mpl%msv%valr
   H22 = mpl%msv%valr
   H33 = mpl%msv%valr
   H12 = mpl%msv%valr
end if

! Probe out
@:probe_out()

end subroutine func_lct_d2h

!----------------------------------------------------------------------
! Subroutine: func_lct_h2r
!> From H (local correlation tensor) to support radii
!----------------------------------------------------------------------
subroutine func_lct_h2r(mpl,H11,H22,H33,H12,rh,rv)

implicit none

! Passed variables
type(mpl_type),intent(inout) :: mpl !< MPI data
real(kind_real),intent(in) :: H11   !< Local correlation tensor component 11
real(kind_real),intent(in) :: H22   !< Local correlation tensor component 22
real(kind_real),intent(in) :: H33   !< Local correlation tensor component 33
real(kind_real),intent(in) :: H12   !< Local correlation tensor component 12
real(kind_real),intent(out) :: rh   !< Horizontal support radius
real(kind_real),intent(out) :: rv   !< Vertical support radius

! Local variables
real(kind_real) :: tr,det,diff

! Set name
@:set_name(func_lct_h2r)

! Probe in
@:probe_in()

if (mpl%msv%isnot(H11).and.mpl%msv%isnot(H22).and.mpl%msv%isnot(H33).and.mpl%msv%isnot(H12)) then
   ! Check diagonal positivity
   if ((H11<zero).or.(H22<zero)) call mpl%abort('${subr}$','negative diagonal LCT coefficients')

   ! Compute horizontal trace
   tr = H11+H22

   ! Compute horizontal determinant
   det = H11*H22-H12**2

   ! Compute horizontal support radius
   diff = quarter*(H11-H22)**2+H12**2
   if ((det>zero).and..not.(diff<zero)) then
      if (sup(half*tr,sqrt(diff))) then
         rh = gau2gc/sqrt(half*tr-sqrt(diff))
      else
         call mpl%abort('${subr}$','non positive-definite LCT (eigenvalue)')
      end if
   else
      call mpl%abort('${subr}$','non positive-definite LCT (determinant)')
   end if

   ! Compute vertical support radius
   if (H33>zero) then
      rv = gau2gc/sqrt(H33)
   else
      rv = zero
   end if
else
   ! Missing values
   rh = mpl%msv%valr
   rv = mpl%msv%valr
end if

! Probe out
@:probe_out()

end subroutine func_lct_h2r

!----------------------------------------------------------------------
! Subroutine: func_lct_r2d
!> From support radius to Daley tensor diagonal element
!----------------------------------------------------------------------
subroutine func_lct_r2d(r,D)

implicit none

! Passed variables
real(kind_real),intent(in) :: r  !< Support radius
real(kind_real),intent(out) :: D !< Daley tensor diagonal element

! Set name
@:set_name(func_lct_r2d)

! Probe in
@:probe_in()

! Convert from support radius to Daley length-scale and square
D = (gc2gau*r)**2

! Probe out
@:probe_out()

end subroutine func_lct_r2d

!----------------------------------------------------------------------
! Subroutine: func_check_cond
!> Check tensor conditioning
!----------------------------------------------------------------------
subroutine func_check_cond(d1,d2,nod,valid)

implicit none

! Passed variables
real(kind_real),intent(in) :: d1  !< First diagonal coefficient
real(kind_real),intent(in) :: d2  !< Second diagonal coefficient
real(kind_real),intent(in) :: nod !< Normalized off-diagonal coefficient
logical,intent(out) :: valid      !< Conditioning validity

! Local variables
real(kind_real) :: det,tr,diff,ev1,ev2

! Set name
@:set_name(func_check_cond)

! Probe in
@:probe_in()

! Compute trace and determinant
tr = d1+d2
det = d1*d2*(one-nod**2)
diff = quarter*(d1-d2)**2+d1*d2*nod**2

if ((det>zero).and..not.(diff<zero)) then
   ! Compute eigenvalues
   ev1 = half*tr+sqrt(diff)
   ev2 = half*tr-sqrt(diff)

   if (ev2>zero) then
      ! Check conditioning
      valid = inf(ev1,condmax*ev2)
   else
      ! Lowest negative eigenvalue is negative
      valid = .false.
   end if
else
   ! Non-positive definite tensor
   valid = .false.
end if

! Probe out
@:probe_out()

end subroutine func_check_cond

!----------------------------------------------------------------------
! Function: func_matern
!> Compute the normalized diffusion function from eq. (55) of Mirouze and Weaver (2013), for the 3d case (d = 3)
!----------------------------------------------------------------------
function func_matern(mpl,M,x) result(value)

implicit none

! Passed variables
type(mpl_type),intent(inout) :: mpl !< MPI data
integer,intent(in) :: M             !< Matern function order
real(kind_real),intent(in) :: x     !< Argument

! Returned variable
real(kind_real) :: value

! Local variables
integer :: j
real(kind_real) :: xtmp,beta

! Set name
@:set_name(func_matern)

! Probe in
@:probe_in()

! Check
if (M<2) call mpl%abort('${subr}$','M should be larger than 2')
if (mod(M,2)>0) call mpl%abort('${subr}$','M should be even')

! Initialization
value = zero
beta = one
xtmp = x*sqrt(real(2*M-5,kind_real))

do j=0,M-3
   ! Update sum
   value = value+beta*(xtmp)**(M-2-j)

   ! Update beta
   beta = beta*real((j+1+M-2)*(-j+M-2),kind_real)/real(2*(j+1),kind_real)
end do

! Last term and normalization
value = value/beta+one

! Exponential factor
value = value*exp(-xtmp)

! Probe out
@:probe_out()

end function func_matern

!----------------------------------------------------------------------
! Subroutine: func_cholesky
!> Compute cholesky decomposition
! Author: Original FORTRAN77 version by Michael Healy, modifications by AJ Miller, FORTRAN90 version by John Burkardt.
!----------------------------------------------------------------------
subroutine func_cholesky(mpl,n,a,u)

implicit none

! Passed variables
type(mpl_type),intent(inout) :: mpl   !< MPI data
integer,intent(in) :: n               !< Matrix rank
real(kind_real),intent(in) :: a(n,n)  !< Matrix
real(kind_real),intent(out) :: u(n,n) !< Matrix square-root

! Local variables
integer :: nn,i,j,ij
real(kind_real),allocatable :: apack(:),upack(:)

! Set name
@:set_name(func_cholesky)

! Probe in
@:probe_in()

! Allocation
nn = (n*(n+1))/2
allocate(apack(nn))
allocate(upack(nn))

! Pack matrix
ij = 0
do i=1,n
   do j=1,i
      ij = ij+1
      apack(ij) = a(i,j)
   end do
end do

! Cholesky decomposition
call cholesky(mpl,n,nn,apack,upack)

! Unpack matrix
ij = 0
u = zero
do i=1,n
   do j=1,i
      ij = ij+1
      u(i,j) = upack(ij)
   end do
end do

! Release memory
deallocate(apack)
deallocate(upack)

! Probe out
@:probe_out()

end subroutine func_cholesky

!----------------------------------------------------------------------
! Subroutine: func_syminv
!> Compute inverse of a symmetric matrix
! Author: Original FORTRAN77 version by Michael Healy, modifications by AJ Miller, FORTRAN90 version by John Burkardt.
!----------------------------------------------------------------------
subroutine func_syminv(mpl,n,a,c)

implicit none

! Passed variables
type(mpl_type),intent(inout) :: mpl   !< MPI data
integer,intent(in) :: n               !< Matrix rank
real(kind_real),intent(in) :: a(n,n)  !< Matrix
real(kind_real),intent(out) :: c(n,n) !< Matrix inverse

! Local variables
integer :: nn,i,j,ij
real(kind_real),allocatable :: apack(:),cpack(:)

! Set name
@:set_name(func_syminv)

! Probe in
@:probe_in()

! Allocation
nn = (n*(n+1))/2
allocate(apack(nn))
allocate(cpack(nn))

! Pack matrix
ij = 0
do i=1,n
   do j=1,i
      ij = ij+1
      apack(ij) = a(i,j)
   end do
end do

! Matrix inversion
call syminv(mpl,n,nn,apack,cpack)

! Unpack matrix
ij = 0
do i=1,n
   do j=1,i
      ij = ij+1
      c(i,j) = cpack(ij)
      c(j,i) = c(i,j)
   end do
end do

! Release memory
deallocate(apack)
deallocate(cpack)

! Probe out
@:probe_out()

end subroutine func_syminv

!----------------------------------------------------------------------
! Subroutine: func_histogram
!> Compute bins and histogram from a list of values
!----------------------------------------------------------------------
subroutine func_histogram(mpl,nlist,list,nbins,histmin,histmax,bins,hist)

implicit none

! Passed variables
type(mpl_type),intent(inout) :: mpl          !< MPI data
integer,intent(in) :: nlist                  !< List size
real(kind_real),intent(in) :: list(nlist)    !< List
integer,intent(in) :: nbins                  !< Number of bins
real(kind_real),intent(in) :: histmin        !< Histogram minimum
real(kind_real),intent(in) :: histmax        !< Histogram maximum
real(kind_real),intent(out) :: bins(nbins+1) !< Bins
real(kind_real),intent(out) :: hist(nbins)   !< Histogram

! Local variables
integer :: ibins,ilist
real(kind_real) :: delta
logical :: found

! Set name
@:set_name(func_histogram)

! Probe in
@:probe_in()

! Check data
if (nbins<=0) call mpl%abort('${subr}$','the number of bins should be positive')
if (histmax>histmin) then
   if (zss_minval(list,mask=mpl%msv%isnot(list))<histmin) call mpl%abort('${subr}$','values below histogram minimum')
   if (zss_maxval(list,mask=mpl%msv%isnot(list))>histmax) call mpl%abort('${subr}$','values over histogram maximum')

   ! Compute bins
   delta = (histmax-histmin)/real(nbins,kind_real)
   bins(1) = histmin
   do ibins=2,nbins
      bins(ibins) = histmin+real(ibins-1,kind_real)*delta
   end do
   bins(nbins+1) = histmax

   ! Extend first and last bins
   bins(1) = bins(1)-1.0e-6_kind_real*delta
   bins(nbins+1) = bins(nbins+1)+1.0e-6_kind_real*delta

   ! Compute histogram
   hist = zero
   do ilist=1,nlist
      if (mpl%msv%isnot(list(ilist))) then
         ibins = 0
         found = .false.
         do while (.not.found)
            ibins = ibins+1
            if (ibins>nbins) call mpl%abort('${subr}$','bin not found')
            if (infeq(bins(ibins),list(ilist)).and.inf(list(ilist),bins(ibins+1))) then
               hist(ibins) = hist(ibins)+one
               found = .true.
            end if
         end do
      end if
   end do
   if (abs(sum(hist)-real(count(mpl%msv%isnot(list)),kind_real))>half) &
 & call mpl%abort('${subr}$','histogram sum is not equal to the number of valid elements')
else
   bins = mpl%msv%valr
   hist = zero
end if

! Probe out
@:probe_out()

end subroutine func_histogram

!----------------------------------------------------------------------
! Function: func_cx_to_cxa
!> Conversion from global to halo A on subset Scx
!----------------------------------------------------------------------
function func_cx_to_cxa(nproc,proc_to_cx_offset,icx) result(icxa)

implicit none

! Passed variables
integer,intent(in) :: nproc                    !< Number of processors
integer,intent(in) :: proc_to_cx_offset(nproc) !< Processor to offset on subset Scx
integer,intent(in) :: icx                      !< Global index

! Returned variable
integer :: icxa

! Local variable
integer :: iproc

! Set name
@:set_name(func_cx_to_cxa)

! Probe in
@:probe_in()

! Find processor
iproc = cx_to_proc(nproc,proc_to_cx_offset,icx)

! Get halo A index
icxa = icx-proc_to_cx_offset(iproc)

! Probe out
@:probe_out()

end function func_cx_to_cxa

!----------------------------------------------------------------------
! Function: func_cx_to_proc
!> Conversion from global to processor on subset Scx
!----------------------------------------------------------------------
function func_cx_to_proc(nproc,proc_to_cx_offset,icx) result(iproc)

implicit none

! Passed variables
integer,intent(in) :: nproc                    !< Number of processors
integer,intent(in) :: proc_to_cx_offset(nproc) !< Processor to offset on subset Scx
integer,intent(in) :: icx                      !< Global index

! Returned variable
integer :: iproc

! Set name
@:set_name(func_cx_to_proc)

! Probe in
@:probe_in()

! Find processor
do iproc=1,nproc-1
   if ((proc_to_cx_offset(iproc)<icx).and.(icx<=proc_to_cx_offset(iproc+1))) then
@:probe_out()
      return
   end if
end do

! Probe out
@:probe_out()

end function func_cx_to_proc

!----------------------------------------------------------------------
! Function: func_cx_to_cxu
!> Conversion from global to universe on subset Scx
!----------------------------------------------------------------------
function func_cx_to_cxu(nproc,proc_to_cx_offset,proc_to_ncxa,myuniverse,icx) result(icxu)

implicit none

! Passed variables
integer,intent(in) :: nproc                    !< Number of processors
integer,intent(in) :: proc_to_cx_offset(nproc) !< Processor to offset on subset Scx
integer,intent(in) :: proc_to_ncxa(nproc)      !< Processor to halo A size for subset Scx
logical,intent(in) :: myuniverse(nproc)        !< Task universe
integer,intent(in) :: icx                      !< Global index

! Returned variable
integer :: icxu

! Local variable
integer :: iproc,icxa,offset,jproc

! Set name
@:set_name(func_cx_to_cxu)

! Probe in
@:probe_in()

! Find processor
iproc = cx_to_proc(nproc,proc_to_cx_offset,icx)

if (myuniverse(iproc)) then
   ! Get halo A index
   icxa = icx-proc_to_cx_offset(iproc)

   ! Compute universe offset
   offset = 0
   do jproc=1,iproc-1
      if (myuniverse(jproc)) offset = offset+proc_to_ncxa(jproc)
   end do

   ! Get universe index
   icxu = offset+icxa
else
   ! Not in my universe
   icxu = 0
end if

! Probe out
@:probe_out()

end function func_cx_to_cxu

!----------------------------------------------------------------------
! Subroutine: func_convert_i2l_r0
!> Convert integer to logical
!----------------------------------------------------------------------
subroutine func_convert_i2l_r0(mpl,fldi,fldl)

implicit none

! Passed variables
type(mpl_type),intent(inout) :: mpl !< MPI data
integer,intent(in) :: fldi          !< Integer field
logical,intent(out) :: fldl         !< Logical field

! Set name
@:set_name(func_convert_i2l_r0)

! Probe in
@:probe_in()

if (fldi==0) then
   fldl = .false.
elseif (fldi==1) then
   fldl = .true.
else
   call mpl%abort('${subr}$','wrong integer value')
end if

! Probe out
@:probe_out()

end subroutine func_convert_i2l_r0

#:for rank in ranks_1234
!----------------------------------------------------------------------
! Subroutine: func_convert_i2l_r${rank}$
!> Convert integer to logical
!----------------------------------------------------------------------
subroutine func_convert_i2l_r${rank}$(mpl,fldi,fldl)

implicit none

! Passed variables
type(mpl_type),intent(inout) :: mpl        !< MPI data
integer,intent(in) :: fldi(${dim[rank]}$)  !< Integer field
logical,intent(out) :: fldl(${dim[rank]}$) !< Logical field

! Local variable
#:for arg_dim in range(1,rank+1)
integer :: i${arg_dim}$
#:endfor

! Set name
@:set_name(func_convert_i2l_r${rank}$)

! Probe in
@:probe_in()

#:for arg_dim in reversed(range(1,rank+1))
do i${arg_dim}$=1,size(fldl,${arg_dim}$)
#:endfor
   call convert_i2l(mpl,fldi( &
   #:for arg_dim in range(1,rank)
 & i${arg_dim}$, &
   #:endfor
 & i${rank}$),fldl( &
   #:for arg_dim in range(1,rank)
 & i${arg_dim}$, &
   #:endfor
 & i${rank}$))
#:for arg_dim in range(1,rank+1)
end do
#:endfor

! Probe out
@:probe_out()

end subroutine func_convert_i2l_r${rank}$
#:endfor

!----------------------------------------------------------------------
! Subroutine: func_convert_l2i_r0
!> Convert logical to integer
!----------------------------------------------------------------------
subroutine func_convert_l2i_r0(fldl,fldi)

implicit none

! Passed variables
logical,intent(in) :: fldl  !< Logical field
integer,intent(out) :: fldi !< Integer field

! Set name
@:set_name(func_convert_l2i_r0)

! Probe in
@:probe_in()

if (fldl) then
   fldi = 1
else
   fldi = 0
end if

! Probe out
@:probe_out()

end subroutine func_convert_l2i_r0

#:for rank in ranks_1234
!----------------------------------------------------------------------
! Subroutine: func_convert_l2i_r${rank}$
!> Convert logical to integer
!----------------------------------------------------------------------
subroutine func_convert_l2i_r${rank}$(fldl,fldi)

implicit none

! Passed variables
logical,intent(in) :: fldl(${dim[rank]}$)  !< Logical field
integer,intent(out) :: fldi(${dim[rank]}$) !< Integer field

! Local variable
#:for arg_dim in range(1,rank+1)
integer :: i${arg_dim}$
#:endfor

! Set name
@:set_name(func_convert_l2i_r${rank}$)

! Probe in
@:probe_in()

#:for arg_dim in reversed(range(1,rank+1))
do i${arg_dim}$=1,size(fldl,${arg_dim}$)
#:endfor
   call convert_l2i(fldl( &
   #:for arg_dim in range(1,rank)
 & i${arg_dim}$, &
   #:endfor
 & i${rank}$),fldi( &
   #:for arg_dim in range(1,rank)
 & i${arg_dim}$, &
   #:endfor
 & i${rank}$))
#:for arg_dim in range(1,rank+1)
end do
#:endfor

! Probe out
@:probe_out()

end subroutine func_convert_l2i_r${rank}$
#:endfor

#:for dtype in dtypes_ir
#:for rank in ranks_123456
!----------------------------------------------------------------------
! Function: func_zss_maxval_${dtype}$_r${rank}$
!> Zero-size-safe maxval function
!----------------------------------------------------------------------
function func_zss_maxval_${dtype}$_r${rank}$(array,mask) result(value)

implicit none

! Passed variables
${ftype[dtype]}$,intent(in) :: array(${dim[rank]}$) !< Array
logical,intent(in),optional :: mask(${dim[rank]}$)  !< Mask

! Returned variable
${ftype[dtype]}$ :: value

! Set name
@:set_name(func_zss_maxval_${dtype}$_r${rank}$)

! Probe in
@:probe_in()

if (size(array)>0) then
   if (present(mask)) then
      if (any(mask)) then
         value = maxval(array,mask=mask)
      else
         value = -${huge[dtype]}$
      end if
   else
      value = maxval(array)
   end if
else
   value = -${huge[dtype]}$
endif

! Probe out
@:probe_out()

end function func_zss_maxval_${dtype}$_r${rank}$
#:endfor
#:endfor

#:for dtype in dtypes_ir
#:for rank in ranks_123456
!----------------------------------------------------------------------
! Function: func_zss_minval_${dtype}$_r${rank}$
!> Zero-size-safe minval function
!----------------------------------------------------------------------
function func_zss_minval_${dtype}$_r${rank}$(array,mask) result(value)

implicit none

! Passed variables
${ftype[dtype]}$,intent(in) :: array(${dim[rank]}$) !< Array
logical,intent(in),optional :: mask(${dim[rank]}$)  !< Mask

! Returned variable
${ftype[dtype]}$ :: value

! Set name
@:set_name(func_zss_minval_${dtype}$_r${rank}$)

! Probe in
@:probe_in()

if (size(array)>0) then
   if (present(mask)) then
      if (any(mask)) then
         value = minval(array,mask=mask)
      else
         value = ${huge[dtype]}$
      end if
   else
      value = minval(array)
   end if
else
   value = ${huge[dtype]}$
endif

! Probe out
@:probe_out()

end function func_zss_minval_${dtype}$_r${rank}$
#:endfor
#:endfor

#:for dtype in dtypes_ir
#:for rank in ranks_123456
!----------------------------------------------------------------------
! Function: func_zss_sum_${dtype}$_r${rank}$
!> Zero-size-safe sum function
!----------------------------------------------------------------------
function func_zss_sum_${dtype}$_r${rank}$(array,mask) result(value)

implicit none

! Passed variables
${ftype[dtype]}$,intent(in) :: array(${dim[rank]}$) !< Array
logical,intent(in),optional :: mask(${dim[rank]}$)  !< Mask

! Returned variable
${ftype[dtype]}$ :: value

! Set name
@:set_name(func_zss_sum_${dtype}$_r${rank}$)

! Probe in
@:probe_in()

if (size(array)>0) then
   if (present(mask)) then
      if (any(mask)) then
         value = sum(array,mask=mask)
      else
         value = ${zero[dtype]}$
      end if
   else
      value = sum(array)
   end if
else
   value = ${zero[dtype]}$
endif

! Probe out
@:probe_out()

end function func_zss_sum_${dtype}$_r${rank}$
#:endfor
#:endfor

#:for rank in ranks_123456
!----------------------------------------------------------------------
! Function: func_zss_count_r${rank}$
!> Zero-size-safe count function
!----------------------------------------------------------------------
function func_zss_count_r${rank}$(array) result(value)

implicit none

! Passed variables
logical,intent(in) :: array(${dim[rank]}$) !< Array

! Returned variable
integer :: value

! Set name
@:set_name(func_zss_count_r${rank}$)

! Probe in
@:probe_in()

if (size(array)>0) then
   value = count(array)
else
   value = 0
endif

! Probe out
@:probe_out()

end function func_zss_count_r${rank}$
#:endfor

end module tools_func
