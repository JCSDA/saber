#:include '../instrumentation.fypp'
!----------------------------------------------------------------------
! Module: type_nicas_blk
!> NICAS data block derived type
! Author: Benjamin Menetrier
! Licensing: this code is distributed under the CeCILL-C license
! Copyright 2015-... UCAR, CERFACS, METEO-FRANCE and IRIT
!----------------------------------------------------------------------
module type_nicas_blk

use atlas_module, only: atlas_structuredgrid
use fckit_mpi_module, only: fckit_mpi_sum,fckit_mpi_min,fckit_mpi_max
!$ use omp_lib
use tools_const, only: zero,quarter,half,tenth,one,two,three,four,five,hundred,pi,req,reqkm,deg2rad,rad2deg
use tools_fit, only: tensor_d2h
use tools_func, only: lonlatmod,sphere_dist,inside,convert_i2l,convert_l2i,zss_maxval,zss_minval,zss_sum,zss_count
use tools_gc99, only: fit_func_sqrt
use tools_kinds, only: kind_int,kind_real,kind_long,huge_int,huge_real
use tools_netcdf, only: define_grp,inquire_grp,put_att,get_att,define_dim,inquire_dim_size,check_dim,define_var,inquire_var, &
 & inquire_var_presence,put_var,get_var
use tools_qsort, only: qsort
use tools_repro, only: supeq,sup,inf,infeq,eq,indist
use type_bpar, only: bpar_type
use type_cmat_blk, only: cmat_blk_type
use type_com, only: com_type
use type_geom, only: geom_type
use type_io, only: io_type
use type_linop, only: linop_type
use type_mesh, only: mesh_type
use type_mpl, only: mpl_type
use type_nam, only: nam_type
use type_nicas_cmp, only: nicas_cmp
@:use_probe()
use type_rng, only: rng_type
use type_tree, only: tree_type

implicit none

! NICAS block derived type
type nicas_blk_type
   ! General parameters
   integer :: ib                                        !< Block index
   logical :: anisotropic                               !< Anisotropic tensor flag
   logical :: var2d                                     !< Flag for 2D variables in 3D fields

   ! I/O IDs
   integer :: ncid                                      !< main ID

   ! NICAS components
   integer :: ncmp
   type(nicas_cmp),allocatable :: cmp(:)

   ! Block weight
   real(kind_real) :: wgt                               !< Main weight
contains
   procedure :: partial_dealloc => nicas_blk_partial_dealloc
   procedure :: dealloc => nicas_blk_dealloc
   procedure :: read_local => nicas_blk_read_local
   procedure :: write_local_def => nicas_blk_write_local_def
   procedure :: write_local_data => nicas_blk_write_local_data
   procedure :: buffer_size => nicas_blk_buffer_size
   procedure :: serialize => nicas_blk_serialize
   procedure :: deserialize => nicas_blk_deserialize
   procedure :: read_global => nicas_blk_read_global
   procedure :: write_global_def => nicas_blk_write_global_def
   procedure :: write_global_data => nicas_blk_write_global_data
   procedure :: write_grids_def => nicas_blk_write_grids_def
   procedure :: write_grids_data => nicas_blk_write_grids_data
   procedure :: nicas_blk_compute_parameters
   procedure :: nicas_blk_compute_parameters_horizontal_smoother
   generic :: compute_parameters => nicas_blk_compute_parameters,nicas_blk_compute_parameters_horizontal_smoother
   procedure :: copy_cmat => nicas_blk_copy_cmat
   procedure :: compute_vertical => nicas_blk_compute_vertical
   procedure :: compute_horizontal => nicas_blk_compute_horizontal
   procedure :: compute_convol => nicas_blk_compute_convol
   procedure :: compute_convol_network => nicas_blk_compute_convol_network
   procedure :: compute_convol_distance => nicas_blk_compute_convol_distance
   procedure :: compute_convol_weights => nicas_blk_compute_convol_weights
   procedure :: compute_internal_normalization => nicas_blk_compute_internal_normalization
   procedure :: compute_normalization => nicas_blk_compute_normalization
   procedure :: apply => nicas_blk_apply
   procedure :: apply_sqrt => nicas_blk_apply_sqrt
   procedure :: apply_sqrt_ad => nicas_blk_apply_sqrt_ad
   procedure :: apply_convol_sqrt => nicas_blk_apply_convol_sqrt
   procedure :: apply_convol_sqrt_ad => nicas_blk_apply_convol_sqrt_ad
   procedure :: apply_interp => nicas_blk_apply_interp
   procedure :: apply_interp_ad => nicas_blk_apply_interp_ad
   procedure :: apply_interp_horizontal => nicas_blk_apply_interp_horizontal
   procedure :: apply_interp_horizontal_ad => nicas_blk_apply_interp_horizontal_ad
   procedure :: apply_interp_vertical => nicas_blk_apply_interp_vertical
   procedure :: apply_interp_vertical_ad => nicas_blk_apply_interp_vertical_ad
   procedure :: test_adjoint => nicas_blk_test_adjoint
   procedure :: test_normalization => nicas_blk_test_normalization
   procedure :: test_dirac => nicas_blk_test_dirac
end type nicas_blk_type

private
public :: nicas_blk_type

contains

!----------------------------------------------------------------------
! Subroutine: nicas_blk_partial_dealloc
!> Release memory (partial)
!----------------------------------------------------------------------
subroutine nicas_blk_partial_dealloc(nicas_blk)

implicit none

! Passed variables
class(nicas_blk_type),intent(inout) :: nicas_blk !< NICAS data block

! Local variables
integer :: icmp

! Set name
@:set_name(nicas_blk_partial_dealloc)

! Probe in
@:probe_in()

! Release memory
if (allocated(nicas_blk%cmp)) then
   do icmp=1,nicas_blk%ncmp
      call nicas_blk%cmp(icmp)%partial_delloc
   end do
end if

! Probe out
@:probe_out()

end subroutine nicas_blk_partial_dealloc

!----------------------------------------------------------------------
! Subroutine: nicas_blk_dealloc
!> Release memory (full)
!----------------------------------------------------------------------
subroutine nicas_blk_dealloc(nicas_blk)

implicit none

! Passed variables
class(nicas_blk_type),intent(inout) :: nicas_blk !< NICAS data block

! Local variables
integer :: icmp

! Set name
@:set_name(nicas_blk_dealloc)

! Probe in
@:probe_in()

! Release memory
call nicas_blk%partial_dealloc
if (allocated(nicas_blk%cmp)) then
   do icmp=1,nicas_blk%ncmp
      call nicas_blk%cmp(icmp)%dealloc
   end do
   deallocate(nicas_blk%cmp)
end if

! Probe out
@:probe_out()

end subroutine nicas_blk_dealloc

!----------------------------------------------------------------------
! Subroutine: nicas_blk_read_local
!> Read local for global I/O
!----------------------------------------------------------------------
subroutine nicas_blk_read_local(nicas_blk,mpl,nam,geom,bpar)

implicit none

! Passed variables
class(nicas_blk_type),intent(inout) :: nicas_blk !< NICAS data
type(mpl_type),intent(inout) :: mpl              !< MPI data
type(nam_type),intent(in) :: nam                 !< Namelist
type(geom_type),intent(in) :: geom               !< Geometry
type(bpar_type),intent(in) :: bpar               !< Block parameters

! Local variables
integer :: icmp
character(len=1024) :: grpname,cmpname

! Set name
@:set_name(nicas_blk_read_local)

! Probe in
@:probe_in()

! Associate
associate(ib=>nicas_blk%ib)

! Get group name
call nam%io_key_value(bpar%blockname(ib),grpname)
write(mpl%info,'(a13,a)') '','Group '//trim(grpname)
call mpl%flush

! Get group
nicas_blk%grpid = inquire_grp(mpl,nicas_blk%ncid,grpname)

! Read main weight
call get_att(mpl,nicas_blk%grpid,'wgt',nicas_blk%wgt)

! Get number of components
call get_att(mpl,nicas_blk%grpid,'ncmp',nicas_blk%ncmp)

! Allocation
if (.not.allocated(nicas_blk%cmp)) allocate(nicas_blk%cmp(nicas_blk%ncmp))

do icmp=1,nicas_blk%ncmp
   ! Set attributes
   nicas_blk%cmp(icmp)%ib = ib
   nicas_blk%cmp(icmp)%verbosity = .true.
   nicas_blk%cmp(icmp)%smoother = .false.
   nicas_blk%cmp(icmp)%horizontal = .false.
   nicas_blk%cmp(icmp)%compute_norm = (.not.allocated(nicas_blk%cmp(icmp)%norm))

   ! Copy file ID
   nicas_blk%cmp(icmp)%ncid = nicas_blk%ncid

   ! Get component name
   write(cmpname,'(a,i1)') 'cmp_',icmp
   write(mpl%info,'(a16,a)') '','Component '//trim(cmpname)
   call mpl%flush

   ! Get group
   nicas_blk%cmp(icmp)%cmpid = inquire_grp(mpl,nicas_blk%grpid,cmpname)

   ! Component work
   call nicas_blk%cmp(icmp)%read_local(mpl,nam,geom,bpar)
end do

! End associate
end associate

! Probe out
@:probe_out()

end subroutine nicas_blk_read_local

!----------------------------------------------------------------------
! Subroutine: nicas_blk_write_local_def
!> Write data for local I/O, definition mode
!----------------------------------------------------------------------
subroutine nicas_blk_write_local_def(nicas_blk,mpl,nam,bpar)

implicit none

! Passed variables
class(nicas_blk_type),intent(inout) :: nicas_blk !< NICAS data block
type(mpl_type),intent(inout) :: mpl              !< MPI data
type(nam_type),intent(in) :: nam                 !< Namelist
type(bpar_type),intent(in) :: bpar               !< Block parameters

! Local variables
integer :: icmp
character(len=1024) :: grpname,cmpname

! Set name
@:set_name(nicas_blk_write_local_def)

! Probe in
@:probe_in()

! Associate
associate(ib=>nicas_blk%ib)

! Get group name
call nam%io_key_value(bpar%blockname(ib),grpname)
write(mpl%info,'(a13,a)') '','Group '//trim(grpname)
call mpl%flush

! Define group
nicas_blk%grpid = define_grp(mpl,nicas_blk%ncid,grpname)

! Write main weight
call put_att(mpl,nicas_blk%grpid,'wgt',nicas_blk%wgt)

do icmp=1,nicas_blk%ncmp
   ! Get component name
   write(cmpname,'(a,i1)') 'cmp_',icmp
   write(mpl%info,'(a16,a)') '','Component '//trim(cmpname)
   call mpl%flush

   ! Define component
   nicas_blk%cmp(icmp)%cmpid = define_grp(mpl,nicas_blk%grpid,cmpname)

   ! Component work
   call nicas_blk%cmp(icmp)%write_local_def(mpl,nam,bpar)
end do

! End associate
end associate

! Probe out
@:probe_out()

end subroutine nicas_blk_write_local_def

!----------------------------------------------------------------------
! Subroutine: nicas_blk_write_local_data
!> Write data for local I/O, data mode
!----------------------------------------------------------------------
subroutine nicas_blk_write_local_data(nicas_blk,mpl,geom,bpar)

implicit none

! Passed variables
class(nicas_blk_type),intent(in) :: nicas_blk !< NICAS data block
type(mpl_type),intent(inout) :: mpl           !< MPI data
type(geom_type),intent(in) :: geom            !< Geometry
type(bpar_type),intent(in) :: bpar            !< Block parameters

! Local variables
integer :: icmp

! Set name
@:set_name(nicas_blk_write_local_data)

! Probe in
@:probe_in()

do icmp=1,nicas_blk%ncmp
   ! Component work
   call nicas_blk%cmp(icmp)%write_local_data(mpl,geom,bpar)
end do

! Probe out
@:probe_out()

end subroutine nicas_blk_write_local_data

!----------------------------------------------------------------------
! Subroutine: nicas_blk_buffer_size
!> Buffer size
!----------------------------------------------------------------------
subroutine nicas_blk_buffer_size(nicas_blk,mpl,geom,bpar,nbufi,nbufr,nbufl)

implicit none

! Passed variables
class(nicas_blk_type),intent(in) :: nicas_blk !< NICAS data block
type(mpl_type),intent(inout) :: mpl           !< MPI data
type(geom_type),intent(in) :: geom            !< Geometry
type(bpar_type),intent(in) :: bpar            !< Block parameters
integer,intent(out) :: nbufi                  !< Buffer size (integer)
integer,intent(out) :: nbufr                  !< Buffer size (real)
integer,intent(out) :: nbufl                  !< Buffer size (logical)

! Local variables
integer :: nnbufi,nnbufr
integer :: il1

! Set name
@:set_name(nicas_blk_buffer_size)

! Probe in
@:probe_in()

! Associate
associate(ib=>nicas_blk%ib)

! Initialization
nbufi = 0
nbufr = 0
nbufl = 0

! Total dimensions
nbufi = nbufi+4

do icmp=1,nicas_blk%ncmp
   ! Component work
   call nicas_blk%cmp(icmp)%buffer_size(mpl,geom,bpar,nbufi,nbufr,nbufl)
end do

! wgt
nbufr = nbufr+1

! End associate
end associate

! Probe out
@:probe_out()

end subroutine nicas_blk_buffer_size

!----------------------------------------------------------------------
! Subroutine: nicas_blk_serialize
!> Serialize
!----------------------------------------------------------------------
subroutine nicas_blk_serialize(nicas_blk,mpl,geom,bpar,nbufi,nbufr,nbufl,bufi,bufr,bufl)

implicit none

! Passed variables
class(nicas_blk_type),intent(in) :: nicas_blk !< NICAS data block
type(mpl_type),intent(inout) :: mpl           !< MPI data
type(geom_type),intent(in) :: geom            !< Geometry
type(bpar_type),intent(in) :: bpar            !< Block parameters
integer,intent(in) :: nbufi                   !< Buffer size (integer)
integer,intent(in) :: nbufr                   !< Buffer size (real)
integer,intent(in) :: nbufl                   !< Buffer size (logical)
integer,intent(out) :: bufi(nbufi)            !< Buffer (integer)
real(kind_real),intent(out) :: bufr(nbufr)    !< Buffer (real)
logical,intent(out) :: bufl(nbufl)            !< Buffer (logical)

! Local variables
integer :: ibufi,ibufr,ibufl,nnbufi,nnbufr
integer :: il1

! Set name
@:set_name(nicas_blk_serialize)

! Probe in
@:probe_in()

! Associate
associate(ib=>nicas_blk%ib)

! Initialization
ibufi = 0
ibufr = 0
ibufl = 0

! Total dimensions
bufi(ibufi+1) = nicas_blk%ncmp
ibufi = ibufi+1
bufi(ibufi+1) = nbufi
ibufi = ibufi+1
bufi(ibufi+1) = nbufr
ibufi = ibufi+1
bufi(ibufi+1) = nbufl
ibufi = ibufi+1

do icmp=1,nicas_blk%ncmp
   ! Component work
   call nicas_blk%cmp(icmp)%serialize(mpl,geom,bpar,nbufi,nbufr,nbufl,ibufi,ibufr,ibufl,bufi,bufr,bufl)
end do

! wgt
bufr(ibufr+1) = nicas_blk%wgt
ibufr = ibufr+1

! Check sizes
if (ibufi/=nbufi) call mpl%abort('${subr}$','inconsistent final offset/buffer size (integer)')
if (ibufr/=nbufr) call mpl%abort('${subr}$','inconsistent final offset/buffer size (real)')
if (ibufl/=nbufl) call mpl%abort('${subr}$','inconsistent final offset/buffer size (logical)')

! End associate
end associate

! Probe out
@:probe_out()

end subroutine nicas_blk_serialize

!----------------------------------------------------------------------
! Subroutine: nicas_blk_deserialize
!> Deserialize
!----------------------------------------------------------------------
subroutine nicas_blk_deserialize(nicas_blk,mpl,geom,bpar,nbufi,nbufr,nbufl,bufi,bufr,bufl)

implicit none

! Passed variables
class(nicas_blk_type),intent(inout) :: nicas_blk !< NICAS data block
type(mpl_type),intent(inout) :: mpl              !< MPI data
type(geom_type),intent(in) :: geom               !< Geometry
type(bpar_type),intent(in) :: bpar               !< Block parameters
integer,intent(in) :: nbufi                      !< Buffer size (integer)
integer,intent(in) :: nbufr                      !< Buffer size (real)
integer,intent(in) :: nbufl                      !< Buffer size (logical)
integer,intent(in) :: bufi(nbufi)                !< Buffer (integer)
real(kind_real),intent(in) :: bufr(nbufr)        !< Buffer (real)
logical,intent(in) :: bufl(nbufl)                !< Buffer (logical)

! Local variables
integer :: ibufi,ibufr,ibufl,nnbufi,nnbufr
integer :: il1

! Set name
@:set_name(nicas_blk_deserialize)

! Probe in
@:probe_in()

! Associate
associate(ib=>nicas_blk%ib)

! Initialization
ibufi = 0
ibufr = 0
ibufl = 0

! Get number of components
nicas_blk%ncmp = bufi(ibufi+1)
ibufi = ibufi+1

! Allocation
if (.not.allocated(nicas_blk%cmp)) allocate(nicas_blk%cmp(nicas_blk%ncmp))

do icmp=1,nicas_blk%ncmp
   ! Set attributes
   nicas_blk%cmp(icmp)%ib = ib
   nicas_blk%cmp(icmp)%verbosity = .true.
   nicas_blk%cmp(icmp)%smoother = .false.
   nicas_blk%cmp(icmp)%horizontal = .false.
   nicas_blk%cmp(icmp)%compute_norm = (.not.allocated(nicas_blk%cmp(icmp)%norm))
end do

! Check sizes
if (bufi(ibufi+1)/=nbufi) call mpl%abort('${subr}$','inconsistent initial value/buffer size (integer)')
ibufi = ibufi+1
if (bufi(ibufi+1)/=nbufr) call mpl%abort('${subr}$','inconsistent initial value/buffer size (real)')
ibufi = ibufi+1
if (bufi(ibufi+1)/=nbufl) call mpl%abort('${subr}$','inconsistent initial value/buffer size (logical)')
ibufi = ibufi+1

do icmp=1,nicas_blk%ncmp
   ! Component work
   call nicas_blk%cmp(icmp)%deserialize(mpl,geom,bpar,nbufi,nbufr,nbufl,ibufi,ibufr,ibufl,bufi,bufr,bufl)
end do

! wgt
nicas_blk%wgt = bufr(ibufr+1)
ibufr = ibufr+1

! End associate
end associate

! Probe out
@:probe_out()

end subroutine nicas_blk_deserialize

!----------------------------------------------------------------------
! Subroutine: nicas_blk_read_global
!> Read data for global I/O
!----------------------------------------------------------------------
subroutine nicas_blk_read_global(nicas_blk,mpl,nam,geom,bpar)

implicit none

! Passed variables
class(nicas_blk_type),intent(inout) :: nicas_blk !< NICAS data
type(mpl_type),intent(inout) :: mpl              !< MPI data
type(nam_type),intent(in) :: nam                 !< Namelist
type(geom_type),intent(in) :: geom               !< Geometry
type(bpar_type),intent(in) :: bpar               !< Block parameters

! Local variables
integer :: icmp
character(len=1024) :: grpname,cmpname

! Set name
@:set_name(nicas_blk_read_global)

! Probe in
@:probe_in()

! Associate
associate(ib=>nicas_blk%ib)

! Get group name
call nam%io_key_value(bpar%blockname(ib),grpname)
write(mpl%info,'(a13,a)') '','Group '//trim(grpname)
call mpl%flush

! Get group
nicas_blk%grpid = inquire_grp(mpl,nicas_blk%ncid,grpname)

! Read main weight
if (mpl%main) call get_att(mpl,nicas_blk%grpid,'wgt',nicas_cmp%wgt)

! Broadcast main weight
call mpl%f_comm%broadcast(nicas_blk%wgt,mpl%rootproc-1)

! Get number of components
if (mpl%main) call get_att(mpl,nicas_blk%grpid,'ncmp',nicas_blk%ncmp)

! Broadcast number of components
call mpl%f_comm%broadcast(nicas_blk%ncmp,mpl%rootproc-1)

! Allocation
if (.not.allocated(nicas_blk%cmp)) allocate(nicas_blk%cmp(nicas_blk%ncmp))

do icmp=1,nicas_blk%ncmp
   ! Set attributes
   nicas_blk%cmp(icmp)%ib = ib
   nicas_blk%cmp(icmp)%verbosity = .true.
   nicas_blk%cmp(icmp)%smoother = .false.
   nicas_blk%cmp(icmp)%horizontal = .false.
   nicas_blk%cmp(icmp)%compute_norm = (.not.allocated(nicas_blk%cmp(icmp)%norm))

   ! Copy file ID
   nicas_blk%cmp(icmp)%ncid = nicas_blk%ncid

   ! Get component name
   write(cmpname,'(a,i1)') 'cmp_',icmp
   write(mpl%info,'(a16,a)') '','Component '//trim(cmpname)
   call mpl%flush

   ! Get group
   nicas_blk%cmp(icmp)%cmpid = inquire_grp(mpl,nicas_blk%grpid,cmpname)

   ! Component work
   call nicas_blk%cmp(icmp)%read_global(mpl,nam,geom,bpar)
end do

! End associate
end associate

! Probe out
@:probe_out()

end subroutine nicas_blk_read_global

!----------------------------------------------------------------------
! Subroutine: nicas_blk_write_global_def
!> Write data for global I/O, definition mode
!----------------------------------------------------------------------
subroutine nicas_blk_write_global_def(nicas_blk,mpl,nam,geom,bpar)

implicit none

! Passed variables
class(nicas_blk_type),intent(inout) :: nicas_blk !< NICAS data
type(mpl_type),intent(inout) :: mpl              !< MPI data
type(nam_type),intent(in) :: nam                 !< Namelist
type(geom_type),intent(in) :: geom               !< Geometry
type(bpar_type),intent(in) :: bpar               !< Block parameters

! Local variables
integer :: nl1_id,nc1_id,ns_id,c_nopmax_id
integer :: il1,i_s,isa
integer,allocatable :: c_nop(:)
real(kind_real) :: coef_ens_min,coef_ens_max
character(len=1024) :: grpname

! Set name
@:set_name(nicas_blk_write_global_def)

! Probe in
@:probe_in()

! Associate
associate(ib=>nicas_blk%ib)

! Get group name
call nam%io_key_value(bpar%blockname(ib),grpname)
write(mpl%info,'(a10,a)') '','Group '//trim(grpname)//':'
call mpl%flush

! Define group
nicas_blk%grpid = define_grp(mpl,nicas_blk%ncid,grpname)

! Write main weight
call put_att(mpl,nicas_blk%grpid,'wgt',nicas_blk%wgt)

do icmp=1,nicas_blk%ncmp
   ! Get component name
   write(cmpname,'(a,i1)') 'cmp_',icmp
   write(mpl%info,'(a16,a)') '','Component '//trim(cmpname)
   call mpl%flush

   ! Define component
   nicas_blk%cmp(icmp)%cmpid = define_grp(mpl,nicas_blk%grpid,cmpname)

   ! Component work
   call nicas_blk%cmp(icmp)%write_global_def(mpl,nam,geom,bpar)
end do

! End associate
end associate

! Probe out
@:probe_out()

end subroutine nicas_blk_write_global_def

!----------------------------------------------------------------------
! Subroutine: nicas_blk_write_global_data
!> Write data for global I/O, data mode
!----------------------------------------------------------------------
subroutine nicas_blk_write_global_data(nicas_blk,mpl,nam,geom,bpar)

implicit none

! Passed variables
class(nicas_blk_type),intent(inout) :: nicas_blk !< NICAS data
type(mpl_type),intent(inout) :: mpl              !< MPI data
type(nam_type),intent(in) :: nam                 !< Namelist
type(geom_type),intent(in) :: geom               !< Geometry
type(bpar_type),intent(in) :: bpar               !< Block parameters

! Local variables
integer :: icmp

! Set name
@:set_name(nicas_blk_write_global_data)

! Probe in
@:probe_in()

! Associate
associate(ib=>nicas_blk%ib)

do icmp=1,nicas_blk%ncmp
   ! Component work
   call nicas_blk%cmp(icmp)%write_global_data(mpl,nam,geom,bpar)
end do

! End associate
end associate

! Probe out
@:probe_out()

end subroutine nicas_blk_write_global_data

!----------------------------------------------------------------------
! Subroutine: nicas_blk_write_grids_def
!> Write NICAS grids, definition mode
!----------------------------------------------------------------------
subroutine nicas_blk_write_grids_def(nicas_blk,mpl,nam,bpar)

implicit none

! Passed variables
class(nicas_blk_type),intent(inout) :: nicas_blk !< NICAS data block
type(mpl_type),intent(inout) :: mpl              !< MPI data
type(nam_type),intent(in) :: nam                 !< Namelist
type(bpar_type),intent(in) :: bpar               !< Block parameters

! Local variables
integer :: nsa_id,nsb_id,nsc_id
character(len=1024) :: grpname

! Set name
@:set_name(nicas_blk_write_grids_def)

! Probe in
@:probe_in()

! Associate
associate(ib=>nicas_blk%ib)

! Get group name
call nam%io_key_value(bpar%blockname(ib),grpname)
write(mpl%info,'(a10,a)') '','Group '//trim(grpname)//':'
call mpl%flush

! Define group
nicas_blk%grpid = define_grp(mpl,nicas_blk%ncid,grpname)

do icmp=1,nicas_blk%ncmp
   ! Get component name
   write(cmpname,'(a,i1)') 'cmp_',icmp
   write(mpl%info,'(a16,a)') '','Component '//trim(cmpname)
   call mpl%flush

   ! Define component
   nicas_blk%cmp(icmp)%cmpid = define_grp(mpl,nicas_blk%grpid,cmpname)

   ! Component work
   call nicas_blk%cmp(icmp)%write_grids_def(mpl,nam,bpar)
end do

! End associate
end associate

! Probe out
@:probe_out()

end subroutine nicas_blk_write_grids_def

!----------------------------------------------------------------------
! Subroutine: nicas_blk_write_grids_data
!> Write NICAS grids, data mode
!----------------------------------------------------------------------
subroutine nicas_blk_write_grids_data(nicas_blk,mpl,nam)

implicit none

! Passed variables
class(nicas_blk_type),intent(in) :: nicas_blk !< NICAS data block
type(mpl_type),intent(inout) :: mpl           !< MPI data
type(nam_type),intent(in) :: nam              !< Namelist

! Local variables
integer :: isa,isb,isc,isu,ic1a,ic1u,il1,il0
real(kind_real) :: lon_sa(nicas_blk%nsa),lat_sa(nicas_blk%nsa),lev_sa(nicas_blk%nsa)
real(kind_real) :: lon_sb(nicas_blk%nsb),lat_sb(nicas_blk%nsb),lev_sb(nicas_blk%nsb)
real(kind_real) :: lon_sc(nicas_blk%nsc),lat_sc(nicas_blk%nsc),lev_sc(nicas_blk%nsc)

! Set name
@:set_name(nicas_blk_write_grids_data)

! Probe in
@:probe_in()

do icmp=1,nicas_blk%ncmp
   ! Component work
   call nicas_blk%cmp(icmp)%write_grids_data(mpl,nam)
end do

! Probe out
@:probe_out()

end subroutine nicas_blk_write_grids_data

!----------------------------------------------------------------------
! Subroutine: nicas_blk_compute_parameters
!> Compute NICAS parameters
!----------------------------------------------------------------------
subroutine nicas_blk_compute_parameters(nicas_blk,mpl,rng,nam,geom)

implicit none

! Passed variables
class(nicas_blk_type),intent(inout) :: nicas_blk !< NICAS data block
type(mpl_type),intent(inout) :: mpl              !< MPI data
type(rng_type),intent(inout) :: rng              !< Random number generator
type(nam_type),intent(in) :: nam                 !< Namelist
type(geom_type),intent(in) :: geom               !< Geometry

! Local variables
integer :: icmp

! Set name
@:set_name(nicas_blk_compute_parameters)

! Probe in
@:probe_in()

! Associate
associate(ib=>nicas_blk%ib)

! Allocation
if (.not.allocated(nicas_blk%cmp)) allocate(nicas_blk%cmp(nicas_blk%ncmp))

do icmp=1,nicas_blk%ncmp
   ! Set attributes
   nicas_blk%cmp(icmp)%ib = ib
   nicas_blk%cmp(icmp)%verbosity = .true.
   nicas_blk%cmp(icmp)%smoother = .false.
   nicas_blk%cmp(icmp)%horizontal = .false.
   nicas_blk%cmp(icmp)%compute_norm = (.not.allocated(nicas_blk%cmp(icmp)%norm))

   ! Component work
   call nicas_blk%cmp(icmp)%compute_parameters(mpl,rng,nam,geom)
end do

! End associate
end associate

! Probe out
@:probe_out()

end subroutine nicas_blk_compute_parameters

!----------------------------------------------------------------------
! Subroutine: nicas_blk_compute_parameters_horizontal_smoother
!> Compute NICAS parameters for a horizontal smoother
!----------------------------------------------------------------------
subroutine nicas_blk_compute_parameters_horizontal_smoother(nicas_blk,mpl,rng,nam,geom,rhflt)

implicit none

! Passed variables
class(nicas_blk_type),intent(inout) :: nicas_blk !< NICAS data block
type(mpl_type),intent(inout) :: mpl              !< MPI data
type(rng_type),intent(inout) :: rng              !< Random number generator
type(nam_type),intent(in) :: nam                 !< Namelist
type(geom_type),intent(in) :: geom               !< Geometry
real(kind_real),intent(in) :: rhflt(geom%nl0)    !< Horizontal support radius profile

! Local variables
integer,parameter :: icmp = 1

! Set name
@:set_name(nicas_blk_compute_parameters_horizontal_smoother)

! Probe in
@:probe_in()

! Associate
associate(ib=>nicas_blk%ib)

! Allocation
nicas_blk%ncmp = 1
allocate(nicas_blk%cmp(nicas_blk%ncmp))

! Set attributes
nicas_blk%cmp(icmp)%ib = ib
nicas_cmp%wgt = one

! Component work
call nicas_blk%cmp(icmp)%compute_parameters(mpl,mpl,rng,nam,geom,rhflt)

! End associate
end associate

! Probe out
@:probe_out()

end subroutine nicas_blk_compute_parameters_horizontal_smoother

!----------------------------------------------------------------------
! Subroutine: nicas_blk_copy_cmat
!> Copy C matrix data
!----------------------------------------------------------------------
subroutine nicas_blk_copy_cmat(nicas_blk,mpl,nam,geom,bpar,cmat_blk)

implicit none

! Passed variables
class(nicas_blk_type),intent(inout) :: nicas_blk !< NICAS data block
type(mpl_type),intent(inout) :: mpl              !< MPI data
type(nam_type),intent(in) :: nam                 !< Namelist
type(geom_type),intent(in) :: geom               !< Geometry
type(bpar_type),intent(in) :: bpar               !< Block parameters
type(cmat_blk_type),intent(in) :: cmat_blk       !< C matrix data block

! Local variables
integer :: iv,ic0a,il0
real(kind_real) :: rhs_max
character(len=1024) :: message

! Set name
@:set_name(nicas_blk_copy_cmat)

! Probe in
@:probe_in()

! Associate
associate(ib=>nicas_blk%ib)

! Copy number of components
nicas_blk%ncmp = cmat_blk%ncmp

! Allocation
if (.not.allocated(nicas_blk%cmp)) allocate(nicas_blk%cmp(nicas_blk%ncmp))

! TODO: correct length-scales depending on icomp

do icmp=1,nicas_blk%ncmp
   ! Set anisotropic parameter
   nicas_blk%cmp(icmp)%anisotropic = allocated(cmat_blk%D11).and.allocated(cmat_blk%D22).and.allocated(cmat_blk%D12)

   ! Allocation
   allocate(nicas%blk(ib)%coef_ens(geom%nc0a,geom%nl0))
   allocate(nicas_blk%cmp(icmp)%rh(geom%nc0a,geom%nl0))
   if (nicas_blk%cmp(icmp)%anisotropic) then
      allocate(nicas_blk%cmp(icmp)%H11(geom%nc0a,geom%nl0))
      allocate(nicas_blk%cmp(icmp)%H22(geom%nc0a,geom%nl0))
      allocate(nicas_blk%cmp(icmp)%H12(geom%nc0a,geom%nl0))
   end if
   allocate(nicas_blk%cmp(icmp)%rv(geom%nc0a,geom%nl0))
   allocate(nicas_blk%cmp(icmp)%rhs(geom%nc0a,geom%nl0))
   allocate(nicas_blk%cmp(icmp)%rvs(geom%nc0a,geom%nl0))

   ! Initialization
   nicas%blk(ib)%coef_ens = mpl%msv%valr
   nicas_blk%cmp(icmp)%rh = mpl%msv%valr
   if (nicas_blk%cmp(icmp)%anisotropic) then
      nicas_blk%cmp(icmp)%H11 = mpl%msv%valr
      nicas_blk%cmp(icmp)%H22 = mpl%msv%valr
      nicas_blk%cmp(icmp)%H12 = mpl%msv%valr
   end if
   nicas_blk%cmp(icmp)%rv = mpl%msv%valr
   nicas_blk%cmp(icmp)%rhs = mpl%msv%valr
   nicas_blk%cmp(icmp)%rvs = mpl%msv%valr

   ! Copy C matrix fields from min_lev to max_lev
   iv = bpar%b_to_v1(ib)
   do il0=1,geom%nl0
      if ((nam%min_lev(iv)<=il0).and.(il0<=nam%max_lev(iv))) then
         nicas_blk%cmp(icmp)%coef_ens(:,il0) = cmat_blk%coef_ens(:,il0)
         nicas_blk%cmp(icmp)%rh(:,il0) = cmat_blk%rh(:,il0)
         if (nicas_blk%cmp(icmp)%anisotropic) then
            do ic0a=1,geom%nc0a
               call tensor_d2h(mpl,cmat_blk%D11(ic0a,il0),cmat_blk%D22(ic0a,il0),cmat_blk%D12(ic0a,il0), &
 & nicas_blk%cmp(icmp)%H11(ic0a,il0),nicas_blk%cmp(icmp)%H22(ic0a,il0),nicas_blk%cmp(icmp)%H12(ic0a,il0))
            end do
         end if
         nicas_blk%cmp(icmp)%rv(:,il0) = cmat_blk%rv(:,il0)
         nicas_blk%cmp(icmp)%rhs(:,il0) = cmat_blk%rhs(:,il0)
         nicas_blk%cmp(icmp)%rvs(:,il0) = cmat_blk%rvs(:,il0)
      end if
   end do

   ! Check horizontal support radius vs. universe radius
   if (geom%nc0a>0) then
      rhs_max = zero
      if (any(geom%gmask_c0a.and.mpl%msv%isnot(nicas_blk%cmp(icmp)%rhs))) rhs_max = zss_maxval(nicas_blk%cmp(icmp)%rhs, &
 & mask=(geom%gmask_c0a.and.mpl%msv%isnot(nicas_blk%cmp(icmp)%rhs)))
      if (rhs_max>nam%universe_rad) then
         write(message,'(a,f10.2,a)') 'horizontal support radius (',rhs_max*reqkm,' km) larger than universe radius'
         call mpl%warning('${subr}$',message)
      end if
   end if
end do

! End associate
end associate

! Probe out
@:probe_out()

end subroutine nicas_blk_copy_cmat

!----------------------------------------------------------------------
! Subroutine: nicas_blk_apply
!> Apply NICAS method
!----------------------------------------------------------------------
subroutine nicas_blk_apply(nicas_blk,mpl,geom,fld)

implicit none

! Passed variables
class(nicas_blk_type),intent(in) :: nicas_blk            !< NICAS data block
type(mpl_type),intent(inout) :: mpl                      !< MPI data
type(geom_type),intent(in) :: geom                       !< Geometry
real(kind_real),intent(inout) :: fld(geom%nc0a,geom%nl0) !< Field

! Local variables
integer :: il0
real(kind_real) :: sums(geom%nl0),sume(geom%nl0)
real(kind_real) :: alpha_a(nicas_blk%nsa),alpha_b(nicas_blk%nsb),alpha_c(nicas_blk%nsc)

! Set name
@:set_name(nicas_blk_apply)

! Probe in
@:probe_in()

if (nicas_blk%smoother) then
   ! Save global sum for each level
   do il0=1,geom%nl0
      sums(il0) = zss_sum(fld(:,il0),mask=geom%gmask_c0a(:,il0))
   end do
   call mpl%f_comm%allreduce(sums,fckit_mpi_sum())

   ! Adjoint interpolation
   call nicas_blk%apply_interp_ad(mpl,geom,fld,alpha_b)

   ! Apply adjoint linear operator
   call nicas_blk%c%apply_ad(mpl,alpha_b,alpha_c)

   ! Halo reduction from zone C to zone A
   call nicas_blk%com_s_AC%red(mpl,alpha_c,alpha_a)

   ! Halo extension from zone A to zone B
   call nicas_blk%com_s_AB%ext(mpl,alpha_a,alpha_b)

   ! Interpolation
   call nicas_blk%apply_interp(mpl,geom,alpha_b,fld)

   ! Reset global sum for each level
   do il0=1,geom%nl0
      sume(il0) = zss_sum(fld(:,il0),mask=geom%gmask_c0a(:,il0))
   end do
   call mpl%f_comm%allreduce(sume,fckit_mpi_sum())
   do il0=1,geom%nl0
      fld(:,il0) = fld(:,il0)*sums(il0)/sume(il0)
   end do
else
   ! Apply square-root adjoint
   call nicas_blk%apply_sqrt_ad(mpl,geom,fld,alpha_a)

   ! Apply square-root
   call nicas_blk%apply_sqrt(mpl,geom,alpha_a,fld)
end if

! Probe out
@:probe_out()

end subroutine nicas_blk_apply

!----------------------------------------------------------------------
! Subroutine: nicas_blk_apply_sqrt
!> Apply NICAS method square-root
!----------------------------------------------------------------------
subroutine nicas_blk_apply_sqrt(nicas_blk,mpl,geom,alpha,fld)

implicit none

! Passed variables
class(nicas_blk_type),intent(in) :: nicas_blk          !< NICAS data block
type(mpl_type),intent(inout) :: mpl                    !< MPI data
type(geom_type),intent(in) :: geom                     !< Geometry
real(kind_real),intent(in) :: alpha(nicas_blk%nsa)     !< Subgrid field
real(kind_real),intent(out) :: fld(geom%nc0a,geom%nl0) !< Field

! Local variable
integer :: ic0a,il0
real(kind_real) :: alpha_a(nicas_blk%nsa),alpha_b(nicas_blk%nsb)

! Set name
@:set_name(nicas_blk_apply_sqrt)

! Probe in
@:probe_in()

! Convolution square-root
alpha_a = alpha
call nicas_blk%apply_convol_sqrt(mpl,alpha_a)

! Halo extension from zone A to zone B
call nicas_blk%com_s_AB%ext(mpl,alpha_a,alpha_b)

! Interpolation
call nicas_blk%apply_interp(mpl,geom,alpha_b,fld)

! Normalization
fld = fld*nicas_blk%norm

! Probe out
@:probe_out()

end subroutine nicas_blk_apply_sqrt

!----------------------------------------------------------------------
! Subroutine: nicas_blk_apply_sqrt_ad
!> Apply NICAS method square-root adjoint
!----------------------------------------------------------------------
subroutine nicas_blk_apply_sqrt_ad(nicas_blk,mpl,geom,fld,alpha)

implicit none

! Passed variables
class(nicas_blk_type),intent(in) :: nicas_blk         !< NICAS data block
type(mpl_type),intent(inout) :: mpl                   !< MPI data
type(geom_type),intent(in) :: geom                    !< Geometry
real(kind_real),intent(in) :: fld(geom%nc0a,geom%nl0) !< Field
real(kind_real),intent(out) :: alpha(nicas_blk%nsa)   !< Subgrid field

! Local variable
integer :: ic0a,il0
real(kind_real) :: fld_tmp(geom%nc0a,geom%nl0),alpha_b(nicas_blk%nsb)

! Set name
@:set_name(nicas_blk_apply_sqrt_ad)

! Probe in
@:probe_in()

! Initialization
fld_tmp = fld

! Normalization
fld_tmp = fld_tmp*nicas_blk%norm

! Adjoint interpolation
call nicas_blk%apply_interp_ad(mpl,geom,fld_tmp,alpha_b)

! Halo reduction from zone B to zone A
call nicas_blk%com_s_AB%red(mpl,alpha_b,alpha)

! Convolution square-root adjoint
call nicas_blk%apply_convol_sqrt_ad(mpl,alpha)

! Probe out
@:probe_out()

end subroutine nicas_blk_apply_sqrt_ad

!----------------------------------------------------------------------
! Subroutine: nicas_blk_apply_convol_sqrt
!> Apply convoltion square-root
!----------------------------------------------------------------------
subroutine nicas_blk_apply_convol_sqrt(nicas_blk,mpl,alpha)

implicit none

! Passed variables
class(nicas_blk_type),intent(in) :: nicas_blk         !< NICAS data block
type(mpl_type),intent(inout) :: mpl                   !< MPI data
real(kind_real),intent(inout) :: alpha(nicas_blk%nsa) !< Subgrid field

! Local variables
real(kind_real) :: alpha_c(nicas_blk%nsc)

! Set name
@:set_name(nicas_blk_apply_convol_sqrt)

! Probe in
@:probe_in()

! Halo extension from zone A to zone C
call nicas_blk%com_s_AC%ext(mpl,alpha,alpha_c)

! Convolution
call nicas_blk%c%apply(mpl,alpha_c,alpha)

! Internal normalization
alpha = alpha*nicas_blk%inorm

! Probe out
@:probe_out()

end subroutine nicas_blk_apply_convol_sqrt

!----------------------------------------------------------------------
! Subroutine: nicas_blk_apply_convol_sqrt_ad
!> Apply convoltion square-root, adjoint
!----------------------------------------------------------------------
subroutine nicas_blk_apply_convol_sqrt_ad(nicas_blk,mpl,alpha)

implicit none

! Passed variables
class(nicas_blk_type),intent(in) :: nicas_blk         !< NICAS data block
type(mpl_type),intent(inout) :: mpl                   !< MPI data
real(kind_real),intent(inout) :: alpha(nicas_blk%nsa) !< Subgrid field

! Local variables
real(kind_real) :: alpha_c(nicas_blk%nsc)

! Set name
@:set_name(nicas_blk_apply_convol_sqrt_ad)

! Probe in
@:probe_in()

! Internal normalization
alpha = alpha*nicas_blk%inorm

! Convolution
call nicas_blk%c%apply_ad(mpl,alpha,alpha_c)

! Halo reduction from zone C to zone A
call nicas_blk%com_s_AC%red(mpl,alpha_c,alpha)

! Probe out
@:probe_out()

end subroutine nicas_blk_apply_convol_sqrt_ad

!----------------------------------------------------------------------
! Subroutine: nicas_blk_apply_interp
!> Apply interpolation
!----------------------------------------------------------------------
subroutine nicas_blk_apply_interp(nicas_blk,mpl,geom,alpha,fld)

implicit none

! Passed variables
class(nicas_blk_type),intent(in) :: nicas_blk          !< NICAS data block
type(mpl_type),intent(inout) :: mpl                    !< MPI data
type(geom_type),intent(in) :: geom                     !< Geometry
real(kind_real),intent(in) :: alpha(nicas_blk%nsb)     !< Subgrid field
real(kind_real),intent(out) :: fld(geom%nc0a,geom%nl0) !< Field

! Local variables
real(kind_real) :: gamma(geom%nc0a,nicas_blk%nl1)

! Set name
@:set_name(nicas_blk_apply_interp)

! Probe in
@:probe_in()

! Horizontal interpolation
call nicas_blk%apply_interp_horizontal(mpl,geom,alpha,gamma)

! Vertical interpolation
call nicas_blk%apply_interp_vertical(mpl,geom,gamma,fld)

! Probe out
@:probe_out()

end subroutine nicas_blk_apply_interp

!----------------------------------------------------------------------
! Subroutine: nicas_blk_apply_interp_ad
!> Apply interpolation adjoint
!----------------------------------------------------------------------
subroutine nicas_blk_apply_interp_ad(nicas_blk,mpl,geom,fld,alpha)

implicit none

! Passed variables
class(nicas_blk_type),intent(in) :: nicas_blk         !< NICAS data block
type(mpl_type),intent(inout) :: mpl                   !< MPI data
type(geom_type),intent(in) :: geom                    !< Geometry
real(kind_real),intent(in) :: fld(geom%nc0a,geom%nl0) !< Field
real(kind_real),intent(out) :: alpha(nicas_blk%nsb)   !< Subgrid field

! Local variables
real(kind_real) :: gamma(geom%nc0a,nicas_blk%nl1)

! Set name
@:set_name(nicas_blk_apply_interp_ad)

! Probe in
@:probe_in()

! Vertical interpolation
call nicas_blk%apply_interp_vertical_ad(mpl,geom,fld,gamma)

! Horizontal interpolation
call nicas_blk%apply_interp_horizontal_ad(mpl,geom,gamma,alpha)

! Probe out
@:probe_out()

end subroutine nicas_blk_apply_interp_ad

!----------------------------------------------------------------------
! Subroutine: nicas_blk_apply_interp_horizontal
!> Apply subsampling interpolation
!----------------------------------------------------------------------
subroutine nicas_blk_apply_interp_horizontal(nicas_blk,mpl,geom,alpha,gamma)

implicit none

! Passed variables
class(nicas_blk_type),intent(in) :: nicas_blk                 !< NICAS data block
type(mpl_type),intent(inout) :: mpl                           !< MPI data
type(geom_type),intent(in) :: geom                            !< Geometry
real(kind_real),intent(in) :: alpha(nicas_blk%nsb)            !< Subgrid field
real(kind_real),intent(out) :: gamma(geom%nc0a,nicas_blk%nl1) !< Subset Sc0 field, subset of levels

! Local variables
integer :: il1,ic1b,isb
real(kind_real),allocatable :: beta(:)

! Set name
@:set_name(nicas_blk_apply_interp_horizontal)

! Probe in
@:probe_in()

!$omp parallel do schedule(static) private(il1,ic1b,isb) firstprivate(beta)
do il1=1,nicas_blk%nl1
   ! Allocation
   allocate(beta(nicas_blk%hor(il1)%nc1b))

   ! Copy
   do ic1b=1,nicas_blk%hor(il1)%nc1b
      isb = nicas_blk%hor(il1)%c1b_to_sb(ic1b)
      beta(ic1b) = alpha(isb)
   end do

   ! Horizontal interpolation
   call nicas_blk%interp_c1b_to_c0a(il1)%apply(mpl,beta,gamma(:,il1),msdst=.false.)

   ! Release memory
   deallocate(beta)
end do
!$omp end parallel do

! Probe out
@:probe_out()

end subroutine nicas_blk_apply_interp_horizontal

!----------------------------------------------------------------------
! Subroutine: nicas_blk_apply_interp_horizontal_ad
!> Apply subsampling interpolation adjoint
!----------------------------------------------------------------------
subroutine nicas_blk_apply_interp_horizontal_ad(nicas_blk,mpl,geom,gamma,alpha)

implicit none

! Passed variables
class(nicas_blk_type),intent(in) :: nicas_blk                !< NICAS data block
type(mpl_type),intent(inout) :: mpl                          !< MPI data
type(geom_type),intent(in) :: geom                           !< Geometry
real(kind_real),intent(in) :: gamma(geom%nc0a,nicas_blk%nl1) !< Subset Sc0 field, subset of levels
real(kind_real),intent(out) :: alpha(nicas_blk%nsb)          !< Subgrid field

! Local variables
integer :: il1,ic1b,isb
real(kind_real),allocatable :: beta(:)

! Set name
@:set_name(nicas_blk_apply_interp_horizontal_ad)

! Probe in
@:probe_in()

!$omp parallel do schedule(static) private(il1,ic1b,isb) firstprivate(beta)
do il1=1,nicas_blk%nl1
   ! Allocation
   allocate(beta(nicas_blk%hor(il1)%nc1b))

   ! Horizontal interpolation
   call nicas_blk%interp_c1b_to_c0a(il1)%apply_ad(mpl,gamma(:,il1),beta)

   ! Copy
   do ic1b=1,nicas_blk%hor(il1)%nc1b
      isb = nicas_blk%hor(il1)%c1b_to_sb(ic1b)
      alpha(isb) = beta(ic1b)
   end do

   ! Release memory
   deallocate(beta)
end do
!$omp end parallel do

! Probe out
@:probe_out()

end subroutine nicas_blk_apply_interp_horizontal_ad

!----------------------------------------------------------------------
! Subroutine: nicas_blk_apply_interp_vertical
!> Apply vertical interpolation
!----------------------------------------------------------------------
subroutine nicas_blk_apply_interp_vertical(nicas_blk,mpl,geom,gamma,fld)

implicit none

! Passed variables
class(nicas_blk_type),intent(in) :: nicas_blk                !< NICAS data block
type(mpl_type),intent(inout) :: mpl                          !< MPI data
type(geom_type),intent(in) :: geom                           !< Geometry
real(kind_real),intent(in) :: gamma(geom%nc0a,nicas_blk%nl1) !< Subset Sc0 field, subset of levels
real(kind_real),intent(out) :: fld(geom%nc0a,geom%nl0)       !< Field

! Local variables
integer :: ic0a,il0
real(kind_real),allocatable :: gamma_tmp(:),fld_tmp(:)

! Set name
@:set_name(nicas_blk_apply_interp_vertical)

! Probe in
@:probe_in()

! Vertical interpolation
!$omp parallel do schedule(static) private(ic0a,il0) firstprivate(gamma_tmp,fld_tmp)
do ic0a=1,geom%nc0a
   ! Allocation
   allocate(gamma_tmp(nicas_blk%nl1))
   allocate(fld_tmp(geom%nl0))

   ! Copy data
   gamma_tmp = gamma(ic0a,:)

   ! Apply interpolation
   call nicas_blk%v%apply(mpl,gamma_tmp,fld_tmp,ivec=ic0a,msdst=.false.)

   ! Copy data
   do il0=1,geom%nl0
      if (nicas_blk%vlev(il0)) fld(ic0a,il0) = fld_tmp(il0)
   end do

   ! Release memory
   deallocate(gamma_tmp)
   deallocate(fld_tmp)
end do
!$omp end parallel do

! Probe out
@:probe_out()

end subroutine nicas_blk_apply_interp_vertical

!----------------------------------------------------------------------
! Subroutine: nicas_blk_apply_interp_vertical_ad
!> Apply vertical interpolation adjoint
!----------------------------------------------------------------------
subroutine nicas_blk_apply_interp_vertical_ad(nicas_blk,mpl,geom,fld,gamma)

implicit none

! Passed variables
class(nicas_blk_type),intent(in) :: nicas_blk                 !< NICAS data block
type(mpl_type),intent(inout) :: mpl                           !< MPI data
type(geom_type),intent(in) :: geom                            !< Geometry
real(kind_real),intent(in) :: fld(geom%nc0a,geom%nl0)         !< Field
real(kind_real),intent(out) :: gamma(geom%nc0a,nicas_blk%nl1) !< Subset Sc0 field, subset of levels

! Local variables
integer :: ic0a
real(kind_real),allocatable :: gamma_tmp(:),fld_tmp(:)

! Set name
@:set_name(nicas_blk_apply_interp_vertical_ad)

! Probe in
@:probe_in()

! Vertical interpolation
!$omp parallel do schedule(static) private(ic0a) firstprivate(gamma_tmp,fld_tmp)
do ic0a=1,geom%nc0a
   ! Allocation
   allocate(gamma_tmp(nicas_blk%nl1))
   allocate(fld_tmp(geom%nl0))

   ! Copy data
   fld_tmp = fld(ic0a,:)

   ! Apply interpolation
   call nicas_blk%v%apply_ad(mpl,fld_tmp,gamma_tmp,ivec=ic0a)

   ! Copy data
   gamma(ic0a,:) = gamma_tmp

   ! Release memory
   deallocate(gamma_tmp)
   deallocate(fld_tmp)
end do
!$omp end parallel do

! Probe out
@:probe_out()

end subroutine nicas_blk_apply_interp_vertical_ad

!----------------------------------------------------------------------
! Subroutine: nicas_blk_test_adjoint
!> Test NICAS adjoint accuracy
!----------------------------------------------------------------------
subroutine nicas_blk_test_adjoint(nicas_blk,mpl,rng,nam,geom,bpar)

implicit none

! Passed variables
class(nicas_blk_type),intent(in) :: nicas_blk !< NICAS data block
type(mpl_type),intent(inout) :: mpl           !< MPI data
type(rng_type),intent(inout) :: rng           !< Random number generator
type(nam_type),intent(in) :: nam              !< Namelist
type(geom_type),intent(in) :: geom            !< Geometry
type(bpar_type),intent(in) :: bpar            !< Block parameters

! Local variables
integer :: iv,il0
real(kind_real) :: sum1,sum2
real(kind_real) :: alpha(nicas_blk%nsb),alpha_save(nicas_blk%nsb),alpha_c(nicas_blk%nsc)
real(kind_real) :: gamma(geom%nc0a,nicas_blk%nl1),gamma_save(geom%nc0a,nicas_blk%nl1)
real(kind_real) :: fld(geom%nc0a,geom%nl0),fld_save(geom%nc0a,geom%nl0)
real(kind_real) :: fld1(geom%nc0a,geom%nl0),fld1_save(geom%nc0a,geom%nl0)
real(kind_real) :: fld2(geom%nc0a,geom%nl0),fld2_save(geom%nc0a,geom%nl0)
real(kind_real),allocatable :: alpha1(:),alpha1_save(:),alpha2(:),alpha2_save(:)

! Set name
@:set_name(nicas_blk_test_adjoint)

! Probe in
@:probe_in()

! Associate
associate(ib=>nicas_blk%ib)

! Variable index
iv = bpar%b_to_v1(ib)

! Interpolation (horizontal)

! Initialization
call rng%rand(zero,one,alpha_save)
call rng%rand(zero,one,gamma_save)

! Adjoint test
call nicas_blk%apply_interp_horizontal(mpl,geom,alpha_save,gamma)
call nicas_blk%apply_interp_horizontal_ad(mpl,geom,gamma_save,alpha)

! Print result
call mpl%dot_prod(alpha,alpha_save,sum1)
call mpl%dot_prod(gamma,gamma_save,sum2)
write(mpl%info,'(a7,a,e15.8,a,e15.8,a,e15.8)') '','Interpolation adjoint test (horizontal):  ', &
 & sum1,' / ',sum2,' / ',two*abs(sum1-sum2)/abs(sum1+sum2)
if (nicas_blk%verbosity) call mpl%flush

! Interpolation (vertical)

! Initialization
call rng%rand(zero,one,gamma_save)
call rng%rand(zero,one,fld_save)
do il0=1,geom%nl0
   if ((il0<nam%min_lev(iv)).or.(nam%max_lev(iv)<il0)) fld_save(:,il0) = mpl%msv%valr
end do

! Adjoint test
call nicas_blk%apply_interp_vertical(mpl,geom,gamma_save,fld)
call nicas_blk%apply_interp_vertical_ad(mpl,geom,fld_save,gamma)

! Print result
call mpl%dot_prod(gamma,gamma_save,sum1)
call mpl%dot_prod(fld,fld_save,sum2)
write(mpl%info,'(a7,a,e15.8,a,e15.8,a,e15.8)') '','Interpolation adjoint test (vertical):    ', &
 & sum1,' / ',sum2,' / ',two*abs(sum1-sum2)/abs(sum1+sum2)
if (nicas_blk%verbosity) call mpl%flush

! Interpolation (total)

! Initialization
call rng%rand(zero,one,alpha_save)
call rng%rand(zero,one,fld_save)
do il0=1,geom%nl0
   if ((il0<nam%min_lev(iv)).or.(nam%max_lev(iv)<il0)) fld_save(:,il0) = mpl%msv%valr
end do

! Adjoint test
call nicas_blk%apply_interp(mpl,geom,alpha_save,fld)
call nicas_blk%apply_interp_ad(mpl,geom,fld_save,alpha)

! Print result
call mpl%dot_prod(alpha,alpha_save,sum1)
call mpl%dot_prod(fld,fld_save,sum2)
write(mpl%info,'(a7,a,e15.8,a,e15.8,a,e15.8)') '','Interpolation adjoint test (total):       ', &
 & sum1,' / ',sum2,' / ',two*abs(sum1-sum2)/abs(sum1+sum2)
if (nicas_blk%verbosity) call mpl%flush

! Allocation
allocate(alpha1(nicas_blk%nsa))
allocate(alpha1_save(nicas_blk%nsb))
allocate(alpha2(nicas_blk%nsb))
allocate(alpha2_save(nicas_blk%nsa))

! Initialization
call rng%rand(zero,one,alpha1_save)
call rng%rand(zero,one,alpha2_save)

! Adjoint test
call nicas_blk%com_s_AB%red(mpl,alpha1_save,alpha1)
call nicas_blk%com_s_AB%ext(mpl,alpha2_save,alpha2)

! Print result
call mpl%dot_prod(alpha1,alpha2_save,sum1)
call mpl%dot_prod(alpha2,alpha1_save,sum2)
write(mpl%info,'(a7,a,e15.8,a,e15.8,a,e15.8)') '','Communication AB adjoint test:            ', &
 & sum1,' / ',sum2,' / ',two*abs(sum1-sum2)/abs(sum1+sum2)
if (nicas_blk%verbosity) call mpl%flush

! Release memory
deallocate(alpha1)
deallocate(alpha1_save)
deallocate(alpha2)
deallocate(alpha2_save)

! Allocation
allocate(alpha1(nicas_blk%nsa))
allocate(alpha1_save(nicas_blk%nsc))
allocate(alpha2(nicas_blk%nsc))
allocate(alpha2_save(nicas_blk%nsa))

! Initialization
call rng%rand(zero,one,alpha1_save)
call rng%rand(zero,one,alpha2_save)

! Adjoint test
call nicas_blk%com_s_AC%red(mpl,alpha1_save,alpha1)
call nicas_blk%com_s_AC%ext(mpl,alpha2_save,alpha2)

! Print result
call mpl%dot_prod(alpha1,alpha2_save,sum1)
call mpl%dot_prod(alpha2,alpha1_save,sum2)
write(mpl%info,'(a7,a,e15.8,a,e15.8,a,e15.8)') '','Communication AC adjoint test:            ', &
 & sum1,' / ',sum2,' / ',two*abs(sum1-sum2)/abs(sum1+sum2)
if (nicas_blk%verbosity) call mpl%flush

! Allocation
deallocate(alpha1)
deallocate(alpha1_save)
deallocate(alpha2)
deallocate(alpha2_save)
allocate(alpha1(nicas_blk%nsa))
allocate(alpha1_save(nicas_blk%nsa))
allocate(alpha2(nicas_blk%nsa))
allocate(alpha2_save(nicas_blk%nsa))

! Initialization
call rng%rand(zero,one,alpha1_save)
call rng%rand(zero,one,alpha2_save)
alpha1 = alpha1_save
alpha2 = alpha2_save

! Adjoint test
alpha_c = zero
call nicas_blk%com_s_AC%ext(mpl,alpha1,alpha_c)
call nicas_blk%c%apply(mpl,alpha_c,alpha1_save)
alpha_c = zero
call nicas_blk%c%apply_ad(mpl,alpha2,alpha_c)
call nicas_blk%com_s_AC%red(mpl,alpha_c,alpha2_save)

! Print result
call mpl%dot_prod(alpha1,alpha2_save,sum1)
call mpl%dot_prod(alpha2,alpha1_save,sum2)
write(mpl%info,'(a7,a,e15.8,a,e15.8,a,e15.8)') '','Convolution / communication adjoint test: ', &
 & sum1,' / ',sum2,' / ',two*abs(sum1-sum2)/abs(sum1+sum2)
if (nicas_blk%verbosity) call mpl%flush

! Initialization
call rng%rand(zero,one,alpha1)
call rng%rand(zero,one,fld2)

! Adjoint test
call nicas_blk%apply_sqrt(mpl,geom,alpha1,fld1)
call nicas_blk%apply_sqrt_ad(mpl,geom,fld2,alpha2)

! Print result
call mpl%dot_prod(alpha1,alpha2,sum1)
call mpl%dot_prod(fld1,fld2,sum2)
write(mpl%info,'(a7,a,e15.8,a,e15.8,a,e15.8)') '','NICAS adjoint test:                       ', &
 & sum1,' / ',sum2,' / ',two*abs(sum1-sum2)/abs(sum1+sum2)
if (nicas_blk%verbosity) call mpl%flush

! Initialization
call rng%rand(zero,one,fld1_save)
call rng%rand(zero,one,fld2_save)
fld1 = fld1_save
fld2 = fld2_save

! Adjoint test
call nicas_blk%apply(mpl,geom,fld1)
call nicas_blk%apply(mpl,geom,fld2)

! Print result
call mpl%dot_prod(fld1,fld2_save,sum1)
call mpl%dot_prod(fld2,fld1_save,sum2)
write(mpl%info,'(a7,a,e15.8,a,e15.8,a,e15.8)') '','NICAS auto-adjoint test:                  ', &
 & sum1,' / ',sum2,' / ',two*abs(sum1-sum2)/abs(sum1+sum2)
if (nicas_blk%verbosity) call mpl%flush

! Release memory
deallocate(alpha1)
deallocate(alpha1_save)
deallocate(alpha2)
deallocate(alpha2_save)

! End associate
end associate

! Probe out
@:probe_out()

end subroutine nicas_blk_test_adjoint

!----------------------------------------------------------------------
! Subroutine: nicas_blk_test_normalization
!> Test NICAS normalization
!----------------------------------------------------------------------
subroutine nicas_blk_test_normalization(nicas_blk,mpl,rng,nam,geom)

implicit none

! Passed variables
class(nicas_blk_type),intent(in) :: nicas_blk !< NICAS data block
type(mpl_type),intent(inout) :: mpl           !< MPI data
type(rng_type),intent(inout) :: rng           !< Random number generator
type(nam_type),intent(in) :: nam              !< Namelist
type(geom_type),intent(in) :: geom            !< Geometry

! Local variables
integer :: itest,isa
integer :: il0(nam%check_normalization),iproc(nam%check_normalization),ic0a(nam%check_normalization)
real(kind_real) :: alpha(nicas_blk%nsa),fld(geom%nc0a,geom%nl0),norm,val(nam%check_normalization)

! Set name
@:set_name(nicas_blk_test_normalization)

! Probe in
@:probe_in()

! Associate
associate(ib=>nicas_blk%ib)

! Get random levels
if (mpl%main) call rng%rand(1,geom%nl0,il0)
call mpl%f_comm%broadcast(il0,mpl%rootproc-1)

! Resynchronize random number generator
call rng%resync(mpl)

! Get random points
do itest=1,nam%check_normalization
   call geom%rand_point(mpl,rng,il0(itest),iproc(itest),ic0a(itest))
end do

! Desynchronize random number generator
call rng%desync(mpl)

if (nicas_blk%smoother) then
   ! Check smoother integral
   write(mpl%info,'(a7,a)') '','Check smoother integral'
   if (nicas_blk%verbosity) call mpl%flush
   do itest=1,nam%check_normalization
      ! Initialization
      fld = zero
      if (mpl%myproc==iproc(itest)) fld(ic0a(itest),il0(itest)) = one

      ! Apply NICAS
      call nicas_blk%apply(mpl,geom,fld)

      ! Get sum
      norm = zss_sum(fld,mask=geom%gmask_c0a)
      call mpl%f_comm%allreduce(norm,fckit_mpi_sum())
      val(itest) = norm
   end do
   write(mpl%info,'(a10,a,f10.7,a,f10.7,a,i6,a)') '','Min / max:',minval(val),' / ',maxval(val),' over ', &
 & nam%check_normalization,' tests'
   if (nicas_blk%verbosity) call mpl%flush
else
   ! Check internal normalization
   write(mpl%info,'(a7,a)') '','Check internal normalization'
   if (nicas_blk%verbosity) call mpl%flush
   do itest=1,nam%check_normalization
      ! Initialization
      alpha = zero
      if (mpl%myproc==iproc(itest)) then
         ! Get random point
         call rng%rand(1,nicas_blk%nsa,isa)
         alpha(isa) = one
      end if

      ! Apply convolution square-root adjoint
      call nicas_blk%apply_convol_sqrt_ad(mpl,alpha)

      ! Apply convolution square-root
      call nicas_blk%apply_convol_sqrt(mpl,alpha)

      ! Broadcast normalization value
      if (mpl%myproc==iproc(itest)) norm = alpha(isa)
      call mpl%f_comm%broadcast(norm,iproc(itest)-1)
      val(itest) = norm
   end do
   write(mpl%info,'(a10,a,f10.7,a,f10.7,a,i6,a)') '','Min / max:',minval(val),' / ',maxval(val),' over ', &
 & nam%check_normalization,' tests'
   if (nicas_blk%verbosity) call mpl%flush

   ! Check normalization
   write(mpl%info,'(a7,a)') '','Check normalization'
   if (nicas_blk%verbosity) call mpl%flush
   do itest=1,nam%check_normalization
      ! Initialization
      fld = zero
      if (mpl%myproc==iproc(itest)) fld(ic0a(itest),il0(itest)) = one

      ! Apply NICAS
      call nicas_blk%apply(mpl,geom,fld)

      ! Broadcast normalization value
      if (mpl%myproc==iproc(itest)) norm = fld(ic0a(itest),il0(itest))
      call mpl%f_comm%broadcast(norm,iproc(itest)-1)
      val(itest) = norm
   end do
   write(mpl%info,'(a10,a,f10.7,a,f10.7,a,i6,a)') '','Min / max:',minval(val),' / ',maxval(val),' over ', &
 & nam%check_normalization,' tests'
   if (nicas_blk%verbosity) call mpl%flush
end if

! End associate
end associate

! Probe out
@:probe_out()

end subroutine nicas_blk_test_normalization

!----------------------------------------------------------------------
! Subroutine: nicas_blk_test_dirac
!> Apply NICAS to diracs
!----------------------------------------------------------------------
subroutine nicas_blk_test_dirac(nicas_blk,mpl,nam,geom,bpar)

implicit none

! Passed variables
class(nicas_blk_type),intent(in) :: nicas_blk !< NICAS data block
type(mpl_type),intent(inout) :: mpl           !< MPI data
type(nam_type),intent(in) :: nam              !< Namelist
type(geom_type),intent(in) :: geom            !< Geometry
type(bpar_type),intent(in) :: bpar            !< Block parameters

! Local variables
integer :: ic0a,il0,idir
real(kind_real) :: val,valmin,valmax
real(kind_real) :: fld(geom%nc0a,geom%nl0),fld_tot(geom%nc0a,geom%nl0)

! Set name
@:set_name(nicas_blk_test_dirac)

! Probe in
@:probe_in()

! Associate
associate(ib=>nicas_blk%ib)

do idir=1,geom%ndir
   ! Generate dirac field
   fld = zero
   if ((ib==bpar%v_to_b(geom%ivdir(idir))).and.(geom%iprocdir(idir)==mpl%myproc)) fld(geom%ic0adir(idir),geom%il0dir(idir)) = one

   ! Apply NICAS method
   call nicas_blk%apply(mpl,geom,fld)

   ! Copy points
   do ic0a=1,geom%nc0a
      if (idir==geom%dirac_index(ic0a)) fld_tot(ic0a,:) = fld(ic0a,:)
   end do
end do

! Write field
if (nam%write_c0) call geom%io%fld_write(mpl,nicas_blk%grpid,nicas_blk%dirac_id,fld_tot,geom%gmask_c0a)

! Print results
write(mpl%info,'(a7,a)') '','Values at dirac points:'
if (nicas_blk%verbosity) call mpl%flush
do idir=1,geom%ndir
   if (geom%iprocdir(idir)==mpl%myproc) val = fld_tot(geom%ic0adir(idir),geom%il0dir(idir))
   call mpl%f_comm%broadcast(val,geom%iprocdir(idir)-1)
   if (mpl%msv%isnot(val)) then
      write(mpl%info,'(a10,f6.1,a,f6.1,a,f10.7)') '',geom%londir(idir)*rad2deg,' / ',geom%latdir(idir)*rad2deg,': ',val
      if (nicas_blk%verbosity) call mpl%flush
   else
      write(mpl%info,'(a10,f6.1,a,f6.1,a)') '',geom%londir(idir)*rad2deg,' / ',geom%latdir(idir)*rad2deg,': missing value'
      if (nicas_blk%verbosity) call mpl%flush
   end if
end do
write(mpl%info,'(a7,a)') '','Min - max: '
if (nicas_blk%verbosity) call mpl%flush
do il0=1,geom%nl0
   valmin = zss_minval(fld_tot(:,il0),mask=geom%gmask_c0a(:,il0))
   valmax = zss_maxval(fld_tot(:,il0),mask=geom%gmask_c0a(:,il0))
   call mpl%f_comm%allreduce(valmin,fckit_mpi_min())
   call mpl%f_comm%allreduce(valmax,fckit_mpi_max())
   if (mpl%msv%isnot(valmin).or.mpl%msv%isnot(valmax)) then
      write(mpl%info,'(a10,a,i3,a,f10.7,a,f10.7)') '','Level ',nam%levs(il0),': ',valmin,' - ',valmax
      if (nicas_blk%verbosity) call mpl%flush
   else
      write(mpl%info,'(a10,a,i3,a)') '','Level ',nam%levs(il0),': missing values'
      if (nicas_blk%verbosity) call mpl%flush
   end if
end do

! End associate
end associate

! Probe out
@:probe_out()

end subroutine nicas_blk_test_dirac

!----------------------------------------------------------------------
! Function: nicas_blk_c1_to_c1a
!> Conversion from global to halo A on subset Sc1
!----------------------------------------------------------------------
function nicas_blk_c1_to_c1a(nicas_blk,ic1,il1) result(ic1a)

implicit none

! Passed variables
class(nicas_blk_type),intent(in) :: nicas_blk !< NICAS data block
integer,intent(in) :: ic1                     !< Global index
integer,intent(in) :: il1                     !< Level index

! Returned variable
integer :: ic1a

! Local variable
integer :: iproc

! Set name
@:set_name(nicas_blk_c1_to_c1a)

! Probe in
@:probe_in()

! Find processor
iproc = nicas_blk%c1_to_proc(ic1,il1)

! Get halo A index
ic1a = ic1-nicas_blk%hor(il1)%proc_to_c1_offset(iproc)

! Probe out
@:probe_out()

end function nicas_blk_c1_to_c1a

!----------------------------------------------------------------------
! Function: nicas_blk_c1_to_proc
!> Conversion from global to processor on subset Sc1
!----------------------------------------------------------------------
function nicas_blk_c1_to_proc(nicas_blk,ic1,il1) result(iproc)

implicit none

! Passed variables
class(nicas_blk_type),intent(in) :: nicas_blk !< NICAS data block
integer,intent(in) :: ic1                     !< Global index
integer,intent(in) :: il1                     !< Level index

! Returned variable
integer :: iproc

! Set name
@:set_name(nicas_blk_c1_to_proc)

! Probe in
@:probe_in()

! Find processor
do iproc=1,nicas_blk%nproc-1
   if ((nicas_blk%hor(il1)%proc_to_c1_offset(iproc)<ic1).and.(ic1<=nicas_blk%hor(il1)%proc_to_c1_offset(iproc+1))) then
@:probe_out()
      return
   end if
end do

! Probe out
@:probe_out()

end function nicas_blk_c1_to_proc

!----------------------------------------------------------------------
! Function: nicas_blk_c1_to_c1u
!> Conversion from global to universe on subset Sc1
!----------------------------------------------------------------------
function nicas_blk_c1_to_c1u(nicas_blk,ic1,il1) result(ic1u)

implicit none

! Passed variables
class(nicas_blk_type),intent(in) :: nicas_blk !< NICAS data block
integer,intent(in) :: ic1                     !< Global index
integer,intent(in) :: il1                     !< Level index

! Returned variable
integer :: ic1u

! Local variable
integer :: iproc,ic1a,offset,jproc

! Set name
@:set_name(nicas_blk_c1_to_c1u)

! Probe in
@:probe_in()

! Find processor
iproc = nicas_blk%c1_to_proc(ic1,il1)

if (nicas_blk%myuniverse(iproc)) then
   ! Get halo A index
   ic1a = ic1-nicas_blk%hor(il1)%proc_to_c1_offset(iproc)

   ! Compute universe offset
   offset = 0
   do jproc=1,iproc-1
      if (nicas_blk%myuniverse(jproc)) offset = offset+nicas_blk%hor(il1)%proc_to_nc1a(jproc)
   end do

   ! Get universe index
   ic1u = offset+ic1a
else
   ! Not in my universe
   ic1u = 0
end if

! Probe out
@:probe_out()

end function nicas_blk_c1_to_c1u

!----------------------------------------------------------------------
! Function: nicas_blk_s_to_sa
!> Conversion from global to halo A on subgrid
!----------------------------------------------------------------------
function nicas_blk_s_to_sa(nicas_blk,is) result(isa)

implicit none

! Passed variables
class(nicas_blk_type),intent(in) :: nicas_blk !< NICAS data block
integer,intent(in) :: is                      !< Global index

! Returned variable
integer :: isa

! Local variable
integer :: iproc

! Set name
@:set_name(nicas_blk_s_to_sa)

! Probe in
@:probe_in()

! Find processor
iproc = nicas_blk%s_to_proc(is)

! Get halo A index
isa = is-nicas_blk%proc_to_s_offset(iproc)

! Probe out
@:probe_out()

end function nicas_blk_s_to_sa

!----------------------------------------------------------------------
! Function: nicas_blk_s_to_proc
!> Conversion from global to processor on subgrid
!----------------------------------------------------------------------
function nicas_blk_s_to_proc(nicas_blk,is) result(iproc)

implicit none

! Passed variables
class(nicas_blk_type),intent(in) :: nicas_blk !< NICAS data block
integer,intent(in) :: is                      !< Global index

! Returned variable
integer :: iproc

! Set name
@:set_name(nicas_blk_s_to_proc)

! Probe in
@:probe_in()

! Find processor
do iproc=1,nicas_blk%nproc-1
   if ((nicas_blk%proc_to_s_offset(iproc)<is).and.(is<=nicas_blk%proc_to_s_offset(iproc+1))) then
@:probe_out()
      return
   end if
end do

! Probe out
@:probe_out()

end function nicas_blk_s_to_proc

!----------------------------------------------------------------------
! Function: nicas_blk_s_to_su
!> Conversion from global to universe on subgrid
!----------------------------------------------------------------------
function nicas_blk_s_to_su(nicas_blk,is) result(isu)

implicit none

! Passed variables
class(nicas_blk_type),intent(in) :: nicas_blk !< NICAS data block
integer,intent(in) :: is                      !< Global index

! Returned variable
integer :: isu

! Local variable
integer :: iproc,isa,offset,jproc

! Set name
@:set_name(nicas_blk_s_to_su)

! Probe in
@:probe_in()

! Find processor
iproc = nicas_blk%s_to_proc(is)

if (nicas_blk%myuniverse(iproc)) then
   ! Get halo A index
   isa = is-nicas_blk%proc_to_s_offset(iproc)

   ! Compute universe offset
   offset = 0
   do jproc=1,iproc-1
      if (nicas_blk%myuniverse(jproc)) offset = offset+nicas_blk%proc_to_nsa(jproc)
   end do

   ! Get universe index
   isu = offset+isa
else
   ! Not in my universe
   isu = 0
end if

! Probe out
@:probe_out()

end function nicas_blk_s_to_su

end module type_nicas_blk
