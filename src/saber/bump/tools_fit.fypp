#:include '../instrumentation.fypp'
!----------------------------------------------------------------------
! Module: tools_fit
!> Fit-related tools
! Author: Benjamin Menetrier
! Licensing: this code is distributed under the CeCILL-C license
! Copyright 2015-... UCAR, CERFACS, METEO-FRANCE and IRIT
!----------------------------------------------------------------------
module tools_fit

use tools_const, only: zero,half,one
use tools_func, only: fit_diag_iso
use tools_gc99, only: npk,nnl,nscaleth,scaleth,ipkhdef,ipkvdef,scalethmax,pk,nl,scaleh,scalev,fit_func, &
 & support_hor,support_ver
use tools_kinds, only: kind_real,huge_real
use tools_repro, only: inf,sup
use type_mpl, only: mpl_type
@:use_probe()

implicit none

real(kind_real),parameter :: negative_lobe_weight = 1.0e2_kind_real !< Specific weight in the cost for negative lobe

interface fast_fit
   module procedure fit_fast_fit
end interface
interface ver_smooth
   module procedure fit_ver_smooth
end interface
interface ver_fill
   module procedure fit_ver_fill
end interface

private
public :: fast_fit,ver_smooth,ver_fill

contains

!----------------------------------------------------------------------
! Subroutine: fit_fast_fit
!> Fast fit length-scale estimation based on the value at mid-height
!----------------------------------------------------------------------
subroutine fit_fast_fit(mpl,n,iz,dist,dir,raw,peakness,negative_lobe,fit_r,fit_pk,fit_nl)

implicit none

! Passed variables
type(mpl_type),intent(inout) :: mpl   !< MPI data
integer,intent(in) :: n               !< Vector size
integer,intent(in) :: iz              !< Zero separation index
real(kind_real),intent(in) :: dist(n) !< Distance
character(len=*),intent(in) :: dir    !< Direction
real(kind_real),intent(in) :: raw(n)  !< Raw data
logical,intent(in) :: peakness        !< Peakness optimization flag
logical,intent(in) :: negative_lobe   !< Negative lobe optimization flag
real(kind_real),intent(out) :: fit_r  !< Support radius
real(kind_real),intent(out) :: fit_pk !< Peakness
real(kind_real),intent(out) :: fit_nl !< Negative lobe parameter

! Local variables
integer :: ntmp,iscaleth,di,i,im,ip,ipk,inl,imin(1)
real(kind_real) :: raw_tmp(n),fit_r_m,fit_r_p
real(kind_real) :: cost,cost_min,fit_r_test,fit_pk_test,fit_nl_test,fit_r_min,fit_pk_min,fit_nl_min,fit(n)
logical :: valid(npk,nnl)

! Set name
@:set_name(fit_fast_fit)

! Probe in
@:probe_in()

if (any(dist<zero)) call mpl%abort('${subr}$','negative distance')

if (raw(iz)>zero) then
   if (n>1) then
      ! Copy points that are lower than the zero-separation
      raw_tmp = mpl%msv%valr
      raw_tmp(iz) = one
      do i=1,n
        if (i/=iz) then
           if (mpl%msv%isnot(raw(i)).and.inf(raw(i),raw(iz))) raw_tmp(i) = raw(i)/raw(iz)
        end if
      end do
      ntmp = count(mpl%msv%isnot(raw_tmp))

      if (ntmp>1) then
         ! Check minimum value
         if (minval(raw_tmp,mask=mpl%msv%isnot(raw_tmp))>scalethmax) then
            if (dir=='hor') then
               call mpl%abort('${subr}$','minimum horizontal diagnostic value is too high, increase nc3')
            elseif (dir=='ver') then
               call mpl%abort('${subr}$','minimum vertical diagnostic value is too high, increase nl0r')
            end if
         end if
 
         ! Initialization
         imin = minloc(raw_tmp,mask=mpl%msv%isnot(raw_tmp))
         cost_min = huge_real
         fit_r_min = mpl%msv%valr
         fit_pk_min = mpl%msv%valr
         fit_nl_min = mpl%msv%valr

         ! Loop over thresholds
         do iscaleth=1,nscaleth
            ! Find support radius, lower value
            fit_r_m = mpl%msv%valr
            if (iz>1) then
               ip = iz
               do di=1,n
                  ! Check whether fit value has been found
                  if (mpl%msv%is(fit_r_m)) then
                     ! Index
                     im = iz-di

                     ! Check index validity
                     if (im>=1) then
                        ! Check whether threshold has been crossed
                        if (mpl%msv%isnot(raw_tmp(im)).and.inf(raw_tmp(im),scaleth(iscaleth))) then
                           ! Set fit value
                           fit_r_m = dist(im)+(dist(ip)-dist(im))*(scaleth(iscaleth)-raw_tmp(im))/(raw_tmp(ip)-raw_tmp(im))
                        else
                           ! Update index
                           ip = im
                        end if
                     end if
                  end if
               end do
            end if

            ! Find support radius, upper value
            fit_r_p = mpl%msv%valr
            if (iz<n) then
               im = iz
               do di=1,n
                  ! Check whether fit value has been found
                  if (mpl%msv%is(fit_r_p)) then
                     ! Index
                     ip = iz+di

                     ! Check index validity
                     if (ip<=n) then
                        ! Check whether threshold has been crossed
                        if (mpl%msv%isnot(raw_tmp(ip)).and.inf(raw_tmp(ip),scaleth(iscaleth))) then
                           ! Set fit value
                           fit_r_p = dist(im)+(dist(ip)-dist(im))*(scaleth(iscaleth)-raw_tmp(im))/(raw_tmp(ip)-raw_tmp(im))
                        else
                           ! Update index
                           im = ip
                        end if
                     end if
                  end if
               end do
            end if

            ! Gather values
            if (mpl%msv%isnot(fit_r_m).and.mpl%msv%isnot(fit_r_p)) then
               fit_r = half*(fit_r_m+fit_r_p)
            elseif (mpl%msv%isnot(fit_r_m)) then
               fit_r = fit_r_m
            elseif (mpl%msv%isnot(fit_r_p)) then
               fit_r = fit_r_p
            else
               fit_r = mpl%msv%valr
            end if
            
            ! Check validity and positivity
            if (mpl%msv%isnot(fit_r)) then
               ! Prepare optimization mask
               if (dir=='hor') then
                  valid = .false.
                  valid(ipkhdef,1) = .true.
                  if (peakness) valid(:,1) = .true.
               elseif (dir=='ver') then
                  valid = .false.
                  valid(ipkvdef,1) = .true.
                  if (peakness) then
                     if (negative_lobe) then
                        valid = .true.
                     else
                        valid(:,1) = .true.
                     end if
                  else
                     if (negative_lobe) valid(ipkvdef,:) = .true.
                  end if
               end if

               ! Optimize peakness and negative lobe (brute-force)
               do inl=1,nnl
                  do ipk=1,npk
                     if (valid(ipk,inl)) then
                        if (dir=='hor') then
                           fit_r_test = fit_r/scaleh(iscaleth,ipk)
                        elseif (dir=='ver') then
                           fit_r_test = fit_r/scalev(iscaleth,ipk,inl)
                        end if
                        fit_pk_test = pk(ipk)
                        fit_nl_test = nl(inl)
                        call fit_diag_iso(mpl,n,dist,dir,fit_r_test,fit_pk_test,fit_nl_test,fit)
                        cost = sum((fit-raw_tmp)**2)/real(ntmp,kind_real)
                        if ((dir=='ver').and.negative_lobe.and.(raw_tmp(imin(1))<zero)) cost = cost+negative_lobe_weight &
 & *(fit(imin(1))-raw_tmp(imin(1)))**2
                        if (inf(cost,cost_min)) then
                           cost_min = cost
                           fit_r_min = fit_r_test
                           fit_pk_min = fit_pk_test
                           fit_nl_min = fit_nl_test
                        end if
                     end if
                  end do
               end do
            end if
         end do

         ! Set final support radius and peakness
         fit_r = fit_r_min
         fit_pk = fit_pk_min
         fit_nl = fit_nl_min
      else
         ! All positive-separation points are missing
         fit_r = mpl%msv%valr
         fit_pk = mpl%msv%valr
         fit_nl = mpl%msv%valr
      end if
   else
      ! Only one point, zero radius and default peakness
      fit_r = zero
      if (dir=='hor') then
         fit_pk = pk(ipkhdef)
      elseif (dir=='ver') then
         fit_pk = pk(ipkvdef)
      end if
      fit_nl = zero
   end if
else
   ! Zero-separation point is negative
   fit_r = mpl%msv%valr
   fit_pk = mpl%msv%valr
   fit_nl = mpl%msv%valr
end if

! Probe out
@:probe_out()

end subroutine fit_fast_fit

!----------------------------------------------------------------------
! Subroutine: fit_ver_smooth
!> Homogeneous smoothing of a vertical profile
!----------------------------------------------------------------------
subroutine fit_ver_smooth(mpl,n,x,rv,profile)

implicit none

! Passed variables
type(mpl_type),intent(inout) :: mpl         !< MPI data
integer,intent(in) :: n                     !< Vector size
real(kind_real),intent(in) :: x(n)          !< Coordinate
real(kind_real),intent(in) :: rv            !< Filtering support radius
real(kind_real),intent(inout) :: profile(n) !< Vertical profile

! Local variables
integer :: i,j
real(kind_real) :: kernel(n,n),distnorm,profile_init(n),norm

! Set name
@:set_name(fit_ver_smooth)

! Probe in
@:probe_in()

if (n>1) then
   if (rv<zero) call mpl%abort('${subr}$','negative filtering support radius')

   if ((rv>zero).and.mpl%msv%isanynot(profile)) then
      ! Vertical smoothing kernel
      kernel = zero
      do i=1,n
         do j=1,n
            if (mpl%msv%isnot(profile(i)).and.mpl%msv%isnot(profile(j))) then
               ! Gaspari-Cohn (1999) function
               distnorm = abs(x(j)-x(i))/rv
               kernel(i,j) = fit_func(mpl,'ver',distnorm,pk(ipkvdef),zero)
            end if
         end do
      end do

      ! Apply kernel
      profile_init = profile
      profile = zero
      do i=1,n
         norm = zero
         do j=1,n
            profile(i) = profile(i)+kernel(i,j)*profile_init(j)
            norm = norm+kernel(i,j)
         end do
         if (norm>zero) then
            profile(i) = profile(i)/norm
         else
            profile(i) = mpl%msv%valr
         end if
      end do
   end if
end if

! Probe out
@:probe_out()

end subroutine fit_ver_smooth

!----------------------------------------------------------------------
! Subroutine: fit_ver_fill
!> Missing values filling of a vertical profile
!----------------------------------------------------------------------
subroutine fit_ver_fill(mpl,n,x,profile)

implicit none

! Passed variables
type(mpl_type),intent(inout) :: mpl         !< MPI data
integer,intent(in) :: n                     !< Vector size
real(kind_real),intent(in) :: x(n)          !< Coordinate
real(kind_real),intent(inout) :: profile(n) !< Vertical profile

! Local variables
integer :: i,j,iinf,isup
real(kind_real) :: profile_init(n)

! Set name
@:set_name(fit_ver_fill)

! Probe in
@:probe_in()

if (mpl%msv%isanynot(profile)) then
   ! Initialization
   profile_init = profile
   iinf = mpl%msv%vali

   do i=1,n
      if (mpl%msv%isnot(profile_init(i))) then
         ! Valid inferior point
         iinf = i
      else
         ! Look for a superior point
         isup = mpl%msv%vali
         j = i+1
         do while ((j<=n).and.(mpl%msv%is(isup)))
            if (mpl%msv%isnot(profile_init(j))) isup = j
            j = j+1
         end do

         if (mpl%msv%isnot(iinf).and.mpl%msv%isnot(isup)) then
            ! Interpolation
            profile(i) = profile_init(iinf)+(x(i)-x(iinf))*(profile_init(isup)-profile_init(iinf))/(x(isup)-x(iinf))
         elseif (mpl%msv%isnot(isup)) then
            ! Extrapolation with nearest superior point
            profile(i) = profile(isup)
         elseif (mpl%msv%isnot(iinf)) then
            ! Extrapolation with nearest inferior point
            profile(i) = profile(iinf)
         else
            call mpl%abort('${subr}$','too many missing values')
         end if
      end if
   end do
end if

! Probe out
@:probe_out()

end subroutine fit_ver_fill

end module tools_fit
