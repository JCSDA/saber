#:include '../instrumentation.fypp'
!----------------------------------------------------------------------
! Module: tools_samp
!> Sampling functions
! Author: Benjamin Menetrier
! Licensing: this code is distributed under the CeCILL-C license
! Copyright 2015-... UCAR, CERFACS, METEO-FRANCE and IRIT
!----------------------------------------------------------------------
module tools_samp

use atlas_module, only: atlas_structuredgrid
use fckit_mpi_module, only: fckit_mpi_sum,fckit_mpi_min
!$ use omp_lib
use tools_const, only: zero,half,quarter,one,two,four,pi,deg2rad
use tools_func, only: fletcher32,lonlatmod,lonlat2xyz,cart_dist,inside,zss_minval,zss_count
use tools_kinds, only: kind_real,kind_int,huge_real,huge_int
use tools_qsort, only: qsort
use tools_repro, only: inf,indist
use type_mesh, only: mesh_type
use type_mpl, only: mpl_type
@:use_probe()
use type_tree, only: tree_type

implicit none

interface initialize_sampling
   module procedure samp_initialize_sampling
end interface

integer,parameter :: nfacmin = 4 !< Minimum size factor for the first subsampling

private
public :: initialize_sampling

contains

!----------------------------------------------------------------------
! Subroutine: samp_initialize_sampling
!> Intialize sampling
!----------------------------------------------------------------------
subroutine samp_initialize_sampling(mpl,ncxa,lon_cxa,lat_cxa,mask_cxa,rh_cxa,cxa_to_cx,area,ncxu,cxu_to_cxa,tree_cxu,mesh_cxu, &
 & verbosity,ifmt,ns,s_to_cx)

implicit none

! Passed variables
type(mpl_type),intent(inout) :: mpl         !< MPI data
integer,intent(in) :: ncxa                  !< Number of points (local)
real(kind_real),intent(in) :: lon_cxa(ncxa) !< Longitudes (local)
real(kind_real),intent(in) :: lat_cxa(ncxa) !< Latitudes (local)
logical,intent(in) :: mask_cxa(ncxa)        !< Mask (local)
real(kind_real),intent(in) :: rh_cxa(ncxa)  !< Horizontal support radius (local)
integer,intent(in) :: cxa_to_cx(ncxa)       !< Local to global index
real(kind_real),intent(in) :: area          !< Global domain area
integer,intent(in) :: ncxu                  !< Number of points (universe)
integer,intent(in) :: cxu_to_cxa(ncxu)      !< Universe to local index
type(tree_type),intent(in) :: tree_cxu      !< Universe KD-tree
type(mesh_type),intent(in) :: mesh_cxu      !< Universe mesh
logical,intent(in) :: verbosity             !< Verbosity flag
integer,intent(in) :: ifmt                  !< Format indentation
integer,intent(in) :: ns                    !< Number of samplings points (global)
integer,intent(out) :: s_to_cx(ns)          !< Horizontal sampling index (global)


! Local variables
integer :: ncxa_eff,ncx_eff,offset,isa,icxa,is,icx,nfac,nssa,nss,issa,n,ix,iy,issamin,icxmin,iprocmin,nsa,nodemin,inode
integer :: s_to_cxa(ns),nn_index(1)
integer,allocatable :: proc_to_ncxa_eff(:),proc_to_icxmin(:),s_to_cx_tmp(:),ssa_to_cxa(:),ssa_to_cx(:),ssa_to_node(:),s_to_ssa(:)
integer,allocatable :: proc_to_nodemin(:),sa_to_s(:),order_s(:),cxa_to_node(:)
real(kind_real) :: lonlat(2),valmin,valmin_tot,xmin,ymin,zmin,chmin,dist
real(kind_real),allocatable :: proc_to_xmin(:),proc_to_ymin(:),proc_to_zmin(:),proc_to_chmin(:)
real(kind_real),allocatable :: x_ssa(:),y_ssa(:),z_ssa(:),ch_ssa(:),potential(:),lon_sa(:),lat_sa(:),lon_s(:),lat_s(:)
logical :: retry,valid
logical,allocatable :: lmask_cxa(:),lmask_ssa(:),indist_ssa(:)
character(len=6) :: gridid
character(len=1024) :: cfmt
type(atlas_structuredgrid) :: agrid

! Set name
@:set_name(samp_initialize_sampling)

! Probe in
@:probe_in()

! Number of effective points
ncxa_eff = zss_count(mask_cxa)
call mpl%f_comm%allreduce(ncxa_eff,ncx_eff,fckit_mpi_sum())

! Check mask size
if (ncx_eff==0) then
   ! Empty mask
   call mpl%abort('${subr}$','empty mask in initialize sampling')
elseif (ncx_eff<ns) then
   ! Not enough valid points
   call mpl%abort('${subr}$','ns greater than ncx_eff in initialize_sampling')
elseif (ncx_eff==ns) then
   ! Just enough valid points
   write(mpl%info,'(a)') ' all points are used'
   if (verbosity) call mpl%flush

   ! Allocation
   allocate(proc_to_ncxa_eff(mpl%nproc))
   allocate(s_to_cx_tmp(ns))

   ! Communication
   call mpl%f_comm%allgather(ncxa_eff,proc_to_ncxa_eff)

   ! Initialization
   if (mpl%myproc==1) then
      offset = 0
   else
      offset = sum(proc_to_ncxa_eff(1:mpl%myproc-1))
   end if
   s_to_cxa = mpl%msv%vali
   s_to_cx_tmp = 0

   ! Use all valid points
   isa = 0
   do icxa=1,ncxa
      if (mask_cxa(icxa)) then
         isa = isa+1
         is = offset+isa
         icx = cxa_to_cx(icxa)
         s_to_cxa(is) = icxa
         s_to_cx_tmp(is) = icx
      end if
   end do
   call mpl%f_comm%allreduce(s_to_cx_tmp,s_to_cx,fckit_mpi_sum())

   ! Release memory
   deallocate(proc_to_ncxa_eff)
   deallocate(s_to_cx_tmp)
else
   ! Too many valid points: subsampling

   ! Allocation
   allocate(lmask_cxa(ncxa))
   allocate(cxa_to_node(ncxa))

   ! First step: decimate the grid

   ! Initialization
   nfac = nfacmin
   retry = .true.
   write(cfmt,'(a,i2.2,a)') '(a',ifmt+3,',a,i8,a)'
   write(mpl%info,trim(cfmt)) '','Decimate full grid, at least ',ns,' points required'
   if (verbosity) call mpl%flush

   do while (retry)
      ! Update nfac
      nfac = 2*nfac

      ! Number of required points
      nss = nfac*int(real(ns,kind_real)*four*pi/area)

      ! Octahedral grid
      n = int(-4.5_kind_real+sqrt(20.25_kind_real+quarter*real(nss,kind_real)))+1
      write(gridid,'(a,i5.5)') 'O',n
      agrid = atlas_structuredgrid(gridid)
      nss = 4*n**2+36*n

      ! Initialization
      lmask_cxa = .false.
      cxa_to_node = mpl%msv%vali

      ! Loop over octahedral grid points
      inode = 0
      do iy=1,int(agrid%ny(),kind_int)
         do ix=1,int(agrid%nx(iy),kind_int)
            ! Global index
            inode = inode+1

            ! Get longitude/latitude
            lonlat = agrid%lonlat(ix,iy)*deg2rad
            call lonlatmod(lonlat(1),lonlat(2))

            ! Check if point is inside the hull
            call inside(mpl,mesh_cxu%vbnd,lonlat(1),lonlat(2),valid)

            if (valid) then
               ! Find nearest neighbor in universe
               call tree_cxu%find_nearest_neighbors(lonlat(1),lonlat(2),1,nn_index)
               icxa = cxu_to_cxa(nn_index(1))

               ! Keep valid points on each processor
               if (mpl%msv%isnot(icxa)) then
                  lmask_cxa(icxa) = mask_cxa(icxa)
                  cxa_to_node(icxa) = inode
               end if
            end if
         end do
      end do

      ! Local and global number of valid points
      nssa = zss_count(lmask_cxa)
      call mpl%f_comm%allreduce(nssa,nss,fckit_mpi_sum())

      ! Print result
      write(cfmt,'(a,i2.2,a)') '(a',ifmt+3,',a,a,a,i8,a)'
      write(mpl%info,trim(cfmt)) '','Attempt with a ',trim(gridid),' grid: ',nss,' valid points found'
      if (verbosity) call mpl%flush
      retry = (nss<ns)
   end do

   ! Second step: get data on effective local grid

   ! Allocation
   allocate(s_to_ssa(ns))
   allocate(ssa_to_cxa(nssa))
   allocate(ssa_to_cx(nssa))
   allocate(ssa_to_node(nssa))
   allocate(x_ssa(nssa))
   allocate(y_ssa(nssa))
   allocate(z_ssa(nssa))
   allocate(ch_ssa(nssa))
   allocate(lmask_ssa(nssa))

   ! Initialization
   issa = 0
   do icxa=1,ncxa
      if (lmask_cxa(icxa)) then
         issa = issa+1
         icx = cxa_to_cx(icxa)
         ssa_to_cxa(issa) = icxa
         ssa_to_cx(issa) = icx
         ssa_to_node(issa) = cxa_to_node(icxa)
         call lonlat2xyz(mpl,lon_cxa(icxa),lat_cxa(icxa),x_ssa(issa),y_ssa(issa),z_ssa(issa))
         ch_ssa(issa) = two*sin(half*min(rh_cxa(icxa),pi))
      end if
   end do
   lmask_ssa = .true.

   ! Third step: electric potential method

   ! Allocation
   allocate(potential(nssa))
   allocate(indist_ssa(nssa))
   allocate(proc_to_nodemin(mpl%nproc))
   allocate(proc_to_xmin(mpl%nproc))
   allocate(proc_to_ymin(mpl%nproc))
   allocate(proc_to_zmin(mpl%nproc))
   allocate(proc_to_chmin(mpl%nproc))
   allocate(proc_to_icxmin(mpl%nproc))

   ! Initialization
   s_to_ssa = mpl%msv%vali
   s_to_cx = mpl%msv%vali
   write(cfmt,'(a,i2.2,a)') '(a',ifmt+3,',a)'
   write(mpl%info,trim(cfmt)) '','Potential method: '
   if (verbosity) then
      call mpl%flush(.false.)
      call mpl%prog_init(ns)
   end if

   ! Set initial sampling point as close as possible to (0,0)
   is = 1

   ! Compute distance to point of coordinate (0,0)
   do issa=1,nssa
      call cart_dist(x_ssa(issa),y_ssa(issa),z_ssa(issa),zero,zero,zero,potential(issa))
   end do

   ! Find minimum distance globally
   valmin = zss_minval(potential)
   call mpl%f_comm%allreduce(valmin,valmin_tot,fckit_mpi_min())

   ! Check if minimum is indistinguishable
   do issa=1,nssa
      indist_ssa(issa) = indist(potential(issa),valmin_tot)
   end do
   nodemin = mpl%msv%vali
   xmin = mpl%msv%valr
   ymin = mpl%msv%valr
   zmin = mpl%msv%valr
   chmin = mpl%msv%valr
   icxmin = mpl%msv%vali
   if (nssa>0) then
      if (any(indist_ssa)) then
         issamin = minloc(ssa_to_node,mask=indist_ssa,dim=1)
         nodemin = ssa_to_node(issamin)
         xmin = x_ssa(issamin)
         ymin = y_ssa(issamin)
         zmin = z_ssa(issamin)
         chmin = ch_ssa(issamin)
         icxmin = ssa_to_cx(issamin)
      end if
   end if

   ! Communication
   call mpl%f_comm%allgather(nodemin,proc_to_nodemin)
   call mpl%f_comm%allgather(xmin,proc_to_xmin)
   call mpl%f_comm%allgather(ymin,proc_to_ymin)
   call mpl%f_comm%allgather(zmin,proc_to_zmin)
   call mpl%f_comm%allgather(chmin,proc_to_chmin)
   call mpl%f_comm%allgather(icxmin,proc_to_icxmin)

   ! Find processor handling the minimum distance
   iprocmin = minloc(proc_to_nodemin,mask=mpl%msv%isnot(proc_to_nodemin),dim=1)

   ! Reset potential
   potential = zero

   ! Update global sampling, local mask and local potential
   s_to_cx(is) = proc_to_icxmin(iprocmin)
   if (iprocmin==mpl%myproc) then
      lmask_ssa(issamin) = .false.
      s_to_ssa(is) = issamin
   end if
   !$omp parallel do schedule(static) private(issa,dist)
   do issa=1,nssa
      if (lmask_ssa(issa)) then
         ! Cartesian distance
         call cart_dist(x_ssa(issa),y_ssa(issa),z_ssa(issa), &
 & proc_to_xmin(iprocmin),proc_to_ymin(iprocmin),proc_to_zmin(iprocmin),dist)

         ! Update potential
         potential(issa) = potential(issa)+proc_to_chmin(iprocmin)/dist
      end if
   end do
   !$omp end parallel do

   ! Update
   if (verbosity) call mpl%prog_print(is)

   ! Set other points where the potential is minimum
   do is=2,ns
      ! Find minimum distance globally
      valmin = huge_real
      if (nssa>0) then
         if (any(lmask_ssa)) valmin = zss_minval(potential,mask=lmask_ssa)
      end if
      call mpl%f_comm%allreduce(valmin,valmin_tot,fckit_mpi_min())

      ! Check if minimum is indistinguishable
      indist_ssa = .false.
      do issa=1,nssa
         if (lmask_ssa(issa)) indist_ssa(issa) = indist(potential(issa),valmin_tot)
      end do
      nodemin = mpl%msv%vali
      xmin = mpl%msv%valr
      ymin = mpl%msv%valr
      zmin = mpl%msv%valr
      chmin = mpl%msv%valr
      icxmin = mpl%msv%vali
      if (nssa>0) then
         if (any(indist_ssa)) then
            issamin = minloc(ssa_to_node,mask=indist_ssa,dim=1)
            nodemin = ssa_to_node(issamin)
            xmin = x_ssa(issamin)
            ymin = y_ssa(issamin)
            zmin = z_ssa(issamin)
            chmin = ch_ssa(issamin)
            icxmin = ssa_to_cx(issamin)
         end if
      end if

      ! Communication
      call mpl%f_comm%allgather(nodemin,proc_to_nodemin)
      call mpl%f_comm%allgather(xmin,proc_to_xmin)
      call mpl%f_comm%allgather(ymin,proc_to_ymin)
      call mpl%f_comm%allgather(zmin,proc_to_zmin)
      call mpl%f_comm%allgather(chmin,proc_to_chmin)
      call mpl%f_comm%allgather(icxmin,proc_to_icxmin)

      ! Find processor handling the minimum distance
      iprocmin = minloc(proc_to_nodemin,mask=mpl%msv%isnot(proc_to_nodemin),dim=1)

      ! Update global sampling, local mask and local potential
      s_to_cx(is) = proc_to_icxmin(iprocmin)
      if (iprocmin==mpl%myproc) then
         lmask_ssa(issamin) = .false.
         s_to_ssa(is) = issamin
      end if
      !$omp parallel do schedule(static) private(issa,dist)
      do issa=1,nssa
         if (lmask_ssa(issa)) then
            ! Cartesian distance
            call cart_dist(x_ssa(issa),y_ssa(issa),z_ssa(issa), &
 & proc_to_xmin(iprocmin),proc_to_ymin(iprocmin),proc_to_zmin(iprocmin),dist)

            ! Update potential
            potential(issa) = potential(issa)+proc_to_chmin(iprocmin)/dist
         end if
      end do
      !$omp end parallel do

      ! Update
      if (verbosity) call mpl%prog_print(is)
   end do
   if (verbosity) call mpl%prog_final

   ! Copy back from effective grid
   do is=1,ns
      issa = s_to_ssa(is)
      if (mpl%msv%isnot(issa)) then
         icxa = ssa_to_cxa(issa)
         s_to_cxa(is) = icxa
      else
         s_to_cxa(is) = mpl%msv%vali
      end if
   end do

   ! Release memory
   deallocate(lmask_cxa)
   deallocate(cxa_to_node)
   deallocate(s_to_ssa)
   deallocate(ssa_to_cxa)
   deallocate(ssa_to_cx)
   deallocate(ssa_to_node)
   deallocate(x_ssa)
   deallocate(y_ssa)
   deallocate(z_ssa)
   deallocate(ch_ssa)
   deallocate(lmask_ssa)
   deallocate(potential)
   deallocate(proc_to_xmin)
   deallocate(proc_to_ymin)
   deallocate(proc_to_zmin)
   deallocate(proc_to_chmin)
   deallocate(proc_to_nodemin)
   deallocate(proc_to_icxmin)
end if

! Reorder points

! Allocation
nsa = count(mpl%msv%isnot(s_to_cxa))
allocate(sa_to_s(nsa))
allocate(lon_sa(nsa))
allocate(lat_sa(nsa))
allocate(lon_s(ns))
allocate(lat_s(ns))
allocate(order_s(ns))

! Initialization
isa = 0
do is=1,ns
   icxa = s_to_cxa(is)
   if (mpl%msv%isnot(icxa)) then
      isa = isa+1
      sa_to_s(isa) = is
      lon_sa(isa) = lon_cxa(icxa)
      lat_sa(isa) = lat_cxa(icxa)
   end if
end do

! Communication
call mpl%loc_to_glb(nsa,ns,sa_to_s,lon_sa,lon_s,.true.)
call mpl%loc_to_glb(nsa,ns,sa_to_s,lat_sa,lat_s,.true.)

! Define points order
call qsort(ns,lon_s,lat_s,order_s)

! Reorder sampling
s_to_cx = s_to_cx(order_s)

! Release memory
deallocate(sa_to_s)
deallocate(lon_sa)
deallocate(lat_sa)
deallocate(lon_s)
deallocate(lat_s)
deallocate(order_s)

! Probe out
@:probe_out()

end subroutine samp_initialize_sampling

end module tools_samp
