#:include '../instrumentation.fypp'
!----------------------------------------------------------------------
! Module: type_nicas
!> NICAS data derived type
! Author: Benjamin Menetrier
! Licensing: this code is distributed under the CeCILL-C license
! Copyright 2015-... UCAR, CERFACS, METEO-FRANCE and IRIT
!----------------------------------------------------------------------
module type_nicas

use fckit_mpi_module, only: fckit_mpi_sum,fckit_mpi_min,fckit_mpi_status
use tools_const, only: zero,one,two,ten,rad2deg,reqkm,pi
use tools_func, only: fletcher32,sphere_dist,zss_sum
use tools_kinds, only: kind_real,huge_real
use tools_netcdf, only: create_file,open_file,define_grp,define_dim,inquire_dim,check_dim,define_var,put_var,close_file
use tools_qsort, only: qsort
use tools_repro, only: rth
use type_bpar, only: bpar_type
use type_cmat, only: cmat_type
use type_com, only: com_type
use type_cv, only: cv_type
use type_diag, only: diag_type
use type_ens, only: ens_type
use type_geom, only: geom_type
use type_hdiag, only: hdiag_type
use type_linop, only: linop_type
use type_mom, only: mom_type
use type_mpl, only: mpl_type
use type_nam, only: nam_type
use type_nicas_blk, only: nicas_blk_type
@:use_probe()
use type_rng, only: rng_type
use type_samp, only: samp_type

implicit none

integer,parameter :: nfac_rnd = 9 !< Number of ensemble size factors for randomization
integer,parameter :: ntest = 50   !< Number of test vectors

! NICAS derived type
type nicas_type
   character(len=1024) :: prefix                    !< Prefix
   type(nicas_blk_type),allocatable :: blk(:)       !< NICAS data blocks
   logical :: allocated                             !< Allocation flag
   integer,allocatable :: blkid(:)                  !< block ID
   integer,allocatable :: dirac_id(:)               !< dirac ID
   integer,allocatable :: bens_id(:)                !< bens ID
   real(kind_real),allocatable :: dirac(:,:,:)      !< Dirac field
   real(kind_real),allocatable :: dirac_bens(:,:,:) !< Dirac field for localized ensemble application
contains
   procedure :: alloc => nicas_alloc
   procedure :: partial_dealloc => nicas_partial_dealloc
   procedure :: dealloc => nicas_dealloc
   procedure :: read_local => nicas_read_local
   procedure :: write_local => nicas_write_local
   procedure :: read_global => nicas_read_global
   procedure :: write_global => nicas_write_global
   procedure :: write_grids => nicas_write_grids
   procedure :: send => nicas_send
   procedure :: receive => nicas_receive
   procedure :: run_nicas => nicas_run_nicas
   procedure :: run_nicas_tests => nicas_run_nicas_tests
   procedure :: alloc_cv => nicas_alloc_cv
   procedure :: random_cv => nicas_random_cv
   procedure :: apply => nicas_apply
   procedure :: apply_sqrt => nicas_apply_sqrt
   procedure :: apply_sqrt_ad => nicas_apply_sqrt_ad
   procedure :: gen_ens_pert => nicas_gen_ens_pert
   procedure :: apply_bens => nicas_apply_bens
   procedure :: test_adjoint => nicas_test_adjoint
   procedure :: test_dirac => nicas_test_dirac
   procedure :: test_randomization => nicas_test_randomization
end type nicas_type

private
public :: nicas_type

contains

!----------------------------------------------------------------------
! Subroutine: nicas_alloc
!> Allocation
!----------------------------------------------------------------------
subroutine nicas_alloc(nicas,bpar)

! Passed variables
class(nicas_type),intent(inout) :: nicas !< NICAS data
type(bpar_type),intent(in) :: bpar       !< Block parameters

! Local variable
integer :: ib

! Set name
@:set_name(nicas_alloc)

! Probe in
@:probe_in()

! Allocation
if (.not.allocated(nicas%blk)) allocate(nicas%blk(bpar%nbe))

do ib=1,bpar%nbe
   ! Set block index
   nicas%blk(ib)%ib = ib

   ! Set verbosity
   nicas%blk(ib)%verbosity = .true.
end do

! Update allocation flag
nicas%allocated = .true.

! Probe out
@:probe_out()

end subroutine nicas_alloc

!----------------------------------------------------------------------
! Subroutine: nicas_partial_dealloc
!> Release memory (partial)
!----------------------------------------------------------------------
subroutine nicas_partial_dealloc(nicas)

! Passed variables
class(nicas_type),intent(inout) :: nicas !< NICAS data

! Local variable
integer :: ib

! Set name
@:set_name(nicas_partial_dealloc)

! Probe in
@:probe_in()

! Release memory (partial)
if (allocated(nicas%blk)) then
   do ib=1,size(nicas%blk)
      call nicas%blk(ib)%partial_dealloc
   end do
end if
if (allocated(nicas%blkid)) deallocate(nicas%blkid)
if (allocated(nicas%dirac_id)) deallocate(nicas%dirac_id)
if (allocated(nicas%bens_id)) deallocate(nicas%bens_id)

! Probe out
@:probe_out()

end subroutine nicas_partial_dealloc

!----------------------------------------------------------------------
! Subroutine: nicas_dealloc
!> Release memory (full)
!----------------------------------------------------------------------
subroutine nicas_dealloc(nicas)

! Passed variables
class(nicas_type),intent(inout) :: nicas !< NICAS data

! Local variable
integer :: ib

! Set name
@:set_name(nicas_dealloc)

! Probe in
@:probe_in()

! Release memory
if (allocated(nicas%blk)) then
   do ib=1,size(nicas%blk)
      call nicas%blk(ib)%dealloc
   end do
   deallocate(nicas%blk)
end if
if (allocated(nicas%dirac)) deallocate(nicas%dirac)
if (allocated(nicas%dirac_bens)) deallocate(nicas%dirac_bens)

! Update allocation flag
nicas%allocated = .false.

! Probe out
@:probe_out()

end subroutine nicas_dealloc

!----------------------------------------------------------------------
! Subroutine: nicas_read_local
!> Read
!----------------------------------------------------------------------
subroutine nicas_read_local(nicas,mpl,nam,geom,bpar)

implicit none

! Passed variables
class(nicas_type),intent(inout) :: nicas !< NICAS data
type(mpl_type),intent(inout) :: mpl      !< MPI data
type(nam_type),intent(in) :: nam         !< Namelist
type(geom_type),intent(in) :: geom       !< Geometry
type(bpar_type),intent(in) :: bpar       !< Block parameters

! Local variables
integer :: ib,icmp,iproc,iprocio,ncid,is,isa
type(nicas_type) :: nicas_tmp

! Set name
@:set_name(nicas_read_local)

! Probe in
@:probe_in()

write(mpl%info,'(a7,a)') '','Read NICAS local data'
call mpl%flush

! Allocation
call nicas%alloc(bpar)

! Read NICAS blocks
do iproc=1,mpl%nproc
   ! Reading task
   iprocio = mod(iproc,mpl%nprocio)
   if (iprocio==0) iprocio = mpl%nprocio

   if (mpl%myproc==iprocio) then
      write(mpl%info,'(a10,a,i6)') '','Read NICAS data of task ',iproc
      call mpl%flush

      ! Open file
      ncid = open_file(mpl,nam%fname_nicas,iproc)

      ! Check subset Sc0 on halo A size
      if (.not.check_dim(mpl,ncid,'nc0a',geom%proc_to_nc0a(iproc))) call mpl%abort('${subr}$','wrong size for dimension nc0a')

      ! Check number of levels (TODO: nl0 is now defined at block level, whole block should be removed at some point)
      if (mpl%msv%isnot(inquire_dim(mpl,ncid,'nl0'))) then
         if (.not.check_dim(mpl,ncid,'nl0',geom%nl0)) call mpl%abort('${subr}$','wrong size for dimension nl0')
      end if

      if (iproc==iprocio) then
         do ib=1,bpar%nbe
            if (bpar%nicas_block(ib)) then
               ! Copy global ID
               nicas%blk(ib)%ncid = ncid

               ! Read data
               call nicas%blk(ib)%read_local(mpl,nam,geom,bpar)
            else
               ! No component
               nicas%blk(ib)%ncmp = 0
            end if
         end do
      else
         ! Allocation
         call nicas_tmp%alloc(bpar)

         do ib=1,bpar%nbe
            if (bpar%nicas_block(ib)) then
               ! Copy global ID
               nicas_tmp%blk(ib)%ncid = ncid

               ! Read data
               call nicas_tmp%blk(ib)%read_local(mpl,nam,geom,bpar)
            else
               ! No component
               nicas_tmp%blk(ib)%ncmp = 0
            end if
         end do

          ! Send data to task iproc
         call nicas_tmp%send(mpl,geom,bpar,iproc)

         ! Release memory
         call nicas_tmp%dealloc
      end if

      ! Close file
      call close_file(mpl,ncid)
   elseif (mpl%myproc==iproc) then
      ! Receive data from task iprocio
      write(mpl%info,'(a10,a,i6)') '','Receive NICAS data from task ',iprocio
      call mpl%flush
      call nicas%receive(mpl,geom,bpar,iprocio)
   end if
end do

! Update tag
call mpl%update_tag(4)

! Set other fields
do ib=1,bpar%nbe
   if (bpar%nicas_block(ib)) then
      do icmp=1,nicas%blk(ib)%ncmp
         ! Number of processors
         nicas%blk(ib)%cmp(icmp)%nproc = mpl%nproc

         ! Allocation
         allocate(nicas%blk(ib)%cmp(icmp)%myuniverse(mpl%nproc))
         allocate(nicas%blk(ib)%cmp(icmp)%proc_to_nsa(mpl%nproc))
         allocate(nicas%blk(ib)%cmp(icmp)%proc_to_s_offset(mpl%nproc))
         allocate(nicas%blk(ib)%cmp(icmp)%sa_to_s(nicas%blk(ib)%cmp(icmp)%nsa))

         ! Copy universe
         nicas%blk(ib)%cmp(icmp)%myuniverse = geom%myuniverse

         ! Communication
         call mpl%f_comm%allgather(nicas%blk(ib)%cmp(icmp)%nsa,nicas%blk(ib)%cmp(icmp)%proc_to_nsa)

         ! Subset Sc1 offset for halo A
         nicas%blk(ib)%cmp(icmp)%proc_to_s_offset(1) = 0
         do iproc=2,mpl%nproc
            nicas%blk(ib)%cmp(icmp)%proc_to_s_offset(iproc) = nicas%blk(ib)%cmp(icmp)%proc_to_s_offset(iproc-1) &
 & +nicas%blk(ib)%cmp(icmp)%proc_to_nsa(iproc-1)
         end do

         ! Global subgrid size
         nicas%blk(ib)%cmp(icmp)%ns = sum(nicas%blk(ib)%cmp(icmp)%proc_to_nsa)

         ! Automatic conversions on subgrid
         do is=1,nicas%blk(ib)%cmp(icmp)%ns
            iproc = nicas%blk(ib)%cmp(icmp)%s_to_proc(is)
            if (iproc==mpl%myproc) then
               isa = nicas%blk(ib)%cmp(icmp)%s_to_sa(is)
               nicas%blk(ib)%cmp(icmp)%sa_to_s(isa) = is
            end if
         end do
      end do
   end if
end do

! Probe out
@:probe_out()

end subroutine nicas_read_local

!----------------------------------------------------------------------
! Subroutine: nicas_write_local
!> Write
!----------------------------------------------------------------------
subroutine nicas_write_local(nicas,mpl,nam,geom,bpar)

implicit none

! Passed variables
class(nicas_type),intent(inout) :: nicas !< NICAS data
type(mpl_type),intent(inout) :: mpl      !< MPI data
type(nam_type),intent(in) :: nam         !< Namelist
type(geom_type),intent(in) :: geom       !< Geometry
type(bpar_type),intent(in) :: bpar       !< Block parameters

! Local variables
integer :: ncid,nc0a_id
integer :: ib,icmp,iproc,iprocio
type(nicas_type) :: nicas_tmp

! Set name
@:set_name(nicas_write_local)

! Probe in
@:probe_in()

write(mpl%info,'(a7,a)') '','Write NICAS local data'
call mpl%flush

! Write NICAS blocks
do iproc=1,mpl%nproc
   ! Writing task
   iprocio = mod(iproc,mpl%nprocio)
   if (iprocio==0) iprocio = mpl%nprocio

   if (mpl%myproc==iprocio) then
      write(mpl%info,'(a10,a,i6)') '','Write NICAS data of task ',iproc
      call mpl%flush

      ! Create file
      ncid = create_file(mpl,nam%fname_nicas,iproc)

      ! Define dimensions
      if (geom%proc_to_nc0a(iproc)>0) then
         nc0a_id = define_dim(mpl,ncid,'nc0a',geom%proc_to_nc0a(iproc))
      else
         nc0a_id = mpl%msv%vali
      end if

      if (iproc==iprocio) then
         do ib=1,bpar%nbe
            if (bpar%nicas_block(ib)) then
               ! Copy global IDs
               nicas%blk(ib)%ncid = ncid
               do icmp=1,nicas%blk(ib)%ncmp
                  nicas%blk(ib)%cmp(icmp)%nc0a_id = nc0a_id
               end do

               ! Write data (definition mode)
               call nicas%blk(ib)%write_local_def(mpl,nam,geom,bpar)
            end if
         end do

         do ib=1,bpar%nbe
            ! Write data (data mode)
            if (bpar%nicas_block(ib)) call nicas%blk(ib)%write_local_data(mpl,geom)
         end do
      else
         ! Allocation
         call nicas_tmp%alloc(bpar)

         ! Receive data from task iproc
         call nicas_tmp%receive(mpl,geom,bpar,iproc)

         do ib=1,bpar%nbe
            if (bpar%nicas_block(ib)) then
               ! Copy global IDs
               nicas_tmp%blk(ib)%ncid = ncid
               do icmp=1,nicas%blk(ib)%ncmp
                  nicas_tmp%blk(ib)%cmp(icmp)%nc0a_id = nc0a_id
               end do

               ! Write data (definition mode)
               call nicas_tmp%blk(ib)%write_local_def(mpl,nam,geom,bpar)
            end if
         end do

         do ib=1,bpar%nbe
            ! Write data (data mode)
            if (bpar%nicas_block(ib)) call nicas_tmp%blk(ib)%write_local_data(mpl,geom)
         end do

         ! Release memory
         call nicas_tmp%dealloc
      end if

      ! Close file
      call close_file(mpl,ncid)
   elseif (mpl%myproc==iproc) then
      ! Send data to task iprocio
      write(mpl%info,'(a10,a,i6)') '','Send NICAS data to task ',iprocio
      call mpl%flush
      call nicas%send(mpl,geom,bpar,iprocio)
   end if
end do

! Update tag
call mpl%update_tag(4)

! Probe out
@:probe_out()

end subroutine nicas_write_local

!----------------------------------------------------------------------
! Subroutine: nicas_read_global
!> Read
!----------------------------------------------------------------------
subroutine nicas_read_global(nicas,mpl,nam,geom,bpar)

! Passed variables
class(nicas_type),intent(inout) :: nicas !< NICAS data
type(mpl_type),intent(inout) :: mpl      !< MPI data
type(nam_type),intent(in) :: nam         !< Namelist
type(geom_type),intent(in) :: geom       !< Geometry
type(bpar_type),intent(in) :: bpar       !< Block parameters

! Local variable
integer :: ncid
integer :: ib

! Set name
@:set_name(nicas_read_global)

! Probe in
@:probe_in()

write(mpl%info,'(a7,a)') '','Read NICAS global data'
call mpl%flush

! Open file
ncid = open_file(mpl,nam%fname_nicas)

do ib=1,bpar%nbe
   if (bpar%nicas_block(ib)) then
      ! Copy global ID
      nicas%blk(ib)%ncid = ncid

      ! Read global data
      call nicas%blk(ib)%read_global(mpl,nam,geom,bpar)
   else
     ! No component
      nicas%blk(ib)%ncmp = 0
   end if
end do

! Close file
call close_file(mpl,ncid)

! Probe out
@:probe_out()

end subroutine nicas_read_global

!----------------------------------------------------------------------
! Subroutine: nicas_write_global
!> Write
!----------------------------------------------------------------------
subroutine nicas_write_global(nicas,mpl,nam,geom,bpar)

! Passed variables
class(nicas_type),intent(inout) :: nicas !< NICAS data
type(mpl_type),intent(inout) :: mpl      !< MPI data
type(nam_type),intent(in) :: nam         !< Namelist
type(geom_type),intent(in) :: geom       !< Geometry
type(bpar_type),intent(in) :: bpar       !< Block parameters

! Local variable
integer :: ncid,nc0_id
integer :: ib,icmp

! Set name
@:set_name(nicas_write_global)

! Probe in
@:probe_in()

write(mpl%info,'(a7,a)') '','Write NICAS global data'
call mpl%flush

! Open file
ncid = create_file(mpl,nam%fname_nicas)

! Define dimensions
nc0_id = define_dim(mpl,ncid,'nc0',geom%nc0)

do ib=1,bpar%nbe
   if (bpar%nicas_block(ib)) then
      ! Copy global IDs
      nicas%blk(ib)%ncid = ncid
      do icmp=1,nicas%blk(ib)%ncmp
         nicas%blk(ib)%cmp(icmp)%nc0_id = nc0_id
      end do

      ! Write global data (definition mode)
      if (bpar%nicas_block(ib)) call nicas%blk(ib)%write_global_def(mpl,nam,geom,bpar)
   end if
end do

do ib=1,bpar%nbe
   ! Write global data (data mode)
   if (bpar%nicas_block(ib)) call nicas%blk(ib)%write_global_data(mpl,geom)
end do

! Close file
call close_file(mpl,ncid)

! Probe out
@:probe_out()

end subroutine nicas_write_global

!----------------------------------------------------------------------
! Subroutine: nicas_write_grids
!> Write
!----------------------------------------------------------------------
subroutine nicas_write_grids(nicas,mpl,nam,bpar)

! Passed variables
class(nicas_type),intent(inout) :: nicas !< NICAS data
type(mpl_type),intent(inout) :: mpl      !< MPI data
type(nam_type),intent(in) :: nam         !< Namelist
type(bpar_type),intent(in) :: bpar       !< Block parameters

! Local variable
integer :: ncid
integer :: ib

! Set name
@:set_name(nicas_write_grids)

! Probe in
@:probe_in()

! Open file
ncid = create_file(mpl,trim(nam%fname_nicas)//'_grids',mpl%myproc)

do ib=1,bpar%nbe
   if (bpar%nicas_block(ib)) then
      ! Copy global ID
      nicas%blk(ib)%ncid = ncid

      ! Write grids (definition mode)
      call nicas%blk(ib)%write_grids_def(mpl,nam,bpar)
   end if
end do

do ib=1,bpar%nbe
   if (bpar%nicas_block(ib)) then
      ! Write grids (data mode)
      call nicas%blk(ib)%write_grids_data(mpl,nam)
   end if
end do

! Close file
call close_file(mpl,ncid)

! Probe out
@:probe_out()

end subroutine nicas_write_grids

!----------------------------------------------------------------------
! Subroutine: nicas_send
!> Send
!----------------------------------------------------------------------
subroutine nicas_send(nicas,mpl,geom,bpar,iproc)

implicit none

! Passed variables
class(nicas_type),intent(in) :: nicas !< NICAS data
type(mpl_type),intent(inout) :: mpl   !< MPI data
type(geom_type),intent(in) :: geom    !< Geometry
type(bpar_type),intent(in) :: bpar    !< Block parameters
integer,intent(in) :: iproc           !< Destination task

! Local variables
integer :: ib,nbufi,nbufr,nbufl,nnbufi,nnbufr,nnbufl,ibufi,ibufr,ibufl,bufs(3)
integer,allocatable :: bufi(:)
real(kind_real),allocatable :: bufr(:)
logical,allocatable :: bufl(:)

! Set name
@:set_name(nicas_send)

! Probe in
@:probe_in()

! Buffer size
nbufi = 0
nbufr = 0
nbufl = 0
do ib=1,bpar%nbe
   if (bpar%nicas_block(ib)) then
      call nicas%blk(ib)%buffer_size(mpl,geom,nnbufi,nnbufr,nnbufl)
      nbufi = nbufi+nnbufi
      nbufr = nbufr+nnbufr
      nbufl = nbufl+nnbufl
   end if
end do

! Allocation
allocate(bufi(nbufi))
allocate(bufr(nbufr))
allocate(bufl(nbufl))

! Initialization
ibufi = 0
ibufr = 0
ibufl = 0

! Serialize
do ib=1,bpar%nbe
   if (bpar%nicas_block(ib)) then
      call nicas%blk(ib)%buffer_size(mpl,geom,nnbufi,nnbufr,nnbufl)
      call nicas%blk(ib)%serialize(mpl,geom,nnbufi,nnbufr,nnbufl,bufi(ibufi+1:ibufi+nnbufi),bufr(ibufr+1:ibufr+nnbufr), &
 & bufl(ibufl+1:ibufl+nnbufl))
      ibufi = ibufi+nnbufi
      ibufr = ibufr+nnbufr
      ibufl = ibufl+nnbufl
   end if
end do

! Send buffer size
bufs = (/nbufi,nbufr,nbufl/)
call mpl%f_comm%send(bufs,iproc-1,mpl%tag)

! Send data
call mpl%f_comm%send(bufi,iproc-1,mpl%tag+1)
call mpl%f_comm%send(bufr,iproc-1,mpl%tag+2)
call mpl%f_comm%send(bufl,iproc-1,mpl%tag+3)

! Release memory
deallocate(bufi)
deallocate(bufr)
deallocate(bufl)

! Probe out
@:probe_out()

end subroutine nicas_send

!----------------------------------------------------------------------
! Subroutine: nicas_receive
!> Receive
!----------------------------------------------------------------------
subroutine nicas_receive(nicas,mpl,geom,bpar,iproc)

implicit none

! Passed variables
class(nicas_type),intent(inout) :: nicas !< NICAS data
type(mpl_type),intent(inout) :: mpl      !< MPI data
type(geom_type),intent(in) :: geom       !< Geometry
type(bpar_type),intent(in) :: bpar       !< Block parameters
integer,intent(in) :: iproc              !< Source task

! Local variables
integer :: ib,nbufi,nbufr,nbufl,nnbufi,nnbufr,nnbufl,ibufi,ibufr,ibufl,bufs(3)
integer,allocatable :: bufi(:)
real(kind_real),allocatable :: bufr(:)
logical,allocatable :: bufl(:)
type(fckit_mpi_status) :: status

! Set name
@:set_name(nicas_receive)

! Probe in
@:probe_in()

! Receive buffer size
call mpl%f_comm%receive(bufs,iproc-1,mpl%tag,status)
nbufi = bufs(1)
nbufr = bufs(2)
nbufl = bufs(3)

! Allocation
allocate(bufi(nbufi))
allocate(bufr(nbufr))
allocate(bufl(nbufl))

! Receive data
call mpl%f_comm%receive(bufi,iproc-1,mpl%tag+1,status)
call mpl%f_comm%receive(bufr,iproc-1,mpl%tag+2,status)
call mpl%f_comm%receive(bufl,iproc-1,mpl%tag+3,status)

! Initialization
ibufi = 0
ibufr = 0
ibufl = 0

! Deserialize
do ib=1,bpar%nbe
   if (bpar%nicas_block(ib)) then
      nnbufi = bufi(ibufi+1)
      nnbufr = bufi(ibufi+2)
      nnbufl = bufi(ibufi+3)
      call nicas%blk(ib)%deserialize(mpl,geom,nnbufi,nnbufr,nnbufl,bufi(ibufi+1:ibufi+nnbufi),bufr(ibufr+1:ibufr+nnbufr), &
 & bufl(ibufl+1:ibufl+nnbufl))
      ibufi = ibufi+nnbufi
      ibufr = ibufr+nnbufr
      ibufl = ibufl+nnbufl
   end if
end do

! Release memory
deallocate(bufi)
deallocate(bufr)
deallocate(bufl)

! Probe out
@:probe_out()

end subroutine nicas_receive

!----------------------------------------------------------------------
! Subroutine: nicas_run_nicas
!> NICAS driver
!----------------------------------------------------------------------
subroutine nicas_run_nicas(nicas,mpl,rng,nam,geom,bpar,cmat)

implicit none

! Passed variables
class(nicas_type),intent(inout) :: nicas !< NICAS data
type(mpl_type),intent(inout) :: mpl      !< MPI data
type(rng_type),intent(inout) :: rng      !< Random number generator
type(nam_type),intent(inout) :: nam      !< Namelist
type(geom_type),intent(inout) :: geom    !< Geometry
type(bpar_type),intent(in) :: bpar       !< Block parameters
type(cmat_type),intent(in) :: cmat       !< C matrix data

! Local variables
integer :: ib

! Set name
@:set_name(nicas_run_nicas)

! Probe in
@:probe_in()

! Allocation
call nicas%alloc(bpar)

if (nam%load_nicas_global) then
   ! Read global NICAS parameters
   write(mpl%info,'(a)') '-------------------------------------------------------------------'
   call mpl%flush
   write(mpl%info,'(a)') '--- Read global NICAS parameters'
   call mpl%flush
   call nicas%read_global(mpl,nam,geom,bpar)
else
   ! Copy and filter C matrix data
   write(mpl%info,'(a)') '-------------------------------------------------------------------'
   call mpl%flush
   write(mpl%info,'(a)') '--- Copy and filter C matrix data'
   call mpl%flush
   do ib=1,bpar%nbe
      if (bpar%nicas_block(ib)) call nicas%blk(ib)%copy_cmat(mpl,nam,geom,bpar,cmat%blk(ib))
   end do
end if

! Compute NICAS parameters
write(mpl%info,'(a)') '-------------------------------------------------------------------'
call mpl%flush
write(mpl%info,'(a)') '--- Compute NICAS parameters'
call mpl%flush

do ib=1,bpar%nbe
   if (bpar%nicas_block(ib)) then
      write(mpl%info,'(a)') '--- Block: '//trim(bpar%blockname(ib))
      call mpl%flush
   end if

   ! NICAS parameters
   if (bpar%nicas_block(ib)) call nicas%blk(ib)%compute_parameters(mpl,rng,nam,geom,bpar)
end do

if (nam%write_nicas_local.or.nam%write_nicas_global.or.nam%write_nicas_grids) then
   ! Write NICAS parameters
   write(mpl%info,'(a)') '-------------------------------------------------------------------'
   call mpl%flush
   write(mpl%info,'(a)') '--- Write NICAS parameters'
   call mpl%flush

   ! Write local data
   if (nam%write_nicas_local) call nicas%write_local(mpl,nam,geom,bpar)

   ! Write global data
   if (nam%write_nicas_global) call nicas%write_global(mpl,nam,geom,bpar)

   ! Write grids
   if (nam%write_nicas_grids) call nicas%write_grids(mpl,nam,bpar)
end if

! Release memory (partial)
call nicas%partial_dealloc

! Probe out
@:probe_out()

end subroutine nicas_run_nicas

!----------------------------------------------------------------------
! Subroutine: nicas_run_nicas_tests
!> NICAS tests driver
!----------------------------------------------------------------------
subroutine nicas_run_nicas_tests(nicas,mpl,rng,nam,geom,bpar,ens)

implicit none

! Passed variables
class(nicas_type),intent(inout) :: nicas  !< NICAS data
type(mpl_type),intent(inout) :: mpl       !< MPI data
type(rng_type),intent(inout) :: rng       !< Random number generator
type(nam_type),intent(inout) :: nam       !< Namelist
type(geom_type),intent(inout) :: geom     !< Geometry
type(bpar_type),intent(in) :: bpar        !< Block parameters
type(ens_type),intent(in) :: ens          !< Ensemble

! Local variables
integer :: ib,icmp

! Set name
@:set_name(nicas_run_nicas_tests)

! Probe in
@:probe_in()

if (nam%check_adjoints) then
   ! Test adjoint
   write(mpl%info,'(a)') '-------------------------------------------------------------------'
   call mpl%flush
   write(mpl%info,'(a)') '--- Test NICAS adjoint'
   call mpl%flush
   call nicas%test_adjoint(mpl,rng,nam,geom,bpar,ens)

   do ib=1,bpar%nbe
      if (bpar%nicas_block(ib)) then
         write(mpl%info,'(a)') '--- Block: '//trim(bpar%blockname(ib))
         call mpl%flush
         call nicas%blk(ib)%test_adjoint(mpl,rng,geom)

         do icmp=1,nicas%blk(ib)%ncmp
            write(mpl%info,'(a7,a,i1)') '','Component: ',icmp
            call mpl%flush
            call nicas%blk(ib)%cmp(icmp)%test_adjoint(mpl,rng,nam,geom,bpar)
         end do
      end if
   end do
end if

if (nam%check_normalization>0) then
   ! Test normalization
   write(mpl%info,'(a)') '-------------------------------------------------------------------'
   call mpl%flush
   write(mpl%info,'(a)') '--- Test NICAS normalization'
   call mpl%flush

   do ib=1,bpar%nbe
      if (bpar%nicas_block(ib)) then
         write(mpl%info,'(a)') '--- Block: '//trim(bpar%blockname(ib))
         call mpl%flush
         do icmp=1,nicas%blk(ib)%ncmp
            write(mpl%info,'(a7,a,i1)') '','Component: ',icmp
            call mpl%flush
            if (nicas%blk(ib)%cmp(icmp)%smoother) then
               call nicas%blk(ib)%cmp(icmp)%test_normalization(mpl,rng,nam,geom,icmp)
            else
               call nicas%blk(ib)%cmp(icmp)%test_normalization(mpl,rng,nam,geom)
            end if
         end do
      end if
   end do
end if

if (nam%check_dirac) then
   ! Apply NICAS to diracs
   write(mpl%info,'(a)') '-------------------------------------------------------------------'
   call mpl%flush
   write(mpl%info,'(a)') '--- Apply NICAS to diracs'
   call mpl%flush
   call nicas%test_dirac(mpl,nam,geom,bpar,ens)

   ! Apply NICAS block to diracs
   do ib=1,bpar%nbe
      if (bpar%nicas_block(ib)) then
         write(mpl%info,'(a)') '-------------------------------------------------------------------'
         call mpl%flush
         write(mpl%info,'(a)') '--- Block: '//trim(bpar%blockname(ib))
         call mpl%flush
         call nicas%blk(ib)%test_dirac(mpl,nam,geom,bpar)
      end if
   end do
end if

if (nam%check_randomization) then
   ! Test NICAS randomization
   write(mpl%info,'(a)') '-------------------------------------------------------------------'
   call mpl%flush
   write(mpl%info,'(a)') '--- Test NICAS randomization'
   call mpl%flush
   call nicas%test_randomization(mpl,rng,nam,geom,bpar)
end if

! Probe out
@:probe_out()

end subroutine nicas_run_nicas_tests

!----------------------------------------------------------------------
! Subroutine: nicas_alloc_cv
!> Allocation
!----------------------------------------------------------------------
subroutine nicas_alloc_cv(nicas,mpl,bpar,cv,getsizeonly)

implicit none

! Passed variables
class(nicas_type),intent(in) :: nicas      !< NICAS data
type(mpl_type),intent(inout) :: mpl        !< MPI data
type(bpar_type),intent(in) :: bpar         !< Block parameters
type(cv_type),intent(inout) :: cv          !< Control vector
logical,intent(in),optional :: getsizeonly !< Flag to get the control variable size only (no allocation)

! Local variables
integer :: ib,jb,icmp
logical :: lgetsizeonly

! Set name
@:set_name(nicas_alloc_cv)

! Probe in
@:probe_in()

! Check flag existence
lgetsizeonly = .false.
if (present(getsizeonly)) lgetsizeonly = getsizeonly

! Allocation
allocate(cv%blk(bpar%nbe))

! Initialization
cv%n = 0
cv%nbe = bpar%nbe

do ib=1,bpar%nbe
   ! CV block
   jb = bpar%cv_block(ib)

   if (mpl%msv%isnot(jb)) then
      ! Copy number of components
      cv%blk(ib)%ncmp = nicas%blk(jb)%ncmp

      ! Allocation
      allocate(cv%blk(ib)%cmp(cv%blk(ib)%ncmp))

      do icmp=1,cv%blk(ib)%ncmp
         ! Allocation and initialization
         if (.not.lgetsizeonly) call cv%blk(ib)%cmp(icmp)%alloc(mpl,nicas%blk(jb)%cmp(icmp)%nsa)

         ! Update total size
         cv%n = cv%n+nicas%blk(jb)%cmp(icmp)%nsa
      end do
   else
      ! Set zero size
      cv%blk(ib)%ncmp = 0
   end if
end do

! Probe out
@:probe_out()

end subroutine nicas_alloc_cv

!----------------------------------------------------------------------
! Subroutine: nicas_random_cv
!> Generate a random control vector
!----------------------------------------------------------------------
subroutine nicas_random_cv(nicas,mpl,rng,bpar,cv)

implicit none

! Passed variables
class(nicas_type),intent(inout) :: nicas !< NICAS data
type(mpl_type),intent(inout) :: mpl      !< MPI data
type(rng_type),intent(inout) :: rng      !< Random number generator
type(bpar_type),intent(in) :: bpar       !< Block parameters
type(cv_type),intent(out) :: cv          !< Control vector

! Local variables
integer :: ib,jb,icmp
integer,allocatable :: order_s(:)
real(kind_real),allocatable :: alpha(:)

! Set name
@:set_name(nicas_random_cv)

! Probe in
@:probe_in()

! Allocation
call nicas%alloc_cv(mpl,bpar,cv)

! Random initialization
do ib=1,bpar%nbe
   ! CV block
   jb = bpar%cv_block(ib)

   if (mpl%msv%isnot(jb)) then
      do icmp=1,cv%blk(ib)%ncmp
         ! Allocation
         if (mpl%main) then
            allocate(order_s(nicas%blk(jb)%cmp(icmp)%ns))
            allocate(alpha(nicas%blk(jb)%cmp(icmp)%ns))
         else
            allocate(order_s(0))
            allocate(alpha(0))
         end if

         ! Communication
         call mpl%loc_to_glb(nicas%blk(jb)%cmp(icmp)%nsa,nicas%blk(jb)%cmp(icmp)%ns,nicas%blk(jb)%cmp(icmp)%sa_to_s, &
 & nicas%blk(jb)%cmp(icmp)%order_sa,order_s)

         if (mpl%main) then
            ! Random vector
            call rng%rand_gau(alpha)

            ! Reorder random vector
            alpha(order_s) = alpha
         end if

         ! Copy local section
         call mpl%glb_to_loc(nicas%blk(jb)%cmp(icmp)%nsa,nicas%blk(jb)%cmp(icmp)%ns,nicas%blk(jb)%cmp(icmp)%sa_to_s,alpha, &
 & cv%blk(ib)%cmp(icmp)%alpha)

         ! Release memory
         deallocate(order_s)
         deallocate(alpha)
      end do
   end if
end do

! Probe out
@:probe_out()

end subroutine nicas_random_cv

!----------------------------------------------------------------------
! Subroutine: nicas_apply
!> Apply NICAS (non smoother case)
!----------------------------------------------------------------------
subroutine nicas_apply(nicas,mpl,nam,geom,bpar,fld)

implicit none

! Passed variables
class(nicas_type),intent(in) :: nicas                           !< NICAS data
type(mpl_type),intent(inout) :: mpl                             !< MPI data
type(nam_type),intent(in) :: nam                                !< Namelist
type(geom_type),intent(in) :: geom                              !< Geometry
type(bpar_type),intent(in) :: bpar                              !< Block parameters
real(kind_real),intent(inout) :: fld(geom%nc0a,geom%nl0,nam%nv) !< Field

! Local variable
real(kind_real) :: prod
real(kind_real),allocatable :: fld_save(:,:,:)
type(cv_type) :: cv

! Set name
@:set_name(nicas_apply)

! Probe in
@:probe_in()

if (nam%pos_def_test) then
   ! Save field for positivity test
   allocate(fld_save(geom%nc0a,geom%nl0,nam%nv))
   fld_save = fld
end if

! Apply square-root adjoint
call nicas%apply_sqrt_ad(mpl,nam,geom,bpar,fld,cv)

! Apply square-root
call nicas%apply_sqrt(mpl,nam,geom,bpar,cv,fld)

if (nam%pos_def_test) then
   ! Positivity test
   prod = zss_sum(fld_save*fld)
   call mpl%f_comm%allreduce(prod,fckit_mpi_sum())
   if (prod<zero) call mpl%abort('${subr}$','negative result in nicas_apply')

   ! Release memory
   deallocate(fld_save)
end if

! Probe out
@:probe_out()

end subroutine nicas_apply

!----------------------------------------------------------------------
! Subroutine: nicas_apply_sqrt
!> Apply NICAS square-root
!----------------------------------------------------------------------
subroutine nicas_apply_sqrt(nicas,mpl,nam,geom,bpar,cv,fld)

implicit none

! Passed variables
class(nicas_type),intent(in) :: nicas                         !< NICAS data
type(mpl_type),intent(inout) :: mpl                           !< MPI data
type(nam_type),intent(in) :: nam                              !< Namelist
type(geom_type),intent(in) :: geom                            !< Geometry
type(bpar_type),intent(in) :: bpar                            !< Block parameters
type(cv_type),intent(in) :: cv                                !< Control variable
real(kind_real),intent(out) :: fld(geom%nc0a,geom%nl0,nam%nv) !< Field

! Local variable
integer :: ib,iv,jv
real(kind_real),allocatable :: fld_3d(:,:)

! Set name
@:set_name(nicas_apply_sqrt)

! Probe in
@:probe_in()

select case (nam%strategy)
case ('common')
   ! Allocation
   allocate(fld_3d(geom%nc0a,geom%nl0))

   ! Apply common NICAS
   call nicas%blk(bpar%nbe)%apply_sqrt(mpl,geom,cv%blk(bpar%nbe),fld_3d)

   ! Build final vector
   do iv=1,nam%nv
      fld(:,:,iv) = fld_3d
   end do

   ! Release memory
   deallocate(fld_3d)
case ('common_weighted')
   ! Allocation
   allocate(fld_3d(geom%nc0a,geom%nl0))

   ! Initialization
   fld = zero

   do ib=1,bpar%nb
      if (mpl%msv%isnot(bpar%cv_block(ib))) then
         ! Variable index
         jv = bpar%b_to_v1(ib)

         ! Apply specific NICAS
         call nicas%blk(bpar%nbe)%apply_sqrt(mpl,geom,cv%blk(ib),fld_3d)

         ! Apply weights
         do iv=jv,nam%nv
            fld(:,:,iv) = fld(:,:,iv)+nam%loc_wgt_sqrt(iv,jv)*fld_3d
         end do
      end if
   end do

   ! Release memory
   deallocate(fld_3d)
case ('specific_univariate')
   do ib=1,bpar%nb
      if (bpar%nicas_block(ib)) then
         ! Variable index
         iv = bpar%b_to_v1(ib)

         ! Apply specific NICAS
         call nicas%blk(ib)%apply_sqrt(mpl,geom,cv%blk(ib),fld(:,:,iv))
      end if
   end do
case ('specific_multivariate')
   do ib=1,bpar%nb
      if (bpar%nicas_block(ib)) then
         ! Variable index
         iv = bpar%b_to_v1(ib)

         ! Apply specific NICAS
         call nicas%blk(ib)%apply_sqrt(mpl,geom,cv%blk(1),fld(:,:,iv))
      end if
   end do
end select

! Probe out
@:probe_out()

end subroutine nicas_apply_sqrt

!----------------------------------------------------------------------
! Subroutine: nicas_apply_sqrt_ad
!> Apply NICAS square-root, adjoint
!----------------------------------------------------------------------
subroutine nicas_apply_sqrt_ad(nicas,mpl,nam,geom,bpar,fld,cv)

implicit none

! Passed variables
class(nicas_type),intent(in) :: nicas                        !< NICAS data
type(mpl_type),intent(inout) :: mpl                          !< MPI data
type(nam_type),intent(in) :: nam                             !< Namelist
type(geom_type),intent(in) :: geom                           !< Geometry
type(bpar_type),intent(in) :: bpar                           !< Block parameters
real(kind_real),intent(in) :: fld(geom%nc0a,geom%nl0,nam%nv) !< Field
type(cv_type),intent(out) :: cv                              !< Control variable

! Local variable
integer :: ib,iv,jv,icmp
real(kind_real),allocatable :: fld_3d(:,:),fld_tmp(:,:,:)
type(cv_type) :: cv_tmp

! Set name
@:set_name(nicas_apply_sqrt_ad)

! Probe in
@:probe_in()

! Allocation
call nicas%alloc_cv(mpl,bpar,cv)

select case (nam%strategy)
case ('common')
   ! Allocation
   allocate(fld_3d(geom%nc0a,geom%nl0))

   ! Sum product over variables
   fld_3d = zero
   do iv=1,nam%nv
      fld_3d = fld_3d+fld(:,:,iv)
   end do

   ! Apply common NICAS
   call nicas%blk(bpar%nbe)%apply_sqrt_ad(mpl,geom,fld_3d,cv%blk(bpar%nbe))

   ! Release memory
   deallocate(fld_3d)
case ('common_weighted')
   ! Allocation
   allocate(fld_3d(geom%nc0a,geom%nl0))

   do ib=1,bpar%nb
      if (mpl%msv%isnot(bpar%cv_block(ib))) then
         ! Variable index
         iv = bpar%b_to_v1(ib)

         ! Initialization
         fld_3d = zero
         do jv=iv,nam%nv
            fld_3d = fld_3d+nam%loc_wgt_sqrt(jv,iv)*fld(:,:,jv)
         end do

         ! Apply specific NICAS
         call nicas%blk(bpar%nbe)%apply_sqrt_ad(mpl,geom,fld_3d,cv%blk(ib))
      end if
   end do

   ! Release memory
   deallocate(fld_3d)
case ('specific_univariate')
   ! Allocation
   allocate(fld_tmp(geom%nc0a,geom%nl0,nam%nv))

   ! Initialization
   fld_tmp = fld
   do icmp=1,cv%blk(1)%ncmp
      cv%blk(1)%cmp(icmp)%alpha = zero
   end do

   do ib=1,bpar%nb
      if (bpar%nicas_block(ib)) then
         ! Indices
         iv = bpar%b_to_v1(ib)

         ! Apply specific NICAS
         call nicas%blk(ib)%apply_sqrt_ad(mpl,geom,fld_tmp(:,:,iv),cv%blk(ib))
      end if
   end do

   ! Release memory
   deallocate(fld_tmp)
case ('specific_multivariate')
   ! Allocation
   allocate(fld_tmp(geom%nc0a,geom%nl0,nam%nv))
   call nicas%alloc_cv(mpl,bpar,cv_tmp)

   ! Initialization
   fld_tmp = fld
   do icmp=1,cv%blk(1)%ncmp
      cv%blk(1)%cmp(icmp)%alpha = zero
   end do

   do ib=1,bpar%nb
      if (bpar%nicas_block(ib)) then
         ! Variable index
         iv = bpar%b_to_v1(ib)

         ! Apply specific NICAS
         call nicas%blk(ib)%apply_sqrt_ad(mpl,geom,fld_tmp(:,:,iv),cv_tmp%blk(1))

         ! Sum control variable
         do icmp=1,cv%blk(1)%ncmp
            cv%blk(1)%cmp(icmp)%alpha = cv%blk(1)%cmp(icmp)%alpha+cv_tmp%blk(1)%cmp(icmp)%alpha
         end do
      end if
   end do

   ! Release memory
   deallocate(fld_tmp)
end select

! Probe out
@:probe_out()

end subroutine nicas_apply_sqrt_ad

!----------------------------------------------------------------------
! Subroutine: nicas_gen_ens_pert
!> Randomize NICAS to generate an ensemble of perturbation
!----------------------------------------------------------------------
subroutine nicas_gen_ens_pert(nicas,mpl,rng,nam,geom,bpar,ne,ens)

implicit none

! Passed variables
class(nicas_type),intent(inout) :: nicas !< NICAS data
type(mpl_type),intent(inout) :: mpl      !< MPI data
type(rng_type),intent(inout) :: rng      !< Random number generator
type(nam_type),intent(in) :: nam         !< Namelist
type(geom_type),intent(in) :: geom       !< Geometry
type(bpar_type),intent(in) :: bpar       !< Blocal parameters
integer,intent(in) :: ne                 !< Number of members
type(ens_type),intent(inout) :: ens      !< Ensemble

! Local variable
integer :: ie
real(kind_real) :: fld_c0a(geom%nc0a,geom%nl0,nam%nv)
type(cv_type) :: cv_ens(ne)

! Set name
@:set_name(nicas_gen_ens_pert)

! Probe in
@:probe_in()

! Allocation
call ens%alloc(ne,1)

do ie=1,ne
   ! Generate random control vector
   call nicas%random_cv(mpl,rng,bpar,cv_ens(ie))

   ! Apply square-root
   call nicas%apply_sqrt(mpl,nam,geom,bpar,cv_ens(ie),fld_c0a)

   ! Set metadata
   call ens%mem(ie)%init(mpl,geom%afunctionspace_mg,geom%gmask_mga,nam%variables(1:nam%nv),nam%lev2d)

   ! Set member from subset Sc0
   call ens%set_c0(mpl,nam,geom,'member',ie,fld_c0a)
end do

! Normalize ensemble members (unit variance)
call ens%normalize(mpl,nam,geom)

! Probe out
@:probe_out()

end subroutine nicas_gen_ens_pert

!----------------------------------------------------------------------
! Subroutine: nicas_apply_bens
!> Apply localized ensemble covariance
!----------------------------------------------------------------------
subroutine nicas_apply_bens(nicas,mpl,nam,geom,bpar,ens,fld)

implicit none

! Passed variables
class(nicas_type),intent(in) :: nicas                           !< NICAS data
type(mpl_type),intent(inout) :: mpl                             !< MPI data
type(nam_type),intent(in) :: nam                                !< Namelist
type(geom_type),intent(in) :: geom                              !< Geometry
type(bpar_type),intent(in) :: bpar                              !< Blocal parameters
type(ens_type),intent(in) :: ens                                !< Ensemble
real(kind_real),intent(inout) :: fld(geom%nc0a,geom%nl0,nam%nv) !< Field

! Local variable
integer :: ie
real(kind_real) :: fld_copy(geom%nc0a,geom%nl0,nam%nv),fld_tmp(geom%nc0a,geom%nl0,nam%nv)
real(kind_real) :: pert(geom%nc0a,geom%nl0,nam%nv)

! Set name
@:set_name(nicas_apply_bens)

! Probe in
@:probe_in()

! Copy field
fld_copy = fld

! Apply localized ensemble covariance formula
fld = zero
do ie=1,ens%ne
   ! Get member on subset Sc0
   call ens%get_c0(mpl,nam,geom,'pert',ie,pert)

   ! Schur product
   fld_tmp = pert*fld_copy

   ! Apply NICAS
   call nicas%apply(mpl,nam,geom,bpar,fld_tmp)

   ! Schur product
   fld = fld+fld_tmp*pert

   ! Normalization
   fld = fld/real(ens%ne-1,kind_real)
end do

! Probe out
@:probe_out()

end subroutine nicas_apply_bens

!----------------------------------------------------------------------
! Subroutine: nicas_test_adjoint
!> Test NICAS adjoint
!----------------------------------------------------------------------
subroutine nicas_test_adjoint(nicas,mpl,rng,nam,geom,bpar,ens)

implicit none

! Passed variables
class(nicas_type),intent(in) :: nicas     !< NICAS data
type(mpl_type),intent(inout) :: mpl       !< MPI data
type(rng_type),intent(inout) :: rng       !< Random number generator
type(nam_type),intent(in) :: nam          !< Namelist
type(geom_type),intent(in) :: geom        !< Geometry
type(bpar_type),intent(in) :: bpar        !< Block parameters
type(ens_type),intent(in) :: ens          !< Ensemble

! Local variables
real(kind_real) :: sum1,sum2
real(kind_real) :: fld1(geom%nc0a,geom%nl0,nam%nv),fld1_save(geom%nc0a,geom%nl0,nam%nv)
real(kind_real) :: fld2(geom%nc0a,geom%nl0,nam%nv),fld2_save(geom%nc0a,geom%nl0,nam%nv)
real(kind_real),allocatable :: fld1_bens(:,:,:),fld2_bens(:,:,:)
logical :: lbens

! Set name
@:set_name(nicas_test_adjoint)

! Probe in
@:probe_in()

! Initialization
lbens = (allocated(ens%mem).and.(trim(nam%method)/='cor'))

! Allocation
if (lbens) then
   allocate(fld1_bens(geom%nc0a,geom%nl0,nam%nv))
   allocate(fld2_bens(geom%nc0a,geom%nl0,nam%nv))
end if

! Generate random field
call rng%rand(zero,one,fld1_save)
call rng%rand(zero,one,fld2_save)

! Adjoint test
fld1 = fld1_save
fld2 = fld2_save
call nicas%apply(mpl,nam,geom,bpar,fld1)
call nicas%apply(mpl,nam,geom,bpar,fld2)
if (lbens) then
   fld1_bens = fld1_save
   fld2_bens = fld2_save
   call nicas%apply_bens(mpl,nam,geom,bpar,ens,fld1_bens)
   call nicas%apply_bens(mpl,nam,geom,bpar,ens,fld2_bens)
end if

! Print result
call mpl%dot_prod(fld1,fld2_save,sum1)
call mpl%dot_prod(fld2,fld1_save,sum2)
write(mpl%info,'(a,e15.8,a,e15.8,a,e15.8)') '--- Full NICAS adjoint test values:                        ', &
 & sum1,' / ',sum2,' / ',two*abs(sum1-sum2)/abs(sum1+sum2)
call mpl%flush
write(mpl%test,'(a,l1)') '    Full NICAS adjoint test result:                        ', &
 & two*abs(sum1-sum2)/abs(sum1+sum2)<rth
call mpl%flush
if (lbens) then
   call mpl%dot_prod(fld1_bens,fld2_save,sum1)
   call mpl%dot_prod(fld2_bens,fld1_save,sum2)
   write(mpl%info,'(a,e15.8,a,e15.8,a,e15.8)') '--- Ensemble B adjoint test values:                        ', &
 & sum1,' / ',sum2,' / ',two*abs(sum1-sum2)/abs(sum1+sum2)
   call mpl%flush
   write(mpl%test,'(a,l1)') '    Ensemble B adjoint test result:                        ', &
 & two*abs(sum1-sum2)/abs(sum1+sum2)<rth
   call mpl%flush
end if

! Release memory
if (lbens) then
   deallocate(fld1_bens)
   deallocate(fld2_bens)
end if

! Probe out
@:probe_out()

end subroutine nicas_test_adjoint

!----------------------------------------------------------------------
! Subroutine: nicas_test_dirac
!> Apply NICAS to diracs
!----------------------------------------------------------------------
subroutine nicas_test_dirac(nicas,mpl,nam,geom,bpar,ens)

implicit none

! Passed variables
class(nicas_type),intent(inout) :: nicas !< NICAS data
type(mpl_type),intent(inout) :: mpl      !< MPI data
type(nam_type),intent(in) :: nam         !< Namelist
type(geom_type),intent(in) :: geom       !< Geometry
type(bpar_type),intent(in) :: bpar       !< Block parameters
type(ens_type),intent(in) :: ens         !< Ensemble

! Local variables
integer :: ic0a,idir
real(kind_real),allocatable :: fld_c0a(:,:,:),fld_ens_c0a(:,:,:)
logical :: lbens

! Set name
@:set_name(nicas_test_dirac)

! Probe in
@:probe_in()

! Initialization
lbens = (allocated(ens%mem).and.(trim(nam%method)/='cor'))

! Allocation
allocate(fld_c0a(geom%nc0a,geom%nl0,nam%nv))
allocate(nicas%dirac(geom%nc0a,geom%nl0,nam%nv))
if (lbens) then
   allocate(fld_ens_c0a(geom%nc0a,geom%nl0,nam%nv))
   allocate(nicas%dirac_bens(geom%nc0a,geom%nl0,nam%nv))
end if

! Initialization
nicas%dirac = zero
if (lbens) nicas%dirac_bens = zero

do idir=1,geom%ndir
   ! Generate dirac field
   fld_c0a = zero
   if (geom%iprocdir(idir)==mpl%myproc) fld_c0a(geom%ic0adir(idir),geom%il0dir(idir),geom%ivdir(idir)) = one
   if (lbens) fld_ens_c0a = fld_c0a

   ! Apply NICAS to dirac
   call nicas%apply(mpl,nam,geom,bpar,fld_c0a)

   ! Apply localized ensemble covariance
   if (lbens) call nicas%apply_bens(mpl,nam,geom,bpar,ens,fld_ens_c0a)

   ! Copy points
   do ic0a=1,geom%nc0a
      if (idir==geom%dirac_index(ic0a)) then
         nicas%dirac(ic0a,:,:) = fld_c0a(ic0a,:,:)
         if (lbens) nicas%dirac_bens(ic0a,:,:) = fld_ens_c0a(ic0a,:,:)
      end if
   end do
end do

! Probe out
@:probe_out()

end subroutine nicas_test_dirac

!----------------------------------------------------------------------
! Subroutine: nicas_test_randomization
!> Test NICAS randomization method with respect to theoretical error statistics
!----------------------------------------------------------------------
subroutine nicas_test_randomization(nicas,mpl,rng,nam,geom,bpar)

implicit none

! Passed variables
class(nicas_type),intent(inout) :: nicas !< NICAS data
type(mpl_type),intent(inout) :: mpl      !< MPI data
type(rng_type),intent(inout) :: rng      !< Random number generator
type(nam_type),intent(inout) :: nam      !< Namelist variables
type(geom_type),intent(in) :: geom       !< Geometry
type(bpar_type),intent(in) :: bpar       !< Block parameters

! Local variables
integer :: ifac,itest,nefac(nfac_rnd),ens1_ne
integer :: ncid,ntest_id,nfac_id,nefac_id,mse_id,mse_th_id
real(kind_real) :: fld(geom%nc0a,geom%nl0,nam%nv),mse(ntest,nfac_rnd),mse_th(ntest,nfac_rnd),mse_avg,mse_th_avg
real(kind_real),allocatable :: fld_ref(:,:,:,:),fld_save(:,:,:,:)
type(ens_type) :: ens

! Set name
@:set_name(nicas_test_randomization)

! Probe in
@:probe_in()

! Allocation
allocate(fld_ref(geom%nc0a,geom%nl0,nam%nv,ntest))
allocate(fld_save(geom%nc0a,geom%nl0,nam%nv,ntest))

! Define test vectors
write(mpl%info,'(a4,a)') '','Define test vectors'
call mpl%flush
call geom%define_test_vectors(mpl,rng,nam,ntest,fld_save)
if (nam%default_seed) call rng%reseed(mpl)

! Apply NICAS to test vectors
write(mpl%info,'(a4,a)') '','Apply NICAS to test vectors: '
call mpl%flush(.false.)
call mpl%prog_init(ntest)
fld_ref = fld_save
do itest=1,ntest
   ! Apply vector
   call nicas%apply(mpl,nam,geom,bpar,fld_ref(:,:,:,itest))

   ! Update
   call mpl%prog_print(itest)
end do
call mpl%prog_final

! Save namelist variables
ens1_ne = nam%ens1_ne

write(mpl%info,'(a4,a)') '','Test randomization for various ensemble sizes:'
call mpl%flush
do ifac=1,nfac_rnd
   ! Ensemble size
   nefac(ifac) = max(int(real(ifac,kind_real)/real(nfac_rnd,kind_real)*real(ens1_ne,kind_real)),3)
   nam%ens1_ne = nefac(ifac)
   write(mpl%info,'(a7,a,i6,a)') '','Ensemble sizes: ',nefac(ifac),' members'
   call mpl%flush

   ! Randomize ensemble
   write(mpl%info,'(a10,a)') '','Randomization'
   call mpl%flush
   call nicas%gen_ens_pert(mpl,rng,nam,geom,bpar,nefac(ifac),ens)

   ! Test randomized ensemble
   write(mpl%info,'(a10,a)') '','Apply NICAS to test vectors: '
   call mpl%flush(.false.)
   call mpl%prog_init(ntest)
   do itest=1,ntest
      ! Test NICAS
      fld = fld_save(:,:,:,itest)
      call ens%apply_bens(mpl,nam,geom,fld)

      ! RMSE
      fld = fld-fld_ref(:,:,:,itest)
      call mpl%dot_prod(fld,fld,mse(itest,ifac))
      call mpl%dot_prod(fld_ref(:,:,:,itest),fld_ref(:,:,:,itest),mse_th(itest,ifac))
      mse_th(itest,ifac) = one/real(nam%ens1_ne-1,kind_real)*(mse_th(itest,ifac)+real(geom%nc0*geom%nl0*nam%nv,kind_real))

      ! Update
      call mpl%prog_print(itest)
   end do
   call mpl%prog_final

   ! Print scores
   mse_avg = sum(mse(:,ifac))/real(ntest,kind_real)
   mse_th_avg = sum(mse_th(:,ifac))/real(ntest,kind_real)
   write(mpl%test,'(a10,a,e15.8,a,e15.8,a,f5.3)') '','MSE (exp. / th. / ratio): ',mse_avg,' / ',mse_th_avg,' / ',mse_avg/mse_th_avg
   call mpl%flush

   ! Release memory
   call ens%dealloc
end do

! Reset namelist variables
nam%ens1_ne = ens1_ne

if (mpl%main) then
   ! Create file
   ncid = create_file(mpl,trim(nam%prefix)//'randomization',0)

   ! Define dimensions
   ntest_id = define_dim(mpl,ncid,'ntest',ntest)
   nfac_id = define_dim(mpl,ncid,'nfac',nfac_rnd)

   ! Define variables
   nefac_id = define_var(mpl,ncid,'nefac','real',(/nfac_id/))
   mse_id = define_var(mpl,ncid,'mse','real',(/ntest_id,nfac_id/))
   mse_th_id = define_var(mpl,ncid,'mse_th','real',(/ntest_id,nfac_id/))

   ! Write variables
   call put_var(mpl,ncid,nefac_id,nefac)
   call put_var(mpl,ncid,mse_id,mse)
   call put_var(mpl,ncid,mse_th_id,mse_th)

   ! Close file
   call close_file(mpl,ncid)
end if

! Release memory
deallocate(fld_ref)
deallocate(fld_save)

! Probe out
@:probe_out()

end subroutine nicas_test_randomization

end module type_nicas
