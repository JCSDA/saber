#:include 'instrumentation.fypp'
#:include 'generics.fypp'
!----------------------------------------------------------------------
! Module: tools_func
!> Usual functions
! Author: Benjamin Menetrier
! Licensing: this code is distributed under the CeCILL-C license
! Copyright 2015-... UCAR, CERFACS, METEO-FRANCE and IRIT
!----------------------------------------------------------------------
module tools_func

use fckit_mpi_module, only: fckit_mpi_sum
use iso_c_binding
use tools_asa007, only: cholesky,syminv
use tools_const, only: zero,hundredth,tenth,half,one,two,three,four,five,eight,ten,pi,deg2rad,rad2deg,ageometry
use tools_kinds, only: kind_int,kind_short,kind_real,huge_int,huge_short,huge_real
use tools_qsort, only: qsort
use tools_repro, only: repro_th,inf,sup,infeq,small,eq
use tools_wrfda, only: da_eof_decomposition
use type_mpl, only: mpl_type
@:use_probe()

implicit none

interface
   function c_fletcher32(n,var) bind(c,name='fletcher32') result(hash)
   use iso_c_binding, only: c_int16_t,c_int32_t
   integer(c_int32_t) :: n
   integer(c_int16_t) :: var(*)
   integer(c_int32_t) :: hash
   end function c_fletcher32
end interface
interface fletcher32
   module procedure func_fletcher32
end interface
interface lonlatmod
   module procedure func_lonlatmod
end interface
interface rad2short
   module procedure func_rad2short
end interface
interface grid_hash
   module procedure func_grid_hash
end interface
interface independent_levels
   module procedure func_independent_levels
end interface
interface sphere_bearing
   module procedure func_sphere_bearing
end interface
interface sphere_dist
   module procedure func_sphere_dist
end interface
interface cart_dist
   module procedure func_cart_dist
end interface
interface lonlat2xyz
   module procedure func_lonlat2xyz
end interface
interface xyz2lonlat
   module procedure func_xyz2lonlat
end interface
interface vector_product
   module procedure func_vector_product
end interface
interface det
   module procedure func_det
end interface
interface inside
   module procedure func_inside
end interface
interface add
   module procedure func_add
end interface
interface divide
   module procedure func_divide
end interface
interface vert_interp_size
   module procedure func_vert_interp_size
end interface
interface vert_interp_setup
   module procedure func_vert_interp_setup
end interface
interface vert_interp
   module procedure func_vert_interp
end interface
interface cholesky
   module procedure func_cholesky
end interface
interface syminv
   module procedure func_syminv
end interface
interface histogram
   module procedure func_histogram
end interface
interface cx_to_cxa
   module procedure func_cx_to_cxa
end interface
interface cx_to_proc
   module procedure func_cx_to_proc
end interface
interface cx_to_cxu
   module procedure func_cx_to_cxu
end interface
interface convert_i2l
   module procedure func_convert_i2l_r0
#:for rank in ranks_123456
   module procedure func_convert_i2l_r${rank}$
#:endfor
end interface
interface convert_l2i
   module procedure func_convert_l2i_r0
#:for rank in ranks_123456
   module procedure func_convert_l2i_r${rank}$
#:endfor
end interface
interface zss_maxval
   #:for dtype in dtypes_ir
      #:for rank in ranks_123456
         module procedure func_zss_maxval_${dtype}$_r${rank}$
      #:endfor
   #:endfor
end interface
interface zss_minval
   #:for dtype in dtypes_ir
      #:for rank in ranks_123456
         module procedure func_zss_minval_${dtype}$_r${rank}$
      #:endfor
   #:endfor
end interface
interface zss_sum
   #:for dtype in dtypes_ir
      #:for rank in ranks_123456
         module procedure func_zss_sum_${dtype}$_r${rank}$
      #:endfor
   #:endfor
end interface
interface zss_count
   #:for rank in ranks_123456
      module procedure func_zss_count_r${rank}$
   #:endfor
end interface
interface global_average
   #:for rank in ranks_1234
      module procedure func_global_average_r${rank}$
   #:endfor
end interface

private
public :: fletcher32,lonlatmod,rad2short,grid_hash,independent_levels,sphere_bearing,sphere_dist,cart_dist,lonlat2xyz,xyz2lonlat, &
 & vector_product,det,inside,add,divide,vert_interp_size,vert_interp_setup,vert_interp,cholesky,syminv,histogram, &
 & cx_to_cxa,cx_to_proc,cx_to_cxu,convert_i2l,convert_l2i,zss_maxval,zss_minval,zss_sum,zss_count,global_average

contains

!----------------------------------------------------------------------
! Function: func_fletcher32
!> Fletcher-32 checksum algorithm
!----------------------------------------------------------------------
function func_fletcher32(var) result(value)

implicit none

! Passed variables
integer(kind_short),intent(in) :: var(:) !< Variable

! Returned variable
integer :: value

! Local values
integer :: var_size

! Set name
@:set_name(func_fletcher32)

! Probe in
@:probe_in()

! Initialization
var_size  = size(var)

! Call C function
value = c_fletcher32(var_size,var)

! Probe out
@:probe_out()

end function func_fletcher32

!----------------------------------------------------------------------
! Subroutine: func_lonlatmod
!> Set latitude between -pi/2 and pi/2 and longitude between -pi and pi
!----------------------------------------------------------------------
subroutine func_lonlatmod(lon,lat)

implicit none

! Passed variables
real(kind_real),intent(inout) :: lon !< Longitude [radians]
real(kind_real),intent(inout) :: lat !< Latitude [radians]

! Set name
@:set_name(func_lonlatmod)

! Probe in
@:probe_in()

! Check latitude bounds
if (lat>half*pi) then
   lat = pi-lat
   lon = lon+pi
elseif (lat<-half*pi) then
   lat = -pi-lat
   lon = lon+pi
end if

! Check longitude bounds
if (lon>pi) then
   lon = lon-two*pi
elseif (lon<-pi) then
   lon = lon+two*pi
end if

! Same zero longitude for poles
if (abs(lat)>(half-1.0e-6_kind_real)*pi) lon = zero

! Probe out
@:probe_out()

end subroutine func_lonlatmod

!----------------------------------------------------------------------
! Subroutine: func_rad2short
!> Convert lontitude/latitude in radian into short integer for hash computation
!----------------------------------------------------------------------
subroutine func_rad2short(rad_real,rad_short)

implicit none

! Passed variables
real(kind_real),intent(in) :: rad_real       !< Angle (longitude or latitude) [radians]
integer(kind_short),intent(out) :: rad_short !< Short integer value

! Set name
@:set_name(func_rad2short)

! Probe in
@:probe_in()

! Convert to integer
rad_short = int(rad_real/pi*real(huge_short),kind_short)

! Probe out
@:probe_out()

end subroutine func_rad2short

!----------------------------------------------------------------------
! Subroutine: func_grid_hash
!> Compute grid hash value from coordinates
!----------------------------------------------------------------------
subroutine func_grid_hash(ncx,lon_cx,lat_cx,mask_cx,hash)

implicit none

! Passed variables
integer,intent(in) :: ncx                 !< Number of points (global)
real(kind_real),intent(in) :: lon_cx(ncx) !< Longitude [radians]
real(kind_real),intent(in) :: lat_cx(ncx) !< Latitude [radians]
logical,intent(in) :: mask_cx(ncx)        !< Mask
integer,intent(out) :: hash               !< Grid hash

! Local variables
integer :: icx
integer(kind_short) :: lonlat(2*ncx)

! Set name
@:set_name(func_grid_hash)

! Probe in
@:probe_in()

! Intialization
lonlat = 0_kind_short

! Loop over points
do icx=1,ncx
   if (mask_cx(icx)) then
      call rad2short(lon_cx(icx),lonlat(2*(icx-1)+1))
      call rad2short(lat_cx(icx),lonlat(2*icx))
   end if
end do

! Compute hash
hash = fletcher32(lonlat)

! Probe out
@:probe_out()

end subroutine func_grid_hash

!----------------------------------------------------------------------
! Subroutine: func_independent_levels
!> Compute independent levels
!----------------------------------------------------------------------
subroutine func_independent_levels(mpl,ncxa,nlx,mask_cxa,nlxi,lx_to_lxi,lxi_to_lx)

implicit none

! Passed variables
type(mpl_type),intent(inout) :: mpl         !< MPI data
integer,intent(in) :: ncxa                  !< Number of points (local)
integer,intent(in) :: nlx                   !< Number of levels
logical,intent(in) :: mask_cxa(ncxa,nlx)    !< Mask
integer,intent(out) :: nlxi                 !< Number of independent levels
integer,intent(out) :: lx_to_lxi(nlx)       !< Levels to independent levels
integer,intent(out) :: lxi_to_lx(nlx)       !< Independent levels to levels

! Local variables
integer :: icxa,ilx,ilxi,jlx,jlxi,i,n,iproc
integer :: hash(nlx),proc_to_hash(nlx,mpl%nproc),lx_to_lx(nlx)
integer(kind_short) :: jcxa
integer(kind_short),allocatable :: array(:)
logical :: same_grid(mpl%nproc)
character(len=13) :: cfmt

! Set name
@:set_name(func_independent_levels)

! Probe in
@:probe_in()

! Compute local hash for the mask of each level
do ilx=1,nlx
   n = count(.not.mask_cxa(:,ilx))
   if (n==0) then
      hash(ilx) = 0
   else
      ! Allocation
      allocate(array(n))

      ! Fill array
      i = 0
      do icxa=1,ncxa
         if (.not.mask_cxa(icxa,ilx)) then
            i = i+1
            jcxa = int(mod(icxa,int(huge_short,kind_int)),kind_short)
            array(i) = jcxa
         end if
      end do

      ! Fletcher hash
      hash(ilx) = fletcher32(array)

      ! Release memory
      deallocate(array)
   end if
end do

! Communication
call mpl%allgather(hash,proc_to_hash)

! Determine independent levels
lx_to_lx(1) = 1
do ilx=2,nlx
   ! Check if there is already a similar level below
   lx_to_lx(ilx) = ilx
   do jlx=1,ilx-1
      if (lx_to_lx(ilx)==ilx) then
         do iproc=1,mpl%nproc
            same_grid(iproc) = (proc_to_hash(jlx,iproc)==proc_to_hash(ilx,iproc))
         end do
         if (all(same_grid)) lx_to_lx(ilx) = jlx
      end if
   end do
end do

! Count independent levels
nlxi = 0
do ilx=1,nlx
   if (lx_to_lx(ilx)==ilx) nlxi = nlxi+1
end do

! Initialization
lxi_to_lx = mpl%msv%vali

! Get independent levels
ilxi = 0
do ilx=1,nlx
   jlx = lx_to_lx(ilx)
   if (jlx==ilx) then
      ! New independent level
      ilxi = ilxi+1
      lxi_to_lx(ilxi) = ilx
      lx_to_lxi(ilx) = ilxi
   else
      ! Existing level
      jlxi = lx_to_lxi(jlx)
      lx_to_lxi(ilx) = jlxi
   end if
end do

! Print levels
write(mpl%test,'(a)') ''
do ilxi=1,nlxi
   ilx = lxi_to_lx(ilxi)
   n = count(lx_to_lxi==ilxi)
   if (n<10) then
      cfmt = '(a,i3,a,i1,a)'
   elseif (n<100) then
      cfmt = '(a,i3,a,i2,a)'
   elseif (n<1000) then
      cfmt = '(a,i3,a,i3,a)'
   else
      call mpl%abort('${subr}$','level larger than 1000')
   end if
   write(mpl%test,cfmt) trim(mpl%test),ilx,'[',n,'] '
end do
call mpl%flush

! Probe out
@:probe_out()

end subroutine func_independent_levels

!----------------------------------------------------------------------
! Subroutine: func_cart_dist
!> Compute the cartesian distance between two points
!----------------------------------------------------------------------
subroutine func_cart_dist(x_i,y_i,z_i,x_f,y_f,z_f,dist)

implicit none

! Passed variable
real(kind_real),intent(in) :: x_i   !< Initial point X coordinate
real(kind_real),intent(in) :: y_i   !< Initial point Y coordinate
real(kind_real),intent(in) :: z_i   !< Initial point Z coordinate
real(kind_real),intent(in) :: x_f   !< Final point X coordinate
real(kind_real),intent(in) :: y_f   !< Final point Y coordinate
real(kind_real),intent(in) :: z_f   !< Final point Z coordinate
real(kind_real),intent(out) :: dist !< Great-circle distance

! Set name
@:set_name(func_cart_dist)

! Probe in
@:probe_in()

! Compute distance
dist = sqrt((x_f-x_i)**2+(y_f-y_i)**2+(z_f-z_i)**2)

! Probe out
@:probe_out()

end subroutine func_cart_dist

!----------------------------------------------------------------------
! Subroutine: func_sphere_bearing
!> Compute the bearing between two points
!----------------------------------------------------------------------
subroutine func_sphere_bearing(lon_i,lat_i,lon_f,lat_f,bearing)

implicit none

! Passed variable
real(kind_real),intent(in) :: lon_i    !< Initial point longitude [radians]
real(kind_real),intent(in) :: lat_i    !< Initial point latitude [radians]
real(kind_real),intent(in) :: lon_f    !< Final point longitude [radians]
real(kind_real),intent(in) :: lat_f    !< Final point latitude [radians]
real(kind_real),intent(out) :: bearing !< Bearing [radians]

! Local variables
real(kind_real) :: cosdlon,sindlon,coslat_i,coslat_f,sinlat_i,sinlat_f,x,y

! Set name
@:set_name(func_sphere_bearing)

! Probe in
@:probe_in()

! Trigonometry
cosdlon = cos(lon_f-lon_i)
sindlon = sin(lon_f-lon_i)
coslat_i = cos(lat_i)
coslat_f = cos(lat_f)
sinlat_i = sin(lat_i)
sinlat_f = sin(lat_f)

! Compute bearing
x = coslat_f*sindlon
y = coslat_i*sinlat_f-sinlat_i*coslat_f*cosdlon
bearing = atan2(y,x)

! Probe out
@:probe_out()

end subroutine func_sphere_bearing

!----------------------------------------------------------------------
! Subroutine: func_sphere_dist
!> Compute the great-circle distance between two points
!----------------------------------------------------------------------
subroutine func_sphere_dist(lon_i,lat_i,lon_f,lat_f,dist)

implicit none

! Passed variable
real(kind_real),intent(in) :: lon_i !< Initial point longitude [radians]
real(kind_real),intent(in) :: lat_i !< Initial point latitude [radians]
real(kind_real),intent(in) :: lon_f !< Final point longitude [radians]
real(kind_real),intent(in) :: lat_f !< Final point latitude [radians]
real(kind_real),intent(out) :: dist !< Great-circle distance

! Set name
@:set_name(func_sphere_dist)

! Probe in
@:probe_in()

! Create ATLAS geometry


! Compute distance
dist = ageometry%distance(lon_i*rad2deg,lat_i*rad2deg,lon_f*rad2deg,lat_f*rad2deg)

! Probe out
@:probe_out()

end subroutine func_sphere_dist

!----------------------------------------------------------------------
! Subroutine: func_lonlat2xyz
!> Convert longitude/latitude to cartesian coordinates
!----------------------------------------------------------------------
subroutine func_lonlat2xyz(mpl,lon,lat,x,y,z)

implicit none

! Passed variables
type(mpl_type),intent(inout) :: mpl !< MPI data
real(kind_real),intent(in) :: lon   !< Longitude [radians]
real(kind_real),intent(in) :: lat   !< Latitude [radians]
real(kind_real),intent(out) :: x    !< X coordinate
real(kind_real),intent(out) :: y    !< Y coordinate
real(kind_real),intent(out) :: z    !< Z coordinate

! Set name
@:set_name(func_lonlat2xyz)

! Probe in
@:probe_in()

if (mpl%msv%isnot(lat).and.mpl%msv%isnot(lon)) then
   ! Check longitude/latitude
   if (inf(lon,-pi).and.sup(lon,pi)) call mpl%abort('${subr}$','wrong longitude')
   if (inf(lat,-half*pi).and.sup(lat,-half*pi)) call mpl%abort('${subr}$','wrong latitude')

   ! Convert to x/y/z
   call ageometry%lonlat2xyz(lon*rad2deg,lat*rad2deg,x,y,z)
else
   ! Missing values
   x = mpl%msv%valr
   y = mpl%msv%valr
   z = mpl%msv%valr
end if

! Probe out
@:probe_out()

end subroutine func_lonlat2xyz

!----------------------------------------------------------------------
! Subroutine: func_xyz2lonlat
!> Convert longitude/latitude to cartesian coordinates
!----------------------------------------------------------------------
subroutine func_xyz2lonlat(mpl,x,y,z,lon,lat)

implicit none

! Passed variables
type(mpl_type),intent(in) :: mpl   !< MPI data
real(kind_real),intent(in) :: x    !< X coordinate
real(kind_real),intent(in) :: y    !< Y coordinate
real(kind_real),intent(in) :: z    !< Z coordinate
real(kind_real),intent(out) :: lon !< Longitude [radians]
real(kind_real),intent(out) :: lat !< Latitude [radians]

! Set name
@:set_name(func_xyz2lonlat)

! Probe in
@:probe_in()

if (mpl%msv%isnot(x).and.mpl%msv%isnot(y).and.mpl%msv%isnot(z)) then
   ! Convert to lon/lat
   call ageometry%xyz2lonlat(x,y,z,lon,lat)

   ! Copy coordinates
   lon = lon*deg2rad
   lat = lat*deg2rad
else
   ! Missing values
   lon = mpl%msv%valr
   lat = mpl%msv%valr
end if

! Probe out
@:probe_out()

end subroutine func_xyz2lonlat

!----------------------------------------------------------------------
! Subroutine: func_vector_product
!> Compute normalized vector product
!----------------------------------------------------------------------
subroutine func_vector_product(v1,v2,vp)

implicit none

! Passed variables
real(kind_real),intent(in) :: v1(3)  !< First vector
real(kind_real),intent(in) :: v2(3)  !< Second vector
real(kind_real),intent(out) :: vp(3) !< Vector product

! Local variable
real(kind_real) :: r

! Set name
@:set_name(func_vector_product)

! Probe in
@:probe_in()

! Vector product
vp(1) = v1(2)*v2(3)-v1(3)*v2(2)
vp(2) = v1(3)*v2(1)-v1(1)*v2(3)
vp(3) = v1(1)*v2(2)-v1(2)*v2(1)

! Normalization
r = sqrt(sum(vp**2))
if (r>repro_th) then
   vp = vp/r
else
   vp = zero
end if

! Probe out
@:probe_out()

end subroutine func_vector_product

!----------------------------------------------------------------------
! Subroutine: func_det
!> Compute determinant (vector triple product)
!----------------------------------------------------------------------
subroutine func_det(v1,v2,v3,p)

implicit none

! Passed variables
real(kind_real),intent(in) :: v1(3)   !< First vector
real(kind_real),intent(in) :: v2(3)   !< Second vector
real(kind_real),intent(in) :: v3(3)   !< Third vector
real(kind_real),intent(out) :: p      !< Determinant

! Local variable
real(kind_real) :: terms(6)

! Set name
@:set_name(func_det)

! Probe in
@:probe_in()

! Terms
terms(1) = v1(2)*v2(3)*v3(1)
terms(2) = -v1(3)*v2(2)*v3(1)
terms(3) = v1(3)*v2(1)*v3(2)
terms(4) = -v1(1)*v2(3)*v3(2)
terms(5) = v1(1)*v2(2)*v3(3)
terms(6) = -v1(2)*v2(1)*v3(3)

! Sum
p = sum(terms)

! Probe out
@:probe_out()

end subroutine func_det

!----------------------------------------------------------------------
! Subroutine: func_inside
!> Find whether a point is inside the hull boundaries or not
!----------------------------------------------------------------------
subroutine func_inside(mpl,vbnd,lon,lat,inside_hull)

implicit none

! Passed variables
type(mpl_type),intent(inout) :: mpl     !< MPI data
real(kind_real),intent(in) :: vbnd(:,:) !< Boundary coordinates
real(kind_real),intent(in) :: lon       !< Longitude
real(kind_real),intent(in) :: lat       !< Latitude
logical,intent(out) :: inside_hull      !< True if the point is inside the hull

! Local variables
integer :: i,inext
real(kind_real) :: vp(3),v1(3),v2(3),cp(3),cd(3)

! Set name
@:set_name(func_inside)

! Probe in
@:probe_in()

! Transform to cartesian coordinates
call lonlat2xyz(mpl,lon,lat,vp(1),vp(2),vp(3))

! Initialization
inside_hull = .true.

do i=1,size(vbnd,2)
   ! Index
   if (i<size(vbnd,2)) then
      inext = i+1
   else
      inext = 1
   end if

   ! Cross-product
   v1 = vbnd(:,inext)-vbnd(:,i)
   v2 = vp-vbnd(:,i)
   call vector_product(v1,v2,cp)

   ! Centroid
   cd = (vp+vbnd(:,i)+vbnd(:,inext))/three

   ! Compare the directions
   if (inf(sum(cp*cd),zero)) then
      inside_hull = .false.
      exit
   end if
end do

! Probe out
@:probe_out()

end subroutine func_inside

!----------------------------------------------------------------------
! Subroutine: func_add
!> Check if value missing and add if not missing
!----------------------------------------------------------------------
subroutine func_add(mpl,val,cumul,num,wgt)

implicit none

! Passed variables
type(mpl_type),intent(in) :: mpl           !< MPI data
real(kind_real),intent(in) :: val          !< Value to add
real(kind_real),intent(inout) :: cumul     !< Cumul
real(kind_real),intent(inout) :: num       !< Number of values
real(kind_real),intent(in),optional :: wgt !< Weight

! Local variables
real(kind_real) :: lwgt

! Set name
@:set_name(func_add)

! Probe in
@:probe_in()

! Initialize weight
lwgt = one
if (present(wgt)) lwgt = wgt

! Add value to cumul
if (mpl%msv%isnot(val)) then
   cumul = cumul+lwgt*val
   num = num+lwgt
end if

! Probe out
@:probe_out()

end subroutine func_add

!----------------------------------------------------------------------
! Subroutine: func_divide
!> Check if value missing and divide if not missing
!----------------------------------------------------------------------
subroutine func_divide(mpl,val,num)

implicit none

! Passed variables
type(mpl_type),intent(in) :: mpl     !< MPI data
real(kind_real),intent(inout) :: val !< Value to divide
real(kind_real),intent(in) :: num    !< Divider

! Set name
@:set_name(func_divide)

! Probe in
@:probe_in()

! Divide cumul by num
if (abs(num)>zero) then
   val = val/num
else
   val = mpl%msv%valr
end if

! Probe out
@:probe_out()

end subroutine func_divide

!----------------------------------------------------------------------
! Subroutine: func_vert_interp_size
!> Count vertical interpolation levels
!----------------------------------------------------------------------
subroutine func_vert_interp_size(nl0,dl0,nl1)

implicit none

! Passed variables
integer,intent(in) :: nl0     !< Number of levels
integer,intent(in) :: dl0     !< Level delta
integer,intent(out) :: nl1    !< Number of interpolation levels

! Local variables
integer :: il0_prev,il0,dl0_tmp

! Set name
@:set_name(func_vert_interp_size)

! Probe in
@:probe_in()

! Initialization
nl1 = 1
il0_prev = 1

! Loop over levels
do il0=2,nl0
   dl0_tmp = il0-il0_prev
   if (dl0_tmp==dl0) then
      il0_prev = il0
      nl1 = nl1+1
   end if
end do

! Probe out
@:probe_out()

end subroutine func_vert_interp_size

!----------------------------------------------------------------------
! Subroutine: func_vert_interp_setup
!> Setup vertical interpolation levels and weights
!----------------------------------------------------------------------
subroutine func_vert_interp_setup(nl0,dl0,nl1,il0_interp,il1inf,il1sup,rinf,rsup)

implicit none

! Passed variables
integer,intent(in) :: nl0                !< Number of levels
integer,intent(in) :: dl0                !< Level delta
integer,intent(in) :: nl1                !< Number of interpolation levels
integer,intent(out) :: il0_interp(nl1)   !< Interpolation levels
integer,intent(out) :: il1inf(nl0)       !< Inferior interpolation levels
integer,intent(out) :: il1sup(nl0)       !< Superior interpolation levels
real(kind_real),intent(out) :: rinf(nl0) !< Inferior interpolation weights
real(kind_real),intent(out) :: rsup(nl0) !< Superior interpolation weights

! Local variables
integer :: il0,il0_prev,jl0,dl0_tmp,il0_inf,il0_sup
integer :: il1,il1_inf,il1_sup

! Set name
@:set_name(func_vert_interp_setup)

! Probe in
@:probe_in()

! Initialization
il1 = 1
il0_interp(il1) = 1
il0_prev = 1
il0_sup = 1

! Loop over levels
do il0=2,nl0
   dl0_tmp = il0-il0_prev
   if (dl0_tmp==dl0) then
      il0_prev = il0
      il1 = il1+1
      il0_interp(il1) = il0
   end if
end do

! Loop over interpolation levels
do il1_inf=1,nl1
   il1_sup = min(il1_inf+1,nl1)
   il0_inf = il0_sup
   il0_sup = min(il0_inf+dl0,nl0)
   do jl0=il0_inf,il0_sup
      if (il0_inf==il0_sup) then
         il1inf(jl0) = il1_inf
         rinf(jl0) = one
         il1sup(jl0) = il1_sup
         rsup(jl0) = zero
      else
         il1inf(jl0) = il1_inf
         rinf(jl0) = real(il0_sup-jl0,kind_real)/real(il0_sup-il0_inf,kind_real)
         il1sup(jl0) = il1_sup
         rsup(jl0) = real(jl0-il0_inf,kind_real)/real(il0_sup-il0_inf,kind_real)
      end if
   end do
end do

! Probe out
@:probe_out()

end subroutine func_vert_interp_setup

!----------------------------------------------------------------------
! Subroutine: func_vert_interp
!> Apply vertical interpolation
!----------------------------------------------------------------------
subroutine func_vert_interp(mpl,nl1,data_l1,nl0,il1inf,il1sup,rinf,rsup,data_l0)

implicit none

! Passed variables
type(mpl_type),intent(inout) :: mpl         !< MPI data
integer,intent(in) :: nl1                   !< Number of interpolation levels
real(kind_real),intent(in) :: data_l1(nl1)  !< Input data
integer,intent(in) :: nl0                   !< Number of levels
integer,intent(in) :: il1inf(nl0)           !< Inferior interpolation levels
integer,intent(in) :: il1sup(nl0)           !< Superior interpolation levels
real(kind_real),intent(in) :: rinf(nl0)     !< Inferior interpolation weights
real(kind_real),intent(in) :: rsup(nl0)     !< Superior interpolation weights
real(kind_real),intent(out) :: data_l0(nl0) !< Output data

! Local variables
integer :: il0

! Set name
@:set_name(func_vert_interp)

! Probe in
@:probe_in()

! Interpolate
do il0=1,nl0
   if ((mpl%msv%is(data_l1(il1inf(il0))).and.(rinf(il0)>zero)) &
 & .or.(mpl%msv%is(data_l1(il1sup(il0))).and.(rsup(il0)>zero))) then
      data_l0(il0) = mpl%msv%valr
   else
      data_l0(il0) = rinf(il0)*data_l1(il1inf(il0))+rsup(il0)*data_l1(il1sup(il0))
   end if
end do

! Probe out
@:probe_out()

end subroutine func_vert_interp

!----------------------------------------------------------------------
! Subroutine: func_cholesky
!> Compute cholesky decomposition
! Author: Original FORTRAN77 version by Michael Healy, modifications by AJ Miller, FORTRAN90 version by John Burkardt.
!----------------------------------------------------------------------
subroutine func_cholesky(mpl,n,a,u)

implicit none

! Passed variables
type(mpl_type),intent(inout) :: mpl   !< MPI data
integer,intent(in) :: n               !< Matrix rank
real(kind_real),intent(in) :: a(n,n)  !< Matrix
real(kind_real),intent(out) :: u(n,n) !< Matrix square-root

! Local variables
integer :: nn,i,j,ij
real(kind_real),allocatable :: apack(:),upack(:)

! Set name
@:set_name(func_cholesky)

! Probe in
@:probe_in()

! Allocation
nn = (n*(n+1))/2
allocate(apack(nn))
allocate(upack(nn))

! Pack matrix
ij = 0
do i=1,n
   do j=1,i
      ij = ij+1
      apack(ij) = a(i,j)
   end do
end do

! Cholesky decomposition
call cholesky(mpl,n,nn,apack,upack)

! Unpack matrix
ij = 0
u = zero
do i=1,n
   do j=1,i
      ij = ij+1
      u(i,j) = upack(ij)
   end do
end do

! Release memory
deallocate(apack)
deallocate(upack)

! Probe out
@:probe_out()

end subroutine func_cholesky

!----------------------------------------------------------------------
! Subroutine: func_syminv
!> Compute inverse of a symmetric matrix
! Author: Original FORTRAN77 version by Michael Healy, modifications by AJ Miller, FORTRAN90 version by John Burkardt.
!----------------------------------------------------------------------
subroutine func_syminv(mpl,n,a,c)

implicit none

! Passed variables
type(mpl_type),intent(inout) :: mpl   !< MPI data
integer,intent(in) :: n               !< Matrix rank
real(kind_real),intent(in) :: a(n,n)  !< Matrix
real(kind_real),intent(out) :: c(n,n) !< Matrix inverse

! Local variables
integer :: nn,i,j,ij
real(kind_real),allocatable :: apack(:),cpack(:)

! Set name
@:set_name(func_syminv)

! Probe in
@:probe_in()

! Allocation
nn = (n*(n+1))/2
allocate(apack(nn))
allocate(cpack(nn))

! Pack matrix
ij = 0
do i=1,n
   do j=1,i
      ij = ij+1
      apack(ij) = a(i,j)
   end do
end do

! Matrix inversion
call syminv(mpl,n,nn,apack,cpack)

! Unpack matrix
ij = 0
do i=1,n
   do j=1,i
      ij = ij+1
      c(i,j) = cpack(ij)
      c(j,i) = c(i,j)
   end do
end do

! Release memory
deallocate(apack)
deallocate(cpack)

! Probe out
@:probe_out()

end subroutine func_syminv

!----------------------------------------------------------------------
! Subroutine: func_histogram
!> Compute bins and histogram from a list of values
!----------------------------------------------------------------------
subroutine func_histogram(mpl,nlist,list,nbins,histmin,histmax,bins,hist)

implicit none

! Passed variables
type(mpl_type),intent(inout) :: mpl          !< MPI data
integer,intent(in) :: nlist                  !< List size
real(kind_real),intent(in) :: list(nlist)    !< List
integer,intent(in) :: nbins                  !< Number of bins
real(kind_real),intent(in) :: histmin        !< Histogram minimum
real(kind_real),intent(in) :: histmax        !< Histogram maximum
real(kind_real),intent(out) :: bins(nbins+1) !< Bins
real(kind_real),intent(out) :: hist(nbins)   !< Histogram

! Local variables
integer :: ibins,ilist
real(kind_real) :: delta
logical :: found

! Set name
@:set_name(func_histogram)

! Probe in
@:probe_in()

! Check data
if (nbins<=0) call mpl%abort('${subr}$','the number of bins should be positive')
if (histmax>histmin) then
   if (zss_minval(list,mask=mpl%msv%isnot(list))<histmin) call mpl%abort('${subr}$','values below histogram minimum')
   if (zss_maxval(list,mask=mpl%msv%isnot(list))>histmax) call mpl%abort('${subr}$','values over histogram maximum')

   ! Compute bins
   delta = (histmax-histmin)/real(nbins,kind_real)
   bins(1) = histmin
   do ibins=2,nbins
      bins(ibins) = histmin+real(ibins-1,kind_real)*delta
   end do
   bins(nbins+1) = histmax

   ! Extend first and last bins
   bins(1) = bins(1)-1.0e-6_kind_real*delta
   bins(nbins+1) = bins(nbins+1)+1.0e-6_kind_real*delta

   ! Compute histogram
   hist = zero
   do ilist=1,nlist
      if (mpl%msv%isnot(list(ilist))) then
         ibins = 0
         found = .false.
         do while (.not.found)
            ibins = ibins+1
            if (ibins>nbins) call mpl%abort('${subr}$','bin not found')
            if (infeq(bins(ibins),list(ilist)).and.inf(list(ilist),bins(ibins+1))) then
               hist(ibins) = hist(ibins)+one
               found = .true.
            end if
         end do
      end if
   end do
   if (abs(sum(hist)-real(count(mpl%msv%isnot(list)),kind_real))>half) &
 & call mpl%abort('${subr}$','histogram sum is not equal to the number of valid elements')
else
   bins = mpl%msv%valr
   hist = zero
end if

! Probe out
@:probe_out()

end subroutine func_histogram

!----------------------------------------------------------------------
! Function: func_cx_to_cxa
!> Conversion from global to halo A on subset Scx
!----------------------------------------------------------------------
function func_cx_to_cxa(nproc,proc_to_cx_offset,icx) result(icxa)

implicit none

! Passed variables
integer,intent(in) :: nproc                    !< Number of processors
integer,intent(in) :: proc_to_cx_offset(nproc) !< Processor to offset on subset Scx
integer,intent(in) :: icx                      !< Global index

! Returned variable
integer :: icxa

! Local variable
integer :: iproc

! Set name
@:set_name(func_cx_to_cxa)

! Probe in
@:probe_in()

! Find processor
iproc = cx_to_proc(nproc,proc_to_cx_offset,icx)

! Get halo A index
icxa = icx-proc_to_cx_offset(iproc)

! Probe out
@:probe_out()

end function func_cx_to_cxa

!----------------------------------------------------------------------
! Function: func_cx_to_proc
!> Conversion from global to processor on subset Scx
!----------------------------------------------------------------------
function func_cx_to_proc(nproc,proc_to_cx_offset,icx) result(iproc)

implicit none

! Passed variables
integer,intent(in) :: nproc                    !< Number of processors
integer,intent(in) :: proc_to_cx_offset(nproc) !< Processor to offset on subset Scx
integer,intent(in) :: icx                      !< Global index

! Returned variable
integer :: iproc

! Set name
@:set_name(func_cx_to_proc)

! Probe in
@:probe_in()

! Find processor
do iproc=1,nproc-1
   if ((proc_to_cx_offset(iproc)<icx).and.(icx<=proc_to_cx_offset(iproc+1))) then
@:probe_out()
      return
   end if
end do

! Probe out
@:probe_out()

end function func_cx_to_proc

!----------------------------------------------------------------------
! Function: func_cx_to_cxu
!> Conversion from global to universe on subset Scx
!----------------------------------------------------------------------
function func_cx_to_cxu(nproc,proc_to_cx_offset,proc_to_ncxa,myuniverse,icx) result(icxu)

implicit none

! Passed variables
integer,intent(in) :: nproc                    !< Number of processors
integer,intent(in) :: proc_to_cx_offset(nproc) !< Processor to offset on subset Scx
integer,intent(in) :: proc_to_ncxa(nproc)      !< Processor to halo A size for subset Scx
logical,intent(in) :: myuniverse(nproc)        !< Task universe
integer,intent(in) :: icx                      !< Global index

! Returned variable
integer :: icxu

! Local variable
integer :: iproc,icxa,offset,jproc

! Set name
@:set_name(func_cx_to_cxu)

! Probe in
@:probe_in()

! Find processor
iproc = cx_to_proc(nproc,proc_to_cx_offset,icx)

if (myuniverse(iproc)) then
   ! Get halo A index
   icxa = icx-proc_to_cx_offset(iproc)

   ! Compute universe offset
   offset = 0
   do jproc=1,iproc-1
      if (myuniverse(jproc)) offset = offset+proc_to_ncxa(jproc)
   end do

   ! Get universe index
   icxu = offset+icxa
else
   ! Not in my universe
   icxu = 0
end if

! Probe out
@:probe_out()

end function func_cx_to_cxu

!----------------------------------------------------------------------
! Subroutine: func_convert_i2l_r0
!> Convert integer to logical
!----------------------------------------------------------------------
subroutine func_convert_i2l_r0(mpl,fldi,fldl)

implicit none

! Passed variables
type(mpl_type),intent(inout) :: mpl !< MPI data
integer,intent(in) :: fldi          !< Integer field
logical,intent(out) :: fldl         !< Logical field

! Set name
@:set_name(func_convert_i2l_r0)

! Probe in
@:probe_in()

if (fldi==0) then
   fldl = .false.
elseif (fldi==1) then
   fldl = .true.
else
   call mpl%abort('${subr}$','wrong integer value')
end if

! Probe out
@:probe_out()

end subroutine func_convert_i2l_r0

#:for rank in ranks_123456
!----------------------------------------------------------------------
! Subroutine: func_convert_i2l_r${rank}$
!> Convert integer to logical
!----------------------------------------------------------------------
subroutine func_convert_i2l_r${rank}$(mpl,fldi,fldl)

implicit none

! Passed variables
type(mpl_type),intent(inout) :: mpl        !< MPI data
integer,intent(in) :: fldi(${dim[rank]}$)  !< Integer field
logical,intent(out) :: fldl(${dim[rank]}$) !< Logical field

! Local variable
#:for arg_dim in range(1,rank+1)
integer :: i${arg_dim}$
#:endfor

! Set name
@:set_name(func_convert_i2l_r${rank}$)

! Probe in
@:probe_in()

#:for arg_dim in reversed(range(1,rank+1))
do i${arg_dim}$=1,size(fldl,${arg_dim}$)
#:endfor
   call convert_i2l(mpl,fldi( &
   #:for arg_dim in range(1,rank)
 & i${arg_dim}$, &
   #:endfor
 & i${rank}$),fldl( &
   #:for arg_dim in range(1,rank)
 & i${arg_dim}$, &
   #:endfor
 & i${rank}$))
#:for arg_dim in range(1,rank+1)
end do
#:endfor

! Probe out
@:probe_out()

end subroutine func_convert_i2l_r${rank}$
#:endfor

!----------------------------------------------------------------------
! Subroutine: func_convert_l2i_r0
!> Convert logical to integer
!----------------------------------------------------------------------
subroutine func_convert_l2i_r0(fldl,fldi)

implicit none

! Passed variables
logical,intent(in) :: fldl  !< Logical field
integer,intent(out) :: fldi !< Integer field

! Set name
@:set_name(func_convert_l2i_r0)

! Probe in
@:probe_in()

if (fldl) then
   fldi = 1
else
   fldi = 0
end if

! Probe out
@:probe_out()

end subroutine func_convert_l2i_r0

#:for rank in ranks_123456
!----------------------------------------------------------------------
! Subroutine: func_convert_l2i_r${rank}$
!> Convert logical to integer
!----------------------------------------------------------------------
subroutine func_convert_l2i_r${rank}$(fldl,fldi)

implicit none

! Passed variables
logical,intent(in) :: fldl(${dim[rank]}$)  !< Logical field
integer,intent(out) :: fldi(${dim[rank]}$) !< Integer field

! Local variable
#:for arg_dim in range(1,rank+1)
integer :: i${arg_dim}$
#:endfor

! Set name
@:set_name(func_convert_l2i_r${rank}$)

! Probe in
@:probe_in()

#:for arg_dim in reversed(range(1,rank+1))
do i${arg_dim}$=1,size(fldl,${arg_dim}$)
#:endfor
   call convert_l2i(fldl( &
   #:for arg_dim in range(1,rank)
 & i${arg_dim}$, &
   #:endfor
 & i${rank}$),fldi( &
   #:for arg_dim in range(1,rank)
 & i${arg_dim}$, &
   #:endfor
 & i${rank}$))
#:for arg_dim in range(1,rank+1)
end do
#:endfor

! Probe out
@:probe_out()

end subroutine func_convert_l2i_r${rank}$
#:endfor

#:for dtype in dtypes_ir
#:for rank in ranks_123456
!----------------------------------------------------------------------
! Function: func_zss_maxval_${dtype}$_r${rank}$
!> Zero-size-safe maxval function
!----------------------------------------------------------------------
function func_zss_maxval_${dtype}$_r${rank}$(array,mask) result(value)

implicit none

! Passed variables
${ftype[dtype]}$,intent(in) :: array(${dim[rank]}$) !< Array
logical,intent(in),optional :: mask(${dim[rank]}$)  !< Mask

! Returned variable
${ftype[dtype]}$ :: value

! Set name
@:set_name(func_zss_maxval_${dtype}$_r${rank}$)

! Probe in
@:probe_in()

if (size(array)>0) then
   if (present(mask)) then
      if (any(mask)) then
         value = maxval(array,mask=mask)
      else
         value = -${huge[dtype]}$
      end if
   else
      value = maxval(array)
   end if
else
   value = -${huge[dtype]}$
endif

! Probe out
@:probe_out()

end function func_zss_maxval_${dtype}$_r${rank}$
#:endfor
#:endfor

#:for dtype in dtypes_ir
#:for rank in ranks_123456
!----------------------------------------------------------------------
! Function: func_zss_minval_${dtype}$_r${rank}$
!> Zero-size-safe minval function
!----------------------------------------------------------------------
function func_zss_minval_${dtype}$_r${rank}$(array,mask) result(value)

implicit none

! Passed variables
${ftype[dtype]}$,intent(in) :: array(${dim[rank]}$) !< Array
logical,intent(in),optional :: mask(${dim[rank]}$)  !< Mask

! Returned variable
${ftype[dtype]}$ :: value

! Set name
@:set_name(func_zss_minval_${dtype}$_r${rank}$)

! Probe in
@:probe_in()

if (size(array)>0) then
   if (present(mask)) then
      if (any(mask)) then
         value = minval(array,mask=mask)
      else
         value = ${huge[dtype]}$
      end if
   else
      value = minval(array)
   end if
else
   value = ${huge[dtype]}$
endif

! Probe out
@:probe_out()

end function func_zss_minval_${dtype}$_r${rank}$
#:endfor
#:endfor

#:for dtype in dtypes_ir
#:for rank in ranks_123456
!----------------------------------------------------------------------
! Function: func_zss_sum_${dtype}$_r${rank}$
!> Zero-size-safe sum function
!----------------------------------------------------------------------
function func_zss_sum_${dtype}$_r${rank}$(array,mask) result(value)

implicit none

! Passed variables
${ftype[dtype]}$,intent(in) :: array(${dim[rank]}$) !< Array
logical,intent(in),optional :: mask(${dim[rank]}$)  !< Mask

! Returned variable
${ftype[dtype]}$ :: value

! Set name
@:set_name(func_zss_sum_${dtype}$_r${rank}$)

! Probe in
@:probe_in()

if (size(array)>0) then
   if (present(mask)) then
      if (any(mask)) then
         value = sum(array,mask=mask)
      else
         value = ${zero[dtype]}$
      end if
   else
      value = sum(array)
   end if
else
   value = ${zero[dtype]}$
endif

! Probe out
@:probe_out()

end function func_zss_sum_${dtype}$_r${rank}$
#:endfor
#:endfor

#:for rank in ranks_123456
!----------------------------------------------------------------------
! Function: func_zss_count_r${rank}$
!> Zero-size-safe count function
!----------------------------------------------------------------------
function func_zss_count_r${rank}$(array) result(value)

implicit none

! Passed variables
logical,intent(in) :: array(${dim[rank]}$) !< Array

! Returned variable
integer :: value

! Set name
@:set_name(func_zss_count_r${rank}$)

! Probe in
@:probe_in()

if (size(array)>0) then
   value = count(array)
else
   value = 0
endif

! Probe out
@:probe_out()

end function func_zss_count_r${rank}$
#:endfor

#:for rank in ranks_1234
!----------------------------------------------------------------------
! Function: func_global_average_r${rank}$
!> Global average of an array
!----------------------------------------------------------------------
function func_global_average_r${rank}$(mpl,array,gmask) result(value)

implicit none

! Passed variables
type(mpl_type),intent(inout) :: mpl                 !< MPI data
real(kind_real),intent(in) :: array(${dim[rank]}$)  !< Array
logical,intent(in),optional :: gmask(${dim[rank]}$) !< Mask

! Returned variable
real(kind_real) :: value

! Local variables
integer :: shp(${rank}$)
real(kind_real) :: norm
logical,allocatable :: lgmask(${dim[rank]}$)

! Set name
@:set_name(func_global_average_r${rank}$)

! Probe in
@:probe_in()

! Array shape
shp = shape(array)

! Allocation
#{if rank == 1}# allocate(lgmask(shp(1))) #{endif}#
#{if rank == 2}# allocate(lgmask(shp(1),shp(2))) #{endif}#
#{if rank == 3}# allocate(lgmask(shp(1),shp(2),shp(3))) #{endif}#
#{if rank == 4}# allocate(lgmask(shp(1),shp(2),shp(3),shp(4))) #{endif}#

! Initialization
value = zero
norm = zero
if (present(gmask)) then
   lgmask = gmask
else
   lgmask = .true.
end if

! Exclude missing values
lgmask = lgmask.and.mpl%msv%isnot(array)

! Sum of valid points
value = zss_sum(array,mask=lgmask)

! Count valid points
norm = real(zss_count(lgmask),kind_real)

! Communication
call mpl%f_comm%allreduce(value,fckit_mpi_sum())
call mpl%f_comm%allreduce(norm,fckit_mpi_sum())

! Average
if (norm>zero) value = value/norm

! Probe out
@:probe_out()

end function func_global_average_r${rank}$
#:endfor

end module tools_func
