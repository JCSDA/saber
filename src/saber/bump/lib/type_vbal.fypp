#:include 'instrumentation.fypp'
!----------------------------------------------------------------------
! Module: type_vbal
!> Vertical balance derived type
! Author: Benjamin Menetrier
! Licensing: this code is distributed under the CeCILL-C license
! Copyright 2015-... UCAR, CERFACS, METEO-FRANCE and IRIT
!----------------------------------------------------------------------
module type_vbal

use fckit_mpi_module, only: fckit_mpi_sum,fckit_mpi_status
!$ use omp_lib
use tools_const, only: zero,one,two,rad2deg
use tools_func, only: zss_maxval,zss_sum
use tools_kinds, only: kind_real
use tools_netcdf, only: create_file,open_file,define_grp,inquire_grp,define_dim,define_var,inquire_dim_size,inquire_var,put_var, &
 & get_var,close_file
use tools_repro, only: infeq,repro_th
use type_ens, only: ens_type
use type_geom, only: geom_type
use type_gsi, only: gsi_type
use type_mpl, only: mpl_type
use type_nam, only: nam_type
@:use_probe()
use type_rng, only: rng_type
use type_samp, only: samp_type
use type_vbal_blk, only: vbal_blk_type

implicit none

! Vertical balance derived type
type vbal_type
   ! Vertical balance data
   integer :: h_n_s_max                        !< Maximum number of neighbors
   integer,allocatable :: h_n_s(:,:)           !< Number of neighbors for the horizontal interpolation
   integer,allocatable :: h_c2b(:,:,:)         !< Index of neighbors for the horizontal interpolation
   real(kind_real),allocatable :: h_S(:,:,:)   !< Weight of neighbors for the horizontal interpolation
   type(vbal_blk_type),allocatable :: blk(:,:) !< Vertical balance blocks
   real(kind_real),allocatable :: dirac(:,:,:) !< Dirac field

   ! Dimensions for local I/O
   integer :: nc1a                             !< Number of points in subset Sc1, halo A
   integer :: nc2a                             !< Number of points in subset Sc2, halo A
contains
   procedure :: alloc => vbal_alloc
   procedure :: partial_dealloc => vbal_partial_dealloc
   procedure :: dealloc => vbal_dealloc
   procedure :: vbal_cov_read_local
   procedure :: vbal_cov_read_local_single
   generic :: cov_read_local => vbal_cov_read_local,vbal_cov_read_local_single
   procedure :: vbal_cov_write_local
   procedure :: vbal_cov_write_local_single
   generic :: cov_write_local => vbal_cov_write_local,vbal_cov_write_local_single
   procedure :: cov_read_global => vbal_cov_read_global
   procedure :: cov_write_global => vbal_cov_write_global
   procedure :: cov_send => vbal_cov_send
   procedure :: cov_receive => vbal_cov_receive
   procedure :: cov_run => vbal_cov_run
   procedure :: cov_update => vbal_cov_update
   procedure :: vbal_read_local
   procedure :: vbal_read_local_single
   generic :: read_local => vbal_read_local,vbal_read_local_single
   procedure :: vbal_write_local
   procedure :: vbal_write_local_single
   generic :: write_local => vbal_write_local,vbal_write_local_single
   procedure :: read_global => vbal_read_global
   procedure :: write_global => vbal_write_global
   procedure :: send => vbal_send
   procedure :: receive => vbal_receive
   procedure :: run_vbal => vbal_run_vbal
   procedure :: from_gsi => vbal_from_gsi
   procedure :: run_vbal_tests => vbal_run_vbal_tests
   procedure :: apply => vbal_apply
   procedure :: apply_inv => vbal_apply_inv
   procedure :: apply_ad => vbal_apply_ad
   procedure :: apply_inv_ad => vbal_apply_inv_ad
   procedure :: test_inverse => vbal_test_inverse
   procedure :: test_adjoint => vbal_test_adjoint
   procedure :: test_dirac => vbal_test_dirac
end type vbal_type

private
public :: vbal_type

contains

!----------------------------------------------------------------------
! Subroutine: vbal_alloc
!> Allocation
!----------------------------------------------------------------------
subroutine vbal_alloc(vbal,mpl,nam,geom,samp,nsub)

implicit none

! Passed variables
class(vbal_type),intent(inout) :: vbal      !< Vertical balance
type(mpl_type),intent(inout) :: mpl         !< MPI data
type(nam_type),intent(in) :: nam            !< Namelist
type(geom_type),intent(in) :: geom          !< Geometry
type(samp_type),optional,intent(in) :: samp !< Sampling
integer,intent(in),optional :: nsub         !< Number of sub-ensembles

! Local variables
integer :: iv,jv,lnsub

! Set name
@:set_name(vbal_alloc)

! Probe in
@:probe_in()

! Local number of sub-ensembles
lnsub = 0
if (present(nsub)) lnsub = nsub

! Check independent levels
if ((nam%new_vbal_cov.or.nam%load_vbal_cov).and.(geom%nl0i>1)) &
 & call mpl%abort('${subr}$','single independent level required for new_vbal_cov or load_vbal_cov')

! Allocation
allocate(vbal%blk(nam%nv,nam%nv))
do iv=1,nam%nv
   do jv=1,iv
      ! Set attributes
      vbal%blk(iv,jv)%name = trim(nam%variables(jv))//'-'//trim(nam%variables(iv))
      vbal%blk(iv,jv)%iv = iv
      vbal%blk(iv,jv)%jv = jv
      vbal%blk(iv,jv)%nsub = lnsub

      ! Block allocation
      if (present(samp)) call vbal%blk(iv,jv)%alloc(nam,geom,samp,iv,jv)
   end do
end do

! Probe out
@:probe_out()

end subroutine vbal_alloc

!----------------------------------------------------------------------
! Subroutine: vbal_partial_dealloc
!> Release memory (partial)
!----------------------------------------------------------------------
subroutine vbal_partial_dealloc(vbal)

implicit none

! Passed variables
class(vbal_type),intent(inout) :: vbal !< Vertical balance

! Local variables
integer :: iv,jv

! Set name
@:set_name(vbal_partial_dealloc)

! Probe in
@:probe_in()

! Release memory
if (allocated(vbal%blk)) then
   do jv=1,size(vbal%blk,2)
      do iv=1,size(vbal%blk,1)
         call vbal%blk(iv,jv)%partial_dealloc
      end do
   end do
end if

! Probe out
@:probe_out()

end subroutine vbal_partial_dealloc

!----------------------------------------------------------------------
! Subroutine: vbal_dealloc
!> Release memory (full)
!----------------------------------------------------------------------
subroutine vbal_dealloc(vbal)

implicit none

! Passed variables
class(vbal_type),intent(inout) :: vbal !< Vertical balance

! Local variables
integer :: iv,jv

! Set name
@:set_name(vbal_dealloc)

! Probe in
@:probe_in()

! Release memory
if (allocated(vbal%h_n_s)) deallocate(vbal%h_n_s)
if (allocated(vbal%h_c2b)) deallocate(vbal%h_c2b)
if (allocated(vbal%h_S)) deallocate(vbal%h_S)
if (allocated(vbal%blk)) then
   do jv=1,size(vbal%blk,2)
      do iv=1,size(vbal%blk,1)
         call vbal%blk(iv,jv)%dealloc
      end do
   end do
   deallocate(vbal%blk)
end if
if (allocated(vbal%dirac)) deallocate(vbal%dirac)

! Probe out
@:probe_out()

end subroutine vbal_dealloc

!----------------------------------------------------------------------
! Subroutine: vbal_cov_read_local
!> Read local full covariances
!----------------------------------------------------------------------
subroutine vbal_cov_read_local(vbal,mpl,nam,geom,samp,nsub)

implicit none

! Passed variables
class(vbal_type),intent(inout) :: vbal !< Vertical balance
type(mpl_type),intent(inout) :: mpl    !< MPI data
type(nam_type),intent(inout) :: nam    !< Namelist
type(geom_type),intent(in) :: geom     !< Geometry
type(samp_type),intent(in) :: samp     !< Sampling
integer,intent(in) :: nsub             !< Number of sub-ensembles

! Local variables
integer :: iproc,iprocio
type(vbal_type) :: vbal_tmp

! Set name
@:set_name(vbal_cov_read_local)

! Probe in
@:probe_in()

! Allocation
call vbal%alloc(mpl,nam,geom,samp,nsub)

do iproc=1,mpl%nproc
   ! Reading task
   iprocio = mod(iproc,mpl%nprocio)
   if (iprocio==0) iprocio = mpl%nprocio

   if (mpl%myproc==iprocio) then
      write(mpl%info,'(a10,a,i6,a,i6)') '','Read full covariances of task ',iproc,' from task ',iprocio
      call mpl%flush

      if (iproc==iprocio) then
         ! Read data
         call vbal%cov_read_local(mpl,nam,geom,nsub,iproc)
         if (vbal%nc1a/=samp%nc1a) call mpl%abort('${subr}$','vbal%nc1a is not equal to samp%nc1a')
      else
         ! Allocation
         call vbal_tmp%alloc(mpl,nam,geom)

         ! Read data
         call vbal_tmp%cov_read_local(mpl,nam,geom,nsub,iproc)

         ! Send data to task iproc
         call vbal_tmp%cov_send(mpl,nam,geom,iproc)

         ! Release memory
         call vbal_tmp%dealloc
      end if
   elseif (mpl%myproc==iproc) then
      ! Receive data from task iprocio
      write(mpl%info,'(a10,a,i6,a,i6)') '','Receive full covariances of task ',iproc,' from task ',iprocio
      call mpl%flush
      call vbal%cov_receive(mpl,nam,geom,iprocio)
      if (vbal%nc1a/=samp%nc1a) call mpl%abort('${subr}$','vbal%nc1a is not equal to samp%nc1a')
   end if
end do

! Update tag
call mpl%update_tag(3)

! Probe out
@:probe_out()

end subroutine vbal_cov_read_local

!----------------------------------------------------------------------
! Subroutine: vbal_cov_read_local_single
!> Read local full covariances, single task
!----------------------------------------------------------------------
subroutine vbal_cov_read_local_single(vbal,mpl,nam,geom,nsub,iproc)

implicit none

! Passed variables
class(vbal_type),intent(inout) :: vbal !< Vertical balance
type(mpl_type),intent(inout) :: mpl    !< MPI data
type(nam_type),intent(inout) :: nam    !< Namelist
type(geom_type),intent(in) :: geom     !< Geometry
integer,intent(in) :: nsub             !< Number of sub-ensembles
integer,intent(in) :: iproc            !< Task index

! Local variables
integer :: ncid,grpid,full_cov_c1a_id
integer :: isub,iv,jv
real(kind_real),allocatable :: full_cov_c1a(:,:,:)
character(len=1024) :: grpname,fname_vbal_cov

! Set name
@:set_name(vbal_cov_read_local_single)

do isub=1,nsub
   ! Set file name
   write(fname_vbal_cov,'(a,a,i6.6)') trim(nam%fname_vbal_cov_default),'_',isub
   if (allocated(nam%fname_vbal_cov)) fname_vbal_cov = nam%fname_vbal_cov(isub)

   ! Open file
   ncid = open_file(mpl,fname_vbal_cov,iproc)

   if (isub==1) then
      ! Get dimension
      vbal%nc1a = inquire_dim_size(mpl,ncid,'nc1a',0)

      ! Allocation
      allocate(full_cov_c1a(vbal%nc1a,geom%nl0,geom%nl0))
   end if

   do iv=1,nam%nv
      do jv=1,iv
         if (isub==1) then
            ! Allocation
            allocate(vbal%blk(iv,jv)%full_cov_c1a(vbal%nc1a,geom%nl0,geom%nl0))

            ! Initialization
            vbal%blk(iv,jv)%full_cov_c1a = 0.0
         end if

         ! Get group name
         call nam%alias(vbal%blk(iv,jv)%name,grpname)

         ! Inquire group
         grpid = inquire_grp(mpl,ncid,grpname)

         ! Inquire variable
         full_cov_c1a_id = inquire_var(mpl,grpid,'full_cov_c1a')

         ! Read variable
         call get_var(mpl,grpid,full_cov_c1a_id,full_cov_c1a)

         ! Average data
         vbal%blk(iv,jv)%full_cov_c1a = vbal%blk(iv,jv)%full_cov_c1a+full_cov_c1a
      end do
   end do

   ! Close file
   call close_file(mpl,ncid)
end do

! Normalization
do iv=1,nam%nv
   do jv=1,iv
      vbal%blk(iv,jv)%full_cov_c1a = vbal%blk(iv,jv)%full_cov_c1a/real(nsub,kind_real)
   end do
end do

! Probe out
@:probe_out()

end subroutine vbal_cov_read_local_single

!----------------------------------------------------------------------
! Subroutine: vbal_cov_write_local
!> Write local full covariances
!----------------------------------------------------------------------
subroutine vbal_cov_write_local(vbal,mpl,nam,geom,samp)

implicit none

! Passed variables
class(vbal_type),intent(inout) :: vbal !< Vertical balance
type(mpl_type),intent(inout) :: mpl    !< MPI data
type(nam_type),intent(in) :: nam       !< Namelist
type(geom_type),intent(in) :: geom     !< Geometry
type(samp_type),intent(in) :: samp     !< Sampling

! Local variables
integer :: iproc,iprocio
type(vbal_type) :: vbal_tmp

! Set name
@:set_name(vbal_cov_write_local)

! Probe in
@:probe_in()

do iproc=1,mpl%nproc
   ! Writing task
   iprocio = mod(iproc,mpl%nprocio)
   if (iprocio==0) iprocio = mpl%nprocio

   if (mpl%myproc==iprocio) then
      write(mpl%info,'(a10,a,i6,a,i6)') '','Write full covariances of task ',iproc,' from task ',iprocio
      call mpl%flush

      if (iproc==iprocio) then
         ! Write data
         vbal%nc1a = samp%nc1a
         call vbal%cov_write_local(mpl,nam,geom,iproc)
      else
         ! Receive data from task iproc
         call vbal_tmp%cov_receive(mpl,nam,geom,iproc)

         ! Write data
         call vbal_tmp%cov_write_local(mpl,nam,geom,iproc)

         ! Release memory
         call vbal_tmp%dealloc
      end if
   elseif (mpl%myproc==iproc) then
      ! Send data to task iprocio
      write(mpl%info,'(a10,a,i6,a,i6)') '','Send full covariances of task ',iproc,' to task ',iprocio
      call mpl%flush
      vbal%nc1a = samp%nc1a
      call vbal%cov_send(mpl,nam,geom,iprocio)
   end if
end do

! Update tag
call mpl%update_tag(3)

! Probe out
@:probe_out()

end subroutine vbal_cov_write_local

!----------------------------------------------------------------------
! Subroutine: vbal_cov_write_local_single
!> Write local full covariances, single task
!----------------------------------------------------------------------
subroutine vbal_cov_write_local_single(vbal,mpl,nam,geom,iproc)

implicit none

! Passed variables
class(vbal_type),intent(inout) :: vbal !< Vertical balance
type(mpl_type),intent(inout) :: mpl    !< MPI data
type(nam_type),intent(in) :: nam       !< Namelist
type(geom_type),intent(in) :: geom     !< Geometry
integer,intent(in) :: iproc            !< Task index

! Local variables
integer :: ncid,nc1a_id,nl0_1_id,nl0_2_id
integer :: grpid(nam%nv,nam%nv),full_cov_c1a_id(nam%nv,nam%nv)
integer :: iv,jv
character(len=1024) :: grpname

! Set name
@:set_name(vbal_cov_write_local_single)

! Probe in
@:probe_in()

! Open files
ncid = create_file(mpl,nam%fname_vbal_cov_default,iproc)

! Define dimensions
nc1a_id = define_dim(mpl,ncid,'nc1a',vbal%nc1a)
nl0_1_id = define_dim(mpl,ncid,'nl0_1',geom%nl0)
nl0_2_id = define_dim(mpl,ncid,'nl0_2',geom%nl0)

do iv=1,nam%nv
   do jv=1,iv
      ! Get group name
      call nam%alias(vbal%blk(iv,jv)%name,grpname)

      ! Define group
      grpid(iv,jv) = define_grp(mpl,ncid,grpname)

      ! Define variable
      full_cov_c1a_id(iv,jv) = define_var(mpl,grpid(iv,jv),'full_cov_c1a','real',(/nc1a_id,nl0_1_id,nl0_2_id/))
   end do
end do

do iv=1,nam%nv
   do jv=1,iv
      ! Write variable
      call put_var(mpl,grpid(iv,jv),full_cov_c1a_id(iv,jv),vbal%blk(iv,jv)%full_cov_c1a)
   end do
end do

! Close files
call close_file(mpl,ncid)

! Probe out
@:probe_out()

end subroutine vbal_cov_write_local_single

!----------------------------------------------------------------------
! Subroutine: vbal_cov_read_global
!> Read local full covariances
!----------------------------------------------------------------------
subroutine vbal_cov_read_global(vbal,mpl,nam,geom,samp,nsub)

implicit none

! Passed variables
class(vbal_type),intent(inout) :: vbal !< Vertical balance
type(mpl_type),intent(inout) :: mpl    !< MPI data
type(nam_type),intent(inout) :: nam    !< Namelist
type(geom_type),intent(in) :: geom     !< Geometry
type(samp_type),intent(in) :: samp     !< Sampling
integer,intent(in) :: nsub             !< Number of sub-ensembles

! Local variables
integer :: ncid,grpid,full_cov_c1_id
integer :: isub,iv,jv
real(kind_real) :: full_cov_c1a(samp%nc1a,geom%nl0,geom%nl0)
character(len=1024) :: grpname,fname_vbal_cov

! Set name
@:set_name(vbal_cov_read_global)

! Probe in
@:probe_in()

! Allocation
call vbal%alloc(mpl,nam,geom,samp,nsub)

do iv=1,nam%nv
   do jv=1,iv
      ! Allocation
      allocate(vbal%blk(iv,jv)%full_cov_c1a(samp%nc1a,geom%nl0,geom%nl0))

      ! Initialization
      vbal%blk(iv,jv)%full_cov_c1a = 0.0
   end do
end do

do isub=1,nsub
   ! Set file name
   write(fname_vbal_cov,'(a,a,i6.6)') trim(nam%fname_vbal_cov_default),'_',isub
   if (allocated(nam%fname_vbal_cov)) fname_vbal_cov = nam%fname_vbal_cov(isub)

   ! Open file
   ncid = open_file(mpl,fname_vbal_cov)

   do iv=1,nam%nv
      do jv=1,iv
         ! Get group name
         call nam%alias(vbal%blk(iv,jv)%name,grpname)

         ! Define group
         grpid = inquire_grp(mpl,ncid,grpname)

         ! Inquire variable
         full_cov_c1_id = inquire_var(mpl,grpid,'full_cov_c1')

         ! Read variable
         call samp%io_c1%fld_read(mpl,grpid,full_cov_c1_id,full_cov_c1a)

         ! Average data
         vbal%blk(iv,jv)%full_cov_c1a = vbal%blk(iv,jv)%full_cov_c1a+full_cov_c1a
      end do
   end do

   ! Close file
   call close_file(mpl,ncid)
end do

! Normalization
do iv=1,nam%nv
   do jv=1,iv
      vbal%blk(iv,jv)%full_cov_c1a = vbal%blk(iv,jv)%full_cov_c1a/real(nsub,kind_real)
   end do
end do

! Probe out
@:probe_out()

end subroutine vbal_cov_read_global

!----------------------------------------------------------------------
! Subroutine: vbal_cov_write_global
!> Write local full covariances
!----------------------------------------------------------------------
subroutine vbal_cov_write_global(vbal,mpl,nam,geom,samp)

implicit none

! Passed variables
class(vbal_type),intent(inout) :: vbal !< Vertical balance
type(mpl_type),intent(inout) :: mpl    !< MPI data
type(nam_type),intent(in) :: nam       !< Namelist
type(geom_type),intent(in) :: geom     !< Geometry
type(samp_type),intent(in) :: samp     !< Sampling

! Local variables
integer :: ncid,nc1_id,nl0_1_id,nl0_2_id
integer :: grpid(nam%nv,nam%nv),full_cov_c1_id(nam%nv,nam%nv)
integer :: iv,jv
character(len=1024) :: grpname

! Set name
@:set_name(vbal_cov_write_global)

! Probe in
@:probe_in()

! Open files
ncid = create_file(mpl,nam%fname_vbal_cov_default)

! Define dimensions
nc1_id = define_dim(mpl,ncid,'nc1',samp%nc1)
nl0_1_id = define_dim(mpl,ncid,'nl0_1',geom%nl0)
nl0_2_id = define_dim(mpl,ncid,'nl0_2',geom%nl0)

do iv=1,nam%nv
   do jv=1,iv
      ! Get group name
      call nam%alias(vbal%blk(iv,jv)%name,grpname)

      ! Define group
      grpid(iv,jv) = define_grp(mpl,ncid,grpname)

      ! Define variable
      full_cov_c1_id(iv,jv) = define_var(mpl,grpid(iv,jv),'full_cov_c1','real',(/nc1_id,nl0_1_id,nl0_2_id/))
   end do
end do

do iv=1,nam%nv
   do jv=1,iv
      ! Write variable
      call samp%io_c1%fld_write(mpl,grpid(iv,jv),full_cov_c1_id(iv,jv),vbal%blk(iv,jv)%full_cov_c1a)
   end do
end do

! Close files
call close_file(mpl,ncid)

! Probe out
@:probe_out()

end subroutine vbal_cov_write_global

!----------------------------------------------------------------------
! Subroutine: vbal_cov_send
!> Send
!----------------------------------------------------------------------
subroutine vbal_cov_send(vbal,mpl,nam,geom,iproc)

implicit none

! Passed variables
class(vbal_type),intent(in) :: vbal !< Vertical balance
type(mpl_type),intent(inout) :: mpl !< MPI data
type(nam_type),intent(in) :: nam    !< Namelist
type(geom_type),intent(in) :: geom  !< Geometry
integer,intent(in) :: iproc         !< Destination task

! Local variables
integer :: nbufi,nbufr,ibufi,ibufr,iv,jv,bufs(2)
integer,allocatable :: bufi(:)
real(kind_real),allocatable :: bufr(:)

! Set name
@:set_name(vbal_cov_send)

! Probe in
@:probe_in()

! Initialization
nbufi = 0
nbufr = 0

! nc1a
nbufi = nbufi+1

do iv=1,nam%nv
   do jv=1,iv
      ! full_cov_c1a
      nbufr = nbufr+vbal%nc1a*geom%nl0*geom%nl0
   end do
end do

! Allocation
allocate(bufi(nbufi))
allocate(bufr(nbufr))

! Initialization
ibufi = 0
ibufr = 0

! nc1a
bufi(ibufi+1) = vbal%nc1a
ibufi = ibufi+1

do iv=1,nam%nv
   do jv=1,iv
      ! full_cov_c1a
      bufr(ibufr+1:ibufr+vbal%nc1a*geom%nl0*geom%nl0) = reshape(vbal%blk(iv,jv)%full_cov_c1a,(/vbal%nc1a*geom%nl0*geom%nl0/))
      ibufr = ibufr+vbal%nc1a*geom%nl0*geom%nl0
   end do
end do

! Check sizes
if (ibufi/=nbufi) call mpl%abort('${subr}$','wrong final index ibufi')
if (ibufr/=nbufr) call mpl%abort('${subr}$','wrong final index ibufr')

! Send buffer size
bufs = (/nbufi,nbufr/)
call mpl%f_comm%send(bufs,iproc-1,mpl%tag)

! Send data
call mpl%f_comm%send(bufi,iproc-1,mpl%tag+1)
call mpl%f_comm%send(bufr,iproc-1,mpl%tag+2)

! Release memory
deallocate(bufi)
deallocate(bufr)

! Probe out
@:probe_out()

end subroutine vbal_cov_send

!----------------------------------------------------------------------
! Subroutine: vbal_cov_receive
!> Receive
!----------------------------------------------------------------------
subroutine vbal_cov_receive(vbal,mpl,nam,geom,iproc)

implicit none

! Passed variables
class(vbal_type),intent(inout) :: vbal !< Vertical balance
type(mpl_type),intent(inout) :: mpl    !< MPI data
type(nam_type),intent(in) :: nam       !< Namelist
type(geom_type),intent(in) :: geom     !< Geometry
integer,intent(in) :: iproc            !< Source task

! Local variables
integer :: nbufi,nbufr,ibufi,ibufr,iv,jv,bufs(2)
integer,allocatable :: bufi(:)
real(kind_real),allocatable :: bufr(:)
type(fckit_mpi_status) :: status

! Set name
@:set_name(vbal_cov_receive)

! Probe in
@:probe_in()

! Receive buffer size
call mpl%f_comm%receive(bufs,iproc-1,mpl%tag,status)
nbufi = bufs(1)
nbufr = bufs(2)

! Allocation
allocate(bufi(nbufi))
allocate(bufr(nbufr))

! Receive data
call mpl%f_comm%receive(bufi,iproc-1,mpl%tag+1,status)
call mpl%f_comm%receive(bufr,iproc-1,mpl%tag+2,status)

! Initialization
ibufi = 0
ibufr = 0

! nc1a
vbal%nc1a = bufi(ibufi+1)
ibufi = ibufi+1

! Allocation
if (.not.allocated(vbal%blk)) call vbal%alloc(mpl,nam,geom)

do iv=1,nam%nv
   do jv=1,iv
      ! full_cov_c1a
      allocate(vbal%blk(iv,jv)%full_cov_c1a(vbal%nc1a,geom%nl0,geom%nl0))
      vbal%blk(iv,jv)%full_cov_c1a = reshape(bufr(ibufr+1:ibufr+vbal%nc1a*geom%nl0*geom%nl0),(/vbal%nc1a,geom%nl0,geom%nl0/))
      ibufr = ibufr+vbal%nc1a*geom%nl0*geom%nl0
   end do
end do

! Check sizes
if (ibufi/=nbufi) call mpl%abort('${subr}$','wrong final index ibufi')
if (ibufr/=nbufr) call mpl%abort('${subr}$','wrong final index ibufr')

! Release memory
deallocate(bufr)

! Probe out
@:probe_out()

end subroutine vbal_cov_receive

!----------------------------------------------------------------------
! Subroutine: vbal_cov_run
!> Compute vertical covariance
!----------------------------------------------------------------------
subroutine vbal_cov_run(vbal,mpl,nam,geom,samp,ens)

implicit none

! Passed variables
class(vbal_type),intent(inout) :: vbal !< Vertical balance
type(mpl_type),intent(inout) :: mpl    !< MPI data
type(nam_type),intent(inout) :: nam    !< Namelist
type(geom_type),intent(in) :: geom     !< Geometry
type(samp_type),intent(in) :: samp     !< Sampling
type(ens_type), intent(inout) :: ens   !< Ensemble

! Local variables
integer :: iv,jv

! Set name
@:set_name(vbal_run_vbal)

! Probe in
@:probe_in()

! Allocation
call vbal%alloc(mpl,nam,geom,samp,ens%nsub)

! Compute vertical covariances
write(mpl%info,'(a)') '-------------------------------------------------------------------'
call mpl%flush
write(mpl%info,'(a)') '--- Compute vertical covariances'
call mpl%flush
do iv=1,nam%nv
   do jv=1,iv
      call vbal%blk(iv,jv)%compute_covariance(mpl,nam,geom,samp,ens)
   end do
end do

! Write vertical covariances
if (nam%write_vbal_cov) then
   if (nam%load_samp_local.or.nam%write_samp_local) call vbal%cov_write_local(mpl,nam,geom,samp)
   if (nam%load_samp_global.or.nam%write_samp_global) call vbal%cov_write_global(mpl,nam,geom,samp)
end if

! Probe out
@:probe_out()

end subroutine vbal_cov_run

!----------------------------------------------------------------------
! Subroutine: vbal_cov_update
!> Update vertical covariance
!----------------------------------------------------------------------
subroutine vbal_cov_update(vbal,mpl,nam,geom,samp,fld_c0a,ie)

implicit none

! Passed variables
class(vbal_type),intent(inout) :: vbal                           !< Vertical balance
type(mpl_type),intent(inout) :: mpl                              !< MPI data
type(nam_type),intent(inout) :: nam                              !< Namelist
type(geom_type),intent(in) :: geom                               !< Geometry
type(samp_type),intent(inout) :: samp                            !< Sampling
real(kind_real),intent(in) :: fld_c0a(geom%nc0a,geom%nl0,nam%nv) !< Field
integer,intent(in) :: ie                                         !< Member index

! Local variables
integer :: iv,jv

! Set name
@:set_name(vbal_cov_update)

! Probe in
@:probe_in()

! Update vertical covariance
write(mpl%info,'(a)') '-------------------------------------------------------------------'
call mpl%flush
write(mpl%info,'(a)') '--- Update vertical covariance'
call mpl%flush

! Allocation
if (ie==1) call vbal%alloc(mpl,nam,geom,samp,nam%ens1_nsub)

! Update vertical covariance
do iv=1,nam%nv
   do jv=1,iv
      call vbal%blk(iv,jv)%cov_update(mpl,nam,geom,samp,fld_c0a,ie)
   end do
end do

! Write vertical covariance
if ((ie==nam%ens1_ne).and.nam%write_vbal) then
   if (nam%load_samp_local.or.nam%write_samp_local) call vbal%cov_write_local(mpl,nam,geom,samp)
   if (nam%load_samp_global.or.nam%write_samp_global) call vbal%cov_write_global(mpl,nam,geom,samp)
end if

! Probe out
@:probe_out()

end subroutine vbal_cov_update

!----------------------------------------------------------------------
! Subroutine: vbal_read_local
!> Read local data
!----------------------------------------------------------------------
subroutine vbal_read_local(vbal,mpl,nam,geom,samp)

implicit none

! Passed variables
class(vbal_type),intent(inout) :: vbal !< Vertical balance
type(mpl_type),intent(inout) :: mpl    !< MPI data
type(nam_type),intent(inout) :: nam    !< Namelist
type(geom_type),intent(in) :: geom     !< Geometry
type(samp_type),intent(in) :: samp     !< Sampling

! Local variables
integer :: iv,jv,ic2b,i_s,ic0a,il0i,iproc,iprocio
real(kind_real),allocatable :: reg_c2b(:,:,:)
type(vbal_type) :: vbal_tmp

! Set name
@:set_name(vbal_read_local)

! Probe in
@:probe_in()

! Allocation
allocate(vbal%h_n_s(geom%nc0a,geom%nl0i))

! Initialization
vbal%h_n_s = 0

! Get maximum number of interpolation coefficients
do il0i=1,geom%nl0i
   do i_s=1,samp%interp_c2b_to_c0a(il0i)%n_s
      ic0a = samp%interp_c2b_to_c0a(il0i)%row(i_s)
      vbal%h_n_s(ic0a,il0i) = vbal%h_n_s(ic0a,il0i)+1
   end do
end do
vbal%h_n_s_max = zss_maxval(vbal%h_n_s)

! Allocation
allocate(vbal%h_c2b(vbal%h_n_s_max,geom%nc0a,geom%nl0i))
allocate(vbal%h_S(vbal%h_n_s_max,geom%nc0a,geom%nl0i))

! Initialization
vbal%h_c2b = mpl%msv%vali
vbal%h_S = mpl%msv%valr

! Get interpolation coefficients
vbal%h_n_s = 0
do il0i=1,geom%nl0i
   do i_s=1,samp%interp_c2b_to_c0a(il0i)%n_s
      ic0a = samp%interp_c2b_to_c0a(il0i)%row(i_s)
      vbal%h_n_s(ic0a,il0i) = vbal%h_n_s(ic0a,il0i)+1
      vbal%h_c2b(vbal%h_n_s(ic0a,il0i),ic0a,il0i) = samp%interp_c2b_to_c0a(il0i)%col(i_s)
      vbal%h_S(vbal%h_n_s(ic0a,il0i),ic0a,il0i) = samp%interp_c2b_to_c0a(il0i)%S(i_s)
   end do
end do

! Allocation
call vbal%alloc(mpl,nam,geom,samp)

do iproc=1,mpl%nproc
   ! Reading task
   iprocio = mod(iproc,mpl%nprocio)
   if (iprocio==0) iprocio = mpl%nprocio

   if (mpl%myproc==iprocio) then
      write(mpl%info,'(a10,a,i6,a,i6)') '','Read vertical regression of task ',iproc,' from task ',iprocio
      call mpl%flush

      if (iproc==iprocio) then
         ! Read data
         call vbal%read_local(mpl,nam,geom,iproc)
         if (vbal%nc2a/=samp%nc2a) call mpl%abort('${subr}$','vbal%nc2a is not equal to samp%nc2a')
      else
         ! Allocation
         call vbal_tmp%alloc(mpl,nam,geom)

         ! Read data
         call vbal_tmp%read_local(mpl,nam,geom,iproc)

         ! Send data to task iproc
         call vbal_tmp%send(mpl,nam,geom,iproc)

         ! Release memory
         call vbal_tmp%dealloc
      end if
   elseif (mpl%myproc==iproc) then
      ! Receive data from task iprocio
      write(mpl%info,'(a10,a,i6,a,i6)') '','Receive vertical regression of task ',iproc,' from task ',iprocio
      call mpl%flush
      call vbal%receive(mpl,nam,geom,iprocio)
      if (vbal%nc2a/=samp%nc2a) call mpl%abort('${subr}$','vbal%nc2a is not equal to samp%nc2a')
   end if
end do

! Update tag
call mpl%update_tag(3)

! Allocation
allocate(reg_c2b(samp%nc2b,geom%nl0,geom%nl0))

! Final regression array
do iv=1,nam%nv
   do jv=1,iv
      if (nam%vbal_block(iv,jv)) then
         ! Halo extension
         call samp%com_c2_AB%ext(mpl,vbal%blk(iv,jv)%reg_c2a,reg_c2b)

         ! Horizontal index as last dimension
         do ic2b=1,samp%nc2b
            vbal%blk(iv,jv)%reg_c2b(:,:,ic2b) = reg_c2b(ic2b,:,:)
         end do
      end if
   end do
end do

! Release memory
do iv=1,nam%nv
   do jv=1,iv
      if (nam%vbal_block(iv,jv)) deallocate(vbal%blk(iv,jv)%reg_c2a)
   end do
end do
deallocate(reg_c2b)

! Write balance operator
if (nam%write_vbal.and.nam%write_samp_global) call vbal%write_global(mpl,nam,geom,samp)

! Probe out
@:probe_out()

end subroutine vbal_read_local

!----------------------------------------------------------------------
! Subroutine: vbal_read_local_single
!> Read local data, single task
!----------------------------------------------------------------------
subroutine vbal_read_local_single(vbal,mpl,nam,geom,iproc)

implicit none

! Passed variables
class(vbal_type),intent(inout) :: vbal !< Vertical balance
type(mpl_type),intent(inout) :: mpl    !< MPI data
type(nam_type),intent(inout) :: nam    !< Namelist
type(geom_type),intent(in) :: geom     !< Geometry
integer,intent(in) :: iproc            !< Task index

! Local variables
integer :: ncid,grpid,reg_c2a_id
integer :: iv,jv
character(len=1024) :: grpname

! Set name
@:set_name(vbal_read_local_single)

! Probe in
@:probe_in()

! Open file
ncid = open_file(mpl,nam%fname_vbal,iproc)

! Get dimension
vbal%nc2a = inquire_dim_size(mpl,ncid,'nc2a',0)

! Setup fields output
do iv=1,nam%nv
   do jv=1,iv
      if (nam%vbal_block(iv,jv)) then
         ! Define group name
         call nam%alias(vbal%blk(iv,jv)%name,grpname)

         ! Get group
         grpid = inquire_grp(mpl,ncid,grpname)

         ! Allocation
         allocate(vbal%blk(iv,jv)%reg_c2a(vbal%nc2a,geom%nl0,geom%nl0))

         ! Inquire variable
         reg_c2a_id = inquire_var(mpl,grpid,'reg_c2a')

         ! Read variable
         call get_var(mpl,grpid,reg_c2a_id,vbal%blk(iv,jv)%reg_c2a)
      end if
   end do
end do

! Close file
call close_file(mpl,ncid)

! Probe out
@:probe_out()

end subroutine vbal_read_local_single

!----------------------------------------------------------------------
! Subroutine: vbal_write_local
!> Write local data
!----------------------------------------------------------------------
subroutine vbal_write_local(vbal,mpl,nam,geom,samp)

implicit none

! Passed variables
class(vbal_type),intent(inout) :: vbal !< Vertical balance
type(mpl_type),intent(inout) :: mpl    !< MPI data
type(nam_type),intent(in) :: nam       !< Namelist
type(geom_type),intent(in) :: geom     !< Geometry
type(samp_type),intent(in) :: samp     !< Sampling

! Local variables
integer :: iv,jv,il0,ic2a,ic2b,iproc,iprocio
real(kind_real),allocatable :: explained_var_norm(:,:)
type(vbal_type) :: vbal_tmp

! Set name
@:set_name(vbal_write_local)

! Probe in
@:probe_in()

! Write vertical balance operators
write(mpl%info,'(a)') '-------------------------------------------------------------------'
call mpl%flush
write(mpl%info,'(a)') '--- Write local vertical balance operators'
call mpl%flush

! Allocation
do iv=1,nam%nv
   do jv=1,iv
      if (nam%vbal_block(iv,jv)) allocate(vbal%blk(iv,jv)%reg_c2a(samp%nc2a,geom%nl0,geom%nl0))
      if (nam%new_vbal.and.(nam%vbal_block(iv,jv).or.(iv==jv))) allocate(vbal%blk(iv,jv)%cov_c2a(samp%nc2a,geom%nl0,geom%nl0))
      if (nam%new_vbal.and.nam%vbal_block(iv,jv)) allocate(vbal%blk(iv,jv)%explained_var_c2a(samp%nc2a,geom%nl0))
   end do
end do
if (nam%new_vbal) allocate(explained_var_norm(geom%nl0,samp%nc2b))

! Initialization
do iv=1,nam%nv
   if (nam%new_vbal) then
      ! Compute explained variance normalization
      explained_var_norm = 0.0
      do jv=1,iv
         if (nam%vbal_block(iv,jv)) explained_var_norm = explained_var_norm+vbal%blk(iv,jv)%explained_var_c2b
      end do
      do il0=1,geom%nl0
         explained_var_norm(il0,:) = explained_var_norm(il0,:)+vbal%blk(iv,iv)%cov_c2b(il0,il0,:)
      end do
   end if

   do jv=1,iv
      if (nam%vbal_block(iv,jv)) then
         ! Horizontal index as first dimension
         do ic2a=1,samp%nc2a
            ic2b = samp%c2a_to_c2b(ic2a)
            vbal%blk(iv,jv)%reg_c2a(ic2a,:,:) = vbal%blk(iv,jv)%reg_c2b(:,:,ic2b)
         end do
      end if

      if (nam%new_vbal.and.(nam%vbal_block(iv,jv).or.(iv==jv))) then
         ! Horizontal index as first dimension
         do ic2a=1,samp%nc2a
            ic2b = samp%c2a_to_c2b(ic2a)
            vbal%blk(iv,jv)%cov_c2a(ic2a,:,:) = vbal%blk(iv,jv)%cov_c2b(:,:,ic2b)
         end do
      end if

      if (nam%new_vbal.and.nam%vbal_block(iv,jv)) then
         ! Horizontal index as first dimension
         do ic2a=1,samp%nc2a
            ic2b = samp%c2a_to_c2b(ic2a)
            vbal%blk(iv,jv)%explained_var_c2a(ic2a,:) = vbal%blk(iv,jv)%explained_var_c2b(:,ic2b)/explained_var_norm(:,ic2b)
         end do
      end if
   end do
end do

do iproc=1,mpl%nproc
   ! Writing task
   iprocio = mod(iproc,mpl%nprocio)
   if (iprocio==0) iprocio = mpl%nprocio

   if (mpl%myproc==iprocio) then
      write(mpl%info,'(a10,a,i6,a,i6)') '','Write vertical regression of task ',iproc,' from task ',iprocio
      call mpl%flush

      if (iproc==iprocio) then
         ! Write data
         vbal%nc2a = samp%nc2a
         call vbal%write_local(mpl,nam,geom,iproc)
      else
         ! Allocation
         call vbal_tmp%alloc(mpl,nam,geom)

         ! Receive data from task iproc
         call vbal_tmp%receive(mpl,nam,geom,iproc)

         ! Write data
         call vbal_tmp%write_local(mpl,nam,geom,iproc)

         ! Release memory
         call vbal_tmp%dealloc
      end if
   elseif (mpl%myproc==iproc) then
      ! Send data to task iprocio
      write(mpl%info,'(a10,a,i6,a,i6)') '','Send vertical regression of task ',iproc,' to task ',iprocio
      call mpl%flush
      vbal%nc2a = samp%nc2a
      call vbal%send(mpl,nam,geom,iprocio)
   end if
end do

! Update tag
call mpl%update_tag(3)

! Release memory
do iv=1,nam%nv
   do jv=1,iv
      if (allocated(vbal%blk(iv,jv)%reg_c2a)) deallocate(vbal%blk(iv,jv)%reg_c2a)
      if (allocated(vbal%blk(iv,jv)%cov_c2a)) deallocate(vbal%blk(iv,jv)%cov_c2a)
      if (allocated(vbal%blk(iv,jv)%explained_var_c2a)) deallocate(vbal%blk(iv,jv)%explained_var_c2a)
   end do
end do
if (allocated(explained_var_norm)) deallocate(explained_var_norm)

! Probe out
@:probe_out()

end subroutine vbal_write_local

!----------------------------------------------------------------------
! Subroutine: vbal_write_local_single
!> Write local data, single task
!----------------------------------------------------------------------
subroutine vbal_write_local_single(vbal,mpl,nam,geom,iproc)

implicit none

! Passed variables
class(vbal_type),intent(inout) :: vbal !< Vertical balance
type(mpl_type),intent(inout) :: mpl    !< MPI data
type(nam_type),intent(in) :: nam       !< Namelist
type(geom_type),intent(in) :: geom     !< Geometry
integer,intent(in) :: iproc            !< Task index

! Local variables
integer :: ncid,nc2a_id,nl0_1_id,nl0_2_id
integer :: grpid(nam%nv,nam%nv),reg_c2a_id(nam%nv,nam%nv),cov_c2a_id(nam%nv,nam%nv),explained_var_c2a_id(nam%nv,nam%nv)
integer :: iv,jv
character(len=1024) :: grpname

! Set name
@:set_name(vbal_write_local_single)

! Probe in
@:probe_in()

! Create files
ncid = create_file(mpl,nam%fname_vbal,iproc)

! Define dimensions
nc2a_id = define_dim(mpl,ncid,'nc2a',vbal%nc2a)
nl0_1_id = define_dim(mpl,ncid,'nl0_1',geom%nl0)
nl0_2_id = define_dim(mpl,ncid,'nl0_2',geom%nl0)

do iv=1,nam%nv
   do jv=1,iv
      ! Get group name
      call nam%alias(vbal%blk(iv,jv)%name,grpname)

      ! Define group
      grpid(iv,jv) = define_grp(mpl,ncid,grpname)

      ! Define variables
      if (nam%vbal_block(iv,jv)) reg_c2a_id(iv,jv) = define_var(mpl,grpid(iv,jv),'reg_c2a','real',(/nc2a_id,nl0_1_id,nl0_2_id/))
      if (nam%new_vbal.and.(nam%vbal_block(iv,jv).or.(iv==jv))) cov_c2a_id(iv,jv) = define_var(mpl,grpid(iv,jv),'cov_c2a', &
 & 'real',(/nc2a_id,nl0_1_id,nl0_2_id/))
      if (nam%new_vbal.and.nam%vbal_block(iv,jv)) explained_var_c2a_id(iv,jv) = define_var(mpl,grpid(iv,jv),'explained_var_c2a', &
 & 'real',(/nc2a_id,nl0_1_id/))
   end do
end do

! Write variables
do iv=1,nam%nv
   do jv=1,iv
      if (nam%vbal_block(iv,jv)) call put_var(mpl,grpid(iv,jv),reg_c2a_id(iv,jv),vbal%blk(iv,jv)%reg_c2a)
      if (nam%new_vbal.and.(nam%vbal_block(iv,jv).or.(iv==jv))) call put_var(mpl,grpid(iv,jv),cov_c2a_id(iv,jv), &
 & vbal%blk(iv,jv)%cov_c2a)
      if (nam%new_vbal.and.nam%vbal_block(iv,jv)) call put_var(mpl,grpid(iv,jv),explained_var_c2a_id(iv,jv), &
 & vbal%blk(iv,jv)%explained_var_c2a)
   end do
end do

! Close files
call close_file(mpl,ncid)

! Probe out
@:probe_out()

end subroutine vbal_write_local_single

!----------------------------------------------------------------------
! Subroutine: vbal_read_global
!> Read global data
!----------------------------------------------------------------------
subroutine vbal_read_global(vbal,mpl,nam,geom,samp)

implicit none

! Passed variables
class(vbal_type),intent(inout) :: vbal !< Vertical balance
type(mpl_type),intent(inout) :: mpl    !< MPI data
type(nam_type),intent(inout) :: nam    !< Namelist
type(geom_type),intent(in) :: geom     !< Geometry
type(samp_type),intent(in) :: samp     !< Sampling

! Local variables
integer :: ncid,grpid,reg_c2_id
integer :: iv,jv,ic2b,i_s,ic0a,il0i
real(kind_real),allocatable :: reg_c2a(:,:,:),reg_c2b(:,:,:)
character(len=1024) :: grpname

! Set name
@:set_name(vbal_read_global)

! Probe in
@:probe_in()

! Allocation
allocate(vbal%h_n_s(geom%nc0a,geom%nl0i))

! Initialization
vbal%h_n_s = 0

! Get maximum number of interpolation coefficients
do il0i=1,geom%nl0i
   do i_s=1,samp%interp_c2b_to_c0a(il0i)%n_s
      ic0a = samp%interp_c2b_to_c0a(il0i)%row(i_s)
      vbal%h_n_s(ic0a,il0i) = vbal%h_n_s(ic0a,il0i)+1
   end do
end do
vbal%h_n_s_max = zss_maxval(vbal%h_n_s)

! Allocation
allocate(vbal%h_c2b(vbal%h_n_s_max,geom%nc0a,geom%nl0i))
allocate(vbal%h_S(vbal%h_n_s_max,geom%nc0a,geom%nl0i))

! Initialization
vbal%h_c2b = mpl%msv%vali
vbal%h_S = mpl%msv%valr

! Get interpolation coefficients
vbal%h_n_s = 0
do il0i=1,geom%nl0i
   do i_s=1,samp%interp_c2b_to_c0a(il0i)%n_s
      ic0a = samp%interp_c2b_to_c0a(il0i)%row(i_s)
      vbal%h_n_s(ic0a,il0i) = vbal%h_n_s(ic0a,il0i)+1
      vbal%h_c2b(vbal%h_n_s(ic0a,il0i),ic0a,il0i) = samp%interp_c2b_to_c0a(il0i)%col(i_s)
      vbal%h_S(vbal%h_n_s(ic0a,il0i),ic0a,il0i) = samp%interp_c2b_to_c0a(il0i)%S(i_s)
   end do
end do

! Allocation
call vbal%alloc(mpl,nam,geom,samp)
allocate(reg_c2a(samp%nc2a,geom%nl0,geom%nl0))
allocate(reg_c2b(samp%nc2b,geom%nl0,geom%nl0))

! Open file
ncid = open_file(mpl,nam%fname_vbal)

! Setup fields output
do iv=1,nam%nv
   do jv=1,iv
      if (nam%vbal_block(iv,jv)) then
         ! Define group name
         call nam%alias(vbal%blk(iv,jv)%name,grpname)

         ! Get group
         grpid = inquire_grp(mpl,ncid,grpname)

         ! Inquire variable
         reg_c2_id = inquire_var(mpl,grpid,'reg_c2')

         ! Read variable
         call samp%io_c2%fld_read(mpl,grpid,reg_c2_id,reg_c2a)

         ! Halo extension
         call samp%com_c2_AB%ext(mpl,reg_c2a,reg_c2b)

         ! Horizontal index as first dimension
         do ic2b=1,samp%nc2b
            vbal%blk(iv,jv)%reg_c2b(:,:,ic2b) = reg_c2b(ic2b,:,:)
         end do
      end if
   end do
end do

! Close file
call close_file(mpl,ncid)

! Release memory
deallocate(reg_c2a)
deallocate(reg_c2b)

! Write balance operator
if (nam%write_vbal.and.nam%write_samp_local) call vbal%write_local(mpl,nam,geom,samp)

! Probe out
@:probe_out()

end subroutine vbal_read_global

!----------------------------------------------------------------------
! Subroutine: vbal_write_global
!> Write global data
!----------------------------------------------------------------------
subroutine vbal_write_global(vbal,mpl,nam,geom,samp)

implicit none

! Passed variables
class(vbal_type),intent(inout) :: vbal !< Vertical balance
type(mpl_type),intent(inout) :: mpl    !< MPI data
type(nam_type),intent(in) :: nam       !< Namelist
type(geom_type),intent(in) :: geom     !< Geometry
type(samp_type),intent(in) :: samp     !< Sampling

! Local variables
integer :: ncid,nc2_id,nl0_1_id,nl0_2_id
integer :: grpid(nam%nv,nam%nv),reg_c2_id(nam%nv,nam%nv),cov_c2_id(nam%nv,nam%nv),explained_var_c2_id(nam%nv,nam%nv)
integer :: iv,jv,il0,ic2a,ic2b
real(kind_real) :: reg_c2a(samp%nc2a,geom%nl0,geom%nl0)
real(kind_real),allocatable :: cov_c2a(:,:,:),explained_var_norm(:,:),explained_var_c2a(:,:)
character(len=1024) :: grpname

! Set name
@:set_name(vbal_write_global)

! Probe in
@:probe_in()

! Write vertical balance operators
write(mpl%info,'(a)') '-------------------------------------------------------------------'
call mpl%flush
write(mpl%info,'(a)') '--- Write global vertical balance operators'
call mpl%flush

! Create files
ncid = create_file(mpl,nam%fname_vbal)

! Define dimensions
nc2_id = define_dim(mpl,ncid,'nc2',samp%nc2)
nl0_1_id = define_dim(mpl,ncid,'nl0_1',geom%nl0)
nl0_2_id = define_dim(mpl,ncid,'nl0_2',geom%nl0)

do iv=1,nam%nv
   do jv=1,iv
      ! Get group name
      call nam%alias(vbal%blk(iv,jv)%name,grpname)

      ! Define group
      grpid(iv,jv) = define_grp(mpl,ncid,grpname)

      ! Define variables
      if (nam%vbal_block(iv,jv)) reg_c2_id(iv,jv) = define_var(mpl,grpid(iv,jv),'reg_c2','real',(/nc2_id,nl0_1_id,nl0_2_id/))
      if (nam%new_vbal.and.(nam%vbal_block(iv,jv).or.(iv==jv)).and.(.not.nam%from_gsi)) &
 & cov_c2_id(iv,jv) = define_var(mpl,grpid(iv,jv),'cov_c2','real',(/nc2_id,nl0_1_id,nl0_2_id/))
      if (nam%new_vbal.and.nam%vbal_block(iv,jv).and.(.not.nam%from_gsi)) &
 & explained_var_c2_id(iv,jv) = define_var(mpl,grpid(iv,jv),'explained_var_c2','real',(/nc2_id,nl0_1_id/))
   end do
end do

! Allocation
if (nam%new_vbal.and.(.not.nam%from_gsi)) then
   allocate(cov_c2a(samp%nc2a,geom%nl0,geom%nl0))
   allocate(explained_var_norm(geom%nl0,samp%nc2b))
   allocate(explained_var_c2a(samp%nc2a,geom%nl0))
end if

do iv=1,nam%nv
   if (nam%new_vbal.and.(.not.nam%from_gsi)) then
      ! Compute explained variance normalization
      explained_var_norm = 0.0
      do jv=1,iv
         if (nam%vbal_block(iv,jv)) explained_var_norm = explained_var_norm+vbal%blk(iv,jv)%explained_var_c2b
      end do
      do il0=1,geom%nl0
         explained_var_norm(il0,:) = explained_var_norm(il0,:)+vbal%blk(iv,iv)%cov_c2b(il0,il0,:)
      end do
   end if

   do jv=1,iv
      if (nam%vbal_block(iv,jv)) then
         ! Horizontal index as first dimension
         do ic2a=1,samp%nc2a
            ic2b = samp%c2a_to_c2b(ic2a)
            reg_c2a(ic2a,:,:) = vbal%blk(iv,jv)%reg_c2b(:,:,ic2b)
         end do

         ! Write variable
         call samp%io_c2%fld_write(mpl,grpid(iv,jv),reg_c2_id(iv,jv),reg_c2a)
      end if

      if (nam%new_vbal.and.(nam%vbal_block(iv,jv).or.(iv==jv)).and.(.not.nam%from_gsi)) then
         ! Horizontal index as first dimension
         do ic2a=1,samp%nc2a
            ic2b = samp%c2a_to_c2b(ic2a)
            cov_c2a(ic2a,:,:) = vbal%blk(iv,jv)%cov_c2b(:,:,ic2b)
         end do

         ! Write variable
         call samp%io_c2%fld_write(mpl,grpid(iv,jv),cov_c2_id(iv,jv),cov_c2a)
      end if

      if (nam%new_vbal.and.nam%vbal_block(iv,jv).and.(.not.nam%from_gsi)) then
         ! Horizontal index as first dimension
         do ic2a=1,samp%nc2a
            ic2b = samp%c2a_to_c2b(ic2a)
            explained_var_c2a(ic2a,:) = vbal%blk(iv,jv)%explained_var_c2b(:,ic2b)/explained_var_norm(:,ic2b)
         end do

         ! Write variable
         call samp%io_c2%fld_write(mpl,grpid(iv,jv),explained_var_c2_id(iv,jv),explained_var_c2a)
      end if
   end do
end do

! Release memory
if (nam%new_vbal.and.(.not.nam%from_gsi)) then
   deallocate(cov_c2a)
   deallocate(explained_var_norm)
   deallocate(explained_var_c2a)
end if

! Close files
call close_file(mpl,ncid)

! Probe out
@:probe_out()

end subroutine vbal_write_global

!----------------------------------------------------------------------
! Subroutine: vbal_send
!> Send
!----------------------------------------------------------------------
subroutine vbal_send(vbal,mpl,nam,geom,iproc)

implicit none

! Passed variables
class(vbal_type),intent(in) :: vbal !< Vertical balance
type(mpl_type),intent(inout) :: mpl !< MPI data
type(nam_type),intent(in) :: nam    !< Namelist
type(geom_type),intent(in) :: geom  !< Geometry
integer,intent(in) :: iproc         !< Destination task

! Local variables
integer :: nbufi,nbufr,ibufi,ibufr,iv,jv,bufs(2)
integer,allocatable :: bufi(:)
real(kind_real),allocatable :: bufr(:)

! Set name
@:set_name(vbal_send)

! Probe in
@:probe_in()

! Initialization
nbufi = 0
nbufr = 0

! nc2a
nbufi = nbufi+1

do iv=1,nam%nv
   do jv=1,iv
      ! reg_c2a
      if (nam%vbal_block(iv,jv)) nbufr = nbufr+vbal%nc2a*geom%nl0*geom%nl0

      ! cov_c2a
      if (nam%new_vbal.and.(nam%vbal_block(iv,jv).or.(iv==jv))) nbufr = nbufr+vbal%nc2a*geom%nl0*geom%nl0

      ! explained_var_c2a
      if (nam%new_vbal.and.nam%vbal_block(iv,jv)) nbufr = nbufr+vbal%nc2a*geom%nl0
   end do
end do

! Allocation
allocate(bufi(nbufi))
allocate(bufr(nbufr))

! Initialization
ibufi = 0
ibufr = 0

! nc2a
bufi(ibufi+1) = vbal%nc2a
ibufi = ibufi+1

do iv=1,nam%nv
   do jv=1,iv
       ! reg_c2a
      if (nam%vbal_block(iv,jv)) then
         bufr(ibufr+1:ibufr+vbal%nc2a*geom%nl0*geom%nl0) = reshape(vbal%blk(iv,jv)%reg_c2a,(/vbal%nc2a*geom%nl0*geom%nl0/))
         ibufr = ibufr+vbal%nc2a*geom%nl0*geom%nl0
      end if

      ! cov_c2a
      if (nam%new_vbal.and.(nam%vbal_block(iv,jv).or.(iv==jv))) then
         bufr(ibufr+1:ibufr+vbal%nc2a*geom%nl0*geom%nl0) = reshape(vbal%blk(iv,jv)%cov_c2a,(/vbal%nc2a*geom%nl0*geom%nl0/))
         ibufr = ibufr+vbal%nc2a*geom%nl0*geom%nl0
      end if

      ! explained_var_c2a
      if (nam%new_vbal.and.nam%vbal_block(iv,jv)) then
         bufr(ibufr+1:ibufr+vbal%nc2a*geom%nl0) = reshape(vbal%blk(iv,jv)%explained_var_c2a,(/vbal%nc2a*geom%nl0/))
         ibufr = ibufr+vbal%nc2a*geom%nl0
      end if
   end do
end do

! Check sizes
if (ibufi/=nbufi) call mpl%abort('${subr}$','wrong final index ibufi')
if (ibufr/=nbufr) call mpl%abort('${subr}$','wrong final index ibufr')

! Send buffer size
bufs = (/nbufi,nbufr/)
call mpl%f_comm%send(bufs,iproc-1,mpl%tag)

! Send data
call mpl%f_comm%send(bufi,iproc-1,mpl%tag+1)
call mpl%f_comm%send(bufr,iproc-1,mpl%tag+2)

! Release memory
deallocate(bufi)
deallocate(bufr)

! Probe out
@:probe_out()

end subroutine vbal_send

!----------------------------------------------------------------------
! Subroutine: vbal_receive
!> Receive
!----------------------------------------------------------------------
subroutine vbal_receive(vbal,mpl,nam,geom,iproc)

implicit none

! Passed variables
class(vbal_type),intent(inout) :: vbal !< Vertical balance
type(mpl_type),intent(inout) :: mpl    !< MPI data
type(nam_type),intent(in) :: nam       !< Namelist
type(geom_type),intent(in) :: geom     !< Geometry
integer,intent(in) :: iproc            !< Source task

! Local variables
integer :: nbufi,nbufr,ibufi,ibufr,iv,jv,bufs(2)
integer,allocatable :: bufi(:)
real(kind_real),allocatable :: bufr(:)
type(fckit_mpi_status) :: status

! Set name
@:set_name(vbal_receive)

! Probe in
@:probe_in()

! Receive buffer size
call mpl%f_comm%receive(bufs,iproc-1,mpl%tag,status)
nbufi = bufs(1)
nbufr = bufs(2)

! Allocation
allocate(bufi(nbufi))
allocate(bufr(nbufr))

! Receive data
call mpl%f_comm%receive(bufi,iproc-1,mpl%tag+1,status)
call mpl%f_comm%receive(bufr,iproc-1,mpl%tag+2,status)

! Initialization
ibufi = 0
ibufr = 0

! nc2a
vbal%nc2a = bufi(ibufi+1)
ibufi = ibufi+1

! Allocation
if (.not.allocated(vbal%blk)) call vbal%alloc(mpl,nam,geom)

do iv=1,nam%nv
   do jv=1,iv
       ! reg_c2a
      if (nam%vbal_block(iv,jv)) then
         allocate(vbal%blk(iv,jv)%reg_c2a(vbal%nc2a,geom%nl0,geom%nl0))
         vbal%blk(iv,jv)%reg_c2a = reshape(bufr(ibufr+1:ibufr+vbal%nc2a*geom%nl0*geom%nl0),(/vbal%nc2a,geom%nl0,geom%nl0/))
         ibufr = ibufr+vbal%nc2a*geom%nl0*geom%nl0
      end if

      ! cov_c2a
      if (nam%new_vbal.and.(nam%vbal_block(iv,jv).or.(iv==jv))) then
         allocate(vbal%blk(iv,jv)%cov_c2a(vbal%nc2a,geom%nl0,geom%nl0))
         vbal%blk(iv,jv)%cov_c2a = reshape(bufr(ibufr+1:ibufr+vbal%nc2a*geom%nl0*geom%nl0),(/vbal%nc2a,geom%nl0,geom%nl0/))
         ibufr = ibufr+vbal%nc2a*geom%nl0*geom%nl0
      end if

      ! explained_var_c2a
      if (nam%new_vbal.and.nam%vbal_block(iv,jv)) then
         allocate(vbal%blk(iv,jv)%explained_var_c2a(vbal%nc2a,geom%nl0))
         vbal%blk(iv,jv)%explained_var_c2a = reshape(bufr(ibufr+1:ibufr+vbal%nc2a*geom%nl0),(/vbal%nc2a,geom%nl0/))
         ibufr = ibufr+vbal%nc2a*geom%nl0
      end if
   end do
end do

! Check sizes
if (ibufi/=nbufi) call mpl%abort('${subr}$','wrong final index ibufi')
if (ibufr/=nbufr) call mpl%abort('${subr}$','wrong final index ibufr')

! Release memory
deallocate(bufr)

! Probe out
@:probe_out()

end subroutine vbal_receive

!----------------------------------------------------------------------
! Subroutine: vbal_run_vbal
!> Compute vertical balance
!----------------------------------------------------------------------
subroutine vbal_run_vbal(vbal,mpl,nam,geom,samp,gsi,ens)

implicit none

! Passed variables
class(vbal_type),intent(inout) :: vbal !< Vertical balance
type(mpl_type),intent(inout) :: mpl    !< MPI data
type(nam_type),intent(inout) :: nam    !< Namelist
type(geom_type),intent(in) :: geom     !< Geometry
type(samp_type),intent(in) :: samp     !< Sampling
type(gsi_type),intent(in) :: gsi       !< GSI data
type(ens_type),intent(inout) :: ens    !< Ensemble

! Local variables
integer :: il0,il0i,i_s,ic0a,ic1a,iv,jv,kv,lv,ie
real(kind_real) :: fld_c0a_1(geom%nc0a,geom%nl0),fld_c0a_2(geom%nc0a,geom%nl0)
type(ens_type) :: ensu

! Set name
@:set_name(vbal_run_vbal)

! Probe in
@:probe_in()

! Allocation
allocate(vbal%h_n_s(geom%nc0a,geom%nl0i))

! Initialization
vbal%h_n_s = 0

! Get maximum number of interpolation coefficients
do il0i=1,geom%nl0i
   do i_s=1,samp%interp_c2b_to_c0a(il0i)%n_s
      ic0a = samp%interp_c2b_to_c0a(il0i)%row(i_s)
      vbal%h_n_s(ic0a,il0i) = vbal%h_n_s(ic0a,il0i)+1
   end do
end do
vbal%h_n_s_max = zss_maxval(vbal%h_n_s)

! Allocation
allocate(vbal%h_c2b(vbal%h_n_s_max,geom%nc0a,geom%nl0i))
allocate(vbal%h_S(vbal%h_n_s_max,geom%nc0a,geom%nl0i))

! Initialization
vbal%h_c2b = mpl%msv%vali
vbal%h_S = mpl%msv%valr

! Get interpolation coefficients
vbal%h_n_s = 0
do il0i=1,geom%nl0i
   do i_s=1,samp%interp_c2b_to_c0a(il0i)%n_s
      ic0a = samp%interp_c2b_to_c0a(il0i)%row(i_s)
      vbal%h_n_s(ic0a,il0i) = vbal%h_n_s(ic0a,il0i)+1
      vbal%h_c2b(vbal%h_n_s(ic0a,il0i),ic0a,il0i) = samp%interp_c2b_to_c0a(il0i)%col(i_s)
      vbal%h_S(vbal%h_n_s(ic0a,il0i),ic0a,il0i) = samp%interp_c2b_to_c0a(il0i)%S(i_s)
   end do
end do

if (nam%from_gsi) then
   write(mpl%info,'(a)') '-------------------------------------------------------------------'
   call mpl%flush
   write(mpl%info,'(a)') '--- Interpolate vertical balance from GSI data'
   call mpl%flush
   call vbal%from_gsi(mpl,nam,geom,samp,gsi)
else
   ! Compute vertical balance operators
   write(mpl%info,'(a)') '-------------------------------------------------------------------'
   call mpl%flush
   write(mpl%info,'(a)') '--- Compute vertical balance operators'
   call mpl%flush

   ! Allocation
   if (.not.(nam%new_vbal_cov.or.nam%load_vbal_cov)) then
      call vbal%alloc(mpl,nam,geom,samp,ens%nsub)
      call ensu%alloc(ens%ne,ens%nsub)
   end if

   if (nam%new_vbal_cov.or.nam%load_vbal_cov) then
      ! Initialize diagonal block of A
      do iv=1,nam%nv
         vbal%blk(iv,iv)%a_c1a = 0.0
         do ic1a=1,samp%nc1a
            do il0=1,geom%nl0
               vbal%blk(iv,iv)%a_c1a(il0,il0,ic1a) = 1.0
            end do
         end do
      end do
   else
      ! Copy ensemble
      call ensu%copy(mpl,nam,geom,ens)
   end if

   do iv=1,nam%nv
      do jv=1,iv
         if (nam%vbal_block(iv,jv)) then
            ! Compute cross-covariance
            write(mpl%info,'(a7,a)') '','Compute cross-covariance between '//trim(nam%variables(iv))//' and unbalanced ' &
 & //trim(nam%variables(jv))
            call mpl%flush
            if (nam%new_vbal_cov.or.nam%load_vbal_cov) then
               do ic1a=1,samp%nc1a
                  vbal%blk(iv,jv)%cov_c1a(ic1a,:,:) = 0.0
                  do kv=1,jv
                     vbal%blk(iv,jv)%cov_c1a(ic1a,:,:) = vbal%blk(iv,jv)%cov_c1a(ic1a,:,:) &
 & +matmul(vbal%blk(iv,kv)%full_cov_c1a(ic1a,:,:),transpose(vbal%blk(jv,kv)%a_c1a(:,:,ic1a)))
                  end do
               end do
            else
               call vbal%blk(iv,jv)%compute_covariance(mpl,nam,geom,samp,ens,ensu)
            end if

            ! Spatial average
            write(mpl%info,'(a7,a)') '','Spatial average for cross-covariance:'
            call mpl%flush(newl=.false.)
            call vbal%blk(iv,jv)%compute_spatial_average(mpl,nam,geom,samp)

            ! Compute regression
            write(mpl%info,'(a7,a)') '','Compute regression:'
            call mpl%flush(newl=.false.)
            call vbal%blk(iv,jv)%compute_regression(mpl,nam,geom,samp,vbal%blk(jv,jv)%cov_c2b,vbal%blk(iv,jv)%cov_c2b)
         end if
      end do

      if (nam%new_vbal_cov.or.nam%load_vbal_cov) then
         do jv=1,iv-1
            ! Compute A matrix
            write(mpl%info,'(a7,a)') '','Compute A matrix between '//trim(nam%variables(iv))//' and '//trim(nam%variables(jv))
            call mpl%flush
            vbal%blk(iv,jv)%a_c1a = 0.0
            do ic1a=1,samp%nc1a
               do kv=jv,iv-1
                  if (nam%vbal_block(iv,kv)) then
                     vbal%blk(iv,jv)%a_c1a(:,:,ic1a) = vbal%blk(iv,jv)%a_c1a(:,:,ic1a) &
 & -matmul(vbal%blk(iv,kv)%reg_c1a(:,:,ic1a),vbal%blk(kv,jv)%a_c1a(:,:,ic1a))
                  end if
               end do
            end do
         end do

         ! Compute auto-covariance
         write(mpl%info,'(a7,a)') '','Compute auto-covariance of unbalanced '//trim(nam%variables(iv))
         call mpl%flush
         do ic1a=1,samp%nc1a
            vbal%blk(iv,iv)%cov_c1a(ic1a,:,:) = 0.0
            do kv=1,iv
               do lv=1,iv
                  if (kv>=lv) then
                     vbal%blk(iv,iv)%cov_c1a(ic1a,:,:) = vbal%blk(iv,iv)%cov_c1a(ic1a,:,:) &
 & +matmul(vbal%blk(iv,kv)%a_c1a(:,:,ic1a),matmul(vbal%blk(kv,lv)%full_cov_c1a(ic1a,:,:), &
 & transpose(vbal%blk(iv,lv)%a_c1a(:,:,ic1a))))
                  else
                     vbal%blk(iv,iv)%cov_c1a(ic1a,:,:) = vbal%blk(iv,iv)%cov_c1a(ic1a,:,:) &
 & +matmul(vbal%blk(iv,kv)%a_c1a(:,:,ic1a),matmul(transpose(vbal%blk(lv,kv)%full_cov_c1a(ic1a,:,:)), &
 & transpose(vbal%blk(iv,lv)%a_c1a(:,:,ic1a))))
                  end if
               end do
            end do
         end do
      else
         ! Unbalance ensemble
         if (any(nam%vbal_block(iv,:))) then
            write(mpl%info,'(a7,a)') '','Unbalance ensemble members: '
            call mpl%flush(newl=.false.)
            do ie=1,ensu%ne
               write(mpl%info,'(i6)') ie
               call mpl%flush(newl=.false.)

               ! Get member on subset Sc0
               call ensu%get_c0(mpl,iv,geom,'member',ie,fld_c0a_1)

               do jv=1,iv
                  if (nam%vbal_block(iv,jv)) then
                     ! Get member on subset Sc0
                     call ensu%get_c0(mpl,jv,geom,'member',ie,fld_c0a_2)

                     ! Apply balance operator block
                     call vbal%blk(iv,jv)%apply(geom,vbal%h_n_s_max,vbal%h_n_s,vbal%h_c2b,vbal%h_S,fld_c0a_2)

                     ! Subtract balanced part
                     fld_c0a_1 = fld_c0a_1-fld_c0a_2
                  end if
               end do

               ! Set member from subset Sc0
               call ensu%set_c0(mpl,iv,geom,'member',ie,fld_c0a_1)
            end do
            write(mpl%info,'(a)') ''
            call mpl%flush

            ! Recompute ensemble mean
            call ensu%compute_mean(mpl,nam,geom)
         end if

         ! Compute auto-covariance
         write(mpl%info,'(a7,a)') '','Compute auto-covariance of unbalanced '//trim(nam%variables(iv))
         call mpl%flush
         call vbal%blk(iv,iv)%compute_covariance(mpl,nam,geom,samp,ensu)
      end if

      ! Spatial average
      write(mpl%info,'(a7,a)') '','Spatial average for auto-covariance:'
      call mpl%flush(newl=.false.)
      call vbal%blk(iv,iv)%compute_spatial_average(mpl,nam,geom,samp)
   end do
end if

! Write balance operator
if (nam%write_vbal) then
   if (nam%load_samp_local.or.nam%write_samp_local) call vbal%write_local(mpl,nam,geom,samp)
   if (nam%load_samp_global.or.nam%write_samp_global) call vbal%write_global(mpl,nam,geom,samp)
end if

! Release memory
call ensu%dealloc

! Probe out
@:probe_out()

end subroutine vbal_run_vbal

!----------------------------------------------------------------------
! Subroutine: vbal_from_gsi
!> Interpolate vertical balance from GSI data
!----------------------------------------------------------------------
subroutine vbal_from_gsi(vbal,mpl,nam,geom,samp,gsi)

implicit none

! Passed variables
class(vbal_type),intent(inout) :: vbal !< Vertical balance
type(mpl_type),intent(inout) :: mpl    !< MPI data
type(nam_type),intent(inout) :: nam    !< Namelist
type(geom_type),intent(in) :: geom     !< Geometry
type(samp_type),intent(in) :: samp     !< Sampling
type(gsi_type),intent(in) :: gsi       !< GSI data

! Local variables
integer :: ic2b,ic2u,il0,jl0,iv,jv,ilatm,ilatp
real(kind_real) :: rlatm,rlatp

! Set name
@:set_name(vbal_from_gsi)

! Probe in
@:probe_in()

! Allocation
call vbal%alloc(mpl,nam,geom,samp)

! Loop over blocks
do iv=1,nam%nv
   do jv=1,iv
      if (nam%vbal_block(iv,jv)) then
         ! Interpolate
         if ((nam%variables(iv)=='velocity_potential').and.(nam%variables(jv)=='stream_function')) then
            ! Stream function / velocity potential regression
            do ic2b=1,samp%nc2b
               vbal%blk(iv,jv)%reg_c2b(:,:,ic2b) = zero
               ic2u = samp%c2b_to_c2u(ic2b)
               call gsi%interp_lat(mpl,samp%lat_c2u(ic2u),ilatm,ilatp,rlatm,rlatp)
               do il0=1,geom%nl0
                  vbal%blk(iv,jv)%reg_c2b(il0,il0,ic2b) = &
 &  rlatm*gsi%rlevm(il0)*gsi%vpcon(ilatm,gsi%l0_to_levm(il0)) &
 & +rlatm*gsi%rlevp(il0)*gsi%vpcon(ilatm,gsi%l0_to_levp(il0)) &
 & +rlatp*gsi%rlevm(il0)*gsi%vpcon(ilatp,gsi%l0_to_levm(il0)) &
 & +rlatp*gsi%rlevp(il0)*gsi%vpcon(ilatp,gsi%l0_to_levp(il0))
               end do
            end do
         else if ((nam%variables(iv)=='air_temperature').and.(nam%variables(jv)=='stream_function')) then
            ! Stream function / air temperature regression
            do ic2b=1,samp%nc2b
               ic2u = samp%c2b_to_c2u(ic2b)
               call gsi%interp_lat(mpl,samp%lat_c2u(ic2u),ilatm,ilatp,rlatm,rlatp)
               do jl0=1,geom%nl0
                  do il0=1,geom%nl0
                     vbal%blk(iv,jv)%reg_c2b(il0,jl0,ic2b) = &
 &  rlatm*gsi%rlevm(jl0)*gsi%rlevm(il0)*gsi%tcon(ilatm,gsi%l0_to_levm(il0),gsi%l0_to_levm(jl0)) &
 & +rlatm*gsi%rlevm(jl0)*gsi%rlevp(il0)*gsi%tcon(ilatm,gsi%l0_to_levm(il0),gsi%l0_to_levp(jl0)) &
 & +rlatm*gsi%rlevp(jl0)*gsi%rlevm(il0)*gsi%tcon(ilatm,gsi%l0_to_levp(il0),gsi%l0_to_levm(jl0)) &
 & +rlatm*gsi%rlevp(jl0)*gsi%rlevp(il0)*gsi%tcon(ilatm,gsi%l0_to_levp(il0),gsi%l0_to_levp(jl0)) &
 & +rlatp*gsi%rlevm(jl0)*gsi%rlevm(il0)*gsi%tcon(ilatp,gsi%l0_to_levm(il0),gsi%l0_to_levm(jl0)) &
 & +rlatp*gsi%rlevm(jl0)*gsi%rlevp(il0)*gsi%tcon(ilatp,gsi%l0_to_levm(il0),gsi%l0_to_levp(jl0)) &
 & +rlatp*gsi%rlevp(jl0)*gsi%rlevm(il0)*gsi%tcon(ilatp,gsi%l0_to_levp(il0),gsi%l0_to_levm(jl0)) &
 & +rlatp*gsi%rlevp(jl0)*gsi%rlevp(il0)*gsi%tcon(ilatp,gsi%l0_to_levp(il0),gsi%l0_to_levp(jl0))
                  end do
               end do
            end do
         else if ((nam%variables(iv)=='surface_pressure').and.(nam%variables(jv)=='stream_function')) then
            ! Stream function / surface pressure regression
            do ic2b=1,samp%nc2b
               vbal%blk(iv,jv)%reg_c2b(:,:,ic2b) = zero
               ic2u = samp%c2b_to_c2u(ic2b)
               call gsi%interp_lat(mpl,samp%lat_c2u(ic2u),ilatm,ilatp,rlatm,rlatp)
               do il0=1,geom%nl0
                  if (il0==gsi%ilev2d) then
                     ! Copy fist level as is
                     vbal%blk(iv,jv)%reg_c2b(gsi%ilev2d,il0,ic2b) = rlatm*gsi%pscon(ilatm,1)+rlatp*gsi%pscon(ilatp,1)
                  else
                     ! Other levels
                     vbal%blk(iv,jv)%reg_c2b(gsi%ilev2d,il0,ic2b) = &
 &  rlatm*gsi%rlevm(il0)*gsi%pscon(ilatm,gsi%l0_to_levm(il0)) &
 & +rlatm*gsi%rlevp(il0)*gsi%pscon(ilatm,gsi%l0_to_levp(il0)) &
 & +rlatp*gsi%rlevm(il0)*gsi%pscon(ilatp,gsi%l0_to_levm(il0)) &
 & +rlatp*gsi%rlevp(il0)*gsi%pscon(ilatp,gsi%l0_to_levp(il0))
                  end if
               end do
            end do
         else
            ! Empty block
            vbal%blk(iv,jv)%reg_c2b = zero
         end if
      end if
   end do
end do

! Probe out
@:probe_out()

end subroutine vbal_from_gsi

!----------------------------------------------------------------------
! Subroutine: vbal_run_vbal_tests
!> Compute vertical balance tests
!----------------------------------------------------------------------
subroutine vbal_run_vbal_tests(vbal,mpl,rng,nam,geom)

implicit none

! Passed variables
class(vbal_type),intent(inout) :: vbal !< Vertical balance
type(mpl_type),intent(inout) :: mpl    !< MPI data
type(rng_type),intent(inout) :: rng    !< Random number generator
type(nam_type),intent(inout) :: nam    !< Namelist
type(geom_type),intent(in) :: geom     !< Geometry

! Set name
@:set_name(vbal_run_vbal_tests)

! Probe in
@:probe_in()

! Test inverse
if (nam%check_vbal) call vbal%test_inverse(mpl,rng,nam,geom)

! Test adjoint
if (nam%check_adjoints) call vbal%test_adjoint(mpl,rng,nam,geom)

! Test dirac
if (nam%check_dirac) call vbal%test_dirac(mpl,nam,geom)

! Reset random seed if necessary
if (nam%default_seed) call rng%reseed(mpl)

! Probe out
@:probe_out()

end subroutine vbal_run_vbal_tests

!----------------------------------------------------------------------
! Subroutine: vbal_apply
!> Apply vertical balance
!----------------------------------------------------------------------
subroutine vbal_apply(vbal,nam,geom,fld)

implicit none

! Passed variables
class(vbal_type),intent(in) :: vbal                             !< Vertical balance
type(nam_type),intent(in) :: nam                                !< Namelist
type(geom_type),intent(in) :: geom                              !< Geometry
real(kind_real),intent(inout) :: fld(geom%nc0a,geom%nl0,nam%nv) !< Source/destination vector

! Local variables
integer :: iv,jv
real(kind_real) :: fld_tmp(geom%nc0a,geom%nl0),fld_out(geom%nc0a,geom%nl0,nam%nv)

! Set name
@:set_name(vbal_apply)

! Probe in
@:probe_in()

! Initialization
fld_out = fld

! Add balance component
do iv=1,nam%nv
   do jv=1,iv
      if (nam%vbal_block(iv,jv)) then
         fld_tmp = fld(:,:,jv)
         if (nam%vbal_id) then
            fld_tmp = nam%vbal_id_coef(iv,jv)*fld_tmp
         else
            call vbal%blk(iv,jv)%apply(geom,vbal%h_n_s_max,vbal%h_n_s,vbal%h_c2b,vbal%h_S,fld_tmp)
         end if
         fld_out(:,:,iv) = fld_out(:,:,iv)+fld_tmp
      end if
   end do
end do

! Final copy
fld = fld_out

! Probe out
@:probe_out()

end subroutine vbal_apply

!----------------------------------------------------------------------
! Subroutine: vbal_apply_inv
!> Apply inverse vertical balance
!----------------------------------------------------------------------
subroutine vbal_apply_inv(vbal,nam,geom,fld)

implicit none

! Passed variables
class(vbal_type),intent(in) :: vbal                             !< Vertical balance
type(nam_type),intent(in) :: nam                                !< Namelist
type(geom_type),intent(in) :: geom                              !< Geometry
real(kind_real),intent(inout) :: fld(geom%nc0a,geom%nl0,nam%nv) !< Source/destination vector

! Local variables
integer :: iv,jv
real(kind_real) :: fld_tmp(geom%nc0a,geom%nl0),fld_out(geom%nc0a,geom%nl0,nam%nv)

! Set name
@:set_name(vbal_apply_inv)

! Probe in
@:probe_in()

! Initialization
fld_out = fld

! Remove balance component
do iv=1,nam%nv
   do jv=1,iv
      if (nam%vbal_block(iv,jv)) then
         fld_tmp = fld_out(:,:,jv)
         if (nam%vbal_id) then
            fld_tmp = nam%vbal_id_coef(iv,jv)*fld_tmp
         else
            call vbal%blk(iv,jv)%apply(geom,vbal%h_n_s_max,vbal%h_n_s,vbal%h_c2b,vbal%h_S,fld_tmp)
         end if
         fld_out(:,:,iv) = fld_out(:,:,iv)-fld_tmp
      end if
   end do
end do

! Final copy
fld = fld_out

! Probe out
@:probe_out()

end subroutine vbal_apply_inv

!----------------------------------------------------------------------
! Subroutine: vbal_apply_ad
!> Apply adjoint vertical balance
!----------------------------------------------------------------------
subroutine vbal_apply_ad(vbal,nam,geom,fld)

implicit none

! Passed variables
class(vbal_type),intent(in) :: vbal                             !< Vertical balance
type(nam_type),intent(in) :: nam                                !< Namelist
type(geom_type),intent(in) :: geom                              !< Geometry
real(kind_real),intent(inout) :: fld(geom%nc0a,geom%nl0,nam%nv) !< Source/destination vector

! Local variables
integer :: iv,jv
real(kind_real) :: fld_tmp(geom%nc0a,geom%nl0),fld_out(geom%nc0a,geom%nl0,nam%nv)

! Set name
@:set_name(vbal_apply_ad)

! Probe in
@:probe_in()

! Initialization
fld_out = fld

! Add balance component
do iv=1,nam%nv
   do jv=1,iv
      if (nam%vbal_block(iv,jv)) then
         fld_tmp = fld(:,:,iv)
         if (nam%vbal_id) then
            fld_tmp = nam%vbal_id_coef(iv,jv)*fld_tmp
         else
            call vbal%blk(iv,jv)%apply_ad(geom,vbal%h_n_s_max,vbal%h_n_s,vbal%h_c2b,vbal%h_S,fld_tmp)
         end if
         fld_out(:,:,jv) = fld_out(:,:,jv)+fld_tmp
      end if
   end do
end do

! Final copy
fld = fld_out

! Probe out
@:probe_out()

end subroutine vbal_apply_ad

!----------------------------------------------------------------------
! Subroutine: vbal_apply_inv_ad
!> Apply inverse adjoint vertical balance
!----------------------------------------------------------------------
subroutine vbal_apply_inv_ad(vbal,nam,geom,fld)

implicit none

! Passed variables
class(vbal_type),intent(in) :: vbal                             !< Vertical balance
type(nam_type),intent(in) :: nam                                !< Namelist
type(geom_type),intent(in) :: geom                              !< Geometry
real(kind_real),intent(inout) :: fld(geom%nc0a,geom%nl0,nam%nv) !< Source/destination vector

! Local variables
integer :: iv,jv
real(kind_real) :: fld_tmp(geom%nc0a,geom%nl0),fld_out(geom%nc0a,geom%nl0,nam%nv)

! Set name
@:set_name(vbal_apply_inv_ad)

! Probe in
@:probe_in()

! Initialization
fld_out = fld

! Remove balance component
do iv=nam%nv,1,-1
   do jv=iv+1,nam%nv
      if (nam%vbal_block(jv,iv)) then
         fld_tmp = fld_out(:,:,jv)
         if (nam%vbal_id) then
            fld_tmp = nam%vbal_id_coef(iv,jv)*fld_tmp
         else
            call vbal%blk(jv,iv)%apply_ad(geom,vbal%h_n_s_max,vbal%h_n_s,vbal%h_c2b,vbal%h_S,fld_tmp)
         end if
         fld_out(:,:,iv) = fld_out(:,:,iv)-fld_tmp
      end if
   end do
end do

! Final copy
fld = fld_out

! Probe out
@:probe_out()

end subroutine vbal_apply_inv_ad

!----------------------------------------------------------------------
! Subroutine: vbal_test_inverse
!> Test vertical balance inverse
!----------------------------------------------------------------------
subroutine vbal_test_inverse(vbal,mpl,rng,nam,geom)

implicit none

! Passed variables
class(vbal_type),intent(in) :: vbal !< Vertical balance
type(mpl_type),intent(inout) :: mpl !< MPI data
type(rng_type),intent(inout) :: rng !< Random number generator
type(nam_type),intent(in) :: nam    !< Namelist
type(geom_type),intent(in) :: geom  !< Geometry

! Local variables
real(kind_real) :: norm,mse
real(kind_real) :: fld(geom%nc0a,geom%nl0,nam%nv),fld_save(geom%nc0a,geom%nl0,nam%nv)

! Set name
@:set_name(vbal_test_inverse)

! Probe in
@:probe_in()

! Generate random field
call rng%rand(zero,one,fld_save)
norm = zss_sum(fld_save**2)
call mpl%f_comm%allreduce(norm,fckit_mpi_sum())

! Direct / inverse
fld = fld_save
call vbal%apply(nam,geom,fld)
call vbal%apply_inv(nam,geom,fld)
mse = zss_sum((fld-fld_save)**2)
call mpl%f_comm%allreduce(mse,fckit_mpi_sum())
write(mpl%info,'(a7,a,e15.8)') '','Vertical balance direct/inverse test value:  ',mse/norm
call mpl%flush
write(mpl%test,'(a7,a,l1)') '','Vertical balance direct/inverse test result:  ',mse/norm<repro_th
call mpl%flush

! Inverse / direct
fld = fld_save
call vbal%apply_inv(nam,geom,fld)
call vbal%apply(nam,geom,fld)
mse = zss_sum((fld-fld_save)**2)
call mpl%f_comm%allreduce(mse,fckit_mpi_sum())
write(mpl%info,'(a7,a,e15.8)') '','Vertical balance inverse/direct test value:  ',mse/norm
call mpl%flush
write(mpl%test,'(a7,a,l1)') '','Vertical balance inverse/direct test result:  ',mse/norm<repro_th
call mpl%flush

! Direct / inverse, adjoint
fld = fld_save
call vbal%apply_ad(nam,geom,fld)
call vbal%apply_inv_ad(nam,geom,fld)
mse = zss_sum((fld-fld_save)**2)
call mpl%f_comm%allreduce(mse,fckit_mpi_sum())
write(mpl%info,'(a7,a,e15.8)') '','Vertical balance direct/inverse (adjoint) test value:  ',mse/norm
call mpl%flush
write(mpl%test,'(a7,a,l1)') '','Vertical balance direct/inverse (adjoint) test result:  ',mse/norm<repro_th
call mpl%flush

! Inverse / direct
fld = fld_save
call vbal%apply_inv_ad(nam,geom,fld)
call vbal%apply_ad(nam,geom,fld)
mse = zss_sum((fld-fld_save)**2)
call mpl%f_comm%allreduce(mse,fckit_mpi_sum())
write(mpl%info,'(a7,a,e15.8)') '','Vertical balance inverse/direct (adjoint) test value:  ',mse/norm
call mpl%flush
write(mpl%test,'(a7,a,l1)') '','Vertical balance inverse/direct (adjoint) test result:  ',mse/norm<repro_th
call mpl%flush

! Probe out
@:probe_out()

end subroutine vbal_test_inverse

!----------------------------------------------------------------------
! Subroutine: vbal_test_adjoint
!> Test vertical balance adjoint
!----------------------------------------------------------------------
subroutine vbal_test_adjoint(vbal,mpl,rng,nam,geom)

implicit none

! Passed variables
class(vbal_type),intent(in) :: vbal !< Vertical balance
type(mpl_type),intent(inout) :: mpl !< MPI data
type(rng_type),intent(inout) :: rng !< Random number generator
type(nam_type),intent(in) :: nam    !< Namelist
type(geom_type),intent(in) :: geom  !< Geometry

! Local variables
integer :: iv,jv
real(kind_real) :: sum1,sum2
real(kind_real) :: fld1(geom%nc0a,geom%nl0,nam%nv),fld1_save(geom%nc0a,geom%nl0,nam%nv)
real(kind_real) :: fld2(geom%nc0a,geom%nl0,nam%nv),fld2_save(geom%nc0a,geom%nl0,nam%nv)

! Set name
@:set_name(vbal_test_adjoint)

! Probe in
@:probe_in()

! Generate random field
call rng%rand(zero,one,fld1_save)
call rng%rand(zero,one,fld2_save)

! Block adjoint test
do iv=1,nam%nv
   do jv=1,iv
      if (nam%vbal_block(iv,jv)) then
         fld1(:,:,iv) = fld1_save(:,:,iv)
         fld2(:,:,iv) = fld2_save(:,:,iv)
         call vbal%blk(iv,jv)%apply(geom,vbal%h_n_s_max,vbal%h_n_s,vbal%h_c2b,vbal%h_S,fld1(:,:,iv))
         call vbal%blk(iv,jv)%apply_ad(geom,vbal%h_n_s_max,vbal%h_n_s,vbal%h_c2b,vbal%h_S,fld2(:,:,iv))
         call mpl%dot_prod(fld1(:,:,iv),fld2_save(:,:,iv),sum1)
         call mpl%dot_prod(fld2(:,:,iv),fld1_save(:,:,iv),sum2)
         write(mpl%info,'(a7,a,e15.8,a,e15.8,a,e15.8)') '','Vertical balance block '//trim(vbal%blk(iv,jv)%name)// &
 & ' adjoint test values:  ',sum1,' / ',sum2,' / ',two*abs(sum1-sum2)/abs(sum1+sum2)
         call mpl%flush
         write(mpl%test,'(a7,a,l1)') '','Vertical balance block '//trim(vbal%blk(iv,jv)%name)// &
 & ' adjoint test result:  ',two*abs(sum1-sum2)/abs(sum1+sum2)<repro_th
         call mpl%flush
      end if
   end do
end do

! Direct adjoint test
fld1 = fld1_save
fld2 = fld2_save
call vbal%apply(nam,geom,fld1)
call vbal%apply_ad(nam,geom,fld2)
call mpl%dot_prod(fld1,fld2_save,sum1)
call mpl%dot_prod(fld2,fld1_save,sum2)
write(mpl%info,'(a7,a,e15.8,a,e15.8,a,e15.8)') '','Vertical balance direct adjoint test values:  ', &
 & sum1,' / ',sum2,' / ',two*abs(sum1-sum2)/abs(sum1+sum2)
call mpl%flush
write(mpl%test,'(a7,a,l1)') '','Vertical balance direct adjoint test results:  ', &
 & two*abs(sum1-sum2)/abs(sum1+sum2)<repro_th
call mpl%flush

! Inverse adjoint test
fld1 = fld1_save
fld2 = fld2_save
call vbal%apply_inv(nam,geom,fld1)
call vbal%apply_inv_ad(nam,geom,fld2)
call mpl%dot_prod(fld1,fld2_save,sum1)
call mpl%dot_prod(fld2,fld1_save,sum2)
write(mpl%info,'(a7,a,e15.8,a,e15.8,a,e15.8)') '','Vertical balance inverse adjoint test values: ', &
 & sum1,' / ',sum2,' / ',two*abs(sum1-sum2)/abs(sum1+sum2)
call mpl%flush
write(mpl%test,'(a7,a,l1)') '','Vertical balance inverse adjoint test results: ', &
 & two*abs(sum1-sum2)/abs(sum1+sum2)<repro_th
call mpl%flush

! Probe out
@:probe_out()

end subroutine vbal_test_adjoint

!----------------------------------------------------------------------
! Subroutine: vbal_test_dirac
!> Apply vertical balance to diracs
!----------------------------------------------------------------------
subroutine vbal_test_dirac(vbal,mpl,nam,geom)

implicit none

! Passed variables
class(vbal_type),intent(inout) :: vbal !< Vertical balance
type(mpl_type),intent(inout) :: mpl    !< MPI data
type(nam_type),intent(in) :: nam       !< Namelist
type(geom_type),intent(in) :: geom     !< Geometry

! Local variables
integer :: idir,ic0a,il0
real(kind_real) :: fld_c0a(geom%nc0a,geom%nl0,nam%nv)

! Set name
@:set_name(vbal_test_dirac)

! Probe in
@:probe_in()

! Allocation
allocate(vbal%dirac(geom%nc0a,geom%nl0,nam%nv))

do idir=1,geom%ndir
   ! Generate dirac field
   fld_c0a = zero
   if (geom%iprocdir(idir)==mpl%myproc) fld_c0a(geom%ic0adir(idir),geom%il0dir(idir),geom%ivdir(idir)) = one

   ! Apply vertical balance to dirac
   call vbal%apply(nam,geom,vbal%dirac)

   ! Copy points
   do il0=1,geom%nl0
      do ic0a=1,geom%nc0a
         if (geom%inbdir(ic0a,il0)==idir) vbal%dirac(ic0a,il0,:) = fld_c0a(ic0a,il0,:)
      end do
   end do
end do

! Probe out
@:probe_out()

end subroutine vbal_test_dirac

end module type_vbal
