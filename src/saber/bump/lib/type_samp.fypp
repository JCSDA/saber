#:include 'instrumentation.fypp'
!----------------------------------------------------------------------
! Module: type_samp
!> Sampling derived type
! Author: Benjamin Menetrier
! Licensing: this code is distributed under the CeCILL-C license
! Copyright 2015-... UCAR, CERFACS, METEO-FRANCE and IRIT
!----------------------------------------------------------------------
module type_samp

use atlas_module, only: atlas_structuredgrid
use fckit_mpi_module, only: fckit_mpi_sum,fckit_mpi_min,fckit_mpi_max,fckit_mpi_status
!$ use omp_lib
use tools_atlas, only: get_grid
use tools_const, only: zero,quarter,half,one,four,hundred,pi,req,reqkm,deg2rad,rad2deg
use tools_func, only: lonlatmod,independent_levels,sphere_bearing,sphere_dist,inside,cx_to_cxa,cx_to_proc,cx_to_cxu, &
 & convert_i2l,convert_l2i,zss_maxval,zss_minval,zss_sum,zss_count
use tools_gc99, only: fit_func
use tools_kinds, only: kind_int,kind_real
use tools_netcdf, only: create_file,open_file,put_att,get_att,define_dim,inquire_dim,inquire_dim_size,define_var,inquire_var, &
 & put_var,get_var,close_file
use tools_qsort, only: qsort
use tools_repro, only: eq,inf
use type_com, only: com_type
use type_ens, only: ens_type
use type_geom, only: geom_type
use type_io, only: io_type
use type_linop, only: linop_type
use type_mesh, only: mesh_type
use type_mpl, only: mpl_type
use type_nam, only: nam_type
@:use_probe()
use type_rng, only: rng_type
use type_tree, only: tree_type

implicit none

! Sampling derived type
type samp_type
   ! Parameters
   logical :: sc1                                         !< Subset Sc1 flag
   logical :: sc2                                         !< Subset Sc2 flag
   logical :: sc3                                         !< Subset Sc3 flag
   logical :: lat_bands                                   !< Latitude bands flag
   logical :: compute_c2b_to_c1a                          !< Compute interpolation from subset Sc2, halo B to subset Sc1, halo A flag

   ! Number of processors
   integer :: nproc                                       !< Number of processors

   ! Universe
   logical,allocatable :: myuniverse(:)                   !< MPI tasks in the universe of the local task

   ! Levels
   integer :: nl0ic1                                      !< Number of independent levels in subset Sl0, subset Sc1
   integer,allocatable :: l0_to_l0ic1(:)                  !< Levels to independent levels in Sl0, subset Sc1
   integer,allocatable :: l0ic1_to_l0(:)                  !< Independent levels to level in Sl0, subset Sc1
   integer,allocatable :: nl0ic3(:,:)                     !< Number of independent levels in subset Sl0, subset Sc1 and Sc3
   integer,allocatable :: l0_to_l0ic3(:,:,:)              !< Levels to independent levels in Sl0, subsets Sc1 and Sc3
   integer,allocatable :: l0ic3_to_l0(:,:,:)              !< Independent levels to level in Sl0, subset Sc1 and Sc3

   ! Subset Sc0
   real(kind_real),allocatable :: smask_input_c0a(:,:,:)  !< Mask input field on subset Sc0, halo A
   logical,allocatable :: smask_c0a(:,:)                  !< Mask on subset Sc0, halo A
   logical,allocatable :: smask_hor_c0a(:)                !< Union of horizontal masks on subset Sc0, halo A
   logical,allocatable :: smask_c0u(:,:)                  !< Mask on subset Sc0, universe
   logical,allocatable :: smask_hor_c0u(:)                !< Union of horizontal masks on subset Sc0, universe
   integer,allocatable :: nc0_smask(:)                    !< Horizontal mask size on subset Sc0
   integer :: nc0b                                        !< Number of points in subset Sc0, halo B
   integer :: nc0c                                        !< Number of points in subset Sc0, halo C

   ! Subset Sc1
   integer :: nc1                                         !< Number of points in subset Sc1, global
   integer,allocatable :: proc_to_nc1a(:)                 !< Processor to halo A size for subset Sc1
   integer,allocatable :: proc_to_c1_offset(:)            !< Processor to offset on subset Sc1
   integer :: nc1u                                        !< Number of points in subset Sc1, universe
   integer,allocatable :: c1u_to_c1(:)                    !< Subset Sc1, universe, to subset Sc1, global
   integer,allocatable :: c1u_to_c1a(:)                   !< Subset Sc1, universe, to subset Sc1, halo A
   real(kind_real),allocatable :: lon_c1u(:)              !< Longitudes on subset Sc1, universe
   real(kind_real),allocatable :: lat_c1u(:)              !< Latitudes on subset Sc1, universe
   logical,allocatable :: smask_c1u(:,:)                  !< Mask on subset Sc1, universe
   integer :: nc1a                                        !< Number of points in subset Sc1, halo A
   integer,allocatable :: c1a_to_c1(:)                    !< Subset Sc1, halo A, to subset Sc1, global
   integer,allocatable :: c1a_to_c1u(:)                   !< Subset Sc1, halo A, to subset Sc1, universe
   real(kind_real),allocatable :: lon_c1a(:)              !< Longitudes on subset Sc1, halo A
   real(kind_real),allocatable :: lat_c1a(:)              !< Latitudes on subset Sc1, halo A
   real(kind_real),allocatable :: vert_coord_c1a(:,:)     !< Generalized vertical coordinate on subset Sc1, halo A
   logical,allocatable :: smask_c1a(:,:)                  !< Mask on subset Sc1, halo A
   real(kind_real),allocatable :: lon_c3a(:,:,:)          !< Longitudes on subset Sc1 and Sc3, halo A
   real(kind_real),allocatable :: lat_c3a(:,:,:)          !< Latitudes on subset Sc1 and Sc3, halo A
   logical,allocatable :: smask_c3a(:,:,:,:)              !< Mask on subset Sc1 and Sc3, halo A
   logical,allocatable :: smask_c1dc3(:,:,:,:)            !< Mask on subset Sc1 and Sc3, halo D
   integer :: nc1d                                        !< Number of points in subset Sc1, halo D
   integer,allocatable :: c1d_to_c1u(:)                   !< Subset Sc1, halo D to universe
   integer :: nc1e                                        !< Number of points in subset Sc1, halo E
   integer,allocatable :: c1e_to_c1u(:)                   !< Subset Sc1, halo E to universe
   type(tree_type) :: tree_c1u                            !< Tree on subset Sc1, universe
   type(mesh_type) :: mesh_c1u                            !< Mesh on subset Sc1, universe

   ! Subset Sc2
   integer :: nc2                                         !< Number of points in subset Sc2, global
   integer,allocatable :: proc_to_nc2a(:)                 !< Processor to halo A size for subset Sc2
   integer,allocatable :: proc_to_c2_offset(:)            !< Processor to offset on subset Sc2
   integer :: nc2u                                        !< Number of points in subset Sc2, universe
   integer,allocatable :: c2u_to_c2(:)                    !< Subset Sc2, universe, to subset Sc2, global
   real(kind_real),allocatable :: lon_c2u(:)              !< Longitudes on subset Sc2, universe
   real(kind_real),allocatable :: lat_c2u(:)              !< Latitudes on subset Sc2, universe
   logical,allocatable :: smask_c2u(:,:)                  !< Mask on subset Sc2, universe
   integer :: nc2a                                        !< Number of points in subset Sc2, halo A
   integer,allocatable :: c2a_to_c2(:)                    !< Subset Sc2, halo A, to subset Sc2, global
   integer,allocatable :: c2a_to_c2u(:)                   !< Subset Sc2, halo A, to subset Sc2, universe
   real(kind_real),allocatable :: lon_c2a(:)              !< Longitudes on subset Sc2, halo A
   real(kind_real),allocatable :: lat_c2a(:)              !< Latitudes on subset Sc2, halo A
   real(kind_real),allocatable :: vert_coord_c2a(:,:)     !< Generalized vertical coordinate on subset Sc2, halo A
   logical,allocatable :: smask_c2a(:,:)                  !< Mask on subset Sc2, halo A
   integer :: nc2b                                        !< Number of points in subset Sc2, halo B
   integer,allocatable :: c2a_to_c2b(:)                   !< Subset Sc2, halo A to halo B
   integer,allocatable :: c2b_to_c2u(:)                   !< Subset Sc2, halo B to universe
   integer :: nc2e                                        !< Number of points in subset Sc2, halo E

   ! Local data
   logical,allocatable :: vbal_mask(:,:)                  !< Vertical balance mask
   logical,allocatable :: local_mask(:,:)                 !< Local mask
   integer,allocatable :: nn_c2a_index(:,:)               !< Nearest diagnostic neighbors from diagnostic points
   real(kind_real),allocatable :: nn_c2a_dist(:,:)        !< Nearest diagnostic neighbors distance from diagnostic points

   ! Forced points
   integer,allocatable :: ldwv_to_proc(:)                 !< Local diagnostics profiles to task
   integer,allocatable :: ldwv_to_c0a(:)                  !< Local diagnostics profiles to subset Sc0, halo A
   integer,allocatable :: ldwv_to_c2a(:)                  !< Local diagnostics profiles to subset Sc2, halo A

   ! Interpolations
   type(linop_type),allocatable :: interp_c0b_to_c1a(:)     !< Horizontal interpolation from subset Sc0, halo B to subset Sc1, halo A
   type(linop_type),allocatable :: interp_c0c_to_c3a(:,:,:) !< Horizontal interpolation from subset Sc0, halo C to subset Sc1 and Sc3, halo A
   type(linop_type),allocatable :: interp_c2b_to_c0a(:)     !< Horizontal interpolation from subset Sc2, halo B to subset Sc0, halo A
   type(linop_type) :: interp_c2b_to_c1a                    !< Horizontal interpolation from subset Sc2, halo B to subset Sc1, halo A

   ! Communications
   type(com_type) :: com_c0_AB                            !< Communication between halos A and B (interpolation for zero-separation) on subset Sc0
   type(com_type) :: com_c0_AC                            !< Communication between halos A and C (interpolation for positive separation) on subset Sc0
   type(com_type) :: com_c1_AD                            !< Communication between halos A and D (diagnostic) on subset Sc1
   type(com_type) :: com_c1_AE                            !< Communication between halos A and E (vertical balance) on subset Sc
   type(com_type) :: com_c1_AU                            !< Communication between halo A and universe on subset Sc1
   type(com_type) :: com_c2_AB                            !< Communication between halos A and B (interpolation) on subset Sc2
   type(com_type) :: com_c2_AU                            !< Communication between halo A and universe on subset Sc2

   ! I/O
   type(io_type) :: io_c1                                 !< I/O for subset Sc1
   type(io_type) :: io_c2                                 !< I/O for subset Sc2
contains
   procedure :: alloc => samp_alloc
   procedure :: dealloc => samp_dealloc
   procedure :: copy => samp_copy
   procedure :: samp_read_local
   procedure :: samp_read_local_single
   generic :: read_local => samp_read_local,samp_read_local_single
   procedure :: samp_write_local
   procedure :: samp_write_local_single
   generic :: write_local => samp_write_local,samp_write_local_single
   procedure :: read_global => samp_read_global
   procedure :: write_global => samp_write_global
   procedure :: write_grids => samp_write_grids
   procedure :: send => samp_send
   procedure :: receive => samp_receive
   procedure :: setup => samp_setup
   procedure :: setup_mpi => samp_setup_mpi
   procedure :: setup_write => samp_setup_write
   procedure :: compute_mask => samp_compute_mask
   procedure :: compute_c1_or_c2 => samp_compute_c1_or_c2
   procedure :: compute_c3 => samp_compute_c3
   procedure :: compute_mpi_c1au => samp_compute_mpi_c1au
   procedure :: compute_mpi_c2au => samp_compute_mpi_c2au
   procedure :: compute_mpi_c2b => samp_compute_mpi_c2b
   procedure :: compute_mpi_c0b => samp_compute_mpi_c0b
   procedure :: compute_mpi_c0c => samp_compute_mpi_c0c
   procedure :: compute_mpi_d => samp_compute_mpi_d
   procedure :: compute_mpi_e => samp_compute_mpi_e
   procedure :: diag_filter => samp_diag_filter
   procedure :: diag_fill => samp_diag_fill
   procedure :: c1_to_c1a => samp_c1_to_c1a
   procedure :: c1_to_proc => samp_c1_to_proc
   procedure :: c1_to_c1u => samp_c1_to_c1u
   procedure :: c2_to_c2a => samp_c2_to_c2a
   procedure :: c2_to_proc => samp_c2_to_proc
   procedure :: c2_to_c2u => samp_c2_to_c2u
end type samp_type

private
public :: samp_type

contains

!----------------------------------------------------------------------
! Subroutine: samp_alloc
!> Allocation
!----------------------------------------------------------------------
subroutine samp_alloc(samp,mpl,nam,geom)

implicit none

! Passed variables
class(samp_type),intent(inout) :: samp !< Sampling
type(mpl_type),intent(inout) :: mpl    !< MPI data
type(nam_type),intent(in) :: nam       !< Namelist
type(geom_type),intent(in) :: geom     !< Geometry

! Set name
@:set_name(samp_alloc)

! Probe in
@:probe_in()

! Initialization
samp%nproc = mpl%nproc
samp%sc1 = (.not.nam%from_gsi)
samp%sc2 = nam%new_vbal.or.nam%load_vbal.or.(nam%new_hdiag.and.nam%local_diag)
samp%sc3 = samp%sc1.and.(nam%new_mom.or.nam%load_mom)
samp%lat_bands = ((nam%new_vbal.or.nam%new_hdiag).and.(nam%local_dlat>zero)).or.nam%from_gsi
samp%compute_c2b_to_c1a = nam%new_vbal.and.(nam%new_vbal_cov.or.nam%load_vbal_cov)

! Allocation
allocate(samp%myuniverse(samp%nproc))
if (samp%sc1) then
   allocate(samp%proc_to_nc1a(samp%nproc))
   allocate(samp%proc_to_c1_offset(samp%nproc))
end if
if (samp%sc2) then
   allocate(samp%proc_to_nc2a(samp%nproc))
   allocate(samp%proc_to_c2_offset(samp%nproc))
end if

! Copy universe
samp%myuniverse = geom%myuniverse

! Probe out
@:probe_out()

end subroutine samp_alloc

!----------------------------------------------------------------------
! Subroutine: samp_dealloc
!> Release memory
!----------------------------------------------------------------------
subroutine samp_dealloc(samp)

implicit none

! Passed variables
class(samp_type),intent(inout) :: samp !< Sampling

! Local variables
integer :: il0ic1,il0ic3,il0,jc3,jc4

! Set name
@:set_name(samp_dealloc)

! Probe in
@:probe_in()

! Release memory
if (allocated(samp%myuniverse)) deallocate(samp%myuniverse)
if (allocated(samp%l0_to_l0ic1)) deallocate(samp%l0_to_l0ic1)
if (allocated(samp%l0ic1_to_l0)) deallocate(samp%l0ic1_to_l0)
if (allocated(samp%nl0ic3)) deallocate(samp%nl0ic3)
if (allocated(samp%l0_to_l0ic3)) deallocate(samp%l0_to_l0ic3)
if (allocated(samp%l0ic3_to_l0)) deallocate(samp%l0ic3_to_l0)
if (allocated(samp%smask_c0u)) deallocate(samp%smask_c0u)
if (allocated(samp%smask_hor_c0u)) deallocate(samp%smask_hor_c0u)
if (allocated(samp%smask_c0a)) deallocate(samp%smask_c0a)
if (allocated(samp%smask_hor_c0a)) deallocate(samp%smask_hor_c0a)
if (allocated(samp%nc0_smask)) deallocate(samp%nc0_smask)
if (allocated(samp%proc_to_nc1a)) deallocate(samp%proc_to_nc1a)
if (allocated(samp%proc_to_c1_offset)) deallocate(samp%proc_to_c1_offset)
if (allocated(samp%c1u_to_c1)) deallocate(samp%c1u_to_c1)
if (allocated(samp%c1u_to_c1a)) deallocate(samp%c1u_to_c1a)
if (allocated(samp%lon_c1u)) deallocate(samp%lon_c1u)
if (allocated(samp%lat_c1u)) deallocate(samp%lat_c1u)
if (allocated(samp%smask_c1u)) deallocate(samp%smask_c1u)
if (allocated(samp%c1a_to_c1)) deallocate(samp%c1a_to_c1)
if (allocated(samp%c1a_to_c1u)) deallocate(samp%c1a_to_c1u)
if (allocated(samp%lon_c1a)) deallocate(samp%lon_c1a)
if (allocated(samp%lat_c1a)) deallocate(samp%lat_c1a)
if (allocated(samp%vert_coord_c1a)) deallocate(samp%vert_coord_c1a)
if (allocated(samp%smask_c1a)) deallocate(samp%smask_c1a)
if (allocated(samp%lon_c3a)) deallocate(samp%lon_c3a)
if (allocated(samp%lat_c3a)) deallocate(samp%lat_c3a)
if (allocated(samp%smask_c3a)) deallocate(samp%smask_c3a)
if (allocated(samp%smask_c1dc3)) deallocate(samp%smask_c1dc3)
if (allocated(samp%c1d_to_c1u)) deallocate(samp%c1d_to_c1u)
if (allocated(samp%c1e_to_c1u)) deallocate(samp%c1e_to_c1u)
call samp%tree_c1u%dealloc
call samp%mesh_c1u%dealloc
if (allocated(samp%proc_to_nc2a)) deallocate(samp%proc_to_nc2a)
if (allocated(samp%proc_to_c2_offset)) deallocate(samp%proc_to_c2_offset)
if (allocated(samp%c2u_to_c2)) deallocate(samp%c2u_to_c2)
if (allocated(samp%lon_c2u)) deallocate(samp%lon_c2u)
if (allocated(samp%lat_c2u)) deallocate(samp%lat_c2u)
if (allocated(samp%smask_c2u)) deallocate(samp%smask_c2u)
if (allocated(samp%c2a_to_c2)) deallocate(samp%c2a_to_c2)
if (allocated(samp%c2a_to_c2u)) deallocate(samp%c2a_to_c2u)
if (allocated(samp%lon_c2a)) deallocate(samp%lon_c2a)
if (allocated(samp%lat_c2a)) deallocate(samp%lat_c2a)
if (allocated(samp%vert_coord_c2a)) deallocate(samp%vert_coord_c2a)
if (allocated(samp%smask_c2a)) deallocate(samp%smask_c2a)
if (allocated(samp%c2a_to_c2b)) deallocate(samp%c2a_to_c2b)
if (allocated(samp%c2b_to_c2u)) deallocate(samp%c2b_to_c2u)
if (allocated(samp%vbal_mask)) deallocate(samp%vbal_mask)
if (allocated(samp%local_mask)) deallocate(samp%local_mask)
if (allocated(samp%nn_c2a_index)) deallocate(samp%nn_c2a_index)
if (allocated(samp%nn_c2a_dist)) deallocate(samp%nn_c2a_dist)
if (allocated(samp%ldwv_to_proc)) deallocate(samp%ldwv_to_proc)
if (allocated(samp%ldwv_to_c0a)) deallocate(samp%ldwv_to_c0a)
if (allocated(samp%ldwv_to_c2a)) deallocate(samp%ldwv_to_c2a)
if (allocated(samp%interp_c0b_to_c1a)) then
   do il0ic1=1,size(samp%interp_c0b_to_c1a)
      call samp%interp_c0b_to_c1a(il0ic1)%dealloc
   end do
   deallocate(samp%interp_c0b_to_c1a)
end if
if (allocated(samp%interp_c0c_to_c3a)) then
   do il0ic3=1,size(samp%interp_c0c_to_c3a,3)
      do jc4=1,size(samp%interp_c0c_to_c3a,2)
         do jc3=1,size(samp%interp_c0c_to_c3a,1)
            call samp%interp_c0c_to_c3a(jc3,jc4,il0ic3)%dealloc
         end do
      end do
   end do
   deallocate(samp%interp_c0c_to_c3a)
end if
if (allocated(samp%interp_c2b_to_c0a)) then
   do il0=1,size(samp%interp_c2b_to_c0a)
      call samp%interp_c2b_to_c0a(il0)%dealloc
   end do
   deallocate(samp%interp_c2b_to_c0a)
end if
call samp%interp_c2b_to_c1a%dealloc
call samp%com_c0_AB%dealloc
call samp%com_c0_AC%dealloc
call samp%com_c1_AD%dealloc
call samp%com_c1_AE%dealloc
call samp%com_c1_AU%dealloc
call samp%com_c2_AB%dealloc
call samp%com_c2_AU%dealloc
call samp%io_c1%dealloc
call samp%io_c2%dealloc

! Probe out
@:probe_out()

end subroutine samp_dealloc

!----------------------------------------------------------------------
! Subroutine: samp_copy
!> Copy sampling
!----------------------------------------------------------------------
subroutine samp_copy(samp,mpl,nam,geom,other)

implicit none

! Passed variables
class(samp_type),intent(inout) :: samp !< Sampling
type(mpl_type),intent(inout) :: mpl    !< MPI data
type(nam_type),intent(inout) :: nam    !< Namelist
type(geom_type),intent(in) :: geom     !< Geometry
type(samp_type),intent(in) :: other    !< Other sampling

! Set name
@:set_name(samp_copy)

! Probe in
@:probe_in()

! Allocation
call samp%alloc(mpl,nam,geom)

if (samp%sc1) then
   ! Copy sampling, subset Sc1
   write(mpl%info,'(a7,a,i5,a)') '','Copy sampling, subset Sc1 (nc1 = ',nam%nc1,')'
   call mpl%flush

   ! Copy dimensions
   samp%nc1 = other%nc1
   samp%nc1a = other%nc1a

   ! Allocation
   allocate(samp%lon_c1a(samp%nc1a))
   allocate(samp%lat_c1a(samp%nc1a))
   allocate(samp%vert_coord_c1a(samp%nc1a,geom%nl0))
   allocate(samp%smask_c1a(samp%nc1a,geom%nl0))
   allocate(samp%c1a_to_c1(samp%nc1a))

   ! Copy data
   samp%lon_c1a = other%lon_c1a
   samp%lat_c1a = other%lat_c1a
   samp%proc_to_nc1a = other%proc_to_nc1a
   samp%proc_to_c1_offset = other%proc_to_c1_offset
   samp%vert_coord_c1a = other%vert_coord_c1a
   samp%smask_c1a = other%smask_c1a
   samp%c1a_to_c1 = other%c1a_to_c1
else
   samp%nc1 = 0
   samp%nc1a = 0
end if

if (samp%sc2) then
   ! Copy sampling, subset Sc2
   write(mpl%info,'(a7,a,i5,a)') '','Copy sampling, subset Sc2 (nc2 = ',nam%nc2,')'
   call mpl%flush

   ! Copy dimensions
   samp%nc2 = other%nc2
   samp%nc2a = other%nc2a

   ! Allocation
   allocate(samp%lon_c2a(samp%nc2a))
   allocate(samp%lat_c2a(samp%nc2a))
   allocate(samp%vert_coord_c2a(samp%nc2a,geom%nl0))
   allocate(samp%smask_c2a(samp%nc2a,geom%nl0))
   allocate(samp%c2a_to_c2(samp%nc2a))

   ! Copy data
   samp%lon_c2a = other%lon_c2a
   samp%lat_c2a = other%lat_c2a
   samp%proc_to_nc2a = other%proc_to_nc2a
   samp%proc_to_c2_offset = other%proc_to_c2_offset
   samp%vert_coord_c2a = other%vert_coord_c2a
   samp%smask_c2a = other%smask_c2a
   samp%c2a_to_c2 = other%c2a_to_c2
else
   samp%nc2a = 0
end if

if (samp%sc3) then
   ! Copy sampling, subset Sc3
   write(mpl%info,'(a7,a,i5,a,i5,a)') '','Copy sampling, subset Sc3 (nc3 = ',nam%nc3,' / nc4 = ',nam%nc4,')'
   call mpl%flush

   ! Allocation
   allocate(samp%lon_c3a(samp%nc1a,nam%nc3,nam%nc4))
   allocate(samp%lat_c3a(samp%nc1a,nam%nc3,nam%nc4))
   allocate(samp%smask_c3a(samp%nc1a,nam%nc3,nam%nc4,geom%nl0))

   ! Copy data
   samp%lon_c3a = other%lon_c3a
   samp%lat_c3a = other%lat_c3a
   samp%smask_c3a = other%smask_c3a
end if

! Probe out
@:probe_out()

end subroutine samp_copy

!----------------------------------------------------------------------
! Subroutine: samp_read_local
!> Read (local)
!----------------------------------------------------------------------
subroutine samp_read_local(samp,mpl,nam,geom)

implicit none

! Passed variables
class(samp_type),intent(inout) :: samp !< Sampling
type(mpl_type),intent(inout) :: mpl    !< MPI data
type(nam_type),intent(inout) :: nam    !< Namelist
type(geom_type),intent(in) :: geom     !< Geometry

! Local variables
integer :: iproc,iprocio,ic2,ic2a,ic1,ic1a
type(samp_type) :: samp_tmp

! Set name
@:set_name(samp_read_local)

! Probe in
@:probe_in()

do iproc=1,mpl%nproc
   ! Reading task
   iprocio = mod(iproc,mpl%nprocio)
   if (iprocio==0) iprocio = mpl%nprocio

   if (mpl%myproc==iprocio) then
      write(mpl%info,'(a10,a,i6,a,i6)') '','Read sampling of task ',iproc,' from task ',iprocio
      call mpl%flush

      if (iproc==iprocio) then
         ! Read data
         call samp%read_local(mpl,nam,geom,iproc)
      else
         ! Allocation
         call samp_tmp%alloc(mpl,nam,geom)

         ! Read data
         call samp_tmp%read_local(mpl,nam,geom,iproc)

         ! Send data to task iproc
         call samp_tmp%send(mpl,nam,geom,iproc)

         ! Release memory
         call samp_tmp%dealloc
      end if
   elseif (mpl%myproc==iproc) then
      ! Receive data from task iprocio
      write(mpl%info,'(a10,a,i6,a,i6)') '','Receive sampling of task ',iproc,' from task ',iprocio
      call mpl%flush
      call samp%receive(mpl,nam,geom,iprocio)
   end if
end do

! Update tag
call mpl%update_tag(4)

! Post-processing
if (samp%sc1) then
   ! Communication
   call mpl%f_comm%allgather(samp%nc1a,samp%proc_to_nc1a)
   
   ! Subset Sc1 offset for halo A
   samp%proc_to_c1_offset(1) = 0
   do iproc=2,mpl%nproc
      samp%proc_to_c1_offset(iproc) = samp%proc_to_c1_offset(iproc-1)+samp%proc_to_nc1a(iproc-1)
   end do
   
   ! Conversion
   samp%nc1 = sum(samp%proc_to_nc1a)
   do ic1=1,samp%nc1
      iproc = samp%c1_to_proc(ic1)
      if (iproc==mpl%myproc) then
         ic1a = samp%c1_to_c1a(ic1)
         samp%c1a_to_c1(ic1a) = ic1
      end if
   end do
end if

if (samp%sc2) then
   ! Communication
   call mpl%f_comm%allgather(samp%nc2a,samp%proc_to_nc2a)

   ! Subset Sc2 offset for halo A
   samp%proc_to_c2_offset(1) = 0
   do iproc=2,mpl%nproc
      samp%proc_to_c2_offset(iproc) = samp%proc_to_c2_offset(iproc-1)+samp%proc_to_nc2a(iproc-1)
   end do

   ! Conversion
   samp%nc2 = sum(samp%proc_to_nc2a)
   do ic2=1,samp%nc2
      iproc = samp%c2_to_proc(ic2)
      if (iproc==mpl%myproc) then
         ic2a = samp%c2_to_c2a(ic2)
         samp%c2a_to_c2(ic2a) = ic2
      end if
   end do
end if

! Probe out
@:probe_out()

end subroutine samp_read_local

!----------------------------------------------------------------------
! Subroutine: samp_read_local_single
!> Read single task (local)
!----------------------------------------------------------------------
subroutine samp_read_local_single(samp,mpl,nam,geom,iproc)

implicit none

! Passed variables
class(samp_type),intent(inout) :: samp !< Sampling
type(mpl_type),intent(inout) :: mpl    !< MPI data
type(nam_type),intent(inout) :: nam    !< Namelist
type(geom_type),intent(in) :: geom     !< Geometry
integer,intent(in) :: iproc            !< Task index

! Local variables
integer :: ncid,nc1a_id,lon_c1a_id,lat_c1a_id,vert_coord_c1a_id,smask_c1a_id,lon_c3a_id,lat_c3a_id,smask_c3a_id
integer :: lon_c2a_id,lat_c2a_id,vert_coord_c2a_id,smask_c2a_id

! Set name
@:set_name(samp_read_local_single)

! Open file
ncid = open_file(mpl,nam%fname_samp,iproc)

! Check whether subset Sc1 is present
nc1a_id = inquire_dim(mpl,ncid,'nc1a')
samp%sc1 = mpl%msv%isnot(nc1a_id)

if (samp%sc1) then
   ! Get dimension
   samp%nc1a = inquire_dim_size(mpl,ncid,'nc1a',0)

   ! Allocation
   allocate(samp%lon_c1a(samp%nc1a))
   allocate(samp%lat_c1a(samp%nc1a))
   allocate(samp%vert_coord_c1a(samp%nc1a,geom%nl0))
   allocate(samp%smask_c1a(samp%nc1a,geom%nl0))
   if (samp%sc3) then
      allocate(samp%lon_c3a(samp%nc1a,nam%nc3,nam%nc4))
      allocate(samp%lat_c3a(samp%nc1a,nam%nc3,nam%nc4))
      allocate(samp%smask_c3a(samp%nc1a,nam%nc3,nam%nc4,geom%nl0))
   end if
   allocate(samp%c1a_to_c1(samp%nc1a))

   ! Inquire variables
   lon_c1a_id = inquire_var(mpl,ncid,'lon_c1a')
   lat_c1a_id = inquire_var(mpl,ncid,'lat_c1a')
   vert_coord_c1a_id = inquire_var(mpl,ncid,'vert_coord_c1a',varname_fallback='vunit_c1a')
   smask_c1a_id = inquire_var(mpl,ncid,'smask_c1a')
   if (samp%sc3) then
      lon_c3a_id = inquire_var(mpl,ncid,'lon_c3a')
      lat_c3a_id = inquire_var(mpl,ncid,'lat_c3a')
      smask_c3a_id = inquire_var(mpl,ncid,'smask_c3a')
   end if

   ! Read variables
   call get_var(mpl,ncid,lon_c1a_id,samp%lon_c1a)
   call get_var(mpl,ncid,lat_c1a_id,samp%lat_c1a)
   call get_var(mpl,ncid,vert_coord_c1a_id,samp%vert_coord_c1a)
   call get_var(mpl,ncid,smask_c1a_id,samp%smask_c1a)
   if (samp%sc3) then
      call get_var(mpl,ncid,lon_c3a_id,samp%lon_c3a)
      call get_var(mpl,ncid,lat_c3a_id,samp%lat_c3a)
      call get_var(mpl,ncid,smask_c3a_id,samp%smask_c3a)
   end if
end if

if (samp%sc2) then
   ! Get dimension
   samp%nc2a = inquire_dim_size(mpl,ncid,'nc2a',0)

   ! Get attribute
   call get_att(mpl,ncid,0,'lat_bands',samp%lat_bands)

   ! Allocation
   allocate(samp%lon_c2a(samp%nc2a))
   allocate(samp%lat_c2a(samp%nc2a))
   allocate(samp%vert_coord_c2a(samp%nc2a,geom%nl0))
   allocate(samp%smask_c2a(samp%nc2a,geom%nl0))
   allocate(samp%c2a_to_c2(samp%nc2a))

   ! Inquire variables
   lon_c2a_id = inquire_var(mpl,ncid,'lon_c2a')
   lat_c2a_id = inquire_var(mpl,ncid,'lat_c2a')
   vert_coord_c2a_id = inquire_var(mpl,ncid,'vert_coord_c2a',varname_fallback='vunit_c2a')
   smask_c2a_id = inquire_var(mpl,ncid,'smask_c2a')

   ! Read variables
   call get_var(mpl,ncid,lon_c2a_id,samp%lon_c2a)
   call get_var(mpl,ncid,lat_c2a_id,samp%lat_c2a)
   call get_var(mpl,ncid,vert_coord_c2a_id,samp%vert_coord_c2a)
   call get_var(mpl,ncid,smask_c2a_id,samp%smask_c2a)
else
   ! Initialization
   samp%nc2a = 0
end if

! Close file
call close_file(mpl,ncid) 

! Probe out
@:probe_out()

end subroutine samp_read_local_single

!----------------------------------------------------------------------
! Subroutine: samp_write_local
!> Write (local)
!----------------------------------------------------------------------
subroutine samp_write_local(samp,mpl,nam,geom)

implicit none

! Passed variables
class(samp_type),intent(inout) :: samp !< Sampling
type(mpl_type),intent(inout) :: mpl    !< MPI data
type(nam_type),intent(in) :: nam       !< Namelist
type(geom_type),intent(in) :: geom     !< Geometry

! Local variables
integer :: iproc,iprocio
type(samp_type) :: samp_tmp

! Set name
@:set_name(samp_write_local)

! Probe in
@:probe_in()

do iproc=1,mpl%nproc
   ! Writing task
   iprocio = mod(iproc,mpl%nprocio)
   if (iprocio==0) iprocio = mpl%nprocio

   if (mpl%myproc==iprocio) then
      write(mpl%info,'(a10,a,i6,a,i6)') '','Write sampling of task ',iproc,' from task ',iprocio
      call mpl%flush

      if (iproc==iprocio) then
         ! Write data
         call samp%write_local(mpl,nam,geom,iproc)
      else
         ! Allocation
         call samp_tmp%alloc(mpl,nam,geom)

         ! Receive data from task iproc
         call samp_tmp%receive(mpl,nam,geom,iproc)

         ! Write data
         call samp_tmp%write_local(mpl,nam,geom,iproc)

         ! Release memory
         call samp_tmp%dealloc
      end if
   elseif (mpl%myproc==iproc) then
      ! Send data to task iprocio
      write(mpl%info,'(a10,a,i6,a,i6)') '','Send sampling of task ',iproc,' to task ',iprocio
      call mpl%flush
      call samp%send(mpl,nam,geom,iprocio)
   end if
end do

! Update tag
call mpl%update_tag(4)

! Probe out
@:probe_out()

end subroutine samp_write_local

!----------------------------------------------------------------------
! Subroutine: samp_write_local_single
!> Write single task (local)
!----------------------------------------------------------------------
subroutine samp_write_local_single(samp,mpl,nam,geom,iproc)

implicit none

! Passed variables
class(samp_type),intent(inout) :: samp !< Sampling
type(mpl_type),intent(inout) :: mpl    !< MPI data
type(nam_type),intent(in) :: nam       !< Namelist
type(geom_type),intent(in) :: geom     !< Geometry
integer,intent(in) :: iproc            !< Task index

! Local variables
integer :: ncid,nc1a_id,nl0_id,nc3_id,nc4_id,nc2a_id,lon_c1a_id,lat_c1a_id,vert_coord_c1a_id,smask_c1a_id
integer :: lon_c3a_id,lat_c3a_id,smask_c3a_id,lon_c2a_id,lat_c2a_id,vert_coord_c2a_id,smask_c2a_id

! Set name
@:set_name(samp_write_local_single)

! Probe in
@:probe_in()

! Open file
ncid = create_file(mpl,nam%fname_samp,iproc)

! Define dimensions
if (samp%sc1) nc1a_id = define_dim(mpl,ncid,'nc1a',samp%nc1a)
nl0_id = define_dim(mpl,ncid,'nl0',geom%nl0)
if (samp%sc3) then
   nc3_id = define_dim(mpl,ncid,'nc3',nam%nc3)
   nc4_id = define_dim(mpl,ncid,'nc4',nam%nc4)
end if
if (samp%sc2) nc2a_id = define_dim(mpl,ncid,'nc2a',samp%nc2a)

! Define variables
if (samp%sc1) then
   lon_c1a_id = define_var(mpl,ncid,'lon_c1a','real',(/nc1a_id/))
   lat_c1a_id = define_var(mpl,ncid,'lat_c1a','real',(/nc1a_id/))
   vert_coord_c1a_id = define_var(mpl,ncid,'vert_coord_c1a','real',(/nc1a_id,nl0_id/))
   smask_c1a_id = define_var(mpl,ncid,'smask_c1a','logical',(/nc1a_id,nl0_id/))
end if
if (samp%sc3) then
   lon_c3a_id = define_var(mpl,ncid,'lon_c3a','real',(/nc1a_id,nc3_id,nc4_id/))
   lat_c3a_id = define_var(mpl,ncid,'lat_c3a','real',(/nc1a_id,nc3_id,nc4_id/))
   smask_c3a_id = define_var(mpl,ncid,'smask_c3a','logical',(/nc1a_id,nc3_id,nc4_id,nl0_id/))
end if
if (samp%sc2) then
   lon_c2a_id = define_var(mpl,ncid,'lon_c2a','real',(/nc2a_id/))
   lat_c2a_id = define_var(mpl,ncid,'lat_c2a','real',(/nc2a_id/))
   vert_coord_c2a_id = define_var(mpl,ncid,'vert_coord_c2a','real',(/nc2a_id,nl0_id/))
   smask_c2a_id = define_var(mpl,ncid,'smask_c2a','logical',(/nc2a_id,nl0_id/))
end if

! Put attributes
if (samp%sc2) call put_att(mpl,ncid,0,'lat_bands',samp%lat_bands)

! Write variables
if (samp%sc1) then
   call put_var(mpl,ncid,lon_c1a_id,samp%lon_c1a)
   call put_var(mpl,ncid,lat_c1a_id,samp%lat_c1a)
   call put_var(mpl,ncid,vert_coord_c1a_id,samp%vert_coord_c1a)
   call put_var(mpl,ncid,smask_c1a_id,samp%smask_c1a)
end if
if (samp%sc3) then
   call put_var(mpl,ncid,lon_c3a_id,samp%lon_c3a)
   call put_var(mpl,ncid,lat_c3a_id,samp%lat_c3a)
   call put_var(mpl,ncid,smask_c3a_id,samp%smask_c3a)
end if
if (samp%sc2) then
   call put_var(mpl,ncid,lon_c2a_id,samp%lon_c2a)
   call put_var(mpl,ncid,lat_c2a_id,samp%lat_c2a)
   call put_var(mpl,ncid,vert_coord_c2a_id,samp%vert_coord_c2a)
   call put_var(mpl,ncid,smask_c2a_id,samp%smask_c2a)
end if

! Close file
call close_file(mpl,ncid)

! Probe out
@:probe_out()

end subroutine samp_write_local_single

!----------------------------------------------------------------------
! Subroutine: samp_read_global
!> Read (global)
!----------------------------------------------------------------------
subroutine samp_read_global(samp,mpl,nam,geom)

implicit none

! Passed variables
class(samp_type),intent(inout) :: samp !< Sampling
type(mpl_type),intent(inout) :: mpl    !< MPI data
type(nam_type),intent(inout) :: nam    !< Namelist
type(geom_type),intent(in) :: geom     !< Geometry

! Local variables
integer :: ncid,nc1_id,lon_c1_id,lat_c1_id,vert_coord_c1_id,smask_c1_id,lon_c3_id,lat_c3_id,smask_c3_id
integer :: lon_c2_id,lat_c2_id,vert_coord_c2_id,smask_c2_id
integer :: ic1,ic1a,iproc,ic2,ic2a
integer,allocatable :: lev_c1(:),c1_on_file_to_proc(:),c1_to_c0a(:)
integer,allocatable :: lev_c2(:),c2_on_file_to_proc(:),c2_to_c0a(:)
real(kind_real),allocatable :: lon_c1(:),lat_c1(:),lon_c2(:),lat_c2(:)
logical,allocatable :: gmask_c1(:),gmask_c2(:)

! Set name
@:set_name(samp_read_global)

! Probe in
@:probe_in()

! Open file
ncid = open_file(mpl,nam%fname_samp)

! Check whether subset Sc1 is present
nc1_id = inquire_dim(mpl,ncid,'nc1')
if (mpl%iobcast) call mpl%f_comm_iobcast%broadcast(nc1_id,mpl%rootproc-1)
samp%sc1 = mpl%msv%isnot(nc1_id)

if (samp%sc1) then
   ! Get dimension
   samp%nc1 = inquire_dim_size(mpl,ncid,'nc1')
   if (mpl%iobcast) call mpl%f_comm_iobcast%broadcast(samp%nc1,mpl%rootproc-1)

   ! Allocation
   allocate(lon_c1(samp%nc1))
   allocate(lat_c1(samp%nc1))

   ! Inquire variables
   lon_c1_id = inquire_var(mpl,ncid,'lon_c1')
   lat_c1_id = inquire_var(mpl,ncid,'lat_c1')

   ! Read variables
   call get_var(mpl,ncid,lon_c1_id,lon_c1)
   call get_var(mpl,ncid,lat_c1_id,lat_c1)
   if (mpl%iobcast) then
      call mpl%f_comm_iobcast%broadcast(lon_c1,mpl%rootproc-1)
      call mpl%f_comm_iobcast%broadcast(lat_c1,mpl%rootproc-1)
   end if

   ! Allocation
   allocate(lev_c1(samp%nc1))
   allocate(c1_on_file_to_proc(samp%nc1))
   allocate(c1_to_c0a(samp%nc1))
   allocate(gmask_c1(samp%nc1))

   ! Split sampling among processors
   lev_c1 = 0
   call geom%index_from_lonlat(mpl,samp%nc1,lon_c1,lat_c1,lev_c1,c1_on_file_to_proc,c1_to_c0a,gmask_c1)
   if (mpl%msv%isany(c1_on_file_to_proc)) call mpl%abort('${subr}$','subset Sc1 point is out of the domain')

   ! Sampling size on halo A
   samp%nc1a = count(c1_on_file_to_proc==mpl%myproc)

   ! Allocation
   allocate(samp%lon_c1a(samp%nc1a))
   allocate(samp%lat_c1a(samp%nc1a))
   allocate(samp%c1a_to_c1(samp%nc1a))
   allocate(samp%vert_coord_c1a(samp%nc1a,geom%nl0))
   allocate(samp%smask_c1a(samp%nc1a,geom%nl0))
   if (samp%sc3) then
      allocate(samp%lon_c3a(samp%nc1a,nam%nc3,nam%nc4))
      allocate(samp%lat_c3a(samp%nc1a,nam%nc3,nam%nc4))
      allocate(samp%smask_c3a(samp%nc1a,nam%nc3,nam%nc4,geom%nl0))
   end if

   ! Copy lon/lat
   ic1a = 0
   do ic1=1,samp%nc1
      iproc = c1_on_file_to_proc(ic1)
      if (iproc==mpl%myproc) then
         ic1a = ic1a+1
         samp%lon_c1a(ic1a) = lon_c1(ic1)
         samp%lat_c1a(ic1a) = lat_c1(ic1)
      end if
   end do

   ! Communication
   call mpl%f_comm%allgather(samp%nc1a,samp%proc_to_nc1a)

   ! Subset Sc1 offset for halo A
   samp%proc_to_c1_offset(1) = 0
   do iproc=2,mpl%nproc
      samp%proc_to_c1_offset(iproc) = samp%proc_to_c1_offset(iproc-1)+samp%proc_to_nc1a(iproc-1)
   end do

   ! Conversion
   do ic1=1,samp%nc1
      iproc = samp%c1_to_proc(ic1)
      if (iproc==mpl%myproc) then
         ic1a = samp%c1_to_c1a(ic1)
         samp%c1a_to_c1(ic1a) = ic1
      end if
   end do

   ! Setup fields I/O
   call samp%io_c1%init(mpl,10,'1',samp%nc1,samp%nc1a,samp%c1a_to_c1,samp%proc_to_c1_offset, &
 & lon_cxa=samp%lon_c1a,lat_cxa=samp%lat_c1a)

   ! Inquire variables
   vert_coord_c1_id = inquire_var(mpl,ncid,'vert_coord_c1',varname_fallback='vunit_c1')
   smask_c1_id = inquire_var(mpl,ncid,'smask_c1')
   if (samp%sc3) then
      lon_c3_id = inquire_var(mpl,ncid,'lon_c3')
      lat_c3_id = inquire_var(mpl,ncid,'lat_c3')
      smask_c3_id = inquire_var(mpl,ncid,'smask_c3')
   end if

   ! Read variables
   call samp%io_c1%fld_read(mpl,ncid,vert_coord_c1_id,samp%vert_coord_c1a)
   call samp%io_c1%fld_read(mpl,ncid,smask_c1_id,samp%smask_c1a)
   if (samp%sc3) then
      call samp%io_c1%fld_read(mpl,ncid,lon_c3_id,samp%lon_c3a)
      call samp%io_c1%fld_read(mpl,ncid,lat_c3_id,samp%lat_c3a)
      call samp%io_c1%fld_read(mpl,ncid,smask_c3_id,samp%smask_c3a)
   end if

   ! Release memory
   deallocate(lev_c1)
   deallocate(c1_on_file_to_proc)
   deallocate(c1_to_c0a)
   deallocate(gmask_c1)
end if

if (samp%sc2) then
   ! Get dimension
   samp%nc2 = inquire_dim_size(mpl,ncid,'nc2')
   if (mpl%iobcast) call mpl%f_comm_iobcast%broadcast(samp%nc2,mpl%rootproc-1)

   ! Allocation
   allocate(lon_c2(samp%nc2))
   allocate(lat_c2(samp%nc2))

   ! Get attribute
   call get_att(mpl,ncid,0,'lat_bands',samp%lat_bands)
   if (mpl%iobcast) call mpl%f_comm_iobcast%broadcast(samp%lat_bands,mpl%rootproc-1)

   ! Inquire variables
   lon_c2_id = inquire_var(mpl,ncid,'lon_c2')
   lat_c2_id = inquire_var(mpl,ncid,'lat_c2')

   ! Read variables
   call get_var(mpl,ncid,lon_c2_id,lon_c2)
   call get_var(mpl,ncid,lat_c2_id,lat_c2)
   if (mpl%iobcast) then
      call mpl%f_comm_iobcast%broadcast(lon_c2,mpl%rootproc-1)
      call mpl%f_comm_iobcast%broadcast(lat_c2,mpl%rootproc-1)
   end if

   ! Allocation
   allocate(lev_c2(samp%nc2))
   allocate(c2_on_file_to_proc(samp%nc2))
   allocate(c2_to_c0a(samp%nc2))
   allocate(gmask_c2(samp%nc2))

   ! Split sampling among processors
   lev_c2 = 0
   call geom%index_from_lonlat(mpl,samp%nc2,lon_c2,lat_c2,lev_c2,c2_on_file_to_proc,c2_to_c0a,gmask_c2)
   if (mpl%msv%isany(c2_on_file_to_proc)) call mpl%abort('${subr}$','subset Sc2 point is out of the domain')

   ! Sampling size on halo A
   samp%nc2a = count(c2_on_file_to_proc==mpl%myproc)

   ! Allocation
   allocate(samp%lon_c2a(samp%nc2a))
   allocate(samp%lat_c2a(samp%nc2a))
   allocate(samp%c2a_to_c2(samp%nc2a))
   allocate(samp%vert_coord_c2a(samp%nc2a,geom%nl0))
   allocate(samp%smask_c2a(samp%nc2a,geom%nl0))

   ! Copy lon/lat
   ic2a = 0
   do ic2=1,samp%nc2
      if (c2_on_file_to_proc(ic2)==mpl%myproc) then
         ic2a = ic2a+1
         samp%lon_c2a(ic2a) = lon_c2(ic2)
         samp%lat_c2a(ic2a) = lat_c2(ic2)
      end if
   end do

   ! Communication
   call mpl%f_comm%allgather(samp%nc2a,samp%proc_to_nc2a)

   ! Subset Sc2 offset for halo A
   samp%proc_to_c2_offset(1) = 0
   do iproc=2,mpl%nproc
      samp%proc_to_c2_offset(iproc) = samp%proc_to_c2_offset(iproc-1)+samp%proc_to_nc2a(iproc-1)
   end do

   ! Conversion
   do ic2=1,samp%nc2
      iproc = samp%c2_to_proc(ic2)
      if (iproc==mpl%myproc) then
         ic2a = samp%c2_to_c2a(ic2)
         samp%c2a_to_c2(ic2a) = ic2
      end if
   end do

   ! Setup fields I/O
   call samp%io_c2%init(mpl,10,'2',samp%nc2,samp%nc2a,samp%c2a_to_c2,samp%proc_to_c2_offset, &
 & lon_cxa=samp%lon_c2a,lat_cxa=samp%lat_c2a)

   ! Inquire variables
   vert_coord_c2_id = inquire_var(mpl,ncid,'vert_coord_c2',varname_fallback='vunit_c2')
   smask_c2_id = inquire_var(mpl,ncid,'smask_c2')

   ! Read variables
   call samp%io_c2%fld_read(mpl,ncid,vert_coord_c2_id,samp%vert_coord_c2a)
   call samp%io_c2%fld_read(mpl,ncid,smask_c2_id,samp%smask_c2a)

   ! Release memory
   deallocate(lev_c2)
   deallocate(c2_on_file_to_proc)
   deallocate(c2_to_c0a)
   deallocate(gmask_c2)
else
   ! Initialization
   samp%nc2a = 0
end if

! Close file
call close_file(mpl,ncid)

! Probe out
@:probe_out()

end subroutine samp_read_global

!----------------------------------------------------------------------
! Subroutine: samp_write_global
!> Write (global)
!----------------------------------------------------------------------
subroutine samp_write_global(samp,mpl,nam,geom)

implicit none

! Passed variables
class(samp_type),intent(inout) :: samp !< Sampling
type(mpl_type),intent(inout) :: mpl    !< MPI data
type(nam_type),intent(in) :: nam       !< Namelist
type(geom_type),intent(in) :: geom     !< Geometry

! Local variables
integer :: ncid,nc1_id,nl0_id,nc3_id,nc4_id,nc2_id,lon_c1_id,lat_c1_id,vert_coord_c1_id,smask_c1_id,lon_c3_id,lat_c3_id,smask_c3_id
integer :: lon_c2_id,lat_c2_id,vert_coord_c2_id,smask_c2_id

! Set name
@:set_name(samp_write_global)

! Probe in
@:probe_in()

! Open file
ncid = create_file(mpl,nam%fname_samp)

! Define dimensions
if (samp%sc1) nc1_id = define_dim(mpl,ncid,'nc1',samp%nc1)
nl0_id = define_dim(mpl,ncid,'nl0',geom%nl0)
if (samp%sc3) then
   nc3_id = define_dim(mpl,ncid,'nc3',nam%nc3)
   nc4_id = define_dim(mpl,ncid,'nc4',nam%nc4)
end if
if (samp%sc2) nc2_id = define_dim(mpl,ncid,'nc2',samp%nc2)

! Define variables
if (samp%sc1) then
   lon_c1_id = define_var(mpl,ncid,'lon_c1','real',(/nc1_id/))
   lat_c1_id = define_var(mpl,ncid,'lat_c1','real',(/nc1_id/))
   vert_coord_c1_id = define_var(mpl,ncid,'vert_coord_c1','real',(/nc1_id,nl0_id/))
   smask_c1_id = define_var(mpl,ncid,'smask_c1','logical',(/nc1_id,nl0_id/))
end if
if (samp%sc3) then
   lon_c3_id = define_var(mpl,ncid,'lon_c3','real',(/nc1_id,nc3_id,nc4_id/))
   lat_c3_id = define_var(mpl,ncid,'lat_c3','real',(/nc1_id,nc3_id,nc4_id/))
   smask_c3_id = define_var(mpl,ncid,'smask_c3','logical',(/nc1_id,nc3_id,nc4_id,nl0_id/))
end if
if (samp%sc2) then
   lon_c2_id = define_var(mpl,ncid,'lon_c2','real',(/nc2_id/))
   lat_c2_id = define_var(mpl,ncid,'lat_c2','real',(/nc2_id/))
   vert_coord_c2_id = define_var(mpl,ncid,'vert_coord_c2','real',(/nc2_id,nl0_id/))
   smask_c2_id = define_var(mpl,ncid,'smask_c2','logical',(/nc2_id,nl0_id/))
end if

! Put attributes
if (samp%sc2) call put_att(mpl,ncid,0,'lat_bands',samp%lat_bands)

! Write variables
if (samp%sc1) then
   call samp%io_c1%fld_write(mpl,ncid,lon_c1_id,samp%lon_c1a)
   call samp%io_c1%fld_write(mpl,ncid,lat_c1_id,samp%lat_c1a)
   call samp%io_c1%fld_write(mpl,ncid,vert_coord_c1_id,samp%vert_coord_c1a)
   call samp%io_c1%fld_write(mpl,ncid,smask_c1_id,samp%smask_c1a)
end if
if (samp%sc3) then
   call samp%io_c1%fld_write(mpl,ncid,lon_c3_id,samp%lon_c3a)
   call samp%io_c1%fld_write(mpl,ncid,lat_c3_id,samp%lat_c3a)
   call samp%io_c1%fld_write(mpl,ncid,smask_c3_id,samp%smask_c3a)
end if
if (samp%sc2) then
   call samp%io_c2%fld_write(mpl,ncid,lon_c2_id,samp%lon_c2a)
   call samp%io_c2%fld_write(mpl,ncid,lat_c2_id,samp%lat_c2a)
   call samp%io_c2%fld_write(mpl,ncid,vert_coord_c2_id,samp%vert_coord_c2a)
   call samp%io_c2%fld_write(mpl,ncid,smask_c2_id,samp%smask_c2a)
end if

! Close file
call close_file(mpl,ncid)

! Probe out
@:probe_out()

end subroutine samp_write_global

!----------------------------------------------------------------------
! Subroutine: samp_write_grids
!> Write
!----------------------------------------------------------------------
subroutine samp_write_grids(samp,mpl,nam,geom)

implicit none

! Passed variables
class(samp_type),intent(in) :: samp !< Sampling
type(mpl_type),intent(inout) :: mpl !< MPI data
type(nam_type),intent(in) :: nam    !< Namelist
type(geom_type),intent(in) :: geom  !< Geometry

! Local variables
integer :: il0,jc3,jc4,ic1a,ic2u,ic2a,ic2b,jc1u,jc1d,jc1e,ic0a,j,nc1max
integer :: ncid,nl0_id,nc1a_id,nc3_id,nc4_id,nc2a_id,nc2b_id,nc1max_id
integer :: lon_id,lat_id,lon_local_id,lat_local_id,lon_vbal_id,lat_vbal_id
integer :: igmask_c0a(geom%nc0a,geom%nl0)
real(kind_real),allocatable :: lon(:,:,:,:),lat(:,:,:,:)
real(kind_real),allocatable :: lon_local(:,:,:),lat_local(:,:,:)
real(kind_real),allocatable :: lon_vbal(:,:,:),lat_vbal(:,:,:)

! Set name
@:set_name(samp_write_grids)

! Probe in
@:probe_in()

! Open file
ncid = create_file(mpl,trim(nam%prefix)//'sampling_grids',mpl%myproc,io_override=.true.)

! Define dimensions
nl0_id = define_dim(mpl,ncid,'nl0',geom%nl0,io_override=.true.)
if (samp%sc3) then
   nc3_id = define_dim(mpl,ncid,'nc3',nam%nc3,io_override=.true.)
   nc4_id = define_dim(mpl,ncid,'nc4',nam%nc4,io_override=.true.)
   nc1a_id = define_dim(mpl,ncid,'nc1a',samp%nc1a,io_override=.true.)
end if
if (samp%sc1.and.nam%new_hdiag.and.nam%local_diag) then
   nc1max = 0
   do ic2a=1,samp%nc2a
      nc1max = max(zss_count(samp%local_mask(:,ic2a)),nc1max)
   end do
   call mpl%f_comm%allreduce(nc1max,fckit_mpi_sum())
   nc1max = nc1max+1
   nc1max_id = define_dim(mpl,ncid,'nc1max',nc1max,io_override=.true.)
   nc2a_id = define_dim(mpl,ncid,'nc2a',samp%nc2a,io_override=.true.)
end if
if (samp%sc1.and.nam%new_vbal) then
   nc1max = 0
   do ic2b=1,samp%nc2b
      nc1max = max(zss_count(samp%vbal_mask(:,ic2b)),nc1max)
   end do
   call mpl%f_comm%allreduce(nc1max,fckit_mpi_sum())
   nc1max = nc1max+1
   nc1max_id = define_dim(mpl,ncid,'nc1max',nc1max,io_override=.true.)
   nc2b_id = define_dim(mpl,ncid,'nc2b',samp%nc2b,io_override=.true.)
end if

! Define variables
if (samp%sc3) then
   lon_id = define_var(mpl,ncid,'lon','real',(/nc1a_id,nc3_id,nc4_id,nl0_id/),'degrees_east',io_override=.true.)
   lat_id = define_var(mpl,ncid,'lat','real',(/nc1a_id,nc3_id,nc4_id,nl0_id/),'degrees_north',io_override=.true.)
end if
if (samp%sc1.and.nam%new_hdiag.and.nam%local_diag) then
   lon_local_id = define_var(mpl,ncid,'lon_local','real',(/nc1max_id,nc2a_id,nl0_id/),'degrees_east',io_override=.true.)
   lat_local_id = define_var(mpl,ncid,'lat_local','real',(/nc1max_id,nc2a_id,nl0_id/),'degrees_north',io_override=.true.)
end if
if (samp%sc1.and.nam%new_vbal) then
   lon_vbal_id = define_var(mpl,ncid,'lon_vbal','real',(/nc1max_id,nc2b_id,nl0_id/),'degrees_east',io_override=.true.)
   lat_vbal_id = define_var(mpl,ncid,'lat_vbal','real',(/nc1max_id,nc2b_id,nl0_id/),'degrees_north',io_override=.true.)
end if

! Convert data
do il0=1,geom%nl0
   do ic0a=1,geom%nc0a
      if (geom%gmask_c0a(ic0a,il0)) then
         igmask_c0a(ic0a,il0) = 1
      else
         igmask_c0a(ic0a,il0) = 0
      end if
   end do
end do
if (samp%sc3) then
   ! Allocation
   allocate(lon(samp%nc1a,nam%nc3,nam%nc4,geom%nl0))
   allocate(lat(samp%nc1a,nam%nc3,nam%nc4,geom%nl0))

   ! Distant points
   lon = mpl%msv%valr
   lat = mpl%msv%valr
   do il0=1,geom%nl0
      do jc4=1,nam%nc4
         do jc3=1,nam%nc3
            do ic1a=1,samp%nc1a
               if (samp%smask_c3a(ic1a,jc3,jc4,il0)) then
                  lon(ic1a,jc3,jc4,il0) = samp%lon_c3a(ic1a,jc3,jc4)*rad2deg
                  lat(ic1a,jc3,jc4,il0) = samp%lat_c3a(ic1a,jc3,jc4)*rad2deg
               end if
            end do
         end do
      end do
   end do
end if
if (samp%sc1.and.nam%new_hdiag.and.nam%local_diag) then
   ! Allocation
   allocate(lon_local(nc1max,samp%nc2a,geom%nl0))
   allocate(lat_local(nc1max,samp%nc2a,geom%nl0))

   ! Initialization
   lon_local = mpl%msv%valr
   lat_local = mpl%msv%valr

   ! Fill valid points
   do il0=1,geom%nl0
      do ic2a=1,samp%nc2a
         if (samp%smask_c2a(ic2a,il0)) then
            j = 1
            lon_local(j,ic2a,il0) = samp%lon_c2a(ic2a)*rad2deg
            lat_local(j,ic2a,il0) = samp%lat_c2a(ic2a)*rad2deg
            do jc1d=1,samp%nc1d
               jc1u = samp%c1d_to_c1u(jc1d)
               if (samp%local_mask(jc1u,ic2a).and.samp%smask_c1u(jc1u,il0)) then
                  j = j+1
                  lon_local(j,ic2a,il0) = samp%lon_c1u(jc1u)*rad2deg
                  lat_local(j,ic2a,il0) = samp%lat_c1u(jc1u)*rad2deg
               end if
            end do
         end if
      end do
   end do
end if
if (samp%sc1.and.nam%new_vbal) then
   ! Allocation
   allocate(lon_vbal(nc1max,samp%nc2b,geom%nl0))
   allocate(lat_vbal(nc1max,samp%nc2b,geom%nl0))

   ! Initialization
   lon_vbal = mpl%msv%valr
   lat_vbal = mpl%msv%valr

   ! Fill valid points
   do il0=1,geom%nl0
      do ic2b=1,samp%nc2b
         ic2u = samp%c2b_to_c2u(ic2b)
         if (samp%smask_c2u(ic2u,il0)) then
            j = 1
            lon_vbal(j,ic2b,il0) = samp%lon_c2u(ic2u)*rad2deg
            lat_vbal(j,ic2b,il0) = samp%lat_c2u(ic2u)*rad2deg
            do jc1e=1,samp%nc1e
               jc1u = samp%c1e_to_c1u(jc1e)
               if (samp%vbal_mask(jc1u,ic2b).and.samp%smask_c1u(jc1u,il0)) then
                  j = j+1
                  lon_vbal(j,ic2b,il0) = samp%lon_c1u(jc1u)*rad2deg
                  lat_vbal(j,ic2b,il0) = samp%lat_c1u(jc1u)*rad2deg
               end if
            end do
         end if
      end do
   end do
end if

! Write variables
if (samp%sc3) then
   call put_var(mpl,ncid,lon_id,lon,io_override=.true.)
   call put_var(mpl,ncid,lat_id,lat,io_override=.true.)
end if
if (samp%sc1.and.nam%new_hdiag.and.nam%local_diag) then
   call put_var(mpl,ncid,lon_local_id,lon_local,io_override=.true.)
   call put_var(mpl,ncid,lat_local_id,lat_local,io_override=.true.)
end if
if (samp%sc1.and.nam%new_vbal) then
   call put_var(mpl,ncid,lon_vbal_id,lon_vbal,io_override=.true.)
   call put_var(mpl,ncid,lat_vbal_id,lat_vbal,io_override=.true.)
end if

! Close file
call close_file(mpl,ncid,io_override=.true.)

! Release memory
if (samp%sc3) then
   deallocate(lon)
   deallocate(lat)
end if
if (samp%sc1.and.nam%new_hdiag.and.nam%local_diag) then
   deallocate(lon_local)
   deallocate(lat_local)
end if
if (samp%sc1.and.nam%new_vbal) then
   deallocate(lon_vbal)
   deallocate(lat_vbal)
end if

! Probe out
@:probe_out()

end subroutine samp_write_grids

!----------------------------------------------------------------------
! Subroutine: samp_send
!> Send
!----------------------------------------------------------------------
subroutine samp_send(samp,mpl,nam,geom,iproc)

implicit none

! Passed variables
class(samp_type),intent(in) :: samp !< Sampling
type(mpl_type),intent(inout) :: mpl !< MPI data
type(nam_type),intent(in) :: nam    !< Namelist
type(geom_type),intent(in) :: geom  !< Geometry
integer,intent(in) :: iproc         !< Destination task

! Local variables
integer :: nbufi,nbufr,nbufl,ibufi,ibufr,ibufl,bufs(3)
integer,allocatable :: bufi(:)
real(kind_real),allocatable :: bufr(:)
logical,allocatable :: bufl(:)

! Set name
@:set_name(samp_send)

! Probe in
@:probe_in()

! Initialization
nbufi = 0
nbufr = 0
nbufl = 0

! sc1, sc2 and sc3
nbufl = nbufl+3

! nc1a
nbufi = nbufi+1

if (samp%sc1) then
   ! lon_c1a
   nbufr = nbufr+samp%nc1a

   ! lat_c1a
   nbufr = nbufr+samp%nc1a

   ! vert_coord_c1a
   nbufr = nbufr+samp%nc1a*geom%nl0

   ! smask_c1a
   nbufl = nbufl+samp%nc1a*geom%nl0

   if (samp%sc3) then
      ! lon_c3a
      nbufr = nbufr+samp%nc1a*nam%nc3*nam%nc4

      ! lat_c3a
      nbufr = nbufr+samp%nc1a*nam%nc3*nam%nc4

      ! smask_c3a
      nbufl = nbufl+samp%nc1a*nam%nc3*nam%nc4*geom%nl0
   end if

   ! c1a_to_c1
   nbufi = nbufi+samp%nc1a
end if

! nc2a
nbufi = nbufi+1
      
if (samp%sc2) then
   ! lat_bands
   nbufl = nbufl+1

   ! lon_c2a
   nbufr = nbufr+samp%nc2a

   ! lon_c2a
   nbufr = nbufr+samp%nc2a

   ! vert_coord_c2a
   nbufr = nbufr+samp%nc2a*geom%nl0

   ! smask_c2a
   nbufl = nbufl+samp%nc2a*geom%nl0

   ! c2a_to_c2
   nbufi = nbufi+samp%nc2a
end if

! Allocation
allocate(bufi(nbufi))
allocate(bufr(nbufr))
allocate(bufl(nbufl))

! Initialization
ibufi = 0
ibufr = 0
ibufl = 0

! sc1, sc2 and sc3
bufl(ibufl+1) = samp%sc1
ibufl = ibufl+1
bufl(ibufl+1) = samp%sc2
ibufl = ibufl+1
bufl(ibufl+1) = samp%sc3
ibufl = ibufl+1

! nc1a
bufi(ibufi+1) = samp%nc1a
ibufi = ibufi+1

if (samp%sc1) then
   ! lon_c1a
   bufr(ibufr+1:ibufr+samp%nc1a) = samp%lon_c1a
   ibufr = ibufr+samp%nc1a

   ! lat_c1a
   bufr(ibufr+1:ibufr+samp%nc1a) = samp%lat_c1a
   ibufr = ibufr+samp%nc1a

   ! vert_coord_c1a
   bufr(ibufr+1:ibufr+samp%nc1a*geom%nl0) = reshape(samp%vert_coord_c1a,(/samp%nc1a*geom%nl0/))
   ibufr = ibufr+samp%nc1a*geom%nl0

   ! smask_c1a
   bufl(ibufl+1:ibufl+samp%nc1a*geom%nl0) = reshape(samp%smask_c1a,(/samp%nc1a*geom%nl0/))
   ibufl = ibufl+samp%nc1a*geom%nl0

   if (samp%sc3) then
      ! lon_c3a
      bufr(ibufr+1:ibufr+samp%nc1a*nam%nc3*nam%nc4) = reshape(samp%lon_c3a,(/samp%nc1a*nam%nc3*nam%nc4/))
      ibufr = ibufr+samp%nc1a*nam%nc3*nam%nc4

      ! lat_c3a
      bufr(ibufr+1:ibufr+samp%nc1a*nam%nc3*nam%nc4) = reshape(samp%lat_c3a,(/samp%nc1a*nam%nc3*nam%nc4/))
      ibufr = ibufr+samp%nc1a*nam%nc3*nam%nc4

      ! smask_c3a
      bufl(ibufl+1:ibufl+samp%nc1a*nam%nc3*nam%nc4*geom%nl0) = reshape(samp%smask_c3a,(/samp%nc1a*nam%nc3*nam%nc4*geom%nl0/))
      ibufl = ibufl+samp%nc1a*nam%nc3*nam%nc4*geom%nl0
   end if

   ! c1a_to_c1
   bufi(ibufi+1:ibufi+samp%nc1a) = samp%c1a_to_c1
   ibufi = ibufi+samp%nc1a
end if

! nc2a
bufi(ibufi+1) = samp%nc2a
ibufi = ibufi+1
      
if (samp%sc2) then
   ! lat_bands
   bufl(ibufl+1) = samp%lat_bands
   ibufl = ibufl+1

   ! lon_c2a
   bufr(ibufr+1:ibufr+samp%nc2a) = samp%lon_c2a
   ibufr = ibufr+samp%nc2a

   ! lat_c2a
   bufr(ibufr+1:ibufr+samp%nc2a) = samp%lat_c2a
   ibufr = ibufr+samp%nc2a

   ! vert_coord_c2a
   bufr(ibufr+1:ibufr+samp%nc2a*geom%nl0) = reshape(samp%vert_coord_c2a,(/samp%nc2a*geom%nl0/))
   ibufr = ibufr+samp%nc2a*geom%nl0

   ! smask_c2a
   bufl(ibufl+1:ibufl+samp%nc2a*geom%nl0) = reshape(samp%smask_c2a,(/samp%nc2a*geom%nl0/))
   ibufl = ibufl+samp%nc2a*geom%nl0

   ! c2a_to_c2
   bufi(ibufi+1:ibufi+samp%nc2a) = samp%c2a_to_c2
   ibufi = ibufi+samp%nc2a
end if

! Check sizes
if (ibufi/=nbufi) call mpl%abort('${subr}$','wrong final index ibufi')
if (ibufr/=nbufr) call mpl%abort('${subr}$','wrong final index ibufr')
if (ibufl/=nbufl) call mpl%abort('${subr}$','wrong final index ibufl')

! Send buffer size
bufs = (/nbufi,nbufr,nbufl/)
call mpl%f_comm%send(bufs,iproc-1,mpl%tag)

! Send data
call mpl%f_comm%send(bufi,iproc-1,mpl%tag+1)
call mpl%f_comm%send(bufr,iproc-1,mpl%tag+2)
call mpl%f_comm%send(bufl,iproc-1,mpl%tag+3)

! Release memory
deallocate(bufi)
deallocate(bufr)
deallocate(bufl)

! Probe out
@:probe_out()

end subroutine samp_send

!----------------------------------------------------------------------
! Subroutine: samp_receive
!> Receive
!----------------------------------------------------------------------
subroutine samp_receive(samp,mpl,nam,geom,iproc)

implicit none

! Passed variables
class(samp_type),intent(inout) :: samp !< Sampling
type(mpl_type),intent(inout) :: mpl    !< MPI data
type(nam_type),intent(in) :: nam       !< Namelist
type(geom_type),intent(in) :: geom     !< Geometry
integer,intent(in) :: iproc            !< Source task

! Local variables
integer :: nbufi,nbufr,nbufl,ibufi,ibufr,ibufl,bufs(3)
integer,allocatable :: bufi(:)
real(kind_real),allocatable :: bufr(:)
logical,allocatable :: bufl(:)
type(fckit_mpi_status) :: status

! Set name
@:set_name(samp_receive)

! Probe in
@:probe_in()

! Receive buffer size
call mpl%f_comm%receive(bufs,iproc-1,mpl%tag,status)
nbufi = bufs(1)
nbufr = bufs(2)
nbufl = bufs(3)

! Allocation
allocate(bufi(nbufi))
allocate(bufr(nbufr))
allocate(bufl(nbufl))

! Receive data
call mpl%f_comm%receive(bufi,iproc-1,mpl%tag+1,status)
call mpl%f_comm%receive(bufr,iproc-1,mpl%tag+2,status)
call mpl%f_comm%receive(bufl,iproc-1,mpl%tag+3,status)

! Initialization
ibufi = 0
ibufr = 0
ibufl = 0

! sc1, sc2 and sc3
samp%sc1 = bufl(ibufl+1)
ibufl = ibufl+1
samp%sc2 = bufl(ibufl+1)
ibufl = ibufl+1
samp%sc3 = bufl(ibufl+1)
ibufl = ibufl+1

! nc1a
samp%nc1a = bufi(ibufi+1)
ibufi = ibufi+1

if (samp%sc1) then
   ! lon_c1a
   allocate(samp%lon_c1a(samp%nc1a))
   samp%lon_c1a = bufr(ibufr+1:ibufr+samp%nc1a)
   ibufr = ibufr+samp%nc1a

   ! lat_c1a
   allocate(samp%lat_c1a(samp%nc1a))
   samp%lat_c1a = bufr(ibufr+1:ibufr+samp%nc1a)
   ibufr = ibufr+samp%nc1a

   ! vert_coord_c1a
   allocate(samp%vert_coord_c1a(samp%nc1a,geom%nl0))
   samp%vert_coord_c1a = reshape(bufr(ibufr+1:ibufr+samp%nc1a*geom%nl0),(/samp%nc1a,geom%nl0/))
   ibufr = ibufr+samp%nc1a*geom%nl0

   ! smask_c1a
   allocate(samp%smask_c1a(samp%nc1a,geom%nl0))
   samp%smask_c1a = reshape(bufl(ibufl+1:ibufl+samp%nc1a*geom%nl0),(/samp%nc1a,geom%nl0/))
   ibufl = ibufl+samp%nc1a*geom%nl0

   if (samp%sc3) then
      ! lon_c3a
      allocate(samp%lon_c3a(samp%nc1a,nam%nc3,nam%nc4))
      samp%lon_c3a = reshape(bufr(ibufr+1:ibufr+samp%nc1a*nam%nc3*nam%nc4),(/samp%nc1a,nam%nc3,nam%nc4/))
      ibufr = ibufr+samp%nc1a*nam%nc3*nam%nc4

      ! lat_c3a
      allocate(samp%lat_c3a(samp%nc1a,nam%nc3,nam%nc4))
      samp%lat_c3a = reshape(bufr(ibufr+1:ibufr+samp%nc1a*nam%nc3*nam%nc4),(/samp%nc1a,nam%nc3,nam%nc4/))
      ibufr = ibufr+samp%nc1a*nam%nc3*nam%nc4

      ! smask_c3a
      allocate(samp%smask_c3a(samp%nc1a,nam%nc3,nam%nc4,geom%nl0))
      samp%smask_c3a = reshape(bufl(ibufl+1:ibufl+samp%nc1a*nam%nc3*nam%nc4*geom%nl0),(/samp%nc1a,nam%nc3,nam%nc4,geom%nl0/))
      ibufl = ibufl+samp%nc1a*nam%nc3*nam%nc4*geom%nl0
   end if

   ! c1a_to_c1
   allocate(samp%c1a_to_c1(samp%nc1a))
   samp%c1a_to_c1 = bufi(ibufi+1:ibufi+samp%nc1a)
   ibufi = ibufi+samp%nc1a
end if

! nc2a
samp%nc2a = bufi(ibufi+1)
ibufi = ibufi+1
      
if (samp%sc2) then
   ! lat_bands
   samp%lat_bands = bufl(ibufl+1)
   ibufl = ibufl+1

   ! lon_c2a
   allocate(samp%lon_c2a(samp%nc2a))
   samp%lon_c2a = bufr(ibufr+1:ibufr+samp%nc2a)
   ibufr = ibufr+samp%nc2a

   ! lat_c2a
   allocate(samp%lat_c2a(samp%nc2a))
   samp%lat_c2a = bufr(ibufr+1:ibufr+samp%nc2a)
   ibufr = ibufr+samp%nc2a

   ! vert_coord_c2a
   allocate(samp%vert_coord_c2a(samp%nc2a,geom%nl0))
   samp%vert_coord_c2a = reshape(bufr(ibufr+1:ibufr+samp%nc2a*geom%nl0),(/samp%nc2a,geom%nl0/))
   ibufr = ibufr+samp%nc2a*geom%nl0

   ! smask_c2a
   allocate(samp%smask_c2a(samp%nc2a,geom%nl0))
   samp%smask_c2a = reshape(bufl(ibufl+1:ibufl+samp%nc2a*geom%nl0),(/samp%nc2a,geom%nl0/))
   ibufl = ibufl+samp%nc2a*geom%nl0

   ! c2a_to_c2
   allocate(samp%c2a_to_c2(samp%nc2a))
   samp%c2a_to_c2 = bufi(ibufi+1:ibufi+samp%nc2a)
   ibufi = ibufi+samp%nc2a
end if

! Check sizes
if (ibufi/=nbufi) call mpl%abort('${subr}$','wrong final index ibufi')
if (ibufr/=nbufr) call mpl%abort('${subr}$','wrong final index ibufr')
if (ibufl/=nbufl) call mpl%abort('${subr}$','wrong final index ibufl')

! Release memory
deallocate(bufi)
deallocate(bufr)
deallocate(bufl)

! Probe out
@:probe_out()

end subroutine samp_receive

!----------------------------------------------------------------------
! Subroutine: samp_setup
!> Setup sampling
!----------------------------------------------------------------------
subroutine samp_setup(samp,mpl,rng,nam,geom,ens)

implicit none

! Passed variables
class(samp_type),intent(inout) :: samp       !< Sampling
type(mpl_type),intent(inout) :: mpl          !< MPI data
type(rng_type),intent(inout) :: rng          !< Random number generator
type(nam_type),intent(inout) :: nam          !< Namelist
type(geom_type),intent(in) :: geom           !< Geometry
type(ens_type),intent(inout),optional :: ens !< Ensemble

! Local variables
integer :: il0,jc3,jc4,ildwv,jldwv,ival,nc1_valid
real(kind_real),allocatable :: ldwv_to_lon(:),ldwv_to_lat(:)
logical :: valid
character(len=8) :: ivalformat
character(len=1024) :: color

! Set name
@:set_name(samp_setup)

! Probe in
@:probe_in()

! Allocation
call samp%alloc(mpl,nam,geom)

if (nam%load_samp_local) then
   ! Read local sampling
   write(mpl%info,'(a7,a)') '','Read local sampling'
   call mpl%flush
   call samp%read_local(mpl,nam,geom)

   if (samp%sc1) then
      ! Compute MPI distribution, subset Sc1, halo A and universe
      write(mpl%info,'(a7,a)') '','Compute MPI distribution, subset Sc1, halo A and universe'
      call mpl%flush
   end if
elseif (nam%load_samp_global) then
   ! Read global sampling
   write(mpl%info,'(a7,a)') '','Read global sampling'
   call mpl%flush
   call samp%read_global(mpl,nam,geom)

   if (samp%sc1) then
      ! Compute MPI distribution, subset Sc1, halo A and universe
      write(mpl%info,'(a7,a)') '','Compute MPI distribution, subset Sc1, halo A and universe'
      call mpl%flush
   end if
else
   ! Compute sampling mask
   if (present(ens)) then
      call samp%compute_mask(mpl,nam,geom,ens)
   else
      call samp%compute_mask(mpl,nam,geom)
   end if

   ! Compute nearest neighbors for local diagnostics output
   if (nam%nldwv>0) then
      write(mpl%info,'(a7,a)') '','Compute local diagnostics locations:'
      call mpl%flush

      ! Allocation
      allocate(samp%ldwv_to_proc(nam%nldwv))
      allocate(samp%ldwv_to_c0a(nam%nldwv))
      allocate(ldwv_to_lon(nam%nldwv))
      allocate(ldwv_to_lat(nam%nldwv))

      ! Initialization
      ldwv_to_lon = zero
      ldwv_to_lat = zero

      do ildwv=1,nam%nldwv
         ! Get index from lon/lat
         call geom%index_from_lonlat(mpl,nam%lon_ldwv(ildwv),nam%lat_ldwv(ildwv),0,samp%ldwv_to_proc(ildwv), &
 & samp%ldwv_to_c0a(ildwv),valid)
         if (valid) then
            if (samp%ldwv_to_proc(ildwv)==mpl%myproc) then
               ldwv_to_lon(ildwv) = geom%lon_c0a(samp%ldwv_to_c0a(ildwv))
               ldwv_to_lat(ildwv) = geom%lat_c0a(samp%ldwv_to_c0a(ildwv))
            end if
            call mpl%f_comm%broadcast(ldwv_to_lon(ildwv),samp%ldwv_to_proc(ildwv)-1)
            call mpl%f_comm%broadcast(ldwv_to_lat(ildwv),samp%ldwv_to_proc(ildwv)-1)
         else
            call mpl%abort('${subr}$','profile '//trim(nam%name_ldwv(ildwv))//' is masked or out of the domain')
         end if
      end do

      do ildwv=1,nam%nldwv
         ! Check redundancy
         do jldwv=1,ildwv-1
            if (eq(ldwv_to_lon(ildwv),ldwv_to_lon(jldwv)).and.eq(ldwv_to_lat(ildwv),ldwv_to_lat(jldwv))) &
 & call mpl%abort('${subr}$','profiles'//trim(nam%name_ldwv(ildwv))//' and '//trim(nam%name_ldwv(jldwv))// &
 & 'are located grid point')
         end do

         ! Print results
         write(mpl%test,'(a10,a,f6.1,a,f6.1)') '','Profile '//trim(nam%name_ldwv(ildwv))//' computed at lon/lat: ', &
 & ldwv_to_lon(ildwv)*rad2deg,' / ',ldwv_to_lat(ildwv)*rad2deg
         call mpl%flush
      end do

      ! Release memory
      deallocate(ldwv_to_lon)
      deallocate(ldwv_to_lat)
   end if

   if (samp%sc1) then
      ! Compute sampling, subset Sc1
      write(mpl%info,'(a7,a,i5,a)') '','Compute sampling, subset Sc1 (nc1 = ',nam%nc1,')'
      call mpl%flush
      call samp%compute_c1_or_c2(mpl,rng,nam,geom,1)
   else
      samp%nc1a = 0
   end if

   if (samp%sc2) then
      ! Compute sampling, subset Sc2
      write(mpl%info,'(a7,a,i5,a)') '','Compute sampling, subset Sc2 (nc2 = ',nam%nc2,')'
      call mpl%flush
      call samp%compute_c1_or_c2(mpl,rng,nam,geom,2)
   else
      samp%nc2a = 0
   end if

   if (samp%sc3) then
      ! Compute sampling, subset Sc3
      write(mpl%info,'(a7,a,i5,a,i5,a)') '','Compute sampling, subset Sc3 (nc3 = ',nam%nc3,' / nc4 = ',nam%nc4,')'
      call mpl%flush
      call samp%compute_c3(mpl,rng,nam,geom)

      ! Print results
      write(mpl%info,'(a7,a)') '','Sampling efficiency (%):'
      call mpl%flush
      write(mpl%info,'(a10,a,a,f10.2,a)') '','Class size: ',trim(mpl%aqua),nam%dc*reqkm,trim(mpl%black)//' km'
      call mpl%flush
      do il0=1,geom%nl0
         write(mpl%info,'(a10,a,i3,a)') '','Level ',il0,':'
         call mpl%flush
         do jc4=1,nam%nc4
            write(mpl%test,'(a13,f6.2,a10)') '',geom%as(jc4)*rad2deg,' deg.  ~> '
            call mpl%flush(newl=.false.)
            do jc3=1,nam%nc3
               nc1_valid = zss_count(samp%smask_c3a(:,jc3,jc4,il0))
               call mpl%f_comm%allreduce(nc1_valid,fckit_mpi_sum())
               ival = int(hundred*real(nc1_valid,kind_real)/real(samp%nc1,kind_real))
               if (ival==100) then
                  ivalformat = '(a,i3,a)'
               else
                  ivalformat = '(a,i2,a)'
               end if
               if (nc1_valid>=samp%nc1/2) then
                  ! Sucessful sampling
                  color = mpl%green
               else
                 ! Insufficient sampling
                 color = mpl%peach
               end if
               if (jc3==1) color = ' '//trim(color)
               write(mpl%test,ivalformat) trim(color),ival,trim(mpl%black)
               call mpl%flush(newl=.false.)
               if (jc3<nam%nc3) then
                  write(mpl%test,'(a)') '-'
                  call mpl%flush(newl=.false.)
               end if
            end do
            write(mpl%test,'(a)') ''
            call mpl%flush
         end do
      end do
   end if
end if

! Reset random seed if necessary
if (nam%default_seed) call rng%reseed(mpl)

! Probe out
@:probe_out()

end subroutine samp_setup

!----------------------------------------------------------------------
! Subroutine: samp_setup_mpi
!> Setup sampling MPI distribution
!----------------------------------------------------------------------
subroutine samp_setup_mpi(samp,mpl,rng,nam,geom)

implicit none

! Passed variables
class(samp_type),intent(inout) :: samp       !< Sampling
type(mpl_type),intent(inout) :: mpl          !< MPI data
type(rng_type),intent(inout) :: rng          !< Random number generator
type(nam_type),intent(inout) :: nam          !< Namelist
type(geom_type),intent(in) :: geom           !< Geometry

! Set name
@:set_name(samp_setup_mpi)

! Probe in
@:probe_in()

if (samp%sc1) then
   ! Compute MPI distribution, subset Sc1, halo A and universe
   write(mpl%info,'(a7,a)') '','Compute MPI distribution, subset Sc1, halo A and universe'
   call mpl%flush
   call samp%compute_mpi_c1au(mpl,rng,geom)
end if

if (samp%sc2) then
   ! Compute MPI distribution, subset Sc2, halo A and universe
   write(mpl%info,'(a7,a)') '','Compute MPI distribution, subset Sc2, halo A and universe'
   call mpl%flush
   call samp%compute_mpi_c2au(mpl,nam,geom)

   ! Compute MPI distribution, subset Sc2, halo B
   write(mpl%info,'(a7,a)') '','Compute MPI distribution, subset Sc2, halo B'
   call mpl%flush
   call samp%compute_mpi_c2b(mpl,rng,nam,geom)
end if

if (samp%sc1) then
   ! Compute MPI distribution, subset Sc0, halo B
   write(mpl%info,'(a7,a)') '','Compute MPI distribution, subset Sc0, halo B'
   call mpl%flush
   call samp%compute_mpi_c0b(mpl,nam,geom)
end if

if (samp%sc3) then
   ! Compute MPI distribution, subset Sc0, halo C
   write(mpl%info,'(a7,a)') '','Compute MPI distribution, subset Sc0, halo C'
   call mpl%flush
   call samp%compute_mpi_c0c(mpl,nam,geom)
end if

if (samp%sc1.and.nam%new_hdiag.and.nam%local_diag) then
   ! Compute MPI distribution, subset Sc1, halos D
   write(mpl%info,'(a7,a)') '','Compute MPI distribution, subset Sc1, halo D'
   call mpl%flush
   call samp%compute_mpi_d(mpl,nam,geom)
end if

if (samp%sc1.and.nam%new_vbal) then
   ! Compute MPI distribution, subset Sc1, halo E
   write(mpl%info,'(a7,a)') '','Compute MPI distribution, subset Sc1, halo E'
   call mpl%flush
   call samp%compute_mpi_e(mpl,nam)
end if

! Reset random seed if necessary
if (nam%default_seed) call rng%reseed(mpl)

! Probe out
@:probe_out()

end subroutine samp_setup_mpi

!----------------------------------------------------------------------
! Subroutine: samp_setup_write
!> Setup sampling writing
!----------------------------------------------------------------------
subroutine samp_setup_write(samp,mpl,nam,geom)

implicit none

! Passed variables
class(samp_type),intent(inout) :: samp !< Sampling
type(mpl_type),intent(inout) :: mpl    !< MPI data
type(nam_type),intent(inout) :: nam    !< Namelist
type(geom_type),intent(in) :: geom     !< Geometry

! Set name
@:set_name(samp_setup_write)

! Probe in
@:probe_in()

if (nam%write_samp_global) then
   if (samp%sc1.and.(.not.samp%io_c1%initialized)) then
      ! Setup global I/O for subset Sc1
      write(mpl%info,'(a7,a)') '','Setup global I/O for subset Sc1'
      call mpl%flush
      call samp%io_c1%init(mpl,10,'1',samp%nc1,samp%nc1a,samp%c1a_to_c1,samp%proc_to_c1_offset, &
 & lon_cxa=samp%lon_c1a,lat_cxa=samp%lat_c1a)
   end if

   if (samp%sc2.and.(.not.samp%io_c2%initialized)) then
      ! Setup global I/O for subset Sc2
      write(mpl%info,'(a7,a)') '','Setup global I/O for subset Sc2'
      call mpl%flush
      call samp%io_c2%init(mpl,10,'2',samp%nc2,samp%nc2a,samp%c2a_to_c2,samp%proc_to_c2_offset, &
 & lon_cxa=samp%lon_c2a,lat_cxa=samp%lat_c2a)
   end if
end if

if (nam%write_samp_local) then
   ! Write local sampling data
   write(mpl%info,'(a7,a)') '','Write local sampling data'
   call mpl%flush
   call samp%write_local(mpl,nam,geom)
end if

if (nam%write_samp_global) then
   ! Write global sampling data
   write(mpl%info,'(a7,a)') '','Write global sampling data'
   call mpl%flush
   call samp%write_global(mpl,nam,geom)
end if

if (nam%write_samp_grids) then
   ! Write sampling grids
   write(mpl%info,'(a7,a)') '','Write sampling grids'
   call mpl%flush
   call samp%write_grids(mpl,nam,geom)
end if

! Probe out
@:probe_out()

end subroutine samp_setup_write

!----------------------------------------------------------------------
! Subroutine: samp_compute_mask
!> Compute mask
!----------------------------------------------------------------------
subroutine samp_compute_mask(samp,mpl,nam,geom,ens)

implicit none

! Passed variables
class(samp_type),intent(inout) :: samp       !< Sampling
type(mpl_type),intent(inout) :: mpl          !< MPI data
type(nam_type),intent(in) :: nam             !< Namelist
type(geom_type),intent(in) :: geom           !< Geometry
type(ens_type),intent(inout),optional :: ens !< Ensemble

! Local variables
integer :: nsmask,ic0a,il0,ildwv,iv,imask,ncontig,ncontigmax,latmin,latmax
real(kind_real) :: dist
real(kind_real),allocatable :: m2(:,:,:)
logical :: valid
character(len=1024) :: mask_type

! Set name
@:set_name(samp_compute_mask)

! Probe in
@:probe_in()

! Allocation
allocate(samp%smask_c0a(geom%nc0a,geom%nl0))
allocate(samp%smask_c0u(geom%nc0u,geom%nl0))
allocate(samp%smask_hor_c0u(geom%nc0u))
allocate(samp%smask_hor_c0a(geom%nc0a))
allocate(samp%nc0_smask(0:geom%nl0))

! Copy geometry mask
write(mpl%info,'(a7,a)') '','Copy geometry mask'
call mpl%flush
samp%smask_c0a = geom%gmask_c0a

! Count extra masked points in sampling
nsmask = zss_count(geom%gmask_c0a.and..not.samp%smask_c0a)
call mpl%f_comm%allreduce(nsmask,fckit_mpi_sum())

if ((nsmask>0).or.(nam%nmask>0).or.(nam%ncontig_th>0)) then
   ! Compute sampling mask
   write(mpl%info,'(a7,a)') '','Compute sampling mask'
   call mpl%flush

   do imask=1,nam%nmask
      ! Get mask type
      mask_type = nam%mask_type(imask)
      write(mpl%info,'(a10,a,a)') '','Mask type:',trim(mask_type)
      call mpl%flush

      if (mask_type(1:3)=='lat') then
         ! Latitude band
         read(mask_type(4:6),'(i3)') latmin
         read(mask_type(7:9),'(i3)') latmax
         write(mpl%info,'(a13,a,i3,a,i3)') '','Latitude band between ',latmin,' and ',latmax
         call mpl%flush
         if (latmin>=latmax) call mpl%abort('${subr}$','latmin should be lower than latmax')
         do ic0a=1,geom%nc0a
            valid = (geom%lat_c0a(ic0a)>=real(latmin,kind_real)*deg2rad).and.(geom%lat_c0a(ic0a)<=real(latmax,kind_real)*deg2rad)
            do il0=1,geom%nl0
               samp%smask_c0a(ic0a,il0) = samp%smask_c0a(ic0a,il0).and.valid
            end do
         end do
      end if

      if (mask_type=='ldwv') then
         ! Disk around vertical diagnostic points
         write(mpl%info,'(a13,a,e10.3,a)') '','Disk of ',1.1_kind_real*nam%local_rad*reqkm,' km around vertical diagonstic points'
         call mpl%flush
         do ic0a=1,geom%nc0a
            valid = .false.
            do ildwv=1,nam%nldwv
               call sphere_dist(nam%lon_ldwv(ildwv),nam%lat_ldwv(ildwv),geom%lon_c0a(ic0a),geom%lat_c0a(ic0a),dist)
               valid = valid.or.(dist<1.1_kind_real*nam%local_rad)
            end do
            do il0=1,geom%nl0
               samp%smask_c0a(ic0a,il0) = samp%smask_c0a(ic0a,il0).and.valid
            end do
         end do
      end if

      if (mask_type=='stddev') then
         ! Standard-deviation threshold
         if (.not.present(ens)) call mpl%abort('${subr}$','ensemble required to define standard-devation mask')

         ! Allocation
         allocate(m2(geom%nc0a,geom%nl0,nam%nv))

         ! Compute variance and fourth-order moment
         call ens%compute_moments(mpl,nam,geom)

         ! Get variance on subset Sc0
         call ens%get_c0(mpl,nam,geom,'m2',0,m2)

         ! Check standard-deviation value
         write(mpl%info,'(a13,a,e10.3,a)') '','Variable '//trim(nam%mask_variable(imask))//': threshold ',nam%mask_th(imask), &
 & ' used as a '//trim(nam%mask_lu(imask))//' bound for standard-deviation'
         call mpl%flush
         do iv=1,nam%nv
            if (nam%variables(iv)==nam%mask_variable(imask)) then
               if (trim(nam%mask_lu(imask))=='lower') then
                  samp%smask_c0a = samp%smask_c0a.and.(m2(:,:,iv)>nam%mask_th(imask)**2)
               elseif (trim(nam%mask_lu(imask))=='upper') then
                  samp%smask_c0a = samp%smask_c0a.and.(m2(:,:,iv)<nam%mask_th(imask)**2)
               end if
            end if
         end do

         ! Release memory
         deallocate(m2)
      end if

      if (nam%mask_type(imask)=='input') then
         ! Input field threshold
         if (.not.allocated(samp%smask_input_c0a)) call mpl%abort('${subr}$', &
 & 'input parameter sampling_mask_field should be set for this mask_type')

         ! Check input field value
         write(mpl%info,'(a10,a,e10.3,a)') '','Variable '//trim(nam%mask_variable(imask))//': threshold ',nam%mask_th(imask), &
 & ' used as a '//trim(nam%mask_lu(imask))//' bound for input field'
         call mpl%flush
         do iv=1,nam%nv
            if (nam%variables(iv)==nam%mask_variable(imask)) then
               if (trim(nam%mask_lu(imask))=='lower') then
                  samp%smask_c0a = samp%smask_c0a.and.(samp%smask_input_c0a(:,:,iv)>nam%mask_th(imask)**2)
               elseif (trim(nam%mask_lu(imask))=='upper') then
                  samp%smask_c0a = samp%smask_c0a.and.(samp%smask_input_c0a(:,:,iv)<nam%mask_th(imask)**2)
               end if
            end if
         end do
      end if
   end do

   ! Check vertically contiguous points
   if (nam%ncontig_th>0) then
      write(mpl%info,'(a10,a,i3,a)') '','Mask restricted with at least ',min(nam%ncontig_th,geom%nl0), &
 &  ' vertically contiguous points'
      call mpl%flush
      do ic0a=1,geom%nc0a
         ncontig = 0
         ncontigmax = 0
         do il0=1,geom%nl0
            if (samp%smask_c0a(ic0a,il0)) then
               ncontig = ncontig+1
            else
               ncontig = 0
            end if
            if (ncontig>ncontigmax) ncontigmax = ncontig
         end do
         samp%smask_c0a(ic0a,:) = samp%smask_c0a(ic0a,:).and.(ncontigmax>=min(nam%ncontig_th,geom%nl0))
      end do
   end if
end if

! Halo extension
call geom%com_AU%ext(mpl,samp%smask_c0a,samp%smask_c0u)

! Related masks
if (geom%nc0a>0) samp%smask_hor_c0a = any(samp%smask_c0a,dim=2)
if (geom%nc0u>0) samp%smask_hor_c0u = any(samp%smask_c0u,dim=2)
samp%nc0_smask(0) = zss_count(samp%smask_hor_c0a)
do il0=1,geom%nl0
   samp%nc0_smask(il0) = zss_count(samp%smask_c0a(:,il0))
end do
call mpl%f_comm%allreduce(samp%nc0_smask,fckit_mpi_sum())

! Check mask size
if (samp%nc0_smask(0)==0) call mpl%abort('${subr}$','no more points in the sampling mask')

! Print results
write(mpl%info,'(a7,a)') '','Sampling valid points (% of domain mask):'
call mpl%flush
do il0=1,geom%nl0
   write(mpl%test,'(a10,a,i3,a,f5.1,a)') '','Level ',il0,' ~> ',hundred*real(samp%nc0_smask(il0),kind_real) &
 & /real(geom%nc0_gmask(il0),kind_real),'%'
   call mpl%flush
end do

! Probe out
@:probe_out()

end subroutine samp_compute_mask

!----------------------------------------------------------------------
! Subroutine: samp_compute_c1_or_c2
!> Compute sampling, subset Sc1 or Sc2
!----------------------------------------------------------------------
subroutine samp_compute_c1_or_c2(samp,mpl,rng,nam,geom,subset)

implicit none

! Passed variables
class(samp_type),intent(inout) :: samp !< Sampling
type(mpl_type),intent(inout) :: mpl    !< MPI data
type(rng_type),intent(inout) :: rng    !< Random number generator
type(nam_type),intent(inout) :: nam    !< Namelist
type(geom_type),intent(in) :: geom     !< Geometry
integer,intent(in) :: subset           !< Subset index (1 or 2)

! Local variables
integer :: ic0,ic0a,ic0u,icx,icxa,ildwv,iproc,nn_index(1),n,ix,iy,ncx,ncx_eff,ncxa
integer :: proc_to_ncxa(mpl%nproc),proc_to_cx_offset(mpl%nproc)
integer,allocatable :: cx_to_c0(:),cxa_to_cx(:)
real(kind_real) :: lonlat(2),latmin,latmax
real(kind_real),allocatable :: rh_c0a(:),lon_cxa(:),lat_cxa(:),vert_coord_cxa(:,:)
logical :: smask_hor_c0a(geom%nc0a),valid
logical,allocatable :: smask_cxa(:,:)
type(atlas_structuredgrid) :: agrid

! Set name
@:set_name(samp_compute_c1_or_c2)

! Probe in
@:probe_in()

! Initialize sampling mask
smask_hor_c0a = samp%smask_hor_c0a

! Copy ncx
if (subset==1) then
   ncx = nam%nc1
elseif (subset==2) then
   ncx = nam%nc2
else
   call mpl%abort('${subr}$','wrong subset index')
end if

if (samp%lat_bands.and.(subset==2)) then
   ! Latitude bands

   ! All points on root processor
   if (mpl%main) then
      ncxa = nam%nc2
   else
      ncxa = 0
   end if

   ! Allocation
   allocate(lon_cxa(ncxa))
   allocate(lat_cxa(ncxa))

   if (ncx==1) then
      ! Single point
      if (mpl%main) then
         lon_cxa(1) = zero
         lat_cxa(1) = zero
      end if
   else
      ! Latitude bounds
      latmin = zss_minval(geom%lat_c0a)
      latmax = zss_maxval(geom%lat_c0a)
      call mpl%f_comm%allreduce(latmin,fckit_mpi_min())
      call mpl%f_comm%allreduce(latmax,fckit_mpi_max())

      ! Regularly spaced points along zero meridian
      if (mpl%main) then
         do icxa=1,ncxa
            lon_cxa(icxa) = zero
            lat_cxa(icxa) = latmin+real(icxa-1,kind_real)/real(ncxa-1,kind_real)*(latmax-latmin)
         end do
      end if
   end if
else
   ! Initialize subsampling
   select case (trim(nam%samp_draw_type))
   case ('random')
      ! Check subsampling size
      if (ncx>samp%nc0_smask(0)) then
         ! Not enough points remaining in the sampling mask
         call mpl%warning('${subr}$','not enough points remaining in sampling mask, resetting ncx to the largest possible value')
         ncx = samp%nc0_smask(0)
      end if

      if (subset==2) then
         ! Update sampling mask with local diagnostic points
         do ildwv=1,nam%nldwv
            iproc = samp%ldwv_to_proc(ildwv)
            if (iproc==mpl%myproc) then

               ic0a = samp%ldwv_to_c0a(ildwv)
               smask_hor_c0a(ic0a) = .false.
            end if
         end do
         ncx_eff = ncx-nam%nldwv
      else
         ! No local diagnostic points
         ncx_eff = ncx
      end if

      ! Allocation
      allocate(rh_c0a(geom%nc0a))
      allocate(cx_to_c0(ncx_eff))

      ! Initialization
      rh_c0a = one
      cx_to_c0 = mpl%msv%vali

      ! Compte subsampling
      write(mpl%info,'(a7,a,i1,a)') '','Compute horizontal subset Sc',subset,':'
      call mpl%flush
      call geom%initialize_sampling(mpl,rng,nam%sampling_method,geom%nc0a,geom%lon_c0a,geom%lat_c0a,smask_hor_c0a,rh_c0a, &
 & geom%c0a_to_c0,geom%nc0u,geom%c0u_to_c0a,geom%tree_c0u,geom%mesh_c0u,7,ncx_eff,cx_to_c0)

      ! Count Scx point in halo A
      ncxa = 0
      do icx=1,ncx_eff
         ic0 = cx_to_c0(icx)
         iproc = geom%c0_to_proc(ic0)
         if (iproc==mpl%myproc) ncxa = ncxa+1
      end do

      if (subset==2) then
         ! Count local diagnostic points
         do ildwv=1,nam%nldwv
            iproc = samp%ldwv_to_proc(ildwv)
            if (iproc==mpl%myproc) ncxa = ncxa+1
         end do
      end if

      ! Allocation
      allocate(lon_cxa(ncxa))
      allocate(lat_cxa(ncxa))

      ! Get lon/lat
      icxa = 0
      do icx=1,ncx_eff
         ic0 = cx_to_c0(icx)
         iproc = geom%c0_to_proc(ic0)
         if (iproc==mpl%myproc) then
            icxa = icxa+1
            ic0u = geom%c0_to_c0u(ic0)
            lon_cxa(icxa) = geom%lon_c0u(ic0u)
            lat_cxa(icxa) = geom%lat_c0u(ic0u)
         end if
      end do

      if (subset==2) then
         ! Insert local diagnostic points
         do ildwv=1,nam%nldwv
            iproc = samp%ldwv_to_proc(ildwv)
            if (iproc==mpl%myproc) then
               icxa = icxa+1
               ic0a = samp%ldwv_to_c0a(ildwv)
               lon_cxa(icxa) = geom%lon_c0a(ic0a)
               lat_cxa(icxa) = geom%lat_c0a(ic0a)
            end if
         end do
      end if

      ! Release memory
      deallocate(rh_c0a)
      deallocate(cx_to_c0)
   case ('octahedral')
      ! Use an octahedral grid
      write(mpl%info,'(a7,a,i1)') '','Use an octahedral grid for subset Sc',subset
      call mpl%flush

      ! Global grid
      n = int(real(ncx,kind_real)*four*pi/geom%area_max_c0)+1
      call get_grid(mpl,n,agrid)

      ! Count valid and local points
      ncxa = 0
      do iy=1,int(agrid%ny(),kind_int)
         do ix=1,int(agrid%nx(iy),kind_int)
            ! Get longitude/latitude
            lonlat = agrid%lonlat(ix,iy)*deg2rad
            call lonlatmod(lonlat(1),lonlat(2))

            ! Check if the point is inside the universe
            if (geom%mesh_c0u%n>0) then
               call inside(mpl,geom%mesh_c0u%vbnd,lonlat(1),lonlat(2),valid)
            else
               valid = .false.
            end if

            if (valid) then
               ! Find nearest neighbor in universe
               call geom%tree_c0u%find_nearest_neighbors(lonlat(1),lonlat(2),1,nn_index)

               ! Check mask
               ic0u = nn_index(1)
               if (geom%gmask_hor_c0u(ic0u)) then
                  ! Find processor
                  ic0 = geom%c0u_to_c0(ic0u)
                  iproc = geom%c0_to_proc(ic0)

                  ! Increment number of local points
                  if (iproc==mpl%myproc) ncxa = ncxa+1
               end if
            end if
         end do
      end do

      ! Allocation
      allocate(lon_cxa(ncxa))
      allocate(lat_cxa(ncxa))

      ! Copy grid lon/lat
      icxa = 0
      do iy=1,int(agrid%ny(),kind_int)
         do ix=1,int(agrid%nx(iy),kind_int)
            ! Get longitude/latitude
            lonlat = agrid%lonlat(ix,iy)*deg2rad
            call lonlatmod(lonlat(1),lonlat(2))

            ! Check if the point is inside the universe
            if (geom%mesh_c0u%n>0) then
               call inside(mpl,geom%mesh_c0u%vbnd,lonlat(1),lonlat(2),valid)
            else
               valid = .false.
            end if

            if (valid) then
               ! Find nearest neighbor in universe
               call geom%tree_c0u%find_nearest_neighbors(lonlat(1),lonlat(2),1,nn_index)

               ! Check mask
               ic0u = nn_index(1)
               if (geom%gmask_hor_c0u(ic0u)) then
                  ! Find processor
                  ic0 = geom%c0u_to_c0(ic0u)
                  iproc = geom%c0_to_proc(ic0)

                  if (iproc==mpl%myproc) then
                     ! Local index
                     icxa = icxa+1

                     ! Copy lon/lat
                     lon_cxa(icxa) = lonlat(1)
                     lat_cxa(icxa) = lonlat(2)
                  end if
               end if
            end if
         end do
      end do
   end select
end if

! Communication
call mpl%f_comm%allgather(ncxa,proc_to_ncxa)

! Subset Scx offset for halo A
proc_to_cx_offset(1) = 0
do iproc=2,mpl%nproc
   proc_to_cx_offset(iproc) = proc_to_cx_offset(iproc-1)+proc_to_ncxa(iproc-1)
end do

! Get subset Scx size
ncx = sum(proc_to_ncxa)

! Allocation
allocate(vert_coord_cxa(ncxa,geom%nl0))
allocate(smask_cxa(ncxa,geom%nl0))
allocate(cxa_to_cx(ncxa))

! Get vertical coordinate and sampling mask on nearest neighbor
do icxa=1,ncxa
   call geom%tree_c0u%find_nearest_neighbors(lon_cxa(icxa),lat_cxa(icxa),1,nn_index)
   ic0u = nn_index(1)
   vert_coord_cxa(icxa,:) = geom%vert_coord_c0u(ic0u,:)
   smask_cxa(icxa,:) = samp%smask_c0u(ic0u,:)
end do

! Conversion
do icx=1,ncx
   iproc = cx_to_proc(samp%nproc,proc_to_cx_offset,icx)
   if (iproc==mpl%myproc) then
      icxa = cx_to_cxa(samp%nproc,proc_to_cx_offset,icx)
      cxa_to_cx(icxa) = icx
   end if
end do

! Copy to Sc1 or Sc2 arrays
if (subset==1) then
   ! Allocation
   samp%nc1 = ncx
   samp%nc1a = ncxa
   allocate(samp%lon_c1a(samp%nc1a))
   allocate(samp%lat_c1a(samp%nc1a))
   allocate(samp%vert_coord_c1a(samp%nc1a,geom%nl0))
   allocate(samp%smask_c1a(samp%nc1a,geom%nl0))
   allocate(samp%c1a_to_c1(samp%nc1a))

   ! Copy
   samp%lon_c1a = lon_cxa
   samp%lat_c1a = lat_cxa
   samp%proc_to_nc1a = proc_to_ncxa
   samp%proc_to_c1_offset = proc_to_cx_offset
   samp%vert_coord_c1a = vert_coord_cxa
   samp%smask_c1a = smask_cxa
   samp%c1a_to_c1 = cxa_to_cx
elseif (subset==2) then
   ! Allocation
   samp%nc2 = ncx
   samp%nc2a = ncxa
   allocate(samp%lon_c2a(samp%nc2a))
   allocate(samp%lat_c2a(samp%nc2a))
   allocate(samp%vert_coord_c2a(samp%nc2a,geom%nl0))
   allocate(samp%smask_c2a(samp%nc2a,geom%nl0))
   allocate(samp%c2a_to_c2(samp%nc2a))

   ! Copy
   samp%lon_c2a = lon_cxa
   samp%lat_c2a = lat_cxa
   samp%proc_to_nc2a = proc_to_ncxa
   samp%proc_to_c2_offset = proc_to_cx_offset
   samp%vert_coord_c2a = vert_coord_cxa
   samp%smask_c2a = smask_cxa
   samp%c2a_to_c2 = cxa_to_cx
end if

! Release memory
deallocate(lon_cxa)
deallocate(lat_cxa)
deallocate(vert_coord_cxa)
deallocate(smask_cxa)
deallocate(cxa_to_cx)

! Probe out
@:probe_out()

end subroutine samp_compute_c1_or_c2

!----------------------------------------------------------------------
! Subroutine: samp_compute_c3
!> Compute sampling, subset Sc3
!----------------------------------------------------------------------
subroutine samp_compute_c3(samp,mpl,rng,nam,geom)

implicit none

! Passed variables
class(samp_type),intent(inout) :: samp !< Sampling
type(mpl_type),intent(inout) :: mpl    !< MPI data
type(rng_type),intent(inout) :: rng    !< Random number generator
type(nam_type),intent(in) :: nam       !< Namelist
type(geom_type),intent(in) :: geom     !< Geometry

! Local variables
integer :: jc3,jc4,ic1a,ir,irtmp,jc0a,jc0u,jc0,il0,iproc
real(kind_real) :: a,d
logical :: done,proc_to_done(mpl%nproc),valid
logical,allocatable :: c3a_free(:,:,:)

! Set name
@:set_name(samp_compute_c3)

! Probe in
@:probe_in()

! Allocation
allocate(samp%lon_c3a(samp%nc1a,nam%nc3,nam%nc4))
allocate(samp%lat_c3a(samp%nc1a,nam%nc3,nam%nc4))
allocate(samp%smask_c3a(samp%nc1a,nam%nc3,nam%nc4,geom%nl0))

! Initialization
samp%lon_c3a = mpl%msv%valr
samp%lat_c3a = mpl%msv%valr
samp%smask_c3a = .false.

! First class
do ic1a=1,samp%nc1a
   samp%lon_c3a(ic1a,1,:) = samp%lon_c1a(ic1a)
   samp%lat_c3a(ic1a,1,:) = samp%lat_c1a(ic1a)
   do il0=1,geom%nl0
      samp%smask_c3a(ic1a,1,:,il0) = samp%smask_c1a(ic1a,il0)
   end do
end do

if ((nam%nc3>1).and.(nam%dc>0.0)) then
   ! Allocation
   allocate(c3a_free(samp%nc1a,nam%nc3,nam%nc4))

   ! Initialization
   c3a_free = .true.

   ! Resynchronize random number generator
   call rng%resync(mpl)

   ! Initialization
   write(mpl%info,'(a7,a)') '','Compute HDIAG pairs: '
   call mpl%flush(newl=.false.)
   call mpl%prog_init(nam%nc3*nam%nc4*samp%nc1a)
   do ic1a=1,samp%nc1a
      mpl%done((ic1a-1)*nam%nc3*nam%nc4+1) = .true.
   end do
   if (samp%nc1a>0) then
      done = all(mpl%done)
   else
      done = .true.
   end if
   call mpl%f_comm%allgather(done,proc_to_done)
   ir = 0

   ! Sample angular sectors and horizontal distance classes
   do while ((.not.all(proc_to_done)).and.(ir<=nam%irmax))
      ! Define a random geographical point
      call geom%rand_point(mpl,rng,0,iproc,jc0a,irtmp)
      ir = ir+irtmp

      if (samp%myuniverse(iproc)) then
         ! Indices
         jc0 = geom%proc_to_c0_offset(iproc)+jc0a
         jc0u = geom%c0_to_c0u(jc0)

         !$omp parallel do schedule(static) private(ic1a,a,jc4,d,jc3)
         do ic1a=1,samp%nc1a
            if (nam%nc4>1) then
               ! Compute the bearing
               call sphere_bearing(samp%lon_c1a(ic1a),samp%lat_c1a(ic1a),geom%lon_c0u(jc0u),geom%lat_c0u(jc0u),a)

               ! Reset bearing between -pi/2 and pi/2
               if (a<=-half*pi) a = a+pi
               if (a>=half*pi) a = a-pi

               ! Find the angular sector
               jc4 = floor((a+half*pi-half*geom%das)/geom%das)+2
               if (jc4==nam%nc4+1) jc4 = 1
               if ((jc4<1).or.(jc4>nam%nc4)) call mpl%abort('${subr}$','jc4 out of bounds')
            else
               ! Single angular sector
               jc4 = 1
            end if

            if (any(c3a_free(ic1a,:,jc4))) then
               ! Compute the distance
               call sphere_dist(samp%lon_c1a(ic1a),samp%lat_c1a(ic1a),geom%lon_c0u(jc0u),geom%lat_c0u(jc0u),d)

               ! Find the horizontal distance class
               if (d>half*nam%dc) then
                  ! Horizontal class distance index
                  jc3 = floor((d-half*nam%dc)/nam%dc)+2
                  if (jc3<1) call mpl%abort('${subr}$','jc3 is not positive')
                  if (jc3<=nam%nc3) then
                     ! Find if this class has not been already filled
                     if (c3a_free(ic1a,jc3,jc4)) then
                        samp%lon_c3a(ic1a,jc3,jc4) = geom%lon_c0u(jc0u)
                        samp%lat_c3a(ic1a,jc3,jc4) = geom%lat_c0u(jc0u)
                        samp%smask_c3a(ic1a,jc3,jc4,:) = samp%smask_c0u(jc0u,:)
                        c3a_free(ic1a,jc3,jc4) = .false.
                        mpl%done((ic1a-1)*nam%nc3*nam%nc4+(jc3-1)*nam%nc4+jc4) = .true.
                     end if
                  end if
               end if
            end if
         end do
         !$omp end parallel do

         ! Update
         call mpl%prog_print
      end if
      if (samp%nc1a>0) then
         done = all(mpl%done)
      else
         done = .true.
      end if
      call mpl%f_comm%allgather(done,proc_to_done)
   end do
   call mpl%prog_final

   ! Desynchronize random number generator
   call rng%desync(mpl)

   ! Release memory
   deallocate(c3a_free)
end if

! Check sampling mask
write(mpl%info,'(a7,a)') '','Check sampling mask: '
call mpl%flush(newl=.false.)
call mpl%prog_init(samp%nc1a)
do ic1a=1,samp%nc1a
   do il0=1,geom%nl0
      ! Check lon/lat/mask
      valid = mpl%msv%isnot(samp%lon_c1a(ic1a)).and.mpl%msv%isnot(samp%lat_c1a(ic1a)).and.samp%smask_c1a(ic1a,il0)

      if (valid) then
         do jc4=1,nam%nc4
            do jc3=1,nam%nc3
               ! Check lon/lat/mask
               valid = mpl%msv%isnot(samp%lon_c3a(ic1a,jc3,jc4)).and.mpl%msv%isnot(samp%lat_c3a(ic1a,jc3,jc4)).and. &
 & samp%smask_c3a(ic1a,jc3,jc4,il0)

               ! Check mask boundaries
               if (nam%mask_check) call geom%mesh_c0u%check_arc(mpl,samp%lon_c1a(ic1a),samp%lat_c1a(ic1a), &
 & samp%lon_c3a(ic1a,jc3,jc4),samp%lat_c3a(ic1a,jc3,jc4),il0,valid)

               ! Copy validity
               samp%smask_c3a(ic1a,jc3,jc4,il0) = valid
            end do
         end do
      else
         ! Copy validity
         samp%smask_c3a(ic1a,:,:,il0) = .false.
      end if
   end do

   ! Update
   call mpl%prog_print(ic1a)
end do
call mpl%prog_final

! Probe out
@:probe_out()

end subroutine samp_compute_c3

!----------------------------------------------------------------------
! Subroutine: samp_compute_mpi_c1au
!> Compute sampling MPI distribution, subset Sc1, halo A and U
!----------------------------------------------------------------------
subroutine samp_compute_mpi_c1au(samp,mpl,rng,geom)

implicit none

! Passed variables
class(samp_type),intent(inout) :: samp !< Sampling
type(mpl_type),intent(inout) :: mpl    !< MPI data
type(rng_type),intent(inout) :: rng    !< Random number generator
type(geom_type),intent(in) :: geom     !< Geometry

! Local variables
integer :: ic1,ic1a,ic1u,iproc

! Set name
@:set_name(samp_compute_mpi_c1au)

! Probe in
@:probe_in()

! Get subset Sc1 size on universe
samp%nc1u = sum(samp%proc_to_nc1a,mask=samp%myuniverse)

! Allocation
allocate(samp%c1a_to_c1u(samp%nc1a))
allocate(samp%c1u_to_c1a(samp%nc1u))
allocate(samp%c1u_to_c1(samp%nc1u))
allocate(samp%lon_c1u(samp%nc1u))
allocate(samp%lat_c1u(samp%nc1u))
allocate(samp%smask_c1u(samp%nc1u,geom%nl0))

! Conversions
samp%c1u_to_c1a = mpl%msv%vali
ic1u = 0
do ic1=1,samp%nc1
   iproc = samp%c1_to_proc(ic1)
   if (samp%myuniverse(iproc)) then
      ic1u = ic1u+1
      if (iproc==mpl%myproc) then
         ic1a = samp%c1_to_c1a(ic1)
         samp%c1a_to_c1u(ic1a) = ic1u
         samp%c1u_to_c1a(ic1u) = ic1a
      end if
      samp%c1u_to_c1(ic1u) = ic1
   end if
end do

! Setup subset Sc1 communication, local to universe
call samp%com_c1_AU%setup(mpl,'com_c1_AU',samp%nc1a,samp%nc1u,samp%nc1,samp%c1a_to_c1,samp%c1u_to_c1)

! Extend fields from halo A to universe on subset Sc1
call samp%com_c1_AU%ext(mpl,samp%lon_c1a,samp%lon_c1u)
call samp%com_c1_AU%ext(mpl,samp%lat_c1a,samp%lat_c1u)
call samp%com_c1_AU%ext(mpl,samp%smask_c1a,samp%smask_c1u)

if (samp%sc2) then
   ! Setup tree
   call samp%tree_c1u%alloc(mpl,samp%nc1u)
   call samp%tree_c1u%init(samp%lon_c1u,samp%lat_c1u)

   ! Setup mesh
   call samp%mesh_c1u%alloc(samp%nc1u)
   call samp%mesh_c1u%init(mpl,rng,samp%lon_c1u,samp%lat_c1u,hull_bnd=.true.)
end if

! Print results
write(mpl%test,'(a10,a,i8)') '','nc1 = ',samp%nc1
call mpl%flush
write(mpl%info,'(a10,a,i8)') '','nc1a = ',samp%nc1a
call mpl%flush
write(mpl%info,'(a10,a,i8)') '','nc1u = ',samp%nc1u
call mpl%flush

! Probe out
@:probe_out()

end subroutine samp_compute_mpi_c1au

!----------------------------------------------------------------------
! Subroutine: samp_compute_mpi_c2au
!> Compute sampling MPI distribution, halo A and universe, subset Sc2
!----------------------------------------------------------------------
subroutine samp_compute_mpi_c2au(samp,mpl,nam,geom)

implicit none

! Passed variables
class(samp_type),intent(inout) :: samp !< Sampling
type(mpl_type),intent(inout) :: mpl    !< MPI data
type(nam_type),intent(in) :: nam       !< Namelist
type(geom_type),intent(in) :: geom     !< Geometry

! Local variables
integer :: ic2,ic2a,ic2u,iproc,ildwv,ic0a,nn_index(1)
type(tree_type) :: tree

! Set name
@:set_name(samp_compute_mpi_c2au)

! Probe in
@:probe_in()

! Define universe
if (samp%lat_bands) then
   samp%myuniverse = .true.
else
   samp%myuniverse = samp%myuniverse
end if

! Get subset Sc2 size on universe
samp%nc2u = sum(samp%proc_to_nc2a,mask=samp%myuniverse)

! Allocation
allocate(samp%c2a_to_c2u(samp%nc2a))
allocate(samp%c2u_to_c2(samp%nc2u))
allocate(samp%lon_c2u(samp%nc2u))
allocate(samp%lat_c2u(samp%nc2u))
allocate(samp%smask_c2u(samp%nc2u,geom%nl0))

! Conversions
ic2u = 0
do ic2=1,samp%nc2
   iproc = samp%c2_to_proc(ic2)
   if (samp%myuniverse(iproc)) then
      ic2u = ic2u+1
      if (iproc==mpl%myproc) then
         ic2a = samp%c2_to_c2a(ic2)
         samp%c2a_to_c2u(ic2a) = ic2u
      end if
      samp%c2u_to_c2(ic2u) = ic2
   end if
end do

! Setup subset Sc2 communication, local to universe
call samp%com_c2_AU%setup(mpl,'com_c2_AU',samp%nc2a,samp%nc2u,samp%nc2,samp%c2a_to_c2,samp%c2u_to_c2)

! Extend fields from halo A to universe on subset Sc2
call samp%com_c2_AU%ext(mpl,samp%lon_c2a,samp%lon_c2u)
call samp%com_c2_AU%ext(mpl,samp%lat_c2a,samp%lat_c2u)
call samp%com_c2_AU%ext(mpl,samp%smask_c2a,samp%smask_c2u)

! Print results
write(mpl%test,'(a10,a,i8)') '','nc2 = ',samp%nc2
call mpl%flush
write(mpl%info,'(a10,a,i8)') '','nc2a = ',samp%nc2a
call mpl%flush
write(mpl%info,'(a10,a,i8)') '','nc2u = ',samp%nc2u
call mpl%flush

! Find nearest neighbors

! Allocation
allocate(samp%nn_c2a_index(samp%nc2u,samp%nc2a))
allocate(samp%nn_c2a_dist(samp%nc2u,samp%nc2a))
allocate(samp%ldwv_to_c2a(nam%nldwv))
call tree%alloc(mpl,samp%nc2u)

! Initialization
call tree%init(samp%lon_c2u,samp%lat_c2u)

! Find nearest neighbors
do ic2a=1,samp%nc2a
   call tree%find_nearest_neighbors(samp%lon_c2a(ic2a),samp%lat_c2a(ic2a),samp%nc2u,samp%nn_c2a_index(:,ic2a), &
 & samp%nn_c2a_dist(:,ic2a))
end do

do ildwv=1,nam%nldwv
   ! Initialization
   samp%ldwv_to_c2a(ildwv) = mpl%msv%vali

   ! Get subset Sc2 index
   iproc = samp%ldwv_to_proc(ildwv)
   if (iproc==mpl%myproc) then
      ic0a = samp%ldwv_to_c0a(ildwv)
      call tree%find_nearest_neighbors(geom%lon_c0a(ic0a),geom%lat_c0a(ic0a),1,nn_index)
      ic2u = nn_index(1)
      do ic2a=1,samp%nc2a
         if (samp%nn_c2a_index(1,ic2a)==ic2u) then
            samp%ldwv_to_c2a(ildwv) = ic2a
            exit
         end if
      end do
   end if
end do

! Release memory
call tree%dealloc

! Probe out
@:probe_out()

end subroutine samp_compute_mpi_c2au

!----------------------------------------------------------------------
! Subroutine: samp_compute_mpi_c2b
!> Compute sampling MPI distribution, halo B
!----------------------------------------------------------------------
subroutine samp_compute_mpi_c2b(samp,mpl,rng,nam,geom)

implicit none

! Passed variables
class(samp_type),intent(inout) :: samp !< Sampling
type(mpl_type),intent(inout) :: mpl    !< MPI data
type(rng_type),intent(inout) :: rng    !< Random number generator
type(nam_type),intent(in) :: nam       !< Namelist
type(geom_type),intent(in) :: geom     !< Geometry

! Local variables
integer :: ic2,ic2a,ic2b,ic2u,jc2,jc2u,i_s,il0i,il0,iproc,jproc
integer,allocatable :: c2b_to_c2(:),c2u_to_c2b(:)
real(kind_real),allocatable :: lon_c2(:),lat_c2(:),rh(:)
logical :: lcheck_c2b(samp%nc2u)
logical,allocatable :: smask_c2a(:,:),smask_c2(:,:),smask_hor_c2(:),smask_hor_c1a(:)
type(mesh_type) :: mesh_c2
type(tree_type) :: tree_c2

! Set name
@:set_name(samp_compute_mpi_c2b)

! Probe in
@:probe_in()

! Allocation
allocate(lon_c2(samp%nc2))
allocate(lat_c2(samp%nc2))
allocate(smask_c2a(samp%nc2a,geom%nl0i))
allocate(smask_c2(samp%nc2,geom%nl0i))
allocate(smask_hor_c2(samp%nc2))
if (.not.samp%lat_bands) then
   call mesh_c2%alloc(samp%nc2)
   call tree_c2%alloc(mpl,samp%nc2)
end if
allocate(samp%interp_c2b_to_c0a(geom%nl0i))
if (samp%compute_c2b_to_c1a) allocate(smask_hor_c1a(samp%nc1a))
if (nam%samp_interp_type=='si') allocate(rh(geom%nc0a))

! Initialization
do il0i=1,geom%nl0i
   il0 = geom%l0i_to_l0(il0i)
   smask_c2a(:,il0i) = samp%smask_c2a(:,il0)
end do

! Communication
call mpl%loc_to_glb(samp%nc2a,samp%nc2,samp%c2a_to_c2,samp%lon_c2a,lon_c2,.true.)
call mpl%loc_to_glb(samp%nc2a,samp%nc2,samp%c2a_to_c2,samp%lat_c2a,lat_c2,.true.)
call mpl%loc_to_glb(samp%nc2a,samp%nc2,samp%c2a_to_c2,smask_c2a,smask_c2,.true.)

! Initialization
do ic2=1,samp%nc2
   smask_hor_c2(ic2) = any(smask_c2(ic2,:))
end do
if (.not.samp%lat_bands) then
   call mesh_c2%init(mpl,rng,lon_c2,lat_c2)
   call tree_c2%init(lon_c2,lat_c2)
end if
if (samp%compute_c2b_to_c1a) smask_hor_c1a = .true.

! Compute interpolation
do il0i=1,geom%nl0i
   il0 = geom%l0i_to_l0(il0i)
   write(samp%interp_c2b_to_c0a(il0i)%prefix,'(a,i3.3)') 'interp_c2b_to_c0a_',il0i
   if (samp%lat_bands) then
      call samp%interp_c2b_to_c0a(il0i)%interp(mpl,samp%nc2,lat_c2,geom%nc0a,geom%lat_c0a,geom%gmask_c0a(:,il0),7)
   else
      select case (nam%samp_interp_type)
      case ('c0')
         call samp%interp_c2b_to_c0a(il0i)%interp(mpl,nam,il0,samp%nc2,lon_c2,lat_c2,smask_c2(:,il0i), &
 & mesh_c2,tree_c2,geom%nc0a,geom%lon_c0a,geom%lat_c0a,geom%gmask_c0a(:,il0),geom%mesh_c0u,7,.false.)
      case ('c1')
         call samp%interp_c2b_to_c0a(il0i)%interp(mpl,nam,il0,samp%nc2,lon_c2,lat_c2,smask_c2(:,il0i), &
 & mesh_c2,tree_c2,geom%nc0a,geom%lon_c0a,geom%lat_c0a,geom%gmask_c0a(:,il0),geom%mesh_c0u,7,.true.)
      case ('si')
         rh = nam%local_rad
         call samp%interp_c2b_to_c0a(il0i)%interp(mpl,nam,il0,samp%nc2,lon_c2,lat_c2,smask_c2(:,il0i), &
 & tree_c2,geom%nc0a,geom%lon_c0a,geom%lat_c0a,geom%gmask_c0a(:,il0),geom%mesh_c0u,7,rh)
      end select
   end if
end do

if (samp%compute_c2b_to_c1a) then
   samp%interp_c2b_to_c1a%prefix = 'interp_c2b_to_c1a'
   if (samp%lat_bands) then
      call samp%interp_c2b_to_c1a%interp(mpl,samp%nc2,lat_c2,samp%nc1a,samp%lat_c1a,smask_hor_c1a,7)
   else
      call samp%interp_c2b_to_c1a%interp(mpl,nam,0,samp%nc2,lon_c2,lat_c2,smask_hor_c2, &
 & mesh_c2,tree_c2,samp%nc1a,samp%lon_c1a,samp%lat_c1a,smask_hor_c1a,geom%mesh_c0u,7)
   end if
end if

! Release memory
deallocate(lon_c2)
deallocate(lat_c2)
deallocate(smask_c2a)
deallocate(smask_c2)
deallocate(smask_hor_c2)
if (.not.samp%lat_bands) then
   call mesh_c2%dealloc
   call tree_c2%dealloc
end if
if (nam%samp_interp_type=='si') deallocate(rh)

! Define halo B
lcheck_c2b = .false.
do ic2u=1,samp%nc2u
   ic2 = samp%c2u_to_c2(ic2u)
   iproc = samp%c2_to_proc(ic2)
   if (iproc==mpl%myproc) lcheck_c2b(ic2u) = .true.
end do
do il0i=1,geom%nl0i
   do i_s=1,samp%interp_c2b_to_c0a(il0i)%n_s
      jc2 = samp%interp_c2b_to_c0a(il0i)%col(i_s)
      jproc = samp%c2_to_proc(jc2)
      if (samp%myuniverse(jproc)) then
         jc2u = samp%c2_to_c2u(jc2)
         lcheck_c2b(jc2u) = .true.
      else
         call mpl%abort('${subr}$','point of halo B out of universe (increase universe_radius)')
      end if
   end do
end do
if (samp%compute_c2b_to_c1a) then
   do i_s=1,samp%interp_c2b_to_c1a%n_s
      jc2 = samp%interp_c2b_to_c1a%col(i_s)
      jproc = samp%c2_to_proc(jc2)
      if (samp%myuniverse(jproc)) then
         jc2u = samp%c2_to_c2u(jc2)
         lcheck_c2b(jc2u) = .true.
      else
         call mpl%abort('${subr}$','point of halo B out of universe (increase universe_radius)')
      end if
   end do
end if
samp%nc2b = zss_count(lcheck_c2b)

! Allocation
allocate(c2b_to_c2(samp%nc2b))
allocate(samp%c2a_to_c2b(samp%nc2a))
allocate(samp%c2b_to_c2u(samp%nc2b))
allocate(c2u_to_c2b(samp%nc2u))

! Global-local conversion for halo B
c2u_to_c2b = mpl%msv%vali
ic2b = 0
do ic2u=1,samp%nc2u
   if (lcheck_c2b(ic2u)) then
      ic2b = ic2b+1
      ic2 = samp%c2u_to_c2(ic2u)
      iproc = samp%c2_to_proc(ic2)
      if (iproc==mpl%myproc) then
         ic2a = samp%c2_to_c2a(ic2)
         samp%c2a_to_c2b(ic2a) = ic2b
      end if
      c2b_to_c2(ic2b) = ic2
      samp%c2b_to_c2u(ic2b) = ic2u
      c2u_to_c2b(ic2u) = ic2b
   end if
end do

! Local interpolation source
do il0i=1,geom%nl0i
   samp%interp_c2b_to_c0a(il0i)%n_src = samp%nc2b
   do i_s=1,samp%interp_c2b_to_c0a(il0i)%n_s
      ic2 = samp%interp_c2b_to_c0a(il0i)%col(i_s)
      ic2u = samp%c2_to_c2u(ic2)
      ic2b = c2u_to_c2b(ic2u)
      if (mpl%msv%isnot(ic2b)) then
         samp%interp_c2b_to_c0a(il0i)%col(i_s) = ic2b
      else
         call mpl%abort('${subr}$','wrong local source for interp_c2b_to_c0a')
      end if
   end do
end do
if (samp%compute_c2b_to_c1a) then
   samp%interp_c2b_to_c1a%n_src = samp%nc2b
   do i_s=1,samp%interp_c2b_to_c1a%n_s
      ic2 = samp%interp_c2b_to_c1a%col(i_s)
      ic2u = samp%c2_to_c2u(ic2)
      ic2b = c2u_to_c2b(ic2u)
      if (mpl%msv%isnot(ic2b)) then
         samp%interp_c2b_to_c1a%col(i_s) = c2u_to_c2b(ic2u)
      else
         call mpl%abort('${subr}$','wrong local source for interp_c2b_to_c1a')
      end if
   end do
end if

! Setup communications
call samp%com_c2_AB%setup(mpl,'com_c2_AB',samp%nc2a,samp%nc2b,samp%nc2,samp%c2a_to_c2,c2b_to_c2)

! Release memory
deallocate(c2b_to_c2)
deallocate(c2u_to_c2b)
if (samp%compute_c2b_to_c1a) deallocate(smask_hor_c1a)

! Print results
write(mpl%info,'(a10,a,i8)') '','nc2b = ',samp%nc2b
call mpl%flush
do il0i=1,geom%nl0i
   write(mpl%info,'(a10,a,i3,a,i8)') '','interp_c2b_to_c0a(',il0i,')%n_s = ',samp%interp_c2b_to_c0a(il0i)%n_s
   call mpl%flush
end do
if (samp%compute_c2b_to_c1a) then
   write(mpl%info,'(a10,a,i8)') '','interp_c2b_to_c1a%n_s = ',samp%interp_c2b_to_c1a%n_s
   call mpl%flush
end if

! Probe out
@:probe_out()

end subroutine samp_compute_mpi_c2b

!----------------------------------------------------------------------
! Subroutine: samp_compute_mpi_c0b
!> Compute MPI distribution, halo B, subset Sc0
!----------------------------------------------------------------------
subroutine samp_compute_mpi_c0b(samp,mpl,nam,geom)

implicit none

! Passed variables
class(samp_type),intent(inout) :: samp !< Sampling
type(mpl_type),intent(inout) :: mpl    !< MPI data
type(nam_type),intent(in) :: nam       !< Namelist
type(geom_type),intent(in) :: geom     !< Geometry

! Local variables
integer :: ic0u,iproc,ic0,ic0b,jc0u,i_s,il0,il0ic1,nc0own,ic0own
integer :: c0u_to_c0b(geom%nc0u)
integer,allocatable :: c0b_to_c0(:),c0own_to_c0(:)
logical :: lcheck_c0b(geom%nc0u)

! Set name
@:set_name(samp_compute_mpi_c0b)

! Probe in
@:probe_in()

! Allocation
allocate(samp%l0_to_l0ic1(geom%nl0))
allocate(samp%l0ic1_to_l0(geom%nl0))

! Compute independent levels
write(mpl%test,'(a10,a)') '','Independent levels: '
call mpl%flush(newl=.false.)
call independent_levels(mpl,samp%nc1a,geom%nl0,samp%smask_c1a,samp%nl0ic1,samp%l0_to_l0ic1,samp%l0ic1_to_l0)

! Allocation
allocate(samp%interp_c0b_to_c1a(samp%nl0ic1))

! Compute interpolation
do il0ic1=1,samp%nl0ic1
   il0 = samp%l0ic1_to_l0(il0ic1)
   write(samp%interp_c0b_to_c1a(il0ic1)%prefix,'(a,i3.3)') 'interp_c0b_to_c1a_',il0ic1
   call samp%interp_c0b_to_c1a(il0ic1)%interp(mpl,nam,0,geom%nc0u,geom%lon_c0u,geom%lat_c0u,geom%gmask_c0u(:,il0),geom%tree_c0u, &
 & samp%nc1a,samp%lon_c1a,samp%lat_c1a,samp%smask_c1a(:,il0),geom%mesh_c0u,7)
end do

! Define halo B
lcheck_c0b = .false.
do il0ic1=1,samp%nl0ic1
   do i_s=1,samp%interp_c0b_to_c1a(il0ic1)%n_s
      jc0u = samp%interp_c0b_to_c1a(il0ic1)%col(i_s)
      lcheck_c0b(jc0u) = .true.
   end do
end do
samp%nc0b = zss_count(lcheck_c0b)

! Compute own points
ic0b = 0
nc0own = 0
do ic0u=1,geom%nc0u
   if (lcheck_c0b(ic0u)) then
      ic0b = ic0b+1
      ic0 = geom%c0u_to_c0(ic0u)
      iproc = geom%c0_to_proc(ic0)
      if (iproc==mpl%myproc) nc0own = nc0own+1
   end if
end do

! Allocation
allocate(c0b_to_c0(samp%nc0b))
allocate(c0own_to_c0(nc0own))

! Global-local conversion for halo B
c0b_to_c0 = mpl%msv%vali
ic0b = 0
ic0own = 0
do ic0u=1,geom%nc0u
   if (lcheck_c0b(ic0u)) then
      ic0b = ic0b+1
      c0u_to_c0b(ic0u) = ic0b
      ic0 = geom%c0u_to_c0(ic0u)
      c0b_to_c0(ic0b) = ic0
      iproc = geom%c0_to_proc(ic0)
      if (iproc==mpl%myproc) then
         ic0own = ic0own+1
         c0own_to_c0(ic0own) = ic0
      end if
   end if
end do

! Local interpolation source
do il0ic1=1,samp%nl0ic1
   samp%interp_c0b_to_c1a(il0ic1)%n_src = samp%nc0b
   do i_s=1,samp%interp_c0b_to_c1a(il0ic1)%n_s
      ic0u = samp%interp_c0b_to_c1a(il0ic1)%col(i_s)
      ic0b = c0u_to_c0b(ic0u)
      if (mpl%msv%isnot(ic0b)) then
         samp%interp_c0b_to_c1a(il0ic1)%col(i_s) = ic0b
      else
         call mpl%abort('${subr}$','wrong local source for interp_c0b_to_c1a')
      end if
   end do
end do

! Setup communications
call samp%com_c0_AB%setup(mpl,'com_c0_AB',geom%nc0a,samp%nc0b,geom%nc0,geom%c0a_to_c0,c0b_to_c0,c0own_to_c0)

! Release memory
deallocate(c0b_to_c0)

! Print results
write(mpl%info,'(a10,a,i8)') '','nc0b = ',samp%nc0b
call mpl%flush

! Probe out
@:probe_out()

end subroutine samp_compute_mpi_c0b

!----------------------------------------------------------------------
! Subroutine: samp_compute_mpi_c0c
!> Compute MPI distribution, halo C, subset Sc0
!----------------------------------------------------------------------
subroutine samp_compute_mpi_c0c(samp,mpl,nam,geom)

implicit none

! Passed variables
class(samp_type),intent(inout) :: samp !< Sampling
type(mpl_type),intent(inout) :: mpl    !< MPI data
type(nam_type),intent(in) :: nam       !< Namelist
type(geom_type),intent(in) :: geom     !< Geometry

! Local variables
integer :: jc3,jc4,ic0,ic0c,ic0u,jc0u,i_s,il0,il0ic3,nc0own,ic0own,iproc
integer :: c0u_to_c0c(geom%nc0u)
integer,allocatable :: c0c_to_c0(:),c0own_to_c0(:)
logical :: smask(samp%nc1a,geom%nl0),lcheck_c0c(geom%nc0u)

! Set name
@:set_name(samp_compute_mpi_c0c)

! Probe in
@:probe_in()

! Allocation
allocate(samp%nl0ic3(nam%nc3,nam%nc4))
allocate(samp%l0_to_l0ic3(geom%nl0,nam%nc3,nam%nc4))
allocate(samp%l0ic3_to_l0(geom%nl0,nam%nc3,nam%nc4))

do jc4=1,nam%nc4
   do jc3=1,nam%nc3
      ! Initialization
      smask = samp%smask_c3a(:,jc3,jc4,:)

      ! Compute independent levels
      write(mpl%test,'(a10,a,i3,a,i3,a)') '','Independent levels for angular sector ',jc4,' / class ',jc3,': '
      call mpl%flush(newl=.false.)
      call independent_levels(mpl,samp%nc1a,geom%nl0,smask,samp%nl0ic3(jc3,jc4),samp%l0_to_l0ic3(:,jc3,jc4), &
 & samp%l0ic3_to_l0(:,jc3,jc4))
   end do
end do

! Allocation
allocate(samp%interp_c0c_to_c3a(nam%nc3,nam%nc4,geom%nl0))

! Compute interpolation
do jc4=1,nam%nc4
   do jc3=1,nam%nc3
      do il0ic3=1,samp%nl0ic3(jc3,jc4)
         il0 = samp%l0ic3_to_l0(il0ic3,jc3,jc4)
         write(samp%interp_c0c_to_c3a(jc3,jc4,il0ic3)%prefix,'(a,i3.3,a,i3.3,a,i3.3)') 'interp_c0c_to_c3a_',jc3,'-',jc4,'_',il0ic3
         call samp%interp_c0c_to_c3a(jc3,jc4,il0ic3)%interp(mpl,nam,0,geom%nc0u,geom%lon_c0u,geom%lat_c0u,geom%gmask_c0u(:,il0), &
 & geom%tree_c0u,samp%nc1a,samp%lon_c3a(:,jc3,jc4),samp%lat_c3a(:,jc3,jc4),samp%smask_c3a(:,jc3,jc4,il0),geom%mesh_c0u,7)
      end do
   end do
end do

! Define halo C
lcheck_c0c = .false.
do jc4=1,nam%nc4
   do jc3=1,nam%nc3
      do il0ic3=1,samp%nl0ic3(jc3,jc4)
         do i_s=1,samp%interp_c0c_to_c3a(jc3,jc4,il0ic3)%n_s
            jc0u = samp%interp_c0c_to_c3a(jc3,jc4,il0ic3)%col(i_s)
            lcheck_c0c(jc0u) = .true.
         end do
      end do
   end do
end do
samp%nc0c = zss_count(lcheck_c0c)

! Compute own points
ic0c = 0
nc0own = 0
do ic0u=1,geom%nc0u
   if (lcheck_c0c(ic0u)) then
      ic0c = ic0c+1
      ic0 = geom%c0u_to_c0(ic0u)
      iproc = geom%c0_to_proc(ic0)
      if (iproc==mpl%myproc) nc0own = nc0own+1
   end if
end do

! Allocation
allocate(c0c_to_c0(samp%nc0c))
allocate(c0own_to_c0(nc0own))

! Global-local conversion for halo C
c0c_to_c0 = mpl%msv%vali
ic0c = 0
ic0own = 0
do ic0u=1,geom%nc0u
   if (lcheck_c0c(ic0u)) then
      ic0c = ic0c+1
      c0u_to_c0c(ic0u) = ic0c
      ic0 = geom%c0u_to_c0(ic0u)
      c0c_to_c0(ic0c) = ic0
      iproc = geom%c0_to_proc(ic0)
      if (iproc==mpl%myproc) then
         ic0own = ic0own+1
         c0own_to_c0(ic0own) = ic0
      end if
   end if
end do

! Local interpolation source
do jc4=1,nam%nc4
   do jc3=1,nam%nc3
      do il0ic3=1,samp%nl0ic3(jc3,jc4)
         samp%interp_c0c_to_c3a(jc3,jc4,il0ic3)%n_src = samp%nc0c
         do i_s=1,samp%interp_c0c_to_c3a(jc3,jc4,il0ic3)%n_s
            ic0u = samp%interp_c0c_to_c3a(jc3,jc4,il0ic3)%col(i_s)
            ic0c = c0u_to_c0c(ic0u)
            if (mpl%msv%isnot(ic0u)) then
               samp%interp_c0c_to_c3a(jc3,jc4,il0ic3)%col(i_s) = ic0c
            else
               call mpl%abort('${subr}$','wrong local source for interp_c0c_to_c3a')
            end if
         end do
      end do
   end do
end do

! Setup communications
call samp%com_c0_AC%setup(mpl,'com_c0_AC',geom%nc0a,samp%nc0c,geom%nc0,geom%c0a_to_c0,c0c_to_c0,c0own_to_c0)

! Release memory
deallocate(c0c_to_c0)

! Print results
write(mpl%info,'(a10,a,i8)') '','nc0c = ',samp%nc0c
call mpl%flush

! Probe out
@:probe_out()

end subroutine samp_compute_mpi_c0c

!----------------------------------------------------------------------
! Subroutine: samp_compute_mpi_d
!> Compute sampling MPI distribution, halo D
!----------------------------------------------------------------------
subroutine samp_compute_mpi_d(samp,mpl,nam,geom)

implicit none

! Passed variables
class(samp_type),intent(inout) :: samp !< Sampling
type(mpl_type),intent(inout) :: mpl    !< MPI data
type(nam_type),intent(in) :: nam       !< Namelist
type(geom_type),intent(in) :: geom     !< Geometry

! Local variables
integer :: ic2a,nn,i,ic1d,ic1,ic1a,ic1u,jc1u,npack,ipack,il0,jc3,jc4
integer,allocatable :: nn_index(:),c1d_to_c1(:)
logical :: lcheck_c1d(samp%nc1u)
logical,allocatable :: sbuf(:,:),rbuf(:,:)
type(tree_type) :: tree

! Set name
@:set_name(samp_compute_mpi_d)

! Probe in
@:probe_in()

! Allocation
allocate(samp%local_mask(samp%nc1u,samp%nc2a))
call tree%alloc(mpl,samp%nc1u)

! Initialization
samp%local_mask = .false.
lcheck_c1d = .false.
do ic1a=1,samp%nc1a
   ic1u = samp%c1a_to_c1u(ic1a)
   lcheck_c1d(ic1u) = .true.
end do
call tree%init(samp%lon_c1u,samp%lat_c1u)

! Define masks
do ic2a=1,samp%nc2a
   if (nam%local_rad>zero) then
      ! Count nearest neighbors
      call tree%count_nearest_neighbors(samp%lon_c2a(ic2a),samp%lat_c2a(ic2a),nam%local_rad,nn)
      nn = max(nn,1)

      ! Allocation
      allocate(nn_index(nn))

      ! Find nearest neighbors
      call tree%find_nearest_neighbors(samp%lon_c2a(ic2a),samp%lat_c2a(ic2a),nn,nn_index)

      ! Update masks
      do i=1,nn
         jc1u = nn_index(i)
         samp%local_mask(jc1u,ic2a) = .true.
         lcheck_c1d(jc1u) = .true.
      end do

      ! Release memory
      deallocate(nn_index)
   elseif (nam%local_dlat>zero) then
      ! Update masks
      do jc1u=1,samp%nc1u
         if (abs(samp%lat_c2a(ic2a)-samp%lat_c1u(jc1u))<nam%local_dlat) then
            samp%local_mask(jc1u,ic2a) = .true.
            lcheck_c1d(jc1u) = .true.
         end if
      end do
   end if
end do
samp%nc1d = zss_count(lcheck_c1d)

! Release memory
call tree%dealloc

! Allocation
allocate(c1d_to_c1(samp%nc1d))
allocate(samp%c1d_to_c1u(samp%nc1d))

! Halo D
ic1d = 0
do ic1u=1,samp%nc1u
   if (lcheck_c1d(ic1u)) then
      ic1d = ic1d+1
      ic1 = samp%c1u_to_c1(ic1u)
      c1d_to_c1(ic1d) = ic1
      samp%c1d_to_c1u(ic1d) = ic1u
   end if
end do

! Setup communications
call samp%com_c1_AD%setup(mpl,'com_c1_AD',samp%nc1a,samp%nc1d,samp%nc1,samp%c1a_to_c1,c1d_to_c1)

! Allocation
npack = nam%nc3*nam%nc4*geom%nl0
allocate(sbuf(samp%nc1a,npack))
allocate(rbuf(samp%nc1d,npack))
allocate(samp%smask_c1dc3(samp%nc1d,nam%nc3,nam%nc4,geom%nl0))

! Pack
ipack = 0
do il0=1,geom%nl0
   do jc4=1,nam%nc4
      do jc3=1,nam%nc3
         ipack = ipack+1
         sbuf(:,ipack) = samp%smask_c3a(:,jc3,jc4,il0)
      end do
   end do
end do

! Halo extension
call samp%com_c1_AD%ext(mpl,sbuf,rbuf)

! Unpack
ipack = 0
do il0=1,geom%nl0
   do jc4=1,nam%nc4
      do jc3=1,nam%nc3
         ipack = ipack+1
         samp%smask_c1dc3(:,jc3,jc4,il0) = rbuf(:,ipack)
      end do
   end do
end do

! Release memory
deallocate(c1d_to_c1)
deallocate(sbuf)
deallocate(rbuf)

! Print results
write(mpl%info,'(a7,a,i6)') '','Parameters for processor #',mpl%myproc
call mpl%flush
write(mpl%info,'(a10,a,i8)') '','nc1d =      ',samp%nc1d
call mpl%flush

! Probe out
@:probe_out()

end subroutine samp_compute_mpi_d

!----------------------------------------------------------------------
! Subroutine: samp_compute_mpi_e
!> Compute sampling MPI distribution, halo E
!----------------------------------------------------------------------
subroutine samp_compute_mpi_e(samp,mpl,nam)

implicit none

! Passed variables
class(samp_type),intent(inout) :: samp !< Sampling
type(mpl_type),intent(inout) :: mpl    !< MPI data
type(nam_type),intent(in) :: nam       !< Namelist

! Local variables
integer :: ic2b,ic2u,nn,i,ic1,ic1e,ic1u,ic1a,jc1u
integer,allocatable :: nn_index(:),c1e_to_c1(:)
real(kind_real),allocatable :: lon_c1e(:),lat_c1e(:)
logical :: lcheck_c1e(samp%nc1u)
type(tree_type) :: tree

! Set name
@:set_name(samp_compute_mpi_e)

! Probe in
@:probe_in()

! Allocation
allocate(samp%vbal_mask(samp%nc1u,samp%nc2b))
call tree%alloc(mpl,samp%nc1u)

! Initialization
samp%vbal_mask = .false.
lcheck_c1e = .false.
do ic1a=1,samp%nc1a
   ic1u = samp%c1a_to_c1u(ic1a)
   lcheck_c1e(ic1u) = .true.
end do
call tree%init(samp%lon_c1u,samp%lat_c1u)

! Halo E
do ic2b=1,samp%nc2b
   ! Indices
   ic2u = samp%c2b_to_c2u(ic2b)

   if (nam%local_rad>zero) then
      ! Count nearest neighbors
      call tree%count_nearest_neighbors(samp%lon_c2u(ic2u),samp%lat_c2u(ic2u),nam%local_rad,nn)

      ! Allocation
      allocate(nn_index(nn))

      ! Find nearest neighbors
      call tree%find_nearest_neighbors(samp%lon_c2u(ic2u),samp%lat_c2u(ic2u),nn,nn_index)

      ! Update masks
      do i=1,nn
         jc1u = nn_index(i)
         samp%vbal_mask(jc1u,ic2b) = .true.
         lcheck_c1e(jc1u) = .true.
      end do

      ! Release memory
      deallocate(nn_index)
   elseif (nam%local_dlat>zero) then
      ! Update masks
      do jc1u=1,samp%nc1u
         if (abs(samp%lat_c2u(ic2u)-samp%lat_c1u(jc1u))<nam%local_dlat) then
            samp%vbal_mask(jc1u,ic2b) = .true.
            lcheck_c1e(jc1u) = .true.
         end if
      end do
   else
      call mpl%abort('${subr}$','local_rad or local_dlat should be positive')
   end if
end do
samp%nc1e = zss_count(lcheck_c1e)

! Release memory
call tree%dealloc

! Allocation
allocate(c1e_to_c1(samp%nc1e))
allocate(samp%c1e_to_c1u(samp%nc1e))
if (samp%compute_c2b_to_c1a) then
   allocate(lon_c1e(samp%nc1e))
   allocate(lat_c1e(samp%nc1e))
end if

! Halo E
ic1e = 0
do ic1u=1,samp%nc1u
   if (lcheck_c1e(ic1u)) then
      ic1e = ic1e+1
      ic1 = samp%c1u_to_c1(ic1u)
      c1e_to_c1(ic1e) = ic1
      samp%c1e_to_c1u(ic1e) = ic1u
      if (samp%compute_c2b_to_c1a) then
         lon_c1e(ic1e) = samp%lon_c1u(ic1u)
         lat_c1e(ic1e) = samp%lat_c1u(ic1u)
      end if
   end if
end do

! Setup communications
call samp%com_c1_AE%setup(mpl,'com_c1_AE',samp%nc1a,samp%nc1e,samp%nc1,samp%c1a_to_c1,c1e_to_c1)

! Release memory
deallocate(c1e_to_c1)

! Print results
write(mpl%info,'(a7,a,i6)') '','Parameters for processor #',mpl%myproc
call mpl%flush
write(mpl%info,'(a10,a,i8)') '','nc1e =      ',samp%nc1e
call mpl%flush

! Probe out
@:probe_out()

end subroutine samp_compute_mpi_e

!----------------------------------------------------------------------
! Subroutine: samp_diag_filter
!> Filter diagnostics
!----------------------------------------------------------------------
subroutine samp_diag_filter(samp,mpl,filter_type,rflt,diag_c2a,val_c2a)

implicit none

! Passed variables
class(samp_type),intent(in) :: samp                       !< Sampling
type(mpl_type),intent(inout) :: mpl                       !< MPI data
character(len=*),intent(in) :: filter_type                !< Filter type
real(kind_real),intent(in) :: rflt                        !< Filter support radius
real(kind_real),intent(inout) :: diag_c2a(samp%nc2a)      !< Filtered diagnostic
real(kind_real),intent(in),optional :: val_c2a(samp%nc2a) !< Useful value for filtering

! Local variables
integer :: ic2,ic2a,nc2f,ic2f,ic2u,jc2u,nc2eff,ic2eff,kc2u,kc2f
integer :: c2u_to_c2f(samp%nc2u)
integer,allocatable :: c2f_to_c2(:),order(:)
real(kind_real) :: distnorm,norm,wgt
real(kind_real),allocatable :: diag_c2f(:),diag_eff(:),diag_eff_dist(:)
real(kind_real),allocatable :: val_c2f(:),val_eff(:)
logical :: lcheck_c2f(samp%nc2u)
type(com_type) :: com_c2_AF

! Set name
@:set_name(samp_diag_filter)

! Probe in
@:probe_in()

if (rflt>zero) then
   ! Define halo F
   lcheck_c2f = .false.
   do ic2a=1,samp%nc2a
      ic2u = samp%c2a_to_c2u(ic2a)
      lcheck_c2f(ic2u) = .true.
      jc2u = 1
      do while (inf(samp%nn_c2a_dist(jc2u,ic2a),rflt))
         kc2u = samp%nn_c2a_index(jc2u,ic2a)
         lcheck_c2f(kc2u) = .true.
         jc2u = jc2u+1
         if (jc2u>samp%nc2u) exit
      end do
   end do
   nc2f = zss_count(lcheck_c2f)

   ! Allocation
   allocate(c2f_to_c2(nc2f))

   ! Global-local conversion for halo F
   c2u_to_c2f = mpl%msv%vali
   ic2f = 0
   do ic2u=1,samp%nc2u
      if (lcheck_c2f(ic2u)) then
         ic2f = ic2f+1
         ic2 = samp%c2u_to_c2(ic2u)
         c2f_to_c2(ic2f) = ic2
         c2u_to_c2f(ic2u) = ic2f
      end if
   end do

   ! Setup communications
   call com_c2_AF%setup(mpl,'com_c2_AF',samp%nc2a,nc2f,samp%nc2,samp%c2a_to_c2,c2f_to_c2)

   ! Allocation
   allocate(diag_c2f(nc2f))
   if (present(val_c2a)) allocate(val_c2f(nc2f))

   ! Halo extension
   call com_c2_AF%ext(mpl,diag_c2a,diag_c2f)
   if (present(val_c2a)) call com_c2_AF%ext(mpl,val_c2a,val_c2f)

   !!$omp parallel do schedule(static) private(ic2a,nc2eff,ic2eff,jc2u,kc2u,kc2f,distnorm,norm,wgt), & ! TODO: buggy with PGI
   !!$omp&                             firstprivate(diag_eff,diag_eff_dist,val_eff,order)
   do ic2a=1,samp%nc2a
      ! Count involved points
      nc2eff = 0
      jc2u = 1
      do while (inf(samp%nn_c2a_dist(jc2u,ic2a),rflt))
         ! Check the point validity
         kc2u = samp%nn_c2a_index(jc2u,ic2a)
         kc2f = c2u_to_c2f(kc2u)
         if (mpl%msv%isnot(diag_c2f(kc2f))) nc2eff = nc2eff+1
         jc2u = jc2u+1
         if (jc2u>samp%nc2u) exit
      end do

      if (nc2eff>0) then
         ! Allocation
         allocate(diag_eff(nc2eff))
         allocate(diag_eff_dist(nc2eff))
         if (present(val_c2a)) allocate(val_eff(nc2eff))

         ! Build diag_eff of valid points
         ic2eff = 0
         jc2u = 1
         do while (inf(samp%nn_c2a_dist(jc2u,ic2a),rflt))
            ! Check the point validity
            kc2u = samp%nn_c2a_index(jc2u,ic2a)
            kc2f = c2u_to_c2f(kc2u)
            if (mpl%msv%isnot(diag_c2f(kc2f))) then
               ic2eff = ic2eff+1
               diag_eff(ic2eff) = diag_c2f(kc2f)
               diag_eff_dist(ic2eff) = samp%nn_c2a_dist(jc2u,ic2a)
               if (present(val_c2a)) val_eff(ic2eff) = val_c2f(kc2f)
            end if
            jc2u = jc2u+1
            if (jc2u>samp%nc2u) exit
         end do

         ! Apply filter
         select case (trim(filter_type))
         case ('average')
            ! Compute average
            diag_c2a(ic2a) = zss_sum(diag_eff)/real(nc2eff,kind_real)
         case ('gc99')
            ! Gaspari-Cohn (1999) kernel
            diag_c2a(ic2a) = zero
            norm = zero
            do ic2eff=1,nc2eff
               distnorm = diag_eff_dist(ic2eff)/rflt
               wgt = fit_func(mpl,'hor',distnorm)
               diag_c2a(ic2a) = diag_c2a(ic2a)+wgt*diag_eff(ic2eff)
               norm = norm+wgt
            end do
            if (norm>zero) diag_c2a(ic2a) = diag_c2a(ic2a)/norm
         case ('median')
            ! Compute median
            allocate(order(nc2eff))
            if (present(val_c2a)) then
               ! Use external value
               call qsort(nc2eff,val_eff,order)
               diag_eff = diag_eff(order)
            else
               ! Use diagnostic value
               call qsort(nc2eff,diag_eff,order)
            end if
            if (mod(nc2eff,2)==0) then
               diag_c2a(ic2a) = half*(diag_eff(nc2eff/2)+diag_eff(nc2eff/2+1))
            else
               diag_c2a(ic2a) = diag_eff((nc2eff+1)/2)
            end if
            deallocate(order)
         case default
            ! Wrong filter
            call mpl%abort('${subr}$','wrong filter type')
         end select

         ! Release memory
         deallocate(diag_eff)
         deallocate(diag_eff_dist)
         if (present(val_c2a)) deallocate(val_eff)
      else
         diag_c2a(ic2a) = mpl%msv%valr
      end if
   end do
   !!$omp end parallel do

   ! Release memory
   deallocate(c2f_to_c2)
   call com_c2_AF%dealloc
   deallocate(diag_c2f)
   if (present(val_c2a)) deallocate(val_c2f)
end if

! Probe out
@:probe_out()

end subroutine samp_diag_filter

!----------------------------------------------------------------------
! Subroutine: samp_diag_fill
!> Fill diagnostics missing values
!----------------------------------------------------------------------
subroutine samp_diag_fill(samp,mpl,diag_c2a)

implicit none

! Passed variables
class(samp_type),intent(in) :: samp                  !< Sampling
type(mpl_type),intent(inout) :: mpl                  !< MPI data
real(kind_real),intent(inout) :: diag_c2a(samp%nc2a) !< Filtered diagnostic

! Local variables
integer :: nmsr,ic2a,jc2u,kc2u
real(kind_real),allocatable :: diag_c2u(:)

! Set name
@:set_name(samp_diag_fill)

! Probe in
@:probe_in()

! Count missing points
if (samp%nc2a>0) then
   nmsr = zss_count(mpl%msv%is(diag_c2a))
else
   nmsr = 0
end if
call mpl%f_comm%allreduce(nmsr,fckit_mpi_sum())

if (nmsr==samp%nc2) then
   ! All points are missing, do nothing
elseif (nmsr>0) then
   ! Allocation
   allocate(diag_c2u(samp%nc2u))

   ! Halo extension
   call samp%com_c2_AU%ext(mpl,diag_c2a,diag_c2u)

   ! Fill points
   do ic2a=1,samp%nc2a
      jc2u = 1
      do while (mpl%msv%is(diag_c2a(ic2a)))
         kc2u = samp%nn_c2a_index(jc2u,ic2a)
         if (mpl%msv%isnot(diag_c2u(kc2u))) diag_c2a(ic2a) = diag_c2u(kc2u)
         jc2u = jc2u+1
         if (jc2u>samp%nc2u) exit
      end do
   end do

   ! Release memory
   deallocate(diag_c2u)
end if

! Probe out
@:probe_out()

end subroutine samp_diag_fill

!----------------------------------------------------------------------
! Function: samp_c1_to_c1a
!> Conversion from global to halo A on subset Sc1
!----------------------------------------------------------------------
function samp_c1_to_c1a(samp,ic1) result(ic1a)

implicit none

! Passed variables
class(samp_type),intent(in) :: samp !< Sampling
integer,intent(in) :: ic1           !< Global index

! Returned variable
integer :: ic1a

! Set name
@:set_name(samp_c1_to_c1a)

! Probe in
@:probe_in()

! Call generic function
ic1a = cx_to_cxa(samp%nproc,samp%proc_to_c1_offset,ic1)

! Probe out
@:probe_out()

end function samp_c1_to_c1a

!----------------------------------------------------------------------
! Function: samp_c1_to_proc
!> Conversion from global to processor on subset Sc1
!----------------------------------------------------------------------
function samp_c1_to_proc(samp,ic1) result(iproc)

implicit none

! Passed variables
class(samp_type),intent(in) :: samp !< Sampling
integer,intent(in) :: ic1           !< Global index

! Returned variable
integer :: iproc

! Set name
@:set_name(samp_c1_to_proc)

! Probe in
@:probe_in()

! Call generic function
iproc = cx_to_proc(samp%nproc,samp%proc_to_c1_offset,ic1)

! Probe out
@:probe_out()

end function samp_c1_to_proc

!----------------------------------------------------------------------
! Function: samp_c1_to_c1u
!> Conversion from global to universe on subset Sc1
!----------------------------------------------------------------------
function samp_c1_to_c1u(samp,ic1) result(ic1u)

implicit none

! Passed variables
class(samp_type),intent(in) :: samp !< Sampling
integer,intent(in) :: ic1           !< Global index

! Returned variable
integer :: ic1u

! Set name
@:set_name(samp_c1_to_c1u)

! Probe in
@:probe_in()

! Call generic function
ic1u = cx_to_cxu(samp%nproc,samp%proc_to_c1_offset,samp%proc_to_nc1a,samp%myuniverse,ic1)

! Probe out
@:probe_out()

end function samp_c1_to_c1u

!----------------------------------------------------------------------
! Function: samp_c2_to_c2a
!> Conversion from global to halo A on subset Sc2
!----------------------------------------------------------------------
function samp_c2_to_c2a(samp,ic2) result(ic2a)

implicit none

! Passed variables
class(samp_type),intent(in) :: samp !< Sampling
integer,intent(in) :: ic2           !< Global index

! Returned variable
integer :: ic2a

! Set name
@:set_name(samp_c2_to_c2a)

! Probe in
@:probe_in()

! Call generic function
ic2a = cx_to_cxa(samp%nproc,samp%proc_to_c2_offset,ic2)

! Probe out
@:probe_out()

end function samp_c2_to_c2a

!----------------------------------------------------------------------
! Function: samp_c2_to_proc
!> Conversion from global to processor on subset Sc2
!----------------------------------------------------------------------
function samp_c2_to_proc(samp,ic2) result(iproc)

implicit none

! Passed variables
class(samp_type),intent(in) :: samp !< Sampling
integer,intent(in) :: ic2           !< Global index

! Returned variable
integer :: iproc

! Set name
@:set_name(samp_c2_to_proc)

! Probe in
@:probe_in()

! Call generic function
iproc = cx_to_proc(samp%nproc,samp%proc_to_c2_offset,ic2)

! Probe out
@:probe_out()

end function samp_c2_to_proc

!----------------------------------------------------------------------
! Function: samp_c2_to_c2u
!> Conversion from global to universe on subset Sc2
!----------------------------------------------------------------------
function samp_c2_to_c2u(samp,ic2) result(ic2u)

implicit none

! Passed variables
class(samp_type),intent(in) :: samp !< Sampling
integer,intent(in) :: ic2           !< Global index

! Returned variable
integer :: ic2u

! Set name
@:set_name(samp_c2_to_c2u)

! Probe in
@:probe_in()

! Call generic function
ic2u = cx_to_cxu(samp%nproc,samp%proc_to_c2_offset,samp%proc_to_nc2a,samp%myuniverse,ic2)

! Probe out
@:probe_out()

end function samp_c2_to_c2u

end module type_samp
