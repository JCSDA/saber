#:include 'instrumentation.fypp'
!----------------------------------------------------------------------
! Module: type_nicas
!> NICAS data derived type
! Author: Benjamin Menetrier
! Licensing: this code is distributed under the CeCILL-C license
! Copyright 2015-... UCAR, CERFACS, METEO-FRANCE and IRIT
!----------------------------------------------------------------------
module type_nicas

use fckit_mpi_module, only: fckit_mpi_sum,fckit_mpi_min,fckit_mpi_status
use tools_const, only: zero,one,two,ten,rad2deg,reqkm,pi
use tools_func, only: fletcher32,sphere_dist,zss_sum
use tools_kinds, only: kind_real,huge_real
use tools_netcdf, only: create_file,open_file,define_grp,define_dim,inquire_dim,check_dim,define_var,put_var,close_file
use tools_qsort, only: qsort
use tools_repro, only: repro_th
use type_cmat, only: cmat_type
use type_com, only: com_type
use type_cv, only: cv_type
use type_diag, only: diag_type
use type_ens, only: ens_type
use type_geom, only: geom_type
use type_hdiag, only: hdiag_type
use type_linop, only: linop_type
use type_mom, only: mom_type
use type_mpl, only: mpl_type
use type_nam, only: nam_type
use type_nicas_blk, only: nicas_blk_type
@:use_probe()
use type_rng, only: rng_type
use type_samp, only: samp_type

implicit none

integer,parameter :: nfac_rnd = 9 !< Number of ensemble size factors for randomization
integer,parameter :: ntest = 50   !< Number of test vectors

! NICAS derived type
type nicas_type
   character(len=1024) :: prefix                    !< Prefix
   type(nicas_blk_type),allocatable :: blk(:)       !< NICAS data blocks
   logical :: allocated                             !< Allocation flag
   integer,allocatable :: blkid(:)                  !< block ID
   integer,allocatable :: dirac_id(:)               !< dirac ID
   integer,allocatable :: bens_id(:)                !< bens ID
   real(kind_real),allocatable :: dirac(:,:,:)      !< Dirac field
   real(kind_real),allocatable :: dirac_bens(:,:,:) !< Dirac field for localized ensemble application
contains
   procedure :: alloc => nicas_alloc
   procedure :: partial_dealloc => nicas_partial_dealloc
   procedure :: dealloc => nicas_dealloc
   procedure :: read_local => nicas_read_local
   procedure :: write_local => nicas_write_local
   procedure :: read_global => nicas_read_global
   procedure :: write_global => nicas_write_global
   procedure :: write_grids => nicas_write_grids
   procedure :: write_steps => nicas_write_steps
   procedure :: send => nicas_send
   procedure :: receive => nicas_receive
   procedure :: run_nicas => nicas_run_nicas
   procedure :: run_nicas_tests => nicas_run_nicas_tests
   procedure :: alloc_cv => nicas_alloc_cv
   procedure :: random_cv => nicas_random_cv
   procedure :: apply => nicas_apply
   procedure :: apply_sqrt => nicas_apply_sqrt
   procedure :: apply_sqrt_ad => nicas_apply_sqrt_ad
   procedure :: gen_ens_pert => nicas_gen_ens_pert
   procedure :: apply_bens => nicas_apply_bens
   procedure :: test_adjoint => nicas_test_adjoint
   procedure :: test_dirac => nicas_test_dirac
   procedure :: test_randomization => nicas_test_randomization
end type nicas_type

private
public :: nicas_type

contains

!----------------------------------------------------------------------
! Subroutine: nicas_alloc
!> Allocation
!----------------------------------------------------------------------
subroutine nicas_alloc(nicas,nam)

! Passed variables
class(nicas_type),intent(inout) :: nicas !< NICAS data
type(nam_type),intent(in) :: nam         !< Namelist

! Local variable
integer :: ig

! Set name
@:set_name(nicas_alloc)

! Probe in
@:probe_in()

! Allocation
if (.not.allocated(nicas%blk)) allocate(nicas%blk(nam%ng))

do ig=1,nam%ng
   ! Set block index
   nicas%blk(ig)%ig = ig

   ! Set verbosity
   nicas%blk(ig)%verbosity = .true.
end do

! Update allocation flag
nicas%allocated = .true.

! Probe out
@:probe_out()

end subroutine nicas_alloc

!----------------------------------------------------------------------
! Subroutine: nicas_partial_dealloc
!> Release memory (partial)
!----------------------------------------------------------------------
subroutine nicas_partial_dealloc(nicas)

! Passed variables
class(nicas_type),intent(inout) :: nicas !< NICAS data

! Local variable
integer :: ig

! Set name
@:set_name(nicas_partial_dealloc)

! Probe in
@:probe_in()

! Release memory (partial)
if (allocated(nicas%blk)) then
   do ig=1,size(nicas%blk)
      call nicas%blk(ig)%partial_dealloc
   end do
end if
if (allocated(nicas%blkid)) deallocate(nicas%blkid)
if (allocated(nicas%dirac_id)) deallocate(nicas%dirac_id)
if (allocated(nicas%bens_id)) deallocate(nicas%bens_id)

! Probe out
@:probe_out()

end subroutine nicas_partial_dealloc

!----------------------------------------------------------------------
! Subroutine: nicas_dealloc
!> Release memory (full)
!----------------------------------------------------------------------
subroutine nicas_dealloc(nicas)

! Passed variables
class(nicas_type),intent(inout) :: nicas !< NICAS data

! Local variable
integer :: ig

! Set name
@:set_name(nicas_dealloc)

! Probe in
@:probe_in()

! Release memory
if (allocated(nicas%blk)) then
   do ig=1,size(nicas%blk)
      call nicas%blk(ig)%dealloc
   end do
   deallocate(nicas%blk)
end if
if (allocated(nicas%dirac)) deallocate(nicas%dirac)
if (allocated(nicas%dirac_bens)) deallocate(nicas%dirac_bens)

! Update allocation flag
nicas%allocated = .false.

! Probe out
@:probe_out()

end subroutine nicas_dealloc

!----------------------------------------------------------------------
! Subroutine: nicas_read_local
!> Read
!----------------------------------------------------------------------
subroutine nicas_read_local(nicas,mpl,nam,geom)

implicit none

! Passed variables
class(nicas_type),intent(inout) :: nicas !< NICAS data
type(mpl_type),intent(inout) :: mpl      !< MPI data
type(nam_type),intent(in) :: nam         !< Namelist
type(geom_type),intent(in) :: geom       !< Geometry

! Local variables
integer :: ig,icmp,iproc,iprocio,ncid,is,isa
type(nicas_type) :: nicas_tmp

! Set name
@:set_name(nicas_read_local)

! Probe in
@:probe_in()

write(mpl%info,'(a7,a)') '','Read NICAS local data'
call mpl%flush

! Allocation
call nicas%alloc(nam)

! Read NICAS blocks
do iproc=1,mpl%nproc
   ! Reading task
   iprocio = mod(iproc,mpl%nprocio)
   if (iprocio==0) iprocio = mpl%nprocio

   if (mpl%myproc==iprocio) then
      write(mpl%info,'(a10,a,i6,a,i6)') '','Read NICAS data of task ',iproc,' from task ',iprocio
      call mpl%flush

      ! Open file
      ncid = open_file(mpl,nam%fname_nicas,iproc)

      ! Check number of levels (TODO: nl0 is now defined at block level, whole block should be removed at some point)
      if (mpl%msv%isnot(inquire_dim(mpl,ncid,'nl0'))) then
         if (.not.check_dim(mpl,ncid,'nl0',geom%nl0)) call mpl%abort('${subr}$','wrong size for dimension nl0')
      end if

      if (iproc==iprocio) then
         do ig=1,nam%ng
            ! Copy global ID
            nicas%blk(ig)%ncid = ncid

            ! Read data
            call nicas%blk(ig)%read_local(mpl,nam,geom)
         end do
      else
         ! Allocation
         call nicas_tmp%alloc(nam)

         do ig=1,nam%ng
            ! Copy global ID
            nicas_tmp%blk(ig)%ncid = ncid

            ! Read data
            call nicas_tmp%blk(ig)%read_local(mpl,nam,geom)
         end do

          ! Send data to task iproc
         call nicas_tmp%send(mpl,nam,geom,iproc)

         ! Release memory
         call nicas_tmp%dealloc
      end if

      ! Close file
      call close_file(mpl,ncid)
   elseif (mpl%myproc==iproc) then
      ! Receive data from task iprocio
      write(mpl%info,'(a10,a,i6,a,i6)') '','Receive NICAS data of task ',iproc,' from task ',iprocio
      call mpl%flush
      call nicas%receive(mpl,nam,geom,iprocio)
   end if
end do

! Update tag
call mpl%update_tag(4)

! Check subset Sc0 on halo A size
do ig=1,nam%ng
   do icmp=1,nicas%blk(ig)%ncmp
      if (any(nicas%blk(ig)%cmp(icmp)%vlev)) then
         if (nicas%blk(ig)%cmp(icmp)%nc0a/=geom%nc0a) call mpl%abort('${subr}$','wrong size for dimension nc0a')
      end if
   end do
end do

! Set other fields
do ig=1,nam%ng
   do icmp=1,nicas%blk(ig)%ncmp
      ! Number of processors
      nicas%blk(ig)%cmp(icmp)%nproc = mpl%nproc

      ! Allocation
      allocate(nicas%blk(ig)%cmp(icmp)%myuniverse(mpl%nproc))
      allocate(nicas%blk(ig)%cmp(icmp)%proc_to_nsa(mpl%nproc))
      allocate(nicas%blk(ig)%cmp(icmp)%proc_to_s_offset(mpl%nproc))
      allocate(nicas%blk(ig)%cmp(icmp)%sa_to_s(nicas%blk(ig)%cmp(icmp)%nsa))

      ! Copy universe
      nicas%blk(ig)%cmp(icmp)%myuniverse = geom%myuniverse

      ! Communication
      call mpl%f_comm%allgather(nicas%blk(ig)%cmp(icmp)%nsa,nicas%blk(ig)%cmp(icmp)%proc_to_nsa)

      ! Subset Sc1 offset for halo A
      nicas%blk(ig)%cmp(icmp)%proc_to_s_offset(1) = 0
      do iproc=2,mpl%nproc
         nicas%blk(ig)%cmp(icmp)%proc_to_s_offset(iproc) = nicas%blk(ig)%cmp(icmp)%proc_to_s_offset(iproc-1) &
 & +nicas%blk(ig)%cmp(icmp)%proc_to_nsa(iproc-1)
      end do

      ! Global subgrid size
      nicas%blk(ig)%cmp(icmp)%ns = sum(nicas%blk(ig)%cmp(icmp)%proc_to_nsa)

      ! Automatic conversions on subgrid
      do is=1,nicas%blk(ig)%cmp(icmp)%ns
         iproc = nicas%blk(ig)%cmp(icmp)%s_to_proc(is)
         if (iproc==mpl%myproc) then
            isa = nicas%blk(ig)%cmp(icmp)%s_to_sa(is)
            nicas%blk(ig)%cmp(icmp)%sa_to_s(isa) = is
         end if
      end do
   end do
end do

! Probe out
@:probe_out()

end subroutine nicas_read_local

!----------------------------------------------------------------------
! Subroutine: nicas_write_local
!> Write
!----------------------------------------------------------------------
subroutine nicas_write_local(nicas,mpl,nam,geom)

implicit none

! Passed variables
class(nicas_type),intent(inout) :: nicas !< NICAS data
type(mpl_type),intent(inout) :: mpl      !< MPI data
type(nam_type),intent(in) :: nam         !< Namelist
type(geom_type),intent(in) :: geom       !< Geometry

! Local variables
integer :: ncid
integer :: ig,iproc,iprocio
type(nicas_type) :: nicas_tmp

! Set name
@:set_name(nicas_write_local)

! Probe in
@:probe_in()

write(mpl%info,'(a7,a)') '','Write NICAS local data'
call mpl%flush

! Write NICAS blocks
do iproc=1,mpl%nproc
   ! Writing task
   iprocio = mod(iproc,mpl%nprocio)
   if (iprocio==0) iprocio = mpl%nprocio

   if (mpl%myproc==iprocio) then
      write(mpl%info,'(a10,a,i6,a,i6)') '','Write NICAS data of task ',iproc,' from task ',iprocio
      call mpl%flush

      if (nam%new_files) then
         ! Create file
         ncid = create_file(mpl,nam%fname_nicas,iproc)
      else
         ! Open file
         ncid = open_file(mpl,nam%fname_nicas,iproc,nowrite=.false.)
      end if

      if (iproc==iprocio) then
         do ig=1,nam%ng
            ! Copy global ID
            nicas%blk(ig)%ncid = ncid

            ! Write data (definition mode)
            call nicas%blk(ig)%write_local_def(mpl,nam,geom)
         end do

         do ig=1,nam%ng
            ! Write data (data mode)
            call nicas%blk(ig)%write_local_data(mpl)
         end do
      else
         ! Allocation
         call nicas_tmp%alloc(nam)

         ! Receive data from task iproc
         call nicas_tmp%receive(mpl,nam,geom,iproc)

         do ig=1,nam%ng
            ! Copy global ID
            nicas_tmp%blk(ig)%ncid = ncid

            ! Write data (definition mode)
            call nicas_tmp%blk(ig)%write_local_def(mpl,nam,geom)
         end do

         do ig=1,nam%ng
            ! Write data (data mode)
            call nicas_tmp%blk(ig)%write_local_data(mpl)
         end do

         ! Release memory
         call nicas_tmp%dealloc
      end if

      ! Close file
      call close_file(mpl,ncid)
   elseif (mpl%myproc==iproc) then
      ! Send data to task iprocio
      write(mpl%info,'(a10,a,i6,a,i6)') '','Send NICAS data of task ',iproc,' to task ',iprocio
      call mpl%flush
      call nicas%send(mpl,nam,geom,iprocio)
   end if
end do

! Update tag
call mpl%update_tag(4)

! Probe out
@:probe_out()

end subroutine nicas_write_local

!----------------------------------------------------------------------
! Subroutine: nicas_read_global
!> Read
!----------------------------------------------------------------------
subroutine nicas_read_global(nicas,mpl,nam,geom)

! Passed variables
class(nicas_type),intent(inout) :: nicas !< NICAS data
type(mpl_type),intent(inout) :: mpl      !< MPI data
type(nam_type),intent(in) :: nam         !< Namelist
type(geom_type),intent(in) :: geom       !< Geometry

! Local variable
integer :: ncid
integer :: ig

! Set name
@:set_name(nicas_read_global)

! Probe in
@:probe_in()

write(mpl%info,'(a7,a)') '','Read NICAS global data'
call mpl%flush

! Open file
ncid = open_file(mpl,nam%fname_nicas)

do ig=1,nam%ng
   ! Copy global ID
   nicas%blk(ig)%ncid = ncid

   ! Read global data
   call nicas%blk(ig)%read_global(mpl,nam,geom)
end do

! Close file
call close_file(mpl,ncid)

! Probe out
@:probe_out()

end subroutine nicas_read_global

!----------------------------------------------------------------------
! Subroutine: nicas_write_global
!> Write
!----------------------------------------------------------------------
subroutine nicas_write_global(nicas,mpl,nam,geom)

! Passed variables
class(nicas_type),intent(inout) :: nicas !< NICAS data
type(mpl_type),intent(inout) :: mpl      !< MPI data
type(nam_type),intent(in) :: nam         !< Namelist
type(geom_type),intent(in) :: geom       !< Geometry

! Local variable
integer :: ncid
integer :: ig

! Set name
@:set_name(nicas_write_global)

! Probe in
@:probe_in()

write(mpl%info,'(a7,a)') '','Write NICAS global data'
call mpl%flush

! Open file
if (nam%new_files) then
   ! Create file
   ncid = create_file(mpl,nam%fname_nicas)
else
   ! Open file
   ncid = open_file(mpl,nam%fname_nicas,nowrite=.false.)
end if

do ig=1,nam%ng
   ! Copy global ID
   nicas%blk(ig)%ncid = ncid

   ! Write global data (definition mode)
   call nicas%blk(ig)%write_global_def(mpl,nam,geom)
end do

do ig=1,nam%ng
   ! Write global data (data mode)
   call nicas%blk(ig)%write_global_data(mpl)
end do

! Close file
call close_file(mpl,ncid)

! Probe out
@:probe_out()

end subroutine nicas_write_global

!----------------------------------------------------------------------
! Subroutine: nicas_write_grids
!> Write
!----------------------------------------------------------------------
subroutine nicas_write_grids(nicas,mpl,nam)

! Passed variables
class(nicas_type),intent(inout) :: nicas !< NICAS data
type(mpl_type),intent(inout) :: mpl      !< MPI data
type(nam_type),intent(in) :: nam         !< Namelist

! Local variable
integer :: ncid
integer :: ig

! Set name
@:set_name(nicas_write_grids)

! Probe in
@:probe_in()

! Open file
if (nam%new_files) then
   ! Create file
   ncid = create_file(mpl,trim(nam%fname_nicas)//'_grids',mpl%myproc,io_override=.true.)
else
   ! Open file
   ncid = open_file(mpl,trim(nam%fname_nicas)//'_grids',mpl%myproc,nowrite=.false.,io_override=.true.)
end if

do ig=1,nam%ng
   ! Copy global ID
   nicas%blk(ig)%ncid = ncid

   ! Write grids (definition mode)
   call nicas%blk(ig)%write_grids_def(mpl,nam)
end do

do ig=1,nam%ng
   ! Write grids (data mode)
   call nicas%blk(ig)%write_grids_data(mpl)
end do

! Close file
call close_file(mpl,ncid,io_override=.true.)

! Probe out
@:probe_out()

end subroutine nicas_write_grids

!----------------------------------------------------------------------
! Subroutine: nicas_write_steps
!> Write
!----------------------------------------------------------------------
subroutine nicas_write_steps(nicas,mpl,nam)

! Passed variables
class(nicas_type),intent(inout) :: nicas !< NICAS data
type(mpl_type),intent(inout) :: mpl      !< MPI data
type(nam_type),intent(in) :: nam         !< Namelist

! Local variable
integer :: ncid
integer :: ig

! Set name
@:set_name(nicas_write_steps)

! Probe in
@:probe_in()

! Open file
if (nam%new_files) then
   ! Create file
   ncid = create_file(mpl,trim(nam%fname_nicas)//'_steps',mpl%myproc,io_override=.true.)
else
   ! Open file
   ncid = open_file(mpl,trim(nam%fname_nicas)//'_steps',mpl%myproc,nowrite=.false.,io_override=.true.)
end if

do ig=1,nam%ng
   ! Copy global ID
   nicas%blk(ig)%ncid = ncid

   ! Write grids (definition mode)
   call nicas%blk(ig)%write_steps_def(mpl,nam)
end do

do ig=1,nam%ng
   ! Write grids (data mode)
   call nicas%blk(ig)%write_steps_data(mpl)
end do

! Close file
call close_file(mpl,ncid,io_override=.true.)

! Probe out
@:probe_out()

end subroutine nicas_write_steps

!----------------------------------------------------------------------
! Subroutine: nicas_send
!> Send
!----------------------------------------------------------------------
subroutine nicas_send(nicas,mpl,nam,geom,iproc)

implicit none

! Passed variables
class(nicas_type),intent(in) :: nicas !< NICAS data
type(mpl_type),intent(inout) :: mpl   !< MPI data
type(nam_type),intent(in) :: nam      !< Namelist
type(geom_type),intent(in) :: geom    !< Geometry
integer,intent(in) :: iproc           !< Destination task

! Local variables
integer :: ig,nbufi,nbufr,nbufl,nnbufi,nnbufr,nnbufl,ibufi,ibufr,ibufl,bufs(3)
integer,allocatable :: bufi(:)
real(kind_real),allocatable :: bufr(:)
logical,allocatable :: bufl(:)

! Set name
@:set_name(nicas_send)

! Probe in
@:probe_in()

! Buffer size
nbufi = 0
nbufr = 0
nbufl = 0
do ig=1,nam%ng
   call nicas%blk(ig)%buffer_size(mpl,geom,nnbufi,nnbufr,nnbufl)
   nbufi = nbufi+nnbufi
   nbufr = nbufr+nnbufr
   nbufl = nbufl+nnbufl
end do

! Allocation
allocate(bufi(nbufi))
allocate(bufr(nbufr))
allocate(bufl(nbufl))

! Initialization
ibufi = 0
ibufr = 0
ibufl = 0

! Serialize
do ig=1,nam%ng
   call nicas%blk(ig)%buffer_size(mpl,geom,nnbufi,nnbufr,nnbufl)
   call nicas%blk(ig)%serialize(mpl,geom,nnbufi,nnbufr,nnbufl,bufi(ibufi+1:ibufi+nnbufi),bufr(ibufr+1:ibufr+nnbufr), &
 & bufl(ibufl+1:ibufl+nnbufl))
   ibufi = ibufi+nnbufi
   ibufr = ibufr+nnbufr
   ibufl = ibufl+nnbufl
end do

! Send buffer size
bufs = (/nbufi,nbufr,nbufl/)
call mpl%f_comm%send(bufs,iproc-1,mpl%tag)

! Send data
call mpl%f_comm%send(bufi,iproc-1,mpl%tag+1)
call mpl%f_comm%send(bufr,iproc-1,mpl%tag+2)
call mpl%f_comm%send(bufl,iproc-1,mpl%tag+3)

! Release memory
deallocate(bufi)
deallocate(bufr)
deallocate(bufl)

! Probe out
@:probe_out()

end subroutine nicas_send

!----------------------------------------------------------------------
! Subroutine: nicas_receive
!> Receive
!----------------------------------------------------------------------
subroutine nicas_receive(nicas,mpl,nam,geom,iproc)

implicit none

! Passed variables
class(nicas_type),intent(inout) :: nicas !< NICAS data
type(mpl_type),intent(inout) :: mpl      !< MPI data
type(nam_type),intent(in) :: nam         !< Namelist
type(geom_type),intent(in) :: geom       !< Geometry
integer,intent(in) :: iproc              !< Source task

! Local variables
integer :: ig,nbufi,nbufr,nbufl,nnbufi,nnbufr,nnbufl,ibufi,ibufr,ibufl,bufs(3)
integer,allocatable :: bufi(:)
real(kind_real),allocatable :: bufr(:)
logical,allocatable :: bufl(:)
type(fckit_mpi_status) :: status

! Set name
@:set_name(nicas_receive)

! Probe in
@:probe_in()

! Receive buffer size
call mpl%f_comm%receive(bufs,iproc-1,mpl%tag,status)
nbufi = bufs(1)
nbufr = bufs(2)
nbufl = bufs(3)

! Allocation
allocate(bufi(nbufi))
allocate(bufr(nbufr))
allocate(bufl(nbufl))

! Receive data
call mpl%f_comm%receive(bufi,iproc-1,mpl%tag+1,status)
call mpl%f_comm%receive(bufr,iproc-1,mpl%tag+2,status)
call mpl%f_comm%receive(bufl,iproc-1,mpl%tag+3,status)

! Initialization
ibufi = 0
ibufr = 0
ibufl = 0

! Deserialize
do ig=1,nam%ng
   nnbufi = bufi(ibufi+1)
   nnbufr = bufi(ibufi+2)
   nnbufl = bufi(ibufi+3)
   call nicas%blk(ig)%deserialize(mpl,geom,nnbufi,nnbufr,nnbufl,bufi(ibufi+1:ibufi+nnbufi),bufr(ibufr+1:ibufr+nnbufr), &
 & bufl(ibufl+1:ibufl+nnbufl))
   ibufi = ibufi+nnbufi
   ibufr = ibufr+nnbufr
   ibufl = ibufl+nnbufl
end do

! Release memory
deallocate(bufi)
deallocate(bufr)
deallocate(bufl)

! Probe out
@:probe_out()

end subroutine nicas_receive

!----------------------------------------------------------------------
! Subroutine: nicas_run_nicas
!> NICAS driver
!----------------------------------------------------------------------
subroutine nicas_run_nicas(nicas,mpl,rng,nam,geom,cmat)

implicit none

! Passed variables
class(nicas_type),intent(inout) :: nicas !< NICAS data
type(mpl_type),intent(inout) :: mpl      !< MPI data
type(rng_type),intent(inout) :: rng      !< Random number generator
type(nam_type),intent(inout) :: nam      !< Namelist
type(geom_type),intent(inout) :: geom    !< Geometry
type(cmat_type),intent(in) :: cmat       !< C matrix data

! Local variables
integer :: ig,icmp,ic0a,il0

! Set name
@:set_name(nicas_run_nicas)

! Probe in
@:probe_in()

! Allocation
call nicas%alloc(nam)

if (nam%load_nicas_global) then
   ! Read global NICAS parameters
   write(mpl%info,'(a)') '-------------------------------------------------------------------'
   call mpl%flush
   write(mpl%info,'(a)') '--- Read global NICAS parameters'
   call mpl%flush
   call nicas%read_global(mpl,nam,geom)

   if (any(nam%nicas_interp_type=='si')) then
      if (cmat%allocated) then
         do ig=1,nam%ng
            do icmp=1,nicas%blk(ig)%ncmp
               ! Allocation
               allocate(nicas%blk(ig)%cmp(icmp)%rhs(geom%nc0a,geom%nl0))

               ! Initialization
               nicas%blk(ig)%cmp(icmp)%rhs = mpl%msv%valr

               ! Copy C matrix fields
               do il0=1,geom%nl0
                  do ic0a=1,geom%nc0a
                    if (geom%gmask_c0a(ic0a,il0)) nicas%blk(ig)%cmp(icmp)%rhs(ic0a,il0) = cmat%blk(ig)%rhs(ic0a,il0,icmp)
                  end do
               end do
            end do
         end do
      else
         call mpl%abort('${subr}$','rh should be specified in input fields for NICAS global reading with si interpolation')
      end if
   end if
else
   ! Copy and filter C matrix data
   write(mpl%info,'(a)') '-------------------------------------------------------------------'
   call mpl%flush
   write(mpl%info,'(a)') '--- Copy and filter C matrix data'
   call mpl%flush
   do ig=1,nam%ng
      call nicas%blk(ig)%copy_cmat(mpl,nam,geom,cmat%blk(ig))
   end do
end if

! Compute NICAS parameters
write(mpl%info,'(a)') '-------------------------------------------------------------------'
call mpl%flush
write(mpl%info,'(a)') '--- Compute NICAS parameters'
call mpl%flush

do ig=1,nam%ng
   write(mpl%info,'(a)') '--- Block: '//trim(nam%group_names(ig))
   call mpl%flush

   ! NICAS parameters
   call nicas%blk(ig)%compute_parameters(mpl,rng,nam,geom)
end do


if (nam%write_nicas_local.or.nam%write_nicas_global.or.nam%write_nicas_grids) then
   ! Write NICAS parameters
   write(mpl%info,'(a)') '-------------------------------------------------------------------'
   call mpl%flush
   write(mpl%info,'(a)') '--- Write NICAS parameters'
   call mpl%flush

   ! Write local data
   if (nam%write_nicas_local) call nicas%write_local(mpl,nam,geom)

   ! Write global data
   if (nam%write_nicas_global) call nicas%write_global(mpl,nam,geom)

   ! Write grids
   if (nam%write_nicas_grids) call nicas%write_grids(mpl,nam)
end if

! Release memory (partial)
call nicas%partial_dealloc

! Reset random seed if necessary
if (nam%default_seed) call rng%reseed(mpl)

! Probe out
@:probe_out()

end subroutine nicas_run_nicas

!----------------------------------------------------------------------
! Subroutine: nicas_run_nicas_tests
!> NICAS tests driver
!----------------------------------------------------------------------
subroutine nicas_run_nicas_tests(nicas,mpl,rng,nam,geom)

implicit none

! Passed variables
class(nicas_type),intent(inout) :: nicas  !< NICAS data
type(mpl_type),intent(inout) :: mpl       !< MPI data
type(rng_type),intent(inout) :: rng       !< Random number generator
type(nam_type),intent(inout) :: nam       !< Namelist
type(geom_type),intent(inout) :: geom     !< Geometry

! Local variables
integer :: ig,icmp

! Set name
@:set_name(nicas_run_nicas_tests)

! Probe in
@:probe_in()

if (nam%check_adjoints) then
   ! Test adjoint
   write(mpl%info,'(a)') '-------------------------------------------------------------------'
   call mpl%flush
   write(mpl%info,'(a)') '--- Test NICAS adjoint'
   call mpl%flush
   call nicas%test_adjoint(mpl,rng,nam,geom)

   do ig=1,nam%ng
      write(mpl%info,'(a)') '--- Block: '//trim(nam%group_names(ig))
      call mpl%flush
      call nicas%blk(ig)%test_adjoint(mpl,rng,nam,geom)

      do icmp=1,nicas%blk(ig)%ncmp
         write(mpl%info,'(a7,a,i1)') '','Component: ',icmp
         call mpl%flush
         call nicas%blk(ig)%cmp(icmp)%test_adjoint(mpl,rng,nam,geom)
      end do
   end do
end if

if (nam%check_normalization>0) then
   ! Test normalization
   write(mpl%info,'(a)') '-------------------------------------------------------------------'
   call mpl%flush
   write(mpl%info,'(a)') '--- Test NICAS normalization'
   call mpl%flush

   do ig=1,nam%ng
      write(mpl%info,'(a)') '--- Block: '//trim(nam%group_names(ig))
      call mpl%flush
      do icmp=1,nicas%blk(ig)%ncmp
         write(mpl%info,'(a7,a,i1)') '','Component: ',icmp
         call mpl%flush
         if (nicas%blk(ig)%cmp(icmp)%smoother) then
            call nicas%blk(ig)%cmp(icmp)%test_normalization(mpl,rng,nam,geom,icmp)
         else
            call nicas%blk(ig)%cmp(icmp)%test_normalization(mpl,rng,nam,geom)
         end if
      end do
      write(mpl%info,'(a7,a)') '','All components:'
      call mpl%flush
      call nicas%blk(ig)%test_normalization(mpl,rng,nam,geom)
   end do
end if

if (nam%check_dirac) then
   ! Apply NICAS to diracs
   write(mpl%info,'(a)') '-------------------------------------------------------------------'
   call mpl%flush
   write(mpl%info,'(a)') '--- Apply NICAS to diracs'
   call mpl%flush
   call nicas%test_dirac(mpl,nam,geom)

   ! Apply NICAS block to diracs
   do ig=1,nam%ng
      write(mpl%info,'(a)') '-------------------------------------------------------------------'
      call mpl%flush
      write(mpl%info,'(a)') '--- Block: '//trim(nam%group_names(ig))
      call mpl%flush
      call nicas%blk(ig)%test_dirac(mpl,nam,geom)
   end do

   ! Write steps
   if (nam%write_nicas_steps) call nicas%write_steps(mpl,nam)
end if

if (nam%check_randomization) then
   ! Test NICAS randomization
   write(mpl%info,'(a)') '-------------------------------------------------------------------'
   call mpl%flush
   write(mpl%info,'(a)') '--- Test NICAS randomization'
   call mpl%flush
   call nicas%test_randomization(mpl,rng,nam,geom)
end if

! Probe out
@:probe_out()

end subroutine nicas_run_nicas_tests

!----------------------------------------------------------------------
! Subroutine: nicas_alloc_cv
!> Allocation
!----------------------------------------------------------------------
subroutine nicas_alloc_cv(nicas,mpl,nam,cv,getsizeonly)

implicit none

! Passed variables
class(nicas_type),intent(in) :: nicas      !< NICAS data
type(mpl_type),intent(inout) :: mpl        !< MPI data
type(nam_type),intent(in) :: nam           !< Namelist
type(cv_type),intent(inout) :: cv          !< Control vector
logical,intent(in),optional :: getsizeonly !< Flag to get the control variable size only (no allocation)

! Local variables
integer :: ig,icmp,ib,iv
logical :: lgetsizeonly

! Set name
@:set_name(nicas_alloc_cv)

! Probe in
@:probe_in()

! Local flag
lgetsizeonly = .false.
if (present(getsizeonly)) lgetsizeonly = getsizeonly

! Initialization
cv%n = 0

! Number of blocks
select case (nam%strategy)
case ('univariate','duplicated and weighted')
   cv%nb = nam%nv
case ('duplicated')
   cv%nb = nam%ng
case ('crossed')
   cv%nb = 1
end select

! Allocation
allocate(cv%b_to_g(cv%nb))
allocate(cv%blk(cv%nb))

! CV block to NICAS group
select case (nam%strategy)
case ('univariate','duplicated and weighted')
   do iv=1,nam%nv
      cv%b_to_g(iv) = nam%group_index(iv)
   end do
case ('duplicated')
   do ig=1,nam%ng
      cv%b_to_g(ig) = ig
   end do
case ('crossed')
   cv%b_to_g(1) = 1
   do ig=2,nam%ng
      if (nicas%blk(ig)%ncmp/=nicas%blk(1)%ncmp) call mpl%abort('${subr}$','wrong number of components')
      do icmp=1,nicas%blk(ig)%ncmp
         if (nicas%blk(ig)%cmp(icmp)%nsa/=nicas%blk(1)%cmp(icmp)%nsa) call mpl%abort('${subr}$','wrong subgrid size')
      end do
   end do
end select

! CV blocks allocation and initialization
do ib=1,cv%nb
   ! Group index
   ig = cv%b_to_g(ib)

   ! Copy number of components
   cv%blk(ib)%ncmp = nicas%blk(ig)%ncmp

   ! Allocation
   allocate(cv%blk(ib)%cmp(cv%blk(ib)%ncmp))

   do icmp=1,cv%blk(ib)%ncmp
      ! Allocation and initialization
      call cv%blk(ib)%cmp(icmp)%alloc(mpl,nicas%blk(ig)%cmp(icmp)%nsa,lgetsizeonly)

      ! Update total size
      cv%n = cv%n+cv%blk(ib)%cmp(icmp)%n
   end do
end do

! Probe out
@:probe_out()

end subroutine nicas_alloc_cv

!----------------------------------------------------------------------
! Subroutine: nicas_random_cv
!> Generate a random control vector
!----------------------------------------------------------------------
subroutine nicas_random_cv(nicas,mpl,rng,nam,cv)

implicit none

! Passed variables
class(nicas_type),intent(inout) :: nicas !< NICAS data
type(mpl_type),intent(inout) :: mpl      !< MPI data
type(rng_type),intent(inout) :: rng      !< Random number generator
type(nam_type),intent(in) :: nam         !< Namelist
type(cv_type),intent(out) :: cv          !< Control vector

! Local variables
integer :: ib,ig,icmp

! Set name
@:set_name(nicas_random_cv)

! Probe in
@:probe_in()

! Allocation
call nicas%alloc_cv(mpl,nam,cv)

! Random initialization
do ib=1,cv%nb
   ! Group index
   ig = cv%b_to_g(ib)

   do icmp=1,cv%blk(ib)%ncmp
      ! Component work
      call nicas%blk(ig)%cmp(icmp)%random_cv(mpl,rng,nam,cv%blk(ib)%cmp(icmp))
   end do
end do

! Probe out
@:probe_out()

end subroutine nicas_random_cv

!----------------------------------------------------------------------
! Subroutine: nicas_apply
!> Apply NICAS (non smoother case)
!----------------------------------------------------------------------
subroutine nicas_apply(nicas,mpl,nam,geom,fld)

implicit none

! Passed variables
class(nicas_type),intent(inout) :: nicas                        !< NICAS data
type(mpl_type),intent(inout) :: mpl                             !< MPI data
type(nam_type),intent(in) :: nam                                !< Namelist
type(geom_type),intent(in) :: geom                              !< Geometry
real(kind_real),intent(inout) :: fld(geom%nc0a,geom%nl0,nam%nv) !< Field

! Local variable
real(kind_real) :: prod
real(kind_real),allocatable :: fld_save(:,:,:)
type(cv_type) :: cv

! Set name
@:set_name(nicas_apply)

! Probe in
@:probe_in()

if (nam%pos_def_test) then
   ! Save field for positivity test
   allocate(fld_save(geom%nc0a,geom%nl0,nam%nv))
   fld_save = fld
end if

! Apply square-root adjoint
call nicas%apply_sqrt_ad(mpl,nam,geom,fld,cv)

! Apply square-root
call nicas%apply_sqrt(mpl,nam,geom,cv,fld)

if (nam%pos_def_test) then
   ! Positivity test
   prod = zss_sum(fld_save*fld)
   call mpl%f_comm%allreduce(prod,fckit_mpi_sum())
   if (prod<zero) call mpl%abort('${subr}$','negative result in nicas_apply')

   ! Release memory
   deallocate(fld_save)
end if

! Probe out
@:probe_out()

end subroutine nicas_apply

!----------------------------------------------------------------------
! Subroutine: nicas_apply_sqrt
!> Apply NICAS square-root
!----------------------------------------------------------------------
subroutine nicas_apply_sqrt(nicas,mpl,nam,geom,cv,fld)

implicit none

! Passed variables
class(nicas_type),intent(inout) :: nicas                      !< NICAS data
type(mpl_type),intent(inout) :: mpl                           !< MPI data
type(nam_type),intent(in) :: nam                              !< Namelist
type(geom_type),intent(in) :: geom                            !< Geometry
type(cv_type),intent(in) :: cv                                !< Control variable
real(kind_real),intent(out) :: fld(geom%nc0a,geom%nl0,nam%nv) !< Field

! Local variable
integer :: ig,iv,jv
real(kind_real),allocatable :: fld_3d(:,:)

! Set name
@:set_name(nicas_apply_sqrt)

! Probe in
@:probe_in()

select case (nam%strategy)
case ('univariate')
   do iv=1,nam%nv
      ! Group index
      ig = nam%group_index(iv)

      ! Apply NICAS
      call nicas%blk(ig)%apply_sqrt(mpl,geom,cv%blk(iv),fld(:,:,iv))
   end do
case ('duplicated')
   ! Allocation
   allocate(fld_3d(geom%nc0a,geom%nl0))

   do ig=1,nam%ng
      ! Apply NICAS
      call nicas%blk(ig)%apply_sqrt(mpl,geom,cv%blk(ig),fld_3d)

      ! Distribute field
      do iv=1,nam%nv
         if (ig==nam%group_index(iv)) fld(:,:,iv) = fld_3d
      end do
   end do

   ! Release memory
   deallocate(fld_3d)
case ('duplicated and weighted')
   ! Allocation
   allocate(fld_3d(geom%nc0a,geom%nl0))

   ! Initialization
   fld = zero

   do ig=1,nam%ng
      do jv=1,nam%nv
         if (ig==nam%group_index(jv)) then
            ! Apply NICAS
            call nicas%blk(ig)%apply_sqrt(mpl,geom,cv%blk(jv),fld_3d)

            ! Apply weights
            do iv=jv,nam%nv
               fld(:,:,iv) = fld(:,:,iv)+nam%loc_wgt_sqrt(iv,jv)*fld_3d
            end do
         end if
      end do
   end do

   ! Release memory
   deallocate(fld_3d)
case ('crossed')
   ! Allocation
   allocate(fld_3d(geom%nc0a,geom%nl0))

   do ig=1,nam%ng
      ! Apply NICAS
      call nicas%blk(ig)%apply_sqrt(mpl,geom,cv%blk(1),fld_3d)

      ! Distribute field
      do iv=1,nam%nv
         if (ig==nam%group_index(iv)) fld(:,:,iv) = fld_3d
      end do
   end do

   ! Release memory
   deallocate(fld_3d)
end select

! Probe out
@:probe_out()

end subroutine nicas_apply_sqrt

!----------------------------------------------------------------------
! Subroutine: nicas_apply_sqrt_ad
!> Apply NICAS square-root, adjoint
!----------------------------------------------------------------------
subroutine nicas_apply_sqrt_ad(nicas,mpl,nam,geom,fld,cv)

implicit none

! Passed variables
class(nicas_type),intent(inout) :: nicas                     !< NICAS data
type(mpl_type),intent(inout) :: mpl                          !< MPI data
type(nam_type),intent(in) :: nam                             !< Namelist
type(geom_type),intent(in) :: geom                           !< Geometry
real(kind_real),intent(in) :: fld(geom%nc0a,geom%nl0,nam%nv) !< Field
type(cv_type),intent(out) :: cv                              !< Control variable

! Local variable
integer :: ig,iv,jv,icmp
real(kind_real),allocatable :: fld_3d(:,:)
type(cv_type) :: cv_tmp

! Set name
@:set_name(nicas_apply_sqrt_ad)

! Probe in
@:probe_in()

! Allocation
call nicas%alloc_cv(mpl,nam,cv)

select case (nam%strategy)
case ('univariate')
   do iv=1,nam%nv
      ! Group index
      ig = nam%group_index(iv)

      ! Apply specific NICAS
      call nicas%blk(ig)%apply_sqrt_ad(mpl,geom,fld(:,:,iv),cv%blk(iv))
   end do
case ('duplicated')
   ! Allocation
   allocate(fld_3d(geom%nc0a,geom%nl0))

   do ig=1,nam%ng
      ! Sum over variables
      fld_3d = zero
      do iv=1,nam%nv
         if (ig==nam%group_index(iv)) fld_3d = fld_3d+fld(:,:,iv)
      end do

      ! Apply NICAS
      call nicas%blk(ig)%apply_sqrt_ad(mpl,geom,fld_3d,cv%blk(ig))
   end do

   ! Release memory
   deallocate(fld_3d)
case ('duplicated and weighted')
   ! Allocation
   allocate(fld_3d(geom%nc0a,geom%nl0))

   do ig=1,nam%ng
      do iv=1,nam%nv
         if (ig==nam%group_index(iv)) then
            ! Apply weights
            fld_3d = zero
            do jv=iv,nam%nv
               fld_3d = fld_3d+nam%loc_wgt_sqrt(jv,iv)*fld(:,:,jv)
            end do

            ! Apply NICAS
            call nicas%blk(ig)%apply_sqrt_ad(mpl,geom,fld_3d,cv%blk(iv))
         end if
      end do
   end do

   ! Release memory
   deallocate(fld_3d)
case ('crossed')
   ! Allocation
   allocate(fld_3d(geom%nc0a,geom%nl0))
   call nicas%alloc_cv(mpl,nam,cv_tmp)

   ! Initialization
   do icmp=1,cv%blk(1)%ncmp
      cv%blk(1)%cmp(icmp)%alpha = zero
   end do

   do ig=1,nam%ng
      ! Sum over variables
      fld_3d = zero
      do iv=1,nam%nv
         if (ig==nam%group_index(iv)) fld_3d = fld_3d+fld(:,:,iv)
      end do

      ! Apply NICAS
      call nicas%blk(ig)%apply_sqrt_ad(mpl,geom,fld_3d,cv_tmp%blk(1))

      ! Sum control variable
      do icmp=1,cv%blk(1)%ncmp
         cv%blk(1)%cmp(icmp)%alpha = cv%blk(1)%cmp(icmp)%alpha+cv_tmp%blk(1)%cmp(icmp)%alpha
      end do
   end do

   ! Release memory
   deallocate(fld_3d)
end select

! Probe out
@:probe_out()

end subroutine nicas_apply_sqrt_ad

!----------------------------------------------------------------------
! Subroutine: nicas_gen_ens_pert
!> Randomize NICAS to generate an ensemble of perturbation
!----------------------------------------------------------------------
subroutine nicas_gen_ens_pert(nicas,mpl,rng,nam,geom,ne,ens)

implicit none

! Passed variables
class(nicas_type),intent(inout) :: nicas !< NICAS data
type(mpl_type),intent(inout) :: mpl      !< MPI data
type(rng_type),intent(inout) :: rng      !< Random number generator
type(nam_type),intent(in) :: nam         !< Namelist
type(geom_type),intent(in) :: geom       !< Geometry
integer,intent(in) :: ne                 !< Number of members
type(ens_type),intent(inout) :: ens      !< Ensemble

! Local variable
integer :: ie
real(kind_real) :: fld_c0a(geom%nc0a,geom%nl0,nam%nv)
type(cv_type) :: cv_ens(ne)

! Set name
@:set_name(nicas_gen_ens_pert)

! Probe in
@:probe_in()

! Allocation
call ens%alloc(ne,1)

do ie=1,ne
   ! Generate random control vector
   call nicas%random_cv(mpl,rng,nam,cv_ens(ie))

   ! Apply square-root
   call nicas%apply_sqrt(mpl,nam,geom,cv_ens(ie),fld_c0a)

   ! Set metadata
   call ens%mem(ie)%init(mpl,geom%afunctionspace_mg,geom%gmask_mga,nam%variables(1:nam%nv),nam%lev2d,nam%var2d)

   ! Set member from subset Sc0
   call ens%set_c0(mpl,nam,geom,'member',ie,fld_c0a)
end do

! Normalize ensemble members (unit variance)
call ens%normalize(mpl,nam,geom)

! Reset random seed if necessary
if (nam%default_seed) call rng%reseed(mpl)

! Probe out
@:probe_out()

end subroutine nicas_gen_ens_pert

!----------------------------------------------------------------------
! Subroutine: nicas_apply_bens
!> Apply localized ensemble covariance
!----------------------------------------------------------------------
subroutine nicas_apply_bens(nicas,mpl,nam,geom,ens,fld)

implicit none

! Passed variables
class(nicas_type),intent(inout) :: nicas                        !< NICAS data
type(mpl_type),intent(inout) :: mpl                             !< MPI data
type(nam_type),intent(in) :: nam                                !< Namelist
type(geom_type),intent(in) :: geom                              !< Geometry
type(ens_type),intent(in) :: ens                                !< Ensemble
real(kind_real),intent(inout) :: fld(geom%nc0a,geom%nl0,nam%nv) !< Field

! Local variable
integer :: ie
real(kind_real) :: fld_copy(geom%nc0a,geom%nl0,nam%nv),fld_tmp(geom%nc0a,geom%nl0,nam%nv)
real(kind_real) :: pert(geom%nc0a,geom%nl0,nam%nv)

! Set name
@:set_name(nicas_apply_bens)

! Probe in
@:probe_in()

! Copy field
fld_copy = fld

! Apply localized ensemble covariance formula
fld = zero
do ie=1,ens%ne
   ! Get member on subset Sc0
   call ens%get_c0(mpl,nam,geom,'pert',ie,pert)

   ! Schur product
   fld_tmp = pert*fld_copy

   ! Apply NICAS
   call nicas%apply(mpl,nam,geom,fld_tmp)

   ! Schur product
   fld = fld+fld_tmp*pert

   ! Normalization
   fld = fld/real(ens%ne-1,kind_real)
end do

! Probe out
@:probe_out()

end subroutine nicas_apply_bens

!----------------------------------------------------------------------
! Subroutine: nicas_test_adjoint
!> Test NICAS adjoint
!----------------------------------------------------------------------
subroutine nicas_test_adjoint(nicas,mpl,rng,nam,geom)

implicit none

! Passed variables
class(nicas_type),intent(inout) :: nicas !< NICAS data
type(mpl_type),intent(inout) :: mpl      !< MPI data
type(rng_type),intent(inout) :: rng      !< Random number generator
type(nam_type),intent(in) :: nam         !< Namelist
type(geom_type),intent(in) :: geom       !< Geometry

! Local variables
real(kind_real) :: sum1,sum2
real(kind_real) :: fld1(geom%nc0a,geom%nl0,nam%nv),fld1_save(geom%nc0a,geom%nl0,nam%nv)
real(kind_real) :: fld2(geom%nc0a,geom%nl0,nam%nv),fld2_save(geom%nc0a,geom%nl0,nam%nv)

! Set name
@:set_name(nicas_test_adjoint)

! Probe in
@:probe_in()

! Generate random field
call rng%rand(zero,one,fld1_save)
call rng%rand(zero,one,fld2_save)

! Adjoint test
fld1 = fld1_save
fld2 = fld2_save
call nicas%apply(mpl,nam,geom,fld1)
call nicas%apply(mpl,nam,geom,fld2)

! Print result
call mpl%dot_prod(fld1,fld2_save,sum1)
call mpl%dot_prod(fld2,fld1_save,sum2)
write(mpl%info,'(a,e15.8,a,e15.8,a,e15.8)') '--- Full NICAS adjoint test values:                        ', &
 & sum1,' / ',sum2,' / ',two*abs(sum1-sum2)/abs(sum1+sum2)
call mpl%flush
write(mpl%test,'(a,l1)') '    Full NICAS adjoint test result:                        ', &
 & two*abs(sum1-sum2)/abs(sum1+sum2)<repro_th
call mpl%flush

! Reset random seed if necessary
if (nam%default_seed) call rng%reseed(mpl)

! Probe out
@:probe_out()

end subroutine nicas_test_adjoint

!----------------------------------------------------------------------
! Subroutine: nicas_test_dirac
!> Apply NICAS to diracs
!----------------------------------------------------------------------
subroutine nicas_test_dirac(nicas,mpl,nam,geom)

implicit none

! Passed variables
class(nicas_type),intent(inout) :: nicas !< NICAS data
type(mpl_type),intent(inout) :: mpl      !< MPI data
type(nam_type),intent(in) :: nam         !< Namelist
type(geom_type),intent(in) :: geom       !< Geometry

! Local variables
integer :: idir,ic0a,il0
real(kind_real),allocatable :: fld_c0a(:,:,:)

! Set name
@:set_name(nicas_test_dirac)

! Probe in
@:probe_in()

! Allocation
allocate(fld_c0a(geom%nc0a,geom%nl0,nam%nv))
allocate(nicas%dirac(geom%nc0a,geom%nl0,nam%nv))

! Initialization
nicas%dirac = zero

do idir=1,geom%ndir
   ! Generate dirac field
   fld_c0a = zero
   if (geom%iprocdir(idir)==mpl%myproc) fld_c0a(geom%ic0adir(idir),geom%il0dir(idir),geom%ivdir(idir)) = one

   ! Apply NICAS to dirac
   call nicas%apply(mpl,nam,geom,fld_c0a)

   ! Copy points
   do il0=1,geom%nl0
      do ic0a=1,geom%nc0a
         if (geom%inbdir(ic0a,il0)==idir) nicas%dirac(ic0a,il0,:) = fld_c0a(ic0a,il0,:)
      end do
   end do
end do

! Probe out
@:probe_out()

end subroutine nicas_test_dirac

!----------------------------------------------------------------------
! Subroutine: nicas_test_randomization
!> Test NICAS randomization method with respect to theoretical error statistics
!----------------------------------------------------------------------
subroutine nicas_test_randomization(nicas,mpl,rng,nam,geom)

implicit none

! Passed variables
class(nicas_type),intent(inout) :: nicas !< NICAS data
type(mpl_type),intent(inout) :: mpl      !< MPI data
type(rng_type),intent(inout) :: rng      !< Random number generator
type(nam_type),intent(inout) :: nam      !< Namelist variables
type(geom_type),intent(in) :: geom       !< Geometry

! Local variables
integer :: ifac,itest,nefac(nfac_rnd),ens1_ne
integer :: ncid,ntest_id,nfac_id,nefac_id,mse_id,mse_th_id
real(kind_real) :: fld(geom%nc0a,geom%nl0,nam%nv),mse(ntest,nfac_rnd),mse_th(ntest,nfac_rnd),mse_avg,mse_th_avg
real(kind_real),allocatable :: fld_ref(:,:,:,:),fld_save(:,:,:,:)
type(ens_type) :: ens

! Set name
@:set_name(nicas_test_randomization)

! Probe in
@:probe_in()

! Allocation
allocate(fld_ref(geom%nc0a,geom%nl0,nam%nv,ntest))
allocate(fld_save(geom%nc0a,geom%nl0,nam%nv,ntest))

! Define test vectors
write(mpl%info,'(a4,a)') '','Define test vectors'
call mpl%flush
call geom%define_test_vectors(mpl,rng,nam,ntest,fld_save)

! Apply NICAS to test vectors
write(mpl%info,'(a4,a)') '','Apply NICAS to test vectors: '
call mpl%flush(newl=.false.)
call mpl%prog_init(ntest)
fld_ref = fld_save
do itest=1,ntest
   ! Apply vector
   call nicas%apply(mpl,nam,geom,fld_ref(:,:,:,itest))

   ! Update
   call mpl%prog_print(itest)
end do
call mpl%prog_final

! Save namelist variables
ens1_ne = nam%ens1_ne

write(mpl%info,'(a4,a)') '','Test randomization for various ensemble sizes:'
call mpl%flush
do ifac=1,nfac_rnd
   ! Ensemble size
   nefac(ifac) = max(int(real(ifac,kind_real)/real(nfac_rnd,kind_real)*real(ens1_ne,kind_real)),3)
   nam%ens1_ne = nefac(ifac)
   write(mpl%info,'(a7,a,i6,a)') '','Ensemble sizes: ',nefac(ifac),' members'
   call mpl%flush

   ! Randomize ensemble
   write(mpl%info,'(a10,a)') '','Randomization'
   call mpl%flush
   call nicas%gen_ens_pert(mpl,rng,nam,geom,nefac(ifac),ens)

   ! Test randomized ensemble
   write(mpl%info,'(a10,a)') '','Apply NICAS to test vectors: '
   call mpl%flush(newl=.false.)
   call mpl%prog_init(ntest)
   do itest=1,ntest
      ! Test NICAS
      fld = fld_save(:,:,:,itest)
      call ens%apply_bens(mpl,nam,geom,fld)

      ! RMSE
      fld = fld-fld_ref(:,:,:,itest)
      call mpl%dot_prod(fld,fld,mse(itest,ifac))
      call mpl%dot_prod(fld_ref(:,:,:,itest),fld_ref(:,:,:,itest),mse_th(itest,ifac))
      mse_th(itest,ifac) = one/real(nam%ens1_ne-1,kind_real)*(mse_th(itest,ifac)+real(geom%nc0*geom%nl0*nam%nv,kind_real))

      ! Update
      call mpl%prog_print(itest)
   end do
   call mpl%prog_final

   ! Print scores
   mse_avg = sum(mse(:,ifac))/real(ntest,kind_real)
   mse_th_avg = sum(mse_th(:,ifac))/real(ntest,kind_real)
   write(mpl%test,'(a10,a,e15.8,a,e15.8,a,f5.3)') '','MSE (exp. / th. / ratio): ',mse_avg,' / ',mse_th_avg,' / ',mse_avg/mse_th_avg
   call mpl%flush

   ! Release memory
   call ens%dealloc
end do

! Reset namelist variables
nam%ens1_ne = ens1_ne

if (mpl%main) then
   ! Create file
   ncid = create_file(mpl,trim(nam%prefix)//'randomization',0)

   ! Define dimensions
   ntest_id = define_dim(mpl,ncid,'ntest',ntest)
   nfac_id = define_dim(mpl,ncid,'nfac',nfac_rnd)

   ! Define variables
   nefac_id = define_var(mpl,ncid,'nefac','real',(/nfac_id/))
   mse_id = define_var(mpl,ncid,'mse','real',(/ntest_id,nfac_id/))
   mse_th_id = define_var(mpl,ncid,'mse_th','real',(/ntest_id,nfac_id/))

   ! Write variables
   call put_var(mpl,ncid,nefac_id,nefac)
   call put_var(mpl,ncid,mse_id,mse)
   call put_var(mpl,ncid,mse_th_id,mse_th)

   ! Close file
   call close_file(mpl,ncid)
end if

! Release memory
deallocate(fld_ref)
deallocate(fld_save)

! Reset random seed if necessary
if (nam%default_seed) call rng%reseed(mpl)

! Probe out
@:probe_out()

end subroutine nicas_test_randomization

end module type_nicas
