#:include 'generics.fypp'
#:include 'instrumentation.fypp'
!----------------------------------------------------------------------
! Module: type_nam
!> Namelist derived type
! Author: Benjamin Menetrier
! Licensing: this code is distributed under the CeCILL-C license
! Copyright 2015-... UCAR, CERFACS, METEO-FRANCE and IRIT
!----------------------------------------------------------------------
module type_nam

use fckit_configuration_module, only: fckit_configuration
use tools_const, only: zero,hundredth,half,one,ten,hundred,pi,req,deg2rad,rad2deg
use tools_kinds, only: kind_real,kind_int,huge_real
use tools_func, only: cholesky,convert_i2l,zss_minval
use tools_repro, only: eq
use type_mpl, only: mpl_type
@:use_probe()

implicit none

type nam_type
   ! General section
   logical :: default_seed                                    !< Default seed for random numbers
   logical :: repro_ops                                       !< Reproducibility operators
   real(kind_real) :: repro_th                                !< Reproducibility threshold
   real(kind_real) :: universe_radius                         !< Universe radius [in meters]
   character(len=1024) :: sampling_method                     !< Sampling method

   ! I/O section
   character(len=1024) :: datadir                             !< Data directory
   character(len=1024) :: prefix                              !< Files prefix
   logical :: new_files                                       !< Write in new files (default is .true.)
   logical :: parallel_netcdf                                 !< Parallel NetCDF I/O
   integer :: nprocio                                         !< Number of I/O tasks
   character(len=1024),allocatable :: alias_code(:)           !< Alias keys in code
   character(len=1024),allocatable :: alias_file(:)           !< Alias values in file
   character(len=1024) :: fname_samp                          !< Sampling file
   character(len=1024) :: fname_vbal_cov_default              !< Vertical covariance files default base
   character(len=1024),allocatable :: fname_vbal_cov(:)       !< Vertical covariance files
   character(len=1024) :: fname_vbal                          !< Vertical balance file
   character(len=1024) :: fname_mom_default                   !< Moments files default base
   character(len=1024),allocatable :: fname_mom1(:)           !< Moments files, ensemble 1
   character(len=1024),allocatable :: fname_mom2(:)           !< Moments files, ensemble 2
   character(len=1024) :: fname_universe_radius               !< Universe radius file
   character(len=1024) :: fname_nicas                         !< NICAS file
   character(len=1024) :: fname_wind                          !< Wind transform file
   character(len=1024) :: fname_gsi_data                      !< GSI data file
   character(len=1024) :: fname_gsi_nam                       !< GSI namelist

   ! Drivers section
   logical :: compute_cov1                                    !< Compute covariance, ensemble 1
   logical :: compute_cov2                                    !< Compute covariance, ensemble 2
   logical :: compute_cor1                                    !< Compute correlation, ensemble 1
   logical :: compute_cor2                                    !< Compute correlation, ensemble 2
   logical :: compute_loc1                                    !< Compute localization, ensemble 1
   logical :: compute_loc2                                    !< Compute localization, ensemble 2
   logical :: compute_hyb                                     !< Compute hybrid weights
   logical :: new_hdiag                                       !< Compute diagnostics
   character(len=1024) :: hybrid_source                       !< Hybrid term source ('randomized static' or 'lowres ensemble')
   character(len=1024) :: strategy                            !< Multivariate strategy ('univariate', 'duplicated', 'duplicated and weighted' or 'crossed')
   logical :: new_normality                                   !< New normality test
   logical :: load_samp_local                                 !< Read local sampling
   logical :: load_samp_global                                !< Read global sampling
   logical :: write_samp_local                                !< Write local sampling
   logical :: write_samp_global                               !< Write global sampling
   logical :: write_samp_grids                                !< Write sampling grids
   logical :: new_vbal_cov                                    !< New vertical covariance
   logical :: load_vbal_cov                                   !< Read local vertical covariance
   logical :: write_vbal_cov                                  !< Write local vertical covariancee
   logical :: new_vbal                                        !< Compute vertical balance operator
   logical :: load_vbal                                       !< Read local vertical balance operator
   logical :: write_vbal                                      !< Write vertical balance operator
   logical :: new_var                                         !< Compute variance
   logical :: new_mom                                         !< Compute moments
   logical :: load_mom                                        !< Read sampling moments
   logical :: write_mom                                       !< Write sampling moments
   logical :: write_hdiag                                     !< Write diagnostics
   logical :: write_hdiag_detail                              !< Write components detail
   logical :: load_universe_radius                            !< Read universe radius
   logical :: write_universe_radius                           !< Write universe radius
   logical :: new_nicas                                       !< Compute NICAS parameters
   logical :: load_nicas_local                                !< Read local NICAS parameters
   logical :: load_nicas_global                               !< Read global NICAS parameters
   logical :: write_nicas_local                               !< Write local NICAS parameters
   logical :: write_nicas_global                              !< Write global NICAS parameters
   logical :: write_nicas_grids                               !< Write NICAS grids
   logical :: write_nicas_steps                               !< Write NICAS steps
   logical :: new_wind                                        !< Compute wind transform
   logical :: load_wind_local                                 !< Read local wind transform
   logical :: write_wind_local                                !< Write local wind transform
   logical :: check_vbal                                      !< Test vertical balance inverse
   logical :: check_adjoints                                  !< Test adjoints
   integer :: check_normalization                             !< Test NICAS normalization (number of tests)
   logical :: check_dirac                                     !< Test NICAS application on diracs
   logical :: check_randomization                             !< Test NICAS randomization
   logical :: check_consistency                               !< Test HDIAG-NICAS consistency
   logical :: check_optimality                                !< Test HDIAG optimality
   logical :: from_gsi                                        !< Interpolate vertical balance, standard-deviation or length-scales from GSI data

   ! Model section
   integer :: nl0                                             !< Number of levels
   character(len=1024) :: lev2d                               !< Level for 2D variables ('first' or 'last')
   integer :: nv                                              !< Number of variables
   character(len=1024),allocatable :: variables(:)            !< Variables names
   logical,allocatable :: var2d(:)                            !< 2D variable flag
   integer :: ng                                              !< Number of groups of variables
   character(len=1024),allocatable :: group_names(:)          !< Group of variables names
   integer,allocatable :: group_index(:)                      !< Variables group index
   logical :: mask_check                                      !< Check that sampling couples and interpolations do not cross mask boundaries

   ! Ensemble sizes
   integer :: ens1_ne                                         !< Ensemble 1 size
   integer :: ens1_nsub                                       !< Ensemble 1 sub-ensembles number
   integer :: ens2_ne                                         !< Ensemble 2 size
   integer :: ens2_nsub                                       !< Ensemble 2 sub-ensembles number

   ! Sampling section
   integer :: nc1                                             !< Computation grid size
   integer :: nc2                                             !< Diagnostic grid size
   integer :: nc3                                             !< Number of distance classes
   integer :: nc4                                             !< Number of angular sectors
   real(kind_real) :: dc                                      !< Class size, should be larger than the typical grid cell size [in meters]
   integer :: nl0r                                            !< Reduced number of levels for diagnostics
   logical :: local_diag                                      !< Activate local diagnostics
   real(kind_real) :: local_rad                               !< Local diagnostics calculation radius [in meters]
   real(kind_real) :: local_dlat                              !< Local diagnostics calculation latitude band half-width [in degrees]
   character(len=1024) :: samp_draw_type                      !< Diagnostic draw type ('random' or 'octahedral')
   integer :: irmax                                           !< Maximum number of random number draws
   character(len=2) :: samp_interp_type                       !< Sampling C2B to C0A interpolation type ('c0': C0 mesh-based, 'c1': C1 mesh-based or 'si': smooth interpolation)
   integer :: nmask                                           !< Number of masks
   character(len=1024),allocatable :: mask_type(:)            !< Mask restriction type
   real(kind_real),allocatable :: mask_th(:)                  !< Mask threshold
   character(len=1024),allocatable :: mask_lu(:)              !< Mask threshold side ('lower' if mask_th is the lower bound, resp. 'upper')
   character(len=1024),allocatable :: mask_variable(:)        !< Mask variable
   integer :: ncontig_th                                      !< Threshold on vertically contiguous points for sampling mask (0 to skip the test)

   ! Diagnostics section
   integer :: ne                                              !< Ensemble size
   integer :: ne_lr                                           !< Ensemble size of the low-resolution term (ensemble 2)
   logical :: gau_approx                                      !< Gaussian approximation for asymptotic quantities
   real(kind_real) :: gen_kurt_th                             !< Threshold on generalized kurtosis (3.0 = Gaussian distribution)
   integer :: avg_nbins                                       !< Number of bins for averaged statistics histograms
   real(kind_real) :: lengths_scaling                         !< Support radius scaling in CMAT from HDIAG

   ! Vertical balance section
   logical,allocatable :: vbal_block(:,:)                     !< Activation of vertical balance
   logical,allocatable :: vbal_diag_auto(:,:)                 !< Diagonal auto-covariance for the inversion
   logical,allocatable :: vbal_diag_reg(:,:)                  !< Diagonal regression
   real(kind_real),allocatable :: vbal_id_coef(:,:)           !< Scalar coefficients for identity vertical balance
   logical :: vbal_pseudo_inv                                 !< Pseudo-inverse for auto-covariance
   integer :: vbal_pseudo_inv_mmax                            !< Dominant mode for pseudo-inverse
   real(kind_real) :: vbal_pseudo_inv_var_th                  !< Variance threshold to compute the dominant mode for pseudo-inverse
   logical :: vbal_id                                         !< Identity vertical balance for tests

   ! Variance section
   logical :: forced_var                                      !< Force specific variance
   real(kind_real),allocatable :: stddev(:,:)                 !< Forced standard-deviation
   logical :: var_filter                                      !< Filter variance
   integer :: var_niter                                       !< Number of iterations for the variance filtering (0 for uniform variance)
   integer :: var_npass                                       !< Number of passes for the variance filtering (0 for uniform variance)
   real(kind_real),allocatable :: var_rhflt(:,:)              !< Variance initial filtering support radius [in meters]

   ! Optimality test section
   integer :: optimality_nfac                                 !< Number of length-scale factors for optimization
   real(kind_real) :: optimality_delta                        !< Increments of length-scale factors for optimization
   integer :: optimality_ntest                                !< Number of test vectors for optimization

   ! Fit section
   real(kind_real) :: diag_rhflt                              !< Horizontal filtering suport radius [in meters]
   real(kind_real) :: diag_rvflt                              !< Vertical filtering support radius
   integer :: fit_dl0                                         !< Number of levels between interpolation levels
   integer :: fit_ncmp                                        !< Number of components in the fit function

   ! Local profiles section
   integer :: nldwv                                           !< Number of local diagnostics profiles to write (for local_diag = .true.)
   real(kind_real),allocatable :: lon_ldwv(:)                 !< Longitudes of the local diagnostics profiles to write [in degrees]
   real(kind_real),allocatable :: lat_ldwv(:)                 !< Latitudes of the local diagnostics profiles to write [in degrees]
   character(len=1024),allocatable :: name_ldwv(:)            !< Name of the local diagnostics profiles to write

   ! NICAS section
   real(kind_real) :: resol                                   !< Resolution
   integer :: nc1max                                          !< Maximum size of the Sc1 subset
   character(len=1024) :: nicas_draw_type                     !< NICAS draw type ('random' or 'octahedral')
   logical :: forced_radii                                    !< Force specific support radii
   real(kind_real),allocatable :: rh(:,:)                     !< Forced horizontal support radius [in meters]
   real(kind_real),allocatable :: rv(:,:)                     !< Forced vertical support radius
   real(kind_real),allocatable :: loc_wgt_sqrt(:,:)           !< Weights square-root for the 'block_weighted' strategy
   character(len=2),allocatable :: nicas_interp_type(:)       !< NICAS C1B to C0A interpolation type ('c0': C0 mesh-based, 'c1': C1 mesh-based or 'si': smooth interpolation)
   integer :: norm_rand_size                                  !< Normalization randomization size (default is 0, which means exact normalization)
   logical :: pos_def_test                                    !< Positive-definiteness test
   logical :: interp_test                                     !< Horizontal NICAS interpolation test
   integer :: file_component                                  !< Overriding component in file

   ! Psichitouv section
   integer :: wind_nlon                                       !< Number of longitudes for the regular grid
   integer :: wind_nlat                                       !< Number of latitudes for the regular grid
   integer :: wind_nsg                                        !< Half-width of the Savitzky-Golay to compute derivatives
   real(kind_real) :: wind_inflation                          !< Wind inflation to compensate the Savitzky-Golay smoothing

   ! Dirac section
   integer :: ndir                                            !< Number of Diracs
   real(kind_real),allocatable :: londir(:)                   !< Diracs longitudes [in degrees]
   real(kind_real),allocatable :: latdir(:)                   !< Diracs latitudes [in degrees]
   integer,allocatable :: levdir(:)                           !< Diracs level
   integer,allocatable :: ivdir(:)                            !< Diracs variable indices

   ! External section
   logical :: iterative_algo                                  !< Iterative algorithm (ensemble members loaded sequentially)
contains
   procedure :: init => nam_init
   procedure :: final => nam_final
   procedure :: from_conf => nam_from_conf
   procedure :: check => nam_check
   procedure :: alias => nam_alias
   #:for dtype in dtypes_irls
     procedure :: nam_get_${dtype}$
   #:endfor
   procedure :: nam_get_int_value
   procedure :: nam_get_real_value_or_profile
@:init_procedure(6)
   generic :: get => &
   #:for dtype in dtypes_irls
@:add_procedure(nam_get_${dtype}$)
   #:endfor
@:add_procedure(nam_get_int_value)
@:add_procedure(nam_get_real_value_or_profile)
  procedure :: read_universe_radius => nam_read_universe_radius
end type nam_type

interface print_section
   module procedure nam_print_conf
   module procedure nam_print_confs
end interface

interface
  subroutine bump_config_init_c(c_conf) bind(c,name='bump_config_init_f90')
  use, intrinsic :: iso_c_binding
  implicit none
  type(c_ptr),value :: c_conf
  end subroutine bump_config_init_c
end interface

private
public :: nam_type

contains

!----------------------------------------------------------------------
! Subroutine: nam_init
!> Intialize with default values
!----------------------------------------------------------------------
subroutine nam_init(nam,mpl)

implicit none

! Passed variables
class(nam_type),intent(inout) :: nam !< Namelist
type(mpl_type),intent(inout) :: mpl  !< MPI data

! Local variables
type(fckit_configuration) :: conf

! Set name
@:set_name(nam_init)

! Probe in
@:probe_in()

! Initialize empty configuration
conf = fckit_configuration()

! Get default values from C++
call bump_config_init_c(conf%c_ptr())

! Initialize nam
nam%nv = 0
nam%ng = 0
nam%nmask = 0
nam%nldwv = 0
nam%ndir = 0
call nam%from_conf(mpl,conf,.false.)

! Probe out
@:probe_out()

end subroutine nam_init

!----------------------------------------------------------------------
! Subroutine: nam_from_conf
!> Intialize from configuration
!----------------------------------------------------------------------
subroutine nam_from_conf(nam,mpl,conf,verbose)

implicit none

! Passed variables
class(nam_type),intent(inout) :: nam         !< Namelist
type(mpl_type),intent(inout) :: mpl          !< MPI data
type(fckit_configuration),intent(in) :: conf !< Configuration
logical,intent(in),optional :: verbose       !< Print configuration sections

! Local variables
integer :: iv,jv,iconf,rank,itest,it,ivv,jvv,ig
integer,allocatable :: vbal_order(:)
real(kind_real) :: real_scalar
real(kind_real),allocatable :: loc_wgt(:,:)
logical :: lverbose,color_log,found,valid
character(len=:),allocatable :: str,str_bal,str_unbal
character(len=:),allocatable :: str_array(:),str_array_row(:),str_array_col(:)
type(fckit_configuration) :: section
type(fckit_configuration),allocatable :: confs(:)

! Set name
@:set_name(nam_from_conf)

! Probe in
@:probe_in()

! Local flag
lverbose = .true.
if (present(verbose)) lverbose = verbose

! Missing value
call nam%get(conf,'msvalr',mpl%msv%valr)
if (lverbose) then
   write(mpl%info,'(a)') '-------------------------------------------------------------------'
   call mpl%flush
   write(mpl%info,'(a)') '--- Missing values'
   call mpl%flush
   write(mpl%info,'(a4,a,e15.8)') '','Real:    ',mpl%msv%valr
   call mpl%flush
   write(mpl%info,'(a4,a,i6)') '','Integer: ',mpl%msv%vali
   call mpl%flush
end if

! Configuration parameters
if (lverbose) then
   write(mpl%info,'(a)') '-------------------------------------------------------------------'
   call mpl%flush
   write(mpl%info,'(a)') '--- Configuration parameters'
   call mpl%flush
end if

! General section
if (conf%get('general',section)) then
   if (lverbose) call print_section(mpl,section,'General')
   if (section%has('color log')) then
      call section%get_or_die('color log',color_log)
      if (color_log) then
         mpl%black = char(27)//'[0;0m'
         mpl%green = char(27)//'[0;32m'
         mpl%peach = char(27)//'[1;91m'
         mpl%aqua = char(27)//'[1;36m'
         mpl%purple = char(27)//'[1;35m'
         mpl%wng_color = char(27)//'[0;37;42;1m'
      end if
   end if
   call nam%get(section,'testing',mpl%testing)
   call nam%get(section,'default seed',nam%default_seed)
   call nam%get(section,'reproducibility operators',nam%repro_ops)
   call nam%get(section,'reproducibility threshold',nam%repro_th)
   call nam%get(section,'universe length-scale',nam%universe_radius)
   call nam%get(section,'sampling method',nam%sampling_method)
end if

! I/O param
if (conf%get('io',section)) then
   if (lverbose) call print_section(mpl,section,'I/O')
   call nam%get(section,'data directory',nam%datadir)
   call nam%get(section,'files prefix',nam%prefix)
   call nam%get(section,'new files',nam%new_files)
   call nam%get(section,'parallel netcdf',nam%parallel_netcdf)
   call nam%get(section,'io tasks',nam%nprocio)
   if (section%get('alias',confs)) then
      if (size(confs)>0) then
         ! Release memory
         if (allocated(nam%alias_code)) deallocate(nam%alias_code)
         if (allocated(nam%alias_file)) deallocate(nam%alias_file)

         ! Allocation
         allocate(nam%alias_code(size(confs)))
         allocate(nam%alias_file(size(confs)))

         ! Copy
         do iconf=1,size(confs)
            call confs(iconf)%get_or_die('in code',str)
            nam%alias_code(iconf) = str
            call confs(iconf)%get_or_die('in file',str)
            nam%alias_file(iconf) = str
         end do
      end if
   end if
   call nam%get(section,'overriding sampling file',nam%fname_samp)
   nam%fname_vbal_cov_default = ''
   if (section%get('overriding vertical covariance file',str_array)) then
      if (size(str_array)>0) then
         ! Release memory
         if (allocated(nam%fname_vbal_cov)) deallocate(nam%fname_vbal_cov)

         ! Allocation
         allocate(nam%fname_vbal_cov(size(str_array)))

         ! Copy
         nam%fname_vbal_cov = str_array
      end if
   end if
   call nam%get(section,'overriding vertical balance file',nam%fname_vbal)
   nam%fname_mom_default = ''
   if (section%get('overriding moments file',str_array)) then
      if (size(str_array)>0) then
         ! Release memory
         if (allocated(nam%fname_mom1)) deallocate(nam%fname_mom1)

         ! Allocation
         allocate(nam%fname_mom1(size(str_array)))

         ! Copy
         nam%fname_mom1 = str_array
      end if
   end if
   if (section%get('overriding lowres moments file',str_array)) then
      if (size(str_array)>0) then
         ! Release memory
         if (allocated(nam%fname_mom2)) deallocate(nam%fname_mom2)

         ! Allocation
         allocate(nam%fname_mom2(size(str_array)))

         ! Copy
         nam%fname_mom2 = str_array
      end if
   end if
   call nam%get(section,'overriding universe radius file',nam%fname_universe_radius)
   call nam%get(section,'overriding nicas file',nam%fname_nicas)
   call nam%get(section,'overriding psichitouv file',nam%fname_wind)
   call nam%get(section,'gsi data file',nam%fname_gsi_data)
   call nam%get(section,'gsi namelist',nam%fname_gsi_nam)
end if

! Drivers section
if (conf%get('drivers',section)) then
   if (lverbose) call print_section(mpl,section,'Drivers')
   call nam%get(section,'compute covariance',nam%compute_cov1)
   call nam%get(section,'compute lowres covariance',nam%compute_cov2)
   call nam%get(section,'compute correlation',nam%compute_cor1)
   call nam%get(section,'compute lowres correlation',nam%compute_cor2)
   call nam%get(section,'compute localization',nam%compute_loc1)
   call nam%get(section,'compute lowres localization',nam%compute_loc2)
   call nam%get(section,'compute hybrid weights',nam%compute_hyb)
   nam%new_hdiag = nam%compute_cov1.or.nam%compute_cor1.or.nam%compute_loc1.or. &
 & nam%compute_cov2.or.nam%compute_cor2.or.nam%compute_loc2.or.nam%compute_hyb
   call nam%get(section,'hybrid source',nam%hybrid_source)
   call nam%get(section,'multivariate strategy',nam%strategy)
   call nam%get(section,'compute normality',nam%new_normality)
   call nam%get(section,'read local sampling',nam%load_samp_local)
   call nam%get(section,'read global sampling',nam%load_samp_global)
   call nam%get(section,'write local sampling',nam%write_samp_local)
   call nam%get(section,'write global sampling',nam%write_samp_global)
   call nam%get(section,'write sampling grids',nam%write_samp_grids)
   call nam%get(section,'compute vertical covariance',nam%new_vbal_cov)
   call nam%get(section,'read vertical covariance',nam%load_vbal_cov)
   call nam%get(section,'write vertical covariance',nam%write_vbal_cov)
   call nam%get(section,'compute vertical balance',nam%new_vbal)
   call nam%get(section,'read vertical balance',nam%load_vbal)
   call nam%get(section,'write vertical balance',nam%write_vbal)
   call nam%get(section,'compute variance',nam%new_var)
   call nam%get(section,'compute moments',nam%new_mom)
   call nam%get(section,'read moments',nam%load_mom)
   call nam%get(section,'write moments',nam%write_mom)
   call nam%get(section,'write diagnostics',nam%write_hdiag)
   call nam%get(section,'write diagnostics detail',nam%write_hdiag_detail)
   call nam%get(section,'read universe radius',nam%load_universe_radius)
   call nam%get(section,'write universe radius',nam%write_universe_radius)
   call nam%get(section,'compute nicas',nam%new_nicas)
   call nam%get(section,'read local nicas',nam%load_nicas_local)
   call nam%get(section,'read global nicas',nam%load_nicas_global)
   call nam%get(section,'write local nicas',nam%write_nicas_local)
   call nam%get(section,'write global nicas',nam%write_nicas_global)
   call nam%get(section,'write nicas grids',nam%write_nicas_grids)
   call nam%get(section,'write nicas steps',nam%write_nicas_steps)
   call nam%get(section,'compute psichitouv',nam%new_wind)
   call nam%get(section,'read local psichitouv',nam%load_wind_local)
   call nam%get(section,'write local psichitouv',nam%write_wind_local)
   call nam%get(section,'vertical balance inverse test',nam%check_vbal)
   call nam%get(section,'adjoints test',nam%check_adjoints)
   call nam%get(section,'normalization test',nam%check_normalization)
   call nam%get(section,'internal dirac test',nam%check_dirac)
   call nam%get(section,'randomization test',nam%check_randomization)
   call nam%get(section,'internal consistency test',nam%check_consistency)
   call nam%get(section,'localization optimality test',nam%check_optimality)
   call nam%get(section,'interpolate from gsi data',nam%from_gsi)
end if

! Model section
if (conf%get('model',section)) then
   if (lverbose) call print_section(mpl,section,'Model')
   call nam%get(section,'nl0',nam%nl0)
   call nam%get(section,'level for 2d variables',nam%lev2d)
   if (section%get('variables',str_array)) then
      nam%nv = size(str_array)
      if (nam%nv>0) then
         ! Release memory
         if (allocated(nam%variables)) deallocate(nam%variables)

         ! Allocation
         allocate(nam%variables(nam%nv))
         allocate(nam%var2d(nam%nv))

         ! Copy
         nam%variables = str_array

         ! Get 2D variables
         nam%var2d = .false.
         if (section%get('2d variables',str_array)) then
            do it=1,size(str_array)
               do iv=1,nam%nv
                  if (str_array(it)==nam%variables(iv)) then
                     nam%var2d(iv) = .true.
                  end if
               end do
            end do
         end if
         
         ! Groups
         allocate(nam%group_index(nam%nv))
         if (section%get('groups',confs)) then
            nam%ng = size(confs)
            allocate(nam%group_names(nam%ng))
            nam%group_index = 0
            do iconf=1,size(confs)
               call nam%get(confs(iconf),'group name',nam%group_names(iconf))
               call confs(iconf)%get_or_die('variables',str_array)
               do it=1,size(str_array)
                  do iv=1,nam%nv
                      if (str_array(it)==nam%variables(iv)) then
                         if (nam%group_index(iv)==0) then
                            nam%group_index(iv) = iconf
                         else
                            call mpl%abort('${subr}$','variable '//trim(nam%variables(iv))//'is present it distinct groups')
                         end if
                      end if
                  end do
               end do
            end do
         else
            select case (nam%strategy)
            case ('duplicated','duplicated and weighted')
               nam%ng = 1
               allocate(nam%group_names(nam%ng))
               nam%group_names(1) = 'common'
               nam%group_index = 1
            case default
               nam%ng = nam%nv
               allocate(nam%group_names(nam%ng))
               do iv=1,nam%nv
                  nam%group_names(iv) = nam%variables(iv)
                  nam%group_index(iv) = iv
               end do
            end select
         end if
      end if
   end if
   call nam%get(section,'do not cross mask boundaries',nam%mask_check)
end if

! Ensemble sizes
if (conf%get('ensemble sizes',section)) then
   if (lverbose) call print_section(mpl,section,'Ensemble sizes')
   call nam%get(section,'total ensemble size',nam%ens1_ne)
   call nam%get(section,'sub-ensembles',nam%ens1_nsub)
   call nam%get(section,'total lowres ensemble size',nam%ens2_ne)
   call nam%get(section,'lowres sub-ensembles',nam%ens2_nsub)
end if

! Sampling section
if (conf%get('sampling',section)) then
   if (lverbose) call print_section(mpl,section,'Sampling')
   call nam%get(section,'computation grid size',nam%nc1)
   call nam%get(section,'diagnostic grid size',nam%nc2)
   call nam%get(section,'distance classes',nam%nc3)
   call nam%get(section,'angular sectors',nam%nc4)
   call nam%get(section,'distance class width',nam%dc)
   call nam%get(section,'reduced levels',nam%nl0r)
   call nam%get(section,'local diagnostic',nam%local_diag)
   call nam%get(section,'averaging length-scale',nam%local_rad)
   call nam%get(section,'averaging latitude width',nam%local_dlat)
   call nam%get(section,'grid type',nam%samp_draw_type)
   call nam%get(section,'max number of draws',nam%irmax)
   call nam%get(section,'interpolation type',nam%samp_interp_type)
   if (section%get('masks',confs)) then
      nam%nmask = size(confs)
      if (nam%nmask>0) then
         ! Release memory
         if (allocated(nam%mask_type)) deallocate(nam%mask_type)
         if (allocated(nam%mask_th)) deallocate(nam%mask_th)
         if (allocated(nam%mask_lu)) deallocate(nam%mask_lu)
         if (allocated(nam%mask_variable)) deallocate(nam%mask_variable)

         ! Allocation
         allocate(nam%mask_type(nam%nmask))
         allocate(nam%mask_th(nam%nmask))
         allocate(nam%mask_lu(nam%nmask))
         allocate(nam%mask_variable(nam%nmask))

         ! Initialization
         do iconf=1,size(confs)
            nam%mask_type(iconf) = ''
            nam%mask_th(iconf) = mpl%msv%valr
            nam%mask_lu(iconf) = ''
            nam%mask_variable(iconf) = ''
         end do

         ! Get values
         do iconf=1,size(confs)
            call nam%get(confs(iconf),'type',nam%mask_type(iconf))
            call nam%get(confs(iconf),'threshold',nam%mask_th(iconf))
            call nam%get(confs(iconf),'side',nam%mask_lu(iconf))
            call nam%get(confs(iconf),'variable',nam%mask_variable(iconf))
         end do
      end if
   end if
   call nam%get(section,'contiguous levels threshold',nam%ncontig_th)
end if

! Diagnostics section
if (conf%get('diagnostics',section)) then
   if (lverbose) call print_section(mpl,section,'diagnostics')
   call nam%get(section,'target ensemble size',nam%ne)
   call nam%get(section,'target lowres ensemble size',nam%ne_lr)
   call nam%get(section,'gaussian approximation',nam%gau_approx)
   call nam%get(section,'generalized kurtosis threshold',nam%gen_kurt_th)
   call nam%get(section,'histogram bins',nam%avg_nbins)
   call nam%get(section,'diagnosed lengths scaling',nam%lengths_scaling)
end if

! Vertical balance section
if (conf%get('vertical balance',section)) then
   if (lverbose) call print_section(mpl,section,'Vertical balance')
   if (section%get('vbal',confs)) then
      if ((size(confs)>0).and.(nam%nv>0)) then
         ! Release memory
         if (allocated(nam%vbal_block)) deallocate(nam%vbal_block)
         if (allocated(nam%vbal_diag_auto)) deallocate(nam%vbal_diag_auto)
         if (allocated(nam%vbal_diag_reg)) deallocate(nam%vbal_diag_reg)
         if (allocated(nam%vbal_id_coef)) deallocate(nam%vbal_id_coef)

         ! Allocation
         allocate(nam%vbal_block(nam%nv,nam%nv))
         allocate(nam%vbal_diag_auto(nam%nv,nam%nv))
         allocate(nam%vbal_diag_reg(nam%nv,nam%nv))
         allocate(nam%vbal_id_coef(nam%nv,nam%nv))
         allocate(vbal_order(nam%nv))

         ! Get initial matrix
         nam%vbal_block = .false.
         do iconf=1,size(confs)
            call confs(iconf)%get_or_die('balanced variable',str_bal)
            call confs(iconf)%get_or_die('unbalanced variable',str_unbal)
            found = .false.
            do jv=1,nam%nv
               do iv=1,nam%nv
                  if ((str_bal==nam%variables(iv)).and.(str_unbal==nam%variables(jv))) then
                     if (iv==jv) then
                        call mpl%abort('${subr}$','vbal item should be off-diagonal')
                     else
                        if (nam%vbal_block(iv,jv)) then
                           call mpl%abort('${subr}$','redundant vbal item')
                        else
                           nam%vbal_block(iv,jv) = .true.
                           found = .true.
                        end if
                     end if
                  end if
               end do
            end do
            if (.not.found) call mpl%abort('${subr}$','wrong vbal item')
         end do

         ! Get vbal variables order
         vbal_order = 0
         rank = 0

         ! Independent variables first
         do iv=1,nam%nv
            if (count(nam%vbal_block(iv,:))==0) then
               rank = rank+1
               vbal_order(rank) = iv
            end if
         end do

         ! Find least-dependent variables progressively
         iv = 0
         itest = 0
         do while (any(vbal_order==0))
            ! Check number of iterations
            itest = itest+1
            if (itest>nam%nv**2) call mpl%abort('${subr}$','inconsistent vbal items')

            ! Increment variable index
            iv = iv+1
            if (iv>nam%nv) iv = 1

            if (.not.any(vbal_order(1:rank)==iv)) then
               ! Check variable dependencies
               valid = .true.
               do jv=1,nam%nv
                  if (nam%vbal_block(iv,jv)) then
                     if (.not.any(vbal_order(1:rank)==jv)) valid = .false.
                  end if
               end do

               ! Check if variable can be added now
               if (valid) then
                  rank = rank+1
                  vbal_order(rank) = iv
               end if
            end if
         end do

         ! Reorder variables
         nam%variables(1:nam%nv) = nam%variables(vbal_order)
         nam%vbal_block = nam%vbal_block(vbal_order,vbal_order)

         ! Set section
         do iconf=1,size(confs)
            call confs(iconf)%get_or_die('balanced variable',str_bal)
            call confs(iconf)%get_or_die('unbalanced variable',str_unbal)
            do jv=1,nam%nv
               do iv=1,nam%nv
                  if ((str_bal==nam%variables(iv)).and.(str_unbal==nam%variables(jv))) then
                     call confs(iconf)%get_or_die('diagonal autocovariance',nam%vbal_diag_auto(iv,jv))
                     call confs(iconf)%get_or_die('diagonal regression',nam%vbal_diag_reg(iv,jv))
                     call confs(iconf)%get_or_die('identity block weight',nam%vbal_id_coef(iv,jv))
                  end if
               end do
            end do
         end do

         ! Release memory
         deallocate(vbal_order)
      end if
   end if
   call nam%get(section,'pseudo inverse',nam%vbal_pseudo_inv)
   call nam%get(section,'dominant mode',nam%vbal_pseudo_inv_mmax)
   call nam%get(section,'variance threshold',nam%vbal_pseudo_inv_var_th)
   call nam%get(section,'identity blocks',nam%vbal_id)
end if

! Variance section
if (conf%get('variance',section)) then
   if (lverbose) call print_section(mpl,section,'Variance')
   call nam%get(section,'explicit stddev',nam%forced_var)
   call nam%get(mpl,section,'stddev',nam%stddev)
   call nam%get(section,'objective filtering',nam%var_filter)
   call nam%get(section,'filtering iterations',nam%var_niter)
   call nam%get(section,'filtering passes',nam%var_npass)
   call nam%get(mpl,section,'initial length-scale',nam%var_rhflt,one/req)
end if

! Optimality test section
if (conf%get('optimality test',section)) then
   if (lverbose) call print_section(mpl,section,'Optimality test')
   call nam%get(section,'half number of factors',nam%optimality_nfac)
   call nam%get(section,'factors increment',nam%optimality_delta)
   call nam%get(section,'test vectors',nam%optimality_ntest)
end if

! Fit section
if (conf%get('fit',section)) then
   if (lverbose) call print_section(mpl,section,'Fit')
   call nam%get(section,'horizontal filtering length-scale',nam%diag_rhflt)
   call nam%get(section,'vertical filtering length-scale',nam%diag_rvflt)
   call nam%get(section,'vertical stride',nam%fit_dl0)
   call nam%get(section,'number of components',nam%fit_ncmp)
end if

! Local profiles section
if (conf%get('local profiles',confs)) then
   if (lverbose) call print_section(mpl,confs,'Local profiles')
   nam%nldwv = size(confs)
   if (nam%nldwv>0) then
      ! Release memory
      if (allocated(nam%lon_ldwv)) deallocate(nam%lon_ldwv)
      if (allocated(nam%lat_ldwv)) deallocate(nam%lat_ldwv)
      if (allocated(nam%name_ldwv)) deallocate(nam%name_ldwv)

      ! Allocation
      allocate(nam%lon_ldwv(nam%nldwv))
      allocate(nam%lat_ldwv(nam%nldwv))
      allocate(nam%name_ldwv(nam%nldwv))

      ! Initialization
      nam%lon_ldwv = mpl%msv%valr
      nam%lat_ldwv = mpl%msv%valr
      nam%name_ldwv = ''

      do iconf=1,size(confs)
         call nam%get(confs(iconf),'longitude',nam%lon_ldwv(iconf))
         call nam%get(confs(iconf),'latitude',nam%lat_ldwv(iconf))
         call nam%get(confs(iconf),'name',nam%name_ldwv(iconf))
      end do
   end if
end if

! NICAS section
if (conf%get('nicas',section)) then
   if (lverbose) call print_section(mpl,section,'NICAS')
   call nam%get(section,'resolution',nam%resol)
   call nam%get(section,'max horizontal grid size',nam%nc1max)
   call nam%get(section,'grid type',nam%nicas_draw_type)
   call nam%get(section,'explicit length-scales',nam%forced_radii)
   call nam%get(mpl,section,'horizontal length-scale',nam%rh,one/req)
   call nam%get(mpl,section,'vertical length-scale',nam%rv)
   if (section%get('common localization weights',confs)) then
      if ((nam%strategy=='duplicated and weighted').and.(size(confs)>0).and.(nam%nv>0)) then
         ! Release memory
         if (allocated(nam%loc_wgt_sqrt)) deallocate(nam%loc_wgt_sqrt)

         ! Allocation
         allocate(loc_wgt(nam%nv,nam%nv))
         allocate(nam%loc_wgt_sqrt(nam%nv,nam%nv))

         ! Initialize diagonal weights at one, others at zero
         loc_wgt = zero
         do iv=1,nam%nv
            loc_wgt(iv,iv) = one
         end do

         ! Copy weights
         do iconf=1,size(confs)
            ! Get row and column variables, and the value
            call confs(iconf)%get_or_die('row variables',str_array_row)
            call confs(iconf)%get_or_die('column variables',str_array_col)
            call confs(iconf)%get_or_die('value',real_scalar)

            ! Loop over row and column values
            do ivv=1,size(str_array_row)
               do iv=1,nam%nv
                  if (trim(str_array_row(ivv))==trim(nam%variables(iv))) exit
               end do
               do jvv=1,size(str_array_col)
                  do jv=1,nam%nv
                     if (trim(str_array_col(jvv))==trim(nam%variables(jv))) then
                        if (iv/=jv) then
                           loc_wgt(iv,jv) = real_scalar
                           loc_wgt(jv,iv) = real_scalar
                        end if
                        exit
                     end if
                  end do
               end do
            end do
         end do

         ! Cholesky decomposition
         call cholesky(mpl,nam%nv,loc_wgt,nam%loc_wgt_sqrt)

         ! Release memory
         deallocate(loc_wgt)
      end if
   end if
   if (section%get('interpolation type',confs)) then
      if ((size(confs)>0).and.(nam%ng>0)) then
         ! Release memory
         if (allocated(nam%nicas_interp_type)) deallocate(nam%nicas_interp_type)

         ! Allocation
         allocate(nam%nicas_interp_type(nam%ng))

         ! Copy
         nam%nicas_interp_type = 'si'
         do iconf=1,size(confs)
            call confs(iconf)%get_or_die('groups',str_array)
            call confs(iconf)%get_or_die('type',str)
            do it=1,size(str_array)
               do ig=1,nam%ng
                  if (str_array(it)==nam%group_names(ig)) nam%nicas_interp_type(ig) = str
               end do
            end do
         end do
      end if
   end if
   call nam%get(section,'normalization randomization size',nam%norm_rand_size)
   call nam%get(section,'positive-definiteness test',nam%pos_def_test)
   call nam%get(section,'horizontal interpolation test',nam%interp_test)
   call nam%get(section,'overriding component in file',nam%file_component)
end if

! Psichitouv section
if (conf%get('psichitouv',section)) then
   if (lverbose) call print_section(mpl,section,'Psichitouv')
   call nam%get(section,'longitudes',nam%wind_nlon)
   call nam%get(section,'latitudes',nam%wind_nlat)
   call nam%get(section,'savitzky-golay half width',nam%wind_nsg)
   call nam%get(section,'wind inflation',nam%wind_inflation)
end if

! Dirac section
if (conf%get('dirac',confs)) then
   if (lverbose) call print_section(mpl,confs,'Dirac')
   if (size(confs)>0) then
      ! Count valid Dirac points
      nam%ndir = 0
      do iconf=1,size(confs)
         call confs(iconf)%get_or_die('variable',str)
         do iv=1,nam%nv
            if (str==nam%variables(iv)) nam%ndir = nam%ndir+1
         end do
      end do

      ! Release memory
      if (allocated(nam%londir)) deallocate(nam%londir)
      if (allocated(nam%latdir)) deallocate(nam%latdir)
      if (allocated(nam%levdir)) deallocate(nam%levdir)
      if (allocated(nam%ivdir)) deallocate(nam%ivdir)

      ! Allocation
      allocate(nam%londir(nam%ndir))
      allocate(nam%latdir(nam%ndir))
      allocate(nam%levdir(nam%ndir))
      allocate(nam%ivdir(nam%ndir))

      ! Initialization
      nam%ndir = 0
      do iconf=1,size(confs)
         call confs(iconf)%get_or_die('variable',str)
         do iv=1,nam%nv
            if (str==nam%variables(iv)) then
               nam%ndir = nam%ndir+1
               nam%ivdir(nam%ndir) = iv
               call confs(iconf)%get_or_die('longitude',nam%londir(nam%ndir))
               call confs(iconf)%get_or_die('latitude',nam%latdir(nam%ndir))
               call confs(iconf)%get_or_die('level',nam%levdir(nam%ndir))
            end if
         end do
      end do
   end if
end if

! External section
if (conf%get('external',section)) then
   call nam%get(section,'iterative algorithm',nam%iterative_algo)
end if

! Probe out
@:probe_out()

end subroutine nam_from_conf

!----------------------------------------------------------------------
! Subroutine: nam_final
!> Finalize namelist parameters
!----------------------------------------------------------------------
subroutine nam_final(nam,mpl)

implicit none

! Passed variables
class(nam_type),intent(inout) :: nam !< Namelist
type(mpl_type),intent(inout) :: mpl  !< MPI data

! Local variables
integer :: ig

! Set name
@:set_name(nam_final)

! Probe in
@:probe_in()

! Namelist parameters normalization (meters to radians and degrees to radians)
nam%universe_radius = nam%universe_radius/req
nam%dc = nam%dc/req
nam%local_rad = nam%local_rad/req
nam%local_dlat = nam%local_dlat*deg2rad
nam%diag_rhflt = nam%diag_rhflt/req
if (nam%ndir>0) nam%londir = nam%londir*deg2rad
if (nam%ndir>0) nam%latdir = nam%latdir*deg2rad
if (nam%nldwv>0) nam%lon_ldwv = nam%lon_ldwv*deg2rad
if (nam%nldwv>0) nam%lat_ldwv = nam%lat_ldwv*deg2rad
if (nam%forced_radii) then
   do ig=1,nam%ng
      if (mpl%msv%isallnot(nam%rh(:,ig)).and.mpl%msv%isall(nam%rv(:,ig))) then
         call mpl%warning('${subr}$','rh specified but not rv for '//trim(nam%group_names(ig))//', set to zero')
         nam%rv(:,ig) = zero
      end if
   end do
end if

! Required parameters
if (nam%ne==0) nam%ne = nam%ens1_ne
if (.not.allocated(nam%nicas_interp_type)) then
   allocate(nam%nicas_interp_type(nam%ng))
   nam%nicas_interp_type = 'si'
end if

! Apply bounds
nam%nl0r = min(nam%nl0r,nam%nl0)
if (nam%nprocio>mpl%nproc) nam%nprocio = mpl%nproc

end subroutine nam_final

!----------------------------------------------------------------------
! Subroutine: nam_check
!> Check namelist parameters
!----------------------------------------------------------------------
subroutine nam_check(nam,mpl)

implicit none

! Passed variables
class(nam_type),intent(inout) :: nam !< Namelist
type(mpl_type),intent(inout) :: mpl  !< MPI data

! Local variables
integer :: iv,ig,il0,idir,ildwv,imask
character(len=2) :: ildwvchar

! Set name
@:set_name(nam_check)

! Probe in
@:probe_in()

! General section
if (nam%repro_ops) then
  if (nam%repro_th<zero) call mpl%abort('${subr}$','repro_th should be non-negative')
end if
select case (nam%sampling_method)
case ('potential','maxrandom')
case default
   call mpl%abort('${subr}$','wrong sampling method: '//trim(nam%sampling_method))
end select

! I/O section
if (nam%prefix/='') nam%prefix = trim(nam%prefix)//'_'
if (nam%datadir=='') call mpl%abort('${subr}$','datadir not specified')
if (nam%nprocio<1) call mpl%abort('${subr}$','number of I/O tasks should be positive')
if (nam%fname_samp=='') nam%fname_samp = trim(nam%prefix)//'sampling'
nam%fname_vbal_cov_default = trim(nam%prefix)//'vbal_cov'
if (allocated(nam%fname_vbal_cov)) then
   if (size(nam%fname_vbal_cov)<nam%ens1_nsub) call mpl%abort('${subr}$','not enough fname_vbal_cov items')
end if
if (nam%fname_vbal=='') nam%fname_vbal = trim(nam%prefix)//'vbal'
nam%fname_mom_default = trim(nam%prefix)//'mom'
if (allocated(nam%fname_mom1)) then
   if (size(nam%fname_mom1)<nam%ens1_nsub) call mpl%abort('${subr}$','not enough fname_mom1 items')
end if
if (allocated(nam%fname_mom2)) then
   if (size(nam%fname_mom2)<nam%ens2_nsub) call mpl%abort('${subr}$','not enough fname_mom2 items')
end if
if (nam%fname_universe_radius=='') nam%fname_universe_radius = trim(nam%prefix)//'universe_radius'
if (nam%fname_nicas=='') nam%fname_nicas = trim(nam%prefix)//'nicas'
if (nam%fname_wind=='') nam%fname_wind = trim(nam%prefix)//'wind'

! Drivers section
if ((nam%new_hdiag.or.nam%check_optimality).and.nam%compute_hyb) then
   select case (nam%hybrid_source)
   case ('randomized static', 'lowres ensemble')
   case default
      call mpl%abort('${subr}$','wrong hybrid source')
   end select
end if
if (nam%new_hdiag.or.nam%new_nicas.or.nam%load_nicas_local.or.nam%load_nicas_global) then
   select case (nam%strategy)
   case ('univariate','duplicated','duplicated and weighted','crossed')
   case default
      call mpl%abort('${subr}$','wrong strategy')
   end select
end if
if (nam%load_samp_local.and.nam%load_samp_global) call mpl%abort('${subr}$','load_samp_local and load_samp_global are exclusive')
if (nam%load_samp_local.and.nam%write_samp_local) &
 & call mpl%abort('${subr}$','load_samp_local and write_samp_local are exclusive')
if (nam%load_samp_global.and.nam%write_samp_global) &
 & call mpl%abort('${subr}$','load_samp_global and write_samp_global are exclusive')
if (nam%write_samp_grids.and.(.not.(nam%new_vbal_cov.or.nam%new_vbal.or.nam%new_hdiag.or.nam%check_optimality))) &
 & call mpl%abort('${subr}$','new_vbal_cov, new_vbal or new_hdiag required for write_samp_grids')
if (nam%new_vbal_cov.and.nam%load_vbal_cov) call mpl%abort('${subr}$','new_vbal_cov and load_vbal_cov are exclusive')
if (nam%load_vbal_cov.and.(.not.nam%new_vbal)) call mpl%abort('${subr}$','new_vbal required for load_vbal_cov')
if (nam%load_vbal.and.(nam%new_vbal_cov.or.nam%load_vbal_cov)) call mpl%abort('${subr}$', &
 & 'load_vbal is inconsistent with new_vbal_cov, or load_vbal_cov')
if (nam%new_vbal.and.nam%load_vbal) call mpl%abort('${subr}$','new_vbal and load_vbal are exclusive')
if (nam%load_vbal_cov.and.(.not.(nam%load_samp_local.or.nam%load_samp_global))) &
 & call mpl%abort('${subr}$','load_vbal_cov requires load_samp_local/global')
if (nam%write_vbal_cov.and.(.not.(nam%load_samp_local.or.nam%load_samp_global)) &
 & .and.(.not.(nam%write_samp_local.or.nam%write_samp_global))) &
 & call mpl%abort('${subr}$','write_vbal_cov requires write_samp_local/global if load_samp_local/global is not activated')
if (nam%load_vbal.and.(.not.(nam%load_samp_local.or.nam%load_samp_global))) &
 & call mpl%abort('${subr}$','load_vbal requires load_samp_local/global')
 if (nam%write_vbal.and.(.not.(nam%load_samp_local.or.nam%load_samp_global)) &
 & .and.(.not.(nam%write_samp_local.or.nam%write_samp_global))) &
 & call mpl%abort('${subr}$','write_vbal requires write_samp_local/global if load_samp_local/global is not activated')
if (nam%new_mom.and.nam%load_mom) call mpl%abort('${subr}$','new_mom and load_mom are exclusive')
if (nam%load_mom.and.(.not.nam%load_samp_local)) call mpl%abort('${subr}$','load_mom requires load_samp_local')
if (nam%load_universe_radius.and.nam%write_universe_radius) &
 & call mpl%abort('${subr}$','load_universe_radius/write_universe_radius are exclusive')
if (nam%new_nicas.and.(nam%load_nicas_local.or.nam%load_nicas_global)) &
 & call mpl%abort('${subr}$','new_nicas and load_nicas_local/load_nicas_global are exclusive')
if (nam%check_vbal.and..not.(nam%new_vbal.or.nam%load_vbal)) &
 & call mpl%abort('${subr}$','new_vbal or load_vbal required for check_vbal')
if ((nam%new_hdiag.and.(.not.nam%from_gsi)).and.(.not.(nam%new_mom.or.nam%load_mom))) &
 & call mpl%abort('${subr}$','new_mom or load_mom required for new_hdiag')
if (nam%write_hdiag_detail.and.(nam%fit_ncmp==1)) call mpl%abort('${subr}$', &
 & 'fit_ncmp should be larger than 1 for write_hdiag_detail')
if (nam%load_nicas_local.and.nam%write_nicas_global) &
 & call mpl%abort('${subr}$','load_nicas_local and write_nicas_global are exclusive')
if (nam%write_nicas_grids.and.(.not.(nam%new_nicas.or.nam%load_nicas_global))) &
 & call mpl%abort('${subr}$','new_nicas or load_nicas_global required for write_nicas_grids')
if (nam%write_nicas_steps.and.(.not.nam%new_nicas)) call mpl%abort('${subr}$','new_nicas required for write_nicas_steps')
if (nam%check_dirac.and..not.(nam%new_vbal.or.nam%load_vbal.or.(nam%new_hdiag.and.nam%write_hdiag).or.nam%new_nicas &
 & .or.nam%load_nicas_local.or.nam%load_nicas_global)) call mpl%abort('${subr}$','check_dirac not available')
if (nam%check_randomization) then
   if (.not.nam%new_nicas) call mpl%abort('${subr}$','new_nicas required for check_randomization')
end if
if (nam%check_consistency) then
   if (.not.nam%compute_cor1) call mpl%abort('${subr}$','cor method required for check_consistency')
   if (nam%new_nicas) call mpl%abort('${subr}$','new_nicas forbidden for check_consistency')
end if
if (nam%check_optimality) then
   if (.not.nam%compute_loc1) call mpl%abort('${subr}$','loc method required for check_optimality')
   if (nam%new_nicas) call mpl%abort('${subr}$','new_nicas forbidden for check_optimality')
end if

! Model section
if (nam%nl0<=0) call mpl%abort('${subr}$','nl0 should be positive')
if ((nam%lev2d/='first').and.(nam%lev2d/='last')) call mpl%abort('${subr}$','wrong lev2d value')
if (nam%nv<=0) call mpl%abort('${subr}$','no variables')
do iv=1,nam%nv
   if (nam%variables(iv)=='') call mpl%abort('${subr}$','empty variable name')
end do
if (nam%ng<=0) call mpl%abort('${subr}$','no group')
if (any(nam%group_index<1).or.any(nam%group_index>nam%ng)) call mpl%abort('${subr}$','wrong group index')
do ig=1,nam%ng
   if (nam%group_names(ig)=='') call mpl%abort('${subr}$','empty group name')
end do

! Ensemble sizes section
if (((nam%new_normality.or.nam%new_vbal_cov.or.(nam%new_vbal.and.(.not.nam%load_vbal_cov)) &
 & .or.(nam%new_var.and.(.not.nam%forced_var)).or.nam%new_mom &
 & .or.nam%check_randomization.or.nam%check_optimality).and.(nam%compute_cov1.or.nam%compute_cor1.or.nam%compute_loc1)) &
 & .and.(.not.nam%from_gsi)) then
   if (nam%ens1_nsub<1) call mpl%abort('${subr}$','ens1_nsub should be positive')
   if (mod(nam%ens1_ne,nam%ens1_nsub)/=0) call mpl%abort('${subr}$','ens1_nsub should be a divider of ens1_ne')
   if (nam%ens1_ne/nam%ens1_nsub<=3) call mpl%abort('${subr}$','ens1_ne/ens1_nsub should be larger than 3')
end if
if (nam%new_mom.and.(nam%compute_cov2.or.nam%compute_cor2.or.nam%compute_loc2)) then
   if (nam%ens2_nsub<1) call mpl%abort('${subr}$','ens1_nsub should be positive')
   if (mod(nam%ens2_ne,nam%ens2_nsub)/=0) call mpl%abort('${subr}$','ens2_nsub should be a divider of ens2_ne')
   if (nam%ens2_ne/nam%ens2_nsub<=3) call mpl%abort('${subr}$','ens2_ne/ens2_nsub should be larger than 3')
end if
if (nam%compute_loc1.and.(nam%ne>nam%ens1_ne)) call mpl%warning('${subr}$', &
 & 'ensemble size larger than ens1_ne (might enhance sampling noise)')
if (nam%compute_loc2.and.(nam%ne_lr>nam%ens2_ne)) call mpl%warning('${subr}$', &
 & 'ensemble size larger than ens2_ne (might enhance sampling noise)')

! Sampling section
if (nam%new_vbal_cov.or.nam%new_vbal.or.(nam%new_hdiag.and.(.not.nam%from_gsi)).or.nam%check_optimality) then
   if ((.not.(nam%load_samp_local.or.nam%load_samp_global.or.nam%from_gsi)).and.(nam%nc1<3)) &
 & call mpl%abort('${subr}$','nc1 should be larger than 2')
   if (nam%new_vbal.or.(nam%new_hdiag.and.nam%local_diag)) then
      if ((.not.(nam%load_samp_local.or.nam%load_samp_global)).and.(nam%nc2<0)) &
 & call mpl%abort('${subr}$','nc2 should be non-negative')
   else
      if ((.not.(nam%load_samp_local.or.nam%load_samp_global)).and.(nam%nc2<0)) then
          call mpl%warning('${subr}$','nc2 should be set non-negative, resetting nc2 to zero')
          nam%nc2 = 0
      end if
   end if
end if
select case (nam%samp_draw_type)
case ('random')
case ('octahedral')
   if (nam%nldwv>0) call mpl%abort('${subr}$','no local diagnostics with an octahedral draw')
case default
   call mpl%abort('${subr}$','wrong samp_draw_type')
end select
if ((nam%new_hdiag.and.(.not.nam%from_gsi)).or.nam%check_optimality) then
   if (nam%nc3<=0) call mpl%abort('${subr}$','nc3 should be positive')
   if (nam%nc4<=0) call mpl%abort('${subr}$','nc4 should be positive')
   if ((nam%nc4>1).and.(mod(nam%nc4,2)==1)) call mpl%abort('${subr}$','nc4 should be even')
   if (.not.(nam%dc>zero)) call mpl%abort('${subr}$','dc should be positive')
   if (nam%nl0r<1) call mpl%abort ('${subr}$','nl0r should be positive')
end if
if (nam%local_diag) then
   if (.not.((nam%local_rad>zero).or.(nam%local_dlat>zero))) call mpl%abort('${subr}$', &
 & 'local_rad or local_dlat should be positive')
   if ((nam%local_rad>zero).and.(nam%local_dlat>zero)) call mpl%abort('${subr}$', &
 & 'local_rad and local_dlat cannot be positive at the same time')
end if
if (.not.(nam%load_samp_local.or.nam%load_samp_global)) then
   if (nam%irmax<1) call mpl%abort ('${subr}$','irmax should be positive')
end if
select case (nam%samp_interp_type)
case ('c0','c1','si')
case default
   call mpl%abort('${subr}$','wrong sampling interpolation type')
end select
do imask=1,nam%nmask
   select case (nam%mask_type(imask))
   case ('none')
   case ('ldwv')
      if (nam%nldwv<=0) call mpl%abort('${subr}$','nldwv should not be negative for mask_type = ldwv')
   case ('stddev','input')
      if (mpl%msv%is(nam%mask_th(imask))) call mpl%abort('${subr}$','missing mask threshold')
      select case (nam%mask_lu(imask))
      case ('lower','upper')
      case default
         call mpl%abort('${subr}$','wrong mask_lu')
      end select
      if (nam%mask_variable(imask)=='') call mpl%abort('${subr}$','missing mask variable')
    end select
end do

! Diagnostics section
if (nam%new_hdiag.or.nam%check_optimality) then
   if (((.not.nam%from_gsi).and.(nam%compute_cov1.or.nam%compute_cor1.or.nam%compute_loc1)).and.(nam%ne<=3)) &
 & call mpl%abort('${subr}$','ne should be larger than 3')
   if (((.not.nam%from_gsi).and.(nam%compute_cov2.or.nam%compute_cor2.or.nam%compute_loc2)).and.(nam%ne_lr<=3)) &
 & call mpl%abort('${subr}$','ne_lr should be larger than 3')
   if (.not.(nam%gen_kurt_th>zero)) call mpl%abort('${subr}$','gen_kurt_th should be positive')
   if (.not.(nam%lengths_scaling>zero)) call mpl%abort('${subr}$','lengths_scaling should be positive')
end if

! Vertical balance section
if (nam%new_vbal) then
   if ((.not.((nam%local_rad>zero).or.(nam%local_dlat>zero))).and.(.not.nam%from_gsi)) call mpl%abort('${subr}$', &
 & 'local_rad or local_dlat should be positive')
   if ((nam%local_rad>zero).and.(nam%local_dlat>zero)) call mpl%abort('${subr}$', &
 & 'local_rad and local_dlat cannot be positive at the same time')
   if (nam%vbal_pseudo_inv) then
      if ((nam%vbal_pseudo_inv_mmax<=0).and.(.not.nam%vbal_pseudo_inv_var_th>zero)) call mpl%abort('${subr}$', &
 & 'dominant mode or variance threshold should be positive for pseudo-inverse')
   end if
end if

! Variance section
if (nam%new_var) then
   if (nam%forced_var) then
      do iv=1,nam%nv
         do il0=1,nam%nl0
            if (mpl%msv%is(nam%stddev(il0,iv))) call mpl%abort('${subr}$','stddev is missing')
            if (.not.(nam%stddev(il0,iv)>zero)) call mpl%abort('${subr}$','stddev should be positive')
         end do
      end do
      if (nam%var_filter) call mpl%abort('${subr}$','var_filter forbidden for forced_var')
   end if
   if (nam%var_filter) then
      if ((nam%var_niter>0).and.(nam%var_npass>0)) call mpl%abort('${subr}$','var_niter or var_npass only should be non-negative')
      if ((nam%var_niter>0).and.(nam%var_npass>0)) &
 & call mpl%abort('${subr}$','var_niter or var_npass should not be positive at te same time')
      if ((nam%var_niter>0).or.(nam%var_npass>0)) then
         do iv=1,nam%nv
            do il0=1,nam%nl0
               if (mpl%msv%is(nam%var_rhflt(il0,iv))) call mpl%abort('${subr}$','var_rhflt is missing')
               if (.not.(nam%var_rhflt(il0,iv)>zero)) call mpl%abort('${subr}$','var_rhflt should be positive')
            end do
         end do
      end if
   end if
end if

! Optimality test section
if (nam%check_optimality) then
   if (nam%optimality_nfac<1) call mpl%abort('${subr}$','optimality_nfac should be positive')
   if (.not.(nam%optimality_delta>zero)) call mpl%abort('${subr}$','optimality_delta should be positive')
   if (nam%optimality_ntest<1) call mpl%abort('${subr}$','optimality_ntest should be positive')
end if

! Fit section
if (nam%new_hdiag.or.nam%check_optimality) then
   if (nam%diag_rhflt<zero) call mpl%abort('${subr}$','diag_rhflt should be non-negative')
   if (nam%diag_rvflt<zero) call mpl%abort('${subr}$','diag_rvflt should be non-negative')
   if (nam%fit_dl0<=0) call mpl%abort('${subr}$','fit_dl0 should be postive')
   if (nam%fit_ncmp<=0) call mpl%abort('${subr}$','fit_ncmp should be postive')
   if (nam%from_gsi.and.(nam%fit_ncmp/=3)) call mpl%abort('${subr}$','fit_ncmp should be equal to 3 for GSI import')
end if

! Local profiles section
if ((nam%new_hdiag.and.(.not.nam%from_gsi))) then
   if (nam%nldwv<0) call mpl%abort('${subr}$','nldwv should be non-negative')
   if (nam%nldwv>0) then
      if (.not.nam%local_diag) call mpl%abort('${subr}$','local_diag required for nldwv>0')
      if (any(nam%lon_ldwv(1:nam%nldwv)<-pi).or.any(nam%lon_ldwv(1:nam%nldwv)>pi)) &
 & call mpl%abort('${subr}$','lon_ldwv should lie between -180 and 180')
      if (any(nam%lat_ldwv(1:nam%nldwv)<-half*pi).or.any(nam%lat_ldwv(1:nam%nldwv)>half*pi)) &
 & call mpl%abort('${subr}$','lat_ldwv should lie between -90 and 90')
      do ildwv=1,nam%nldwv
         write(ildwvchar,'(i2.2)') ildwv
         if (nam%name_ldwv(ildwv)=='') call mpl%abort('${subr}$','name_ldwv not specified for profile '//ildwvchar)
      end do
   end if
end if

! NICAS section
if (nam%new_nicas.or.nam%load_nicas_local.or.nam%load_nicas_global) then
   if (nam%check_randomization) then
      if (.not.nam%forced_radii) call mpl%abort('${subr}$','forced_radii required for check_randomization')
   end if
   if (nam%check_consistency) then
      if (.not.nam%forced_radii) call mpl%abort('${subr}$','forced_radii required for check_consistency')
   end if
   if (nam%check_optimality) then
      if (.not.nam%forced_radii) call mpl%abort('${subr}$','forced_radii required for check_optimality')
   end if
   if (nam%new_nicas) then
      if (.not.(nam%resol>zero)) call mpl%abort('${subr}$','resol should be positive')
      if (nam%nc1max<=0) call mpl%abort('${subr}$','nc1max should be positive')
   end if
   if (nam%forced_radii) then
      if (.not.allocated(nam%rh)) call mpl%abort('${subr}$','rh is missing')
      if (.not.allocated(nam%rv)) call mpl%abort('${subr}$','rv is missing')
      do ig=1,nam%ng
         do il0=1,nam%nl0
            if (mpl%msv%is(nam%rh(il0,ig))) call mpl%abort('${subr}$','rh is missing for '//trim(nam%group_names(ig)))
            if (mpl%msv%is(nam%rv(il0,ig))) call mpl%abort('${subr}$','rv is missing for '//trim(nam%group_names(ig)))
            if (nam%rh(il0,ig)<zero) call mpl%abort('${subr}$','rh should be non-negative for '//trim(nam%group_names(ig)))
            if (nam%rv(il0,ig)<zero) call mpl%abort('${subr}$','rv should be non-negative for '//trim(nam%group_names(ig)))
         end do
      end do
   end if
   if (nam%strategy=='block_weighted') then
      if (.not.allocated(nam%loc_wgt_sqrt)) call mpl%abort('${subr}$','loc_wgt should be specified for block_weighted')
   end if
   select case (nam%nicas_draw_type)
   case ('random')
   case ('octahedral')
      if (nam%nldwv>0) call mpl%abort('${subr}$','no local diagnostics with an octahedral draw')
   case default
      call mpl%abort('${subr}$','wrong nicas_draw_type')
   end select
   do ig=1,nam%ng
      select case (nam%nicas_interp_type(ig))
      case ('c0','c1','si')
      case default
         call mpl%abort('${subr}$','wrong nicas_interp_type')
      end select
   end do
end if

! Dirac section
if (nam%check_dirac) then
   do idir=1,nam%ndir
      if ((nam%londir(idir)<-pi).or.(nam%londir(idir)>pi)) call mpl%abort('${subr}$','londir should lie between -180 and 180')
      if ((nam%latdir(idir)<-half*pi).or.(nam%latdir(idir)>half*pi)) call mpl%abort('${subr}$','latdir should lie between -90 and 90')
      if ((nam%ivdir(idir)<1).or.(nam%ivdir(idir)>nam%nv)) call mpl%abort('${subr}$','wrong variable for a Dirac')
   end do
end if

! Wind section
if (nam%new_wind) then
   if (nam%wind_nlon<3) call mpl%abort('${subr}$','wind_nlon should be larger than 3')
   if (nam%wind_nlat<3) call mpl%abort('${subr}$','wind_nlat should be larger than 3')
   if (nam%wind_nsg<1) call mpl%abort('${subr}$','wind_nsg should be positive')
   if (nam%wind_inflation<one) call mpl%abort('${subr}$','wind_inflation should be larger than 1')
end if

! Probe out
@:probe_out()

end subroutine nam_check

!----------------------------------------------------------------------
! Subroutine: nam_alias
!> Get alias value from key
!----------------------------------------------------------------------
subroutine nam_alias(nam,key,val)

implicit none

! Passed variables
class(nam_type),intent(in) :: nam      !< Namelist
character(len=*),intent(in) :: key     !< Alias key
character(len=1024),intent(out) :: val !< Alias value

! Local variables
integer :: i

! Set name
@:set_name(nam_alias)

! Probe in
@:probe_in()

! Loop over I/O key-value couples
val = key
if (allocated(nam%alias_code)) then
   do i=1,size(nam%alias_code)
      if (nam%alias_code(i)==key) then
         val = nam%alias_file(i)
         exit
      end if
   end do
end if

! Probe out
@:probe_out()

end subroutine nam_alias

!----------------------------------------------------------------------
! Subroutine: nam_print_conf
!> Print configuration
!----------------------------------------------------------------------
subroutine nam_print_conf(mpl,conf,title)

implicit none

! Passed variables
type(mpl_type),intent(inout) :: mpl          !< MPI data
type(fckit_configuration),intent(in) :: conf !< Configuration
character(len=*),intent(in) :: title         !< Title

! Local variable
integer :: str_size
character(len=:),allocatable :: str

! Set name
@:set_name(nam_print_conf)

! Probe in
@:probe_in()

! Print title
write(mpl%info,'(a7,a,a)') '',trim(title),':'
call mpl%flush(.false.)

! Configuration string
str = conf%json()
str_size = len(str)
do while (str_size>1024)
   write(mpl%info,'(a)') str(1:1024)
   call mpl%flush(.false.)
   str(1:str_size-1024) = str(1025:str_size)
   str_size = str_size-1024
end do
write(mpl%info,'(a)') str(1:str_size)
call mpl%flush

! Probe out
@:probe_out()

end subroutine nam_print_conf

!----------------------------------------------------------------------
! Subroutine: nam_print_confs
!> Print configurations vector
!----------------------------------------------------------------------
subroutine nam_print_confs(mpl,confs,title)

implicit none

! Passed variables
type(mpl_type),intent(inout) :: mpl              !< MPI data
type(fckit_configuration),intent(in) :: confs(:) !< Configurations vector
character(len=*),intent(in) :: title             !< Title

! Local variable
integer :: iconf,str_size
character(len=:),allocatable :: str

! Set name
@:set_name(nam_print_confs)

! Probe in
@:probe_in()

! Print title
write(mpl%info,'(a7,a,a)') '',trim(title),':'
call mpl%flush()

do iconf=1,size(confs)
   ! Configuration string
   str = confs(iconf)%json()
   str_size = len(str)
   do while (str_size>1024)
      write(mpl%info,'(a)') str(1:1024)
      call mpl%flush(.false.)
      str(1:str_size-1024) = str(1025:str_size)
      str_size = str_size-1024
   end do
   write(mpl%info,'(a10,a)') '',str(1:str_size)
   call mpl%flush
end do

! Probe out
@:probe_out()

end subroutine nam_print_confs

#:for dtype in dtypes_irls
!----------------------------------------------------------------------
! Subroutine: nam_get_${dtype}$
!> Get value
!----------------------------------------------------------------------
subroutine nam_get_${dtype}$(nam,conf,key,val)

implicit none

! Passed variables
class(nam_type),intent(inout) :: nam         !< Namelist
type(fckit_configuration),intent(in) :: conf !< Configuration
character(len=*),intent(in) :: key           !< Key
${ftype[dtype]}$,intent(out) :: val          !< Value

! Local variables
#{if dtype == "string"}# character(len=:),allocatable :: str #{endif}#

! Set name
@:set_name(nam_get_${dtype}$)

! Probe in
@:probe_in()

if (conf%has(key)) then
   #:if dtype == "string"
      call conf%get_or_die(key, str)
      val = str
   #:else
      call conf%get_or_die(key, val)
   #:endif
end if

! Probe out
@:probe_out()

end subroutine nam_get_${dtype}$
#:endfor

!----------------------------------------------------------------------
! Subroutine: nam_get_int_value
!> Get integer profile
!----------------------------------------------------------------------
subroutine nam_get_int_value(nam,mpl,conf,key,val)

implicit none

! Passed variables
class(nam_type),intent(inout) :: nam         !< Namelist
type(mpl_type),intent(inout) :: mpl          !< MPI data
type(fckit_configuration),intent(in) :: conf !< Configuration
character(len=*),intent(in) :: key           !< Key
integer,allocatable,intent(inout) :: val(:)  !< Values

! Local variables
integer :: iconf,ig,it
integer :: scalar
character(len=:),allocatable :: str_array(:)
type(fckit_configuration),allocatable :: confs(:)

! Set name
@:set_name(nam_get_int_value)

! Probe in
@:probe_in()

if (conf%has(key).and.(nam%ng>0)) then
   ! Release memory
   if (allocated(val)) deallocate(val)

   ! Allocation
   allocate(val(nam%ng))

   ! Initialization
   val = mpl%msv%vali

  ! Get subconfigurations vector
   call conf%get_or_die(key,confs)

   ! Loop over subconfigurations
   do iconf=1,size(confs)
      if (confs(iconf)%has('groups')) then
         call confs(iconf)%get_or_die('groups',str_array)
      elseif (confs(iconf)%has('variables')) then
         call confs(iconf)%get_or_die('variables',str_array)
      else
         call mpl%abort('${subr}$','groups or variables missing')
      end if
      call confs(iconf)%get_or_die('value',scalar)
      do it=1,size(str_array)
         do ig=1,nam%ng
            if (str_array(it)==nam%group_names(ig)) val(ig) = scalar
         end do
      end do
   end do
end if

! Probe out
@:probe_out()

end subroutine nam_get_int_value

!----------------------------------------------------------------------
! Subroutine: nam_get_real_value_or_profile
!> Get value or profile for all variables
!---------------------------------------------------------------------
subroutine nam_get_real_value_or_profile(nam,mpl,conf,key,val,norm)

implicit none

! Passed variables
class(nam_type),intent(inout) :: nam                  !< Namelist
type(mpl_type),intent(inout) :: mpl                   !< MPI data
type(fckit_configuration),intent(in) :: conf          !< Configuration
character(len=*),intent(in) :: key                    !< Key
real(kind_real),allocatable,intent(inout) :: val(:,:) !< Values
real(kind_real),intent(in),optional :: norm           !< Normalization factor

! Local variables
integer :: iconf,ig,it
real(kind_real) :: scalar,lnorm
real(kind_real),allocatable :: array(:)
character(len=:),allocatable :: str_array(:)
type(fckit_configuration),allocatable :: confs(:)

! Set name
@:set_name(nam_get_real_value_or_profile)

! Probe in
@:probe_in()

! Local normalization factor
lnorm = one
if (present(norm)) lnorm = norm

if (conf%has(key).and.(nam%nl0>0).and.(nam%ng>0)) then
   ! Release memory
   if (allocated(val)) deallocate(val)

   ! Allocation
   allocate(val(nam%nl0,nam%ng))

   ! Initialization
   val = mpl%msv%valr

   ! Get subconfigurations vector
   call conf%get_or_die(key,confs)

   ! Loop over subconfigurations
   do iconf=1,size(confs)
      if (confs(iconf)%has('groups')) then
         call confs(iconf)%get_or_die('groups',str_array)
      elseif (confs(iconf)%has('variables')) then
         call confs(iconf)%get_or_die('variables',str_array)
      else
         call mpl%abort('${subr}$','groups or variables missing')
      end if
      if (confs(iconf)%has('value')) then
         call confs(iconf)%get_or_die('value',scalar)
         do it=1,size(str_array)
            do ig=1,nam%ng
               if (str_array(it)==nam%group_names(ig)) val(:,ig) = scalar*lnorm
            end do
         end do
      elseif (confs(iconf)%has('profile')) then
         call confs(iconf)%get_or_die('profile',array)
         do it=1,size(str_array)
            do ig=1,nam%ng
               if (str_array(it)==nam%group_names(ig)) val(1:size(array),ig) = array*lnorm
            end do
         end do
      else
         call mpl%abort('${subr}$','missing value/profile in '//key)
      end if
   end do
end if

! Probe out
@:probe_out()

end subroutine nam_get_real_value_or_profile

!----------------------------------------------------------------------
! Subroutine: nam_read_universe_radius
!> Write universe_radius
!----------------------------------------------------------------------
subroutine nam_read_universe_radius(nam,mpl)

implicit none

! Passed variables
class(nam_type),intent(inout) :: nam !< Namelist
type(mpl_type),intent(inout) :: mpl  !< MPI data

! Local variables
integer :: lunit,ioflag,iv
real(kind_real) :: universe_radius,universe_radius_max
logical :: variable_found(nam%nv)
character(len=1024) :: variable

! Set name
@:set_name(nam_read_universe_radius)

! Probe in
@:probe_in()

! Initialization
variable_found = .false.

if (mpl%main) then
   ! Get unit
   lunit = 12

   ! Open file
   open(lunit,file=trim(nam%datadir)//'/'//trim(nam%fname_universe_radius),iostat=ioflag,status='old')
   if (ioflag/=0) call mpl%abort('${subr}$', &
 & 'cannot read universe radius file '//trim(nam%datadir)//'/'//trim(nam%fname_universe_radius))

   ! Initialization
   universe_radius_max = zero

   ! Loop over file lines
   do
      read(lunit,*,iostat=ioflag) variable,universe_radius
      if (ioflag/=0) exit
      do iv=1,nam%nv
         if (variable==nam%variables(iv)) then
            variable_found(iv) = .true.
            universe_radius_max = max(universe_radius_max,universe_radius)
         end if
      end do
   end do

   ! Close file
   close(lunit)

   ! Check that all variables have been found
   if (.not.all(variable_found)) call mpl%abort('${subr}$','missing variables in universe radius file')

   ! Normalize
   universe_radius_max = universe_radius_max/req

   ! Apply upper bound
   nam%universe_radius = zss_minval((/nam%universe_radius,universe_radius_max/))
end if

! Broadcast universe radius
call mpl%f_comm%broadcast(nam%universe_radius,mpl%rootproc-1)

! Probe out
@:probe_out()

end subroutine nam_read_universe_radius

end module type_nam
