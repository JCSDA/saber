#:include '../instrumentation.fypp'
!----------------------------------------------------------------------
! Module: type_nam
!> Namelist derived type
! Author: Benjamin Menetrier
! Licensing: this code is distributed under the CeCILL-C license
! Copyright 2015-... UCAR, CERFACS, METEO-FRANCE and IRIT
!----------------------------------------------------------------------
module type_nam

use fckit_configuration_module, only: fckit_configuration
use fckit_mpi_module, only: fckit_mpi_comm
use iso_fortran_env, only: output_unit
use tools_const, only: zero,hundredth,half,one,ten,hundred,pi,req,deg2rad,rad2deg
use tools_kinds,only: kind_real,huge_real
use tools_gc99, only: pkmin,pkmax,nlmin,nlmax,pk,ipkhdef,ipkvdef
use type_mpl, only: mpl_type
@:use_probe()

implicit none

integer,parameter :: nsubmax = 99                 !< Maximum number of sub-ensembles
integer,parameter :: nvmax = 20                   !< Maximum number of variables
integer,parameter :: nl0max = 300                 !< Maximum number of levels
integer,parameter :: nc3max = 100                 !< Maximum number of classes
integer,parameter :: nscalesmax = 5               !< Maximum number of scales
integer,parameter :: ndirmax = 99                 !< Maximum number of diracs
integer,parameter :: nldwvmax = 20                !< Maximum number of local diagnostic profiles
integer,parameter :: nprociomax = 20              !< Maximum number of I/O tasks
integer,parameter :: niokvmax = 50                !< Maximum number of I/O key-values
integer,parameter :: nvbalmax = nvmax*(nvmax-1)/2 !< Maximum number of vertical balance blocks

type nam_type
   ! general_param
   character(len=1024) :: datadir                             !< Data directory
   character(len=1024) :: prefix                              !< Files prefix
   character(len=1024) :: model                               !< Model name ('aro', 'arp', 'fv3', 'gem', 'geos', 'gfs', 'ifs', 'mpas', 'nemo', 'norcpm', 'online', 'qg, 'res' or 'wrf')
   character(len=1024) :: verbosity                           !< Verbosity level ('all', 'main' or 'none')
   logical :: colorlog                                        !< Add colors to the log (for display on terminal)
   logical :: default_seed                                    !< Default seed for random numbers
   logical :: repro                                           !< Inter-compilers reproducibility
   real(kind_real) :: rth                                     !< Reproducibility threshold
   logical :: parallel_io                                     !< Parallel NetCDF I/O
   integer :: nprocio                                         !< Number of I/O processors
   real(kind_real) :: universe_rad                            !< Universe radius [in meters]
   logical:: use_cgal                                         !< Use CGAL for mesh generation (or STRIPACK instead)

   ! driver_param
   character(len=1024) :: method                              !< Localization/hybridization to compute ('cor', 'loc', 'hyb-avg', 'hyb-rnd' or 'dual-ens')
   character(len=1024) :: strategy                            !< Localization strategy ('diag_all', 'common', 'common_weighted', 'specific_univariate' or 'specific_multivariate')
   logical :: new_normality                                   !< New normality test
   logical :: new_vbal_cov                                    !< New vertical covariance
   logical :: update_vbal_cov                                 !< Update vertical covariance sequentially
   logical :: load_vbal_cov                                   !< Load local vertical covariance
   logical :: write_vbal_cov                                  !< Write local vertical covariancee
   logical :: new_vbal                                        !< Compute new vertical balance operator
   logical :: load_vbal                                       !< Load local vertical balance operator
   logical :: write_vbal                                      !< Write vertical balance operator
   logical :: new_var                                         !< Compute new variance
   logical :: update_var                                      !< Update variance sequentially
   logical :: load_var                                        !< Load variance
   logical :: write_var                                       !< Write variance
   logical :: new_mom                                         !< Compute new sampling moments
   logical :: update_mom                                      !< Update sampling moments sequentially
   logical :: load_mom                                        !< Load sampling moments
   logical :: write_mom                                       !< Write sampling moments
   logical :: new_hdiag                                       !< Compute new HDIAG diagnostics
   logical :: write_hdiag                                     !< Write HDIAG diagnostics
   logical :: new_lct                                         !< Compute new LCT
   logical :: write_lct                                       !< Write LCT
   logical :: load_cmat                                       !< Load C matrix
   logical :: write_cmat                                      !< Write C matrix
   logical :: new_nicas                                       !< Compute new NICAS parameters
   logical :: load_nicas_local                                !< Load local NICAS parameters
   logical :: load_nicas_global                               !< Load global NICAS parameters
   logical :: write_nicas_local                               !< Write local NICAS parameters
   logical :: write_nicas_global                              !< Write global NICAS parameters
   logical :: new_wind                                        !< Compute wind transform
   logical :: load_wind_local                                 !< Load local wind transform
   logical :: write_wind_local                                !< Write local wind transform
   logical :: check_vbal                                      !< Test vertical balance inverse and adjoint
   logical :: check_adjoints                                  !< Test NICAS adjoints
   logical :: check_dirac                                     !< Test NICAS application on diracs
   logical :: check_randomization                             !< Test NICAS randomization
   logical :: check_consistency                               !< Test HDIAG-NICAS consistency
   logical :: check_optimality                                !< Test HDIAG optimality
   logical :: check_no_point_mpi                              !< Test BUMP with no grid point on the last MPI task
   logical :: check_no_point_mask                             !< Test BUMP with all grid points masked on half of the domain
   logical :: check_set_param_cor                             !< Test set_parameter interface for correlation
   logical :: check_set_param_hyb                             !< Test set_parameter interface for hybrid case
   logical :: check_set_param_lct                             !< Test set_parameter interface for LCT
   logical :: check_get_param_stddev                          !< Test get_parameter interface for standard-deviation
   logical :: check_get_param_cor                             !< Test get_parameter interface for correlation
   logical :: check_get_param_hyb                             !< Test get_parameter interface for hybrid case
   logical :: check_get_param_Dloc                            !< Test get_parameter interface for anisotropic localization
   logical :: check_get_param_lct                             !< Test get_parameter interface for LCT
   logical :: check_apply_vbal                                !< Test apply_vbal interfaces
   logical :: check_apply_stddev                              !< Test apply_stddev interfaces
   logical :: check_apply_nicas                               !< Test apply_nicas interfaces

   ! files_param
   character(len=1024),dimension(0:nsubmax) :: fname_var      !< Variance files
   character(len=1024) :: fname_samp                          !< Sampling file
   character(len=1024),dimension(0:nsubmax) :: fname_vbal_cov !< Vertical covariance files
   character(len=1024) :: fname_vbal                          !< Vertical balance file
   character(len=1024),dimension(0:nsubmax) :: fname_mom      !< Moments files
   character(len=1024) :: fname_cmat                          !< C matrix file
   character(len=1024) :: fname_nicas                         !< NICAS file
   character(len=1024) :: fname_wind                          !< Wind transform file

   ! model_param
   integer :: nl0                                             !< Number of levels
   integer :: levs(nl0max)                                    !< Levels
   character(len=1024) :: lev2d                               !< Level for 2D variables ('first' or 'last')
   logical :: logpres                                         !< Use pressure logarithm as vertical coordinate (model level if .false.)
   integer :: nv                                              !< Number of variables
   character(len=1024),dimension(nvmax) :: variables          !< Variables names
   character(len=1024) :: variable_change                     !< Variable change
   logical :: nomask                                          !< Do not use geometry mask
   character(len=1024),dimension(niokvmax) :: io_keys         !< I/O keys
   character(len=1024),dimension(niokvmax) :: io_values       !< I/O values
   logical :: qg_redundant                                    !< Redundant points configuration for the QG model
   logical :: qg_regional                                     !< Regional domain configuration for the QG model
   logical :: qg_urban                                        !< Urban domain configuration for the QG model

   ! ens1_param
   integer :: ens1_ne                                         !< Ensemble 1 size
   integer :: ens1_nsub                                       !< Ensemble 1 sub-ensembles number

   ! ens2_param
   integer :: ens2_ne                                         !< Ensemble 2 size
   integer :: ens2_nsub                                       !< Ensemble 2 sub-ensembles number

   ! sampling_param
   logical :: load_samp_local                                 !< Load local sampling
   logical :: load_samp_global                                !< Load global sampling
   logical :: write_samp_local                                !< Write local sampling
   logical :: write_samp_global                               !< Write global sampling
   logical :: write_samp_grids                                !< Write sampling grids
   character(len=1024) :: mask_type                           !< Mask restriction type
   character(len=1024),dimension(nvmax) :: mask_lu            !< Mask threshold side ('lower' if mask_th is the lower bound, 'upper' if mask_th is the upper bound)
   real(kind_real),dimension(nvmax) :: mask_th                !< Mask threshold
   integer :: ncontig_th                                      !< Threshold on vertically contiguous points for sampling mask (0 to skip the test)
   logical :: mask_check                                      !< Check that sampling couples and interpolations do not cross mask boundaries
   character(len=1024) :: diag_draw_type                      !< Sampling draw type ('random_uniform','random_coast' or 'octahedral')
   real(kind_real) :: Lcoast                                  !< Length-scale to increase sampling density along coasts [in meters]
   real(kind_real) :: rcoast                                  !< Minimum value to increase sampling density along coasts
   integer :: nc1                                             !< Number of sampling points
   integer :: nc2                                             !< Number of diagnostic points
   integer :: nc3                                             !< Number of classes
   real(kind_real) :: dc                                      !< Class size (for sam_type='hor'), should be larger than the typical grid cell size [in meters]
   integer :: nl0r                                            !< Reduced number of levels for diagnostics
   integer :: irmax                                           !< Maximum number of random number draws

   ! diag_param
   integer :: ne                                              !< Ensemble size
   real(kind_real) :: gen_kurt_th                             !< Threshold on generalized kurtosis (3.0 = Gaussian distribution)
   logical :: gau_approx                                      !< Gaussian approximation for asymptotic quantities
   integer :: avg_nbins                                       !< Number of bins for averaged statistics histograms
   logical :: vbal_block(nvbalmax)                            !< Activation of vertical balance (ordered line by line in the lower triangular formulation)
   real(kind_real) :: vbal_rad                                !< Vertical balance diagnostic radius [in meters]
   real(kind_real) :: vbal_dlat                               !< Vertical balance diagnostic latitude band half-width [in degrees]
   logical :: vbal_diag_auto(nvbalmax)                        !< Diagonal auto-covariance for the inversion
   logical :: vbal_diag_reg(nvbalmax)                         !< Diagonal regression
   logical :: vbal_pseudo_inv                                 !< Pseudo-inverse for auto-covariance
   integer :: vbal_pseudo_inv_mmax                            !< Dominant mode for pseudo-inverse
   real(kind_real) :: vbal_pseudo_inv_var_th                  !< Variance threshold to compute the dominant mode for pseudo-inverse
   logical :: forced_var                                      !< Force specific variance
   real(kind_real) :: stddev(nl0max,nvmax)                    !< Forced standard-deviation
   logical :: var_filter                                      !< Filter variance
   integer :: var_niter                                       !< Number of iterations for the variance filtering (0 for uniform variance)
   integer :: var_npass                                       !< Number of passes for the variance filtering (0 for uniform variance)
   real(kind_real) :: var_rhflt(nl0max,nvmax)                 !< Variance initial filtering support radius [in meters]
   logical :: local_diag                                      !< Activate local diagnostics
   real(kind_real) :: local_rad                               !< Local diagnostics calculation radius [in meters]
   real(kind_real) :: local_dlat                              !< Local diagnostics calculation latitude band half-width [in degrees]

   ! fit_param
   real(kind_real) :: diag_rhflt                              !< Horizontal filtering suport radius [in meters]
   real(kind_real) :: diag_rvflt                              !< Vertical filtering support radius
   integer :: fit_dl0                                         !< Number of levels between interpolation levels
   logical :: peakness                                        !< Estimate peakness
   logical :: negative_lobe                                   !< Estimate vertical negative lobe
   logical :: diag_sqrt                                       !< Diagnostic of square-root functions
   integer :: lct_nscales                                     !< Number of LCT scales
   real(kind_real) :: lct_scale_ratio                         !< Factor between diffusion scales
   real(kind_real) :: lct_cor_min                             !< Minimum relevant correlation for LCT first guess
   logical :: lct_diag(nscalesmax)                            !< Diagnostic of diagonal LCT components only
   real(kind_real) :: lct_qc_th                               !< LCT quality control threshold
   real(kind_real) :: lct_qc_max                              !< LCT quality control maximum
   logical :: lct_write_cor                                   !< Write full correlations

   ! nicas_param
   logical :: nonunit_diag                                    !< Non-unit diagonal for the NICAS application
   real(kind_real) :: resol                                   !< Resolution
   integer :: nc1max                                          !< Maximum size of the Sc1 subset
   character(len=1024) :: nicas_draw_type                     !< Subsampling draw type ('random_uniform','random_coast' or 'octahedral')
   logical :: network                                         !< Network-base convolution calculation (distance-based if false)
   logical :: forced_radii                                    !< Force specific support radii
   real(kind_real) :: rh(nl0max,0:nvmax)                      !< Forced horizontal support radius [in meters]
   real(kind_real) :: pkh(nl0max,0:nvmax)                     !< Forced horizontal peakness
   real(kind_real) :: rv(nl0max,0:nvmax)                      !< Forced vertical support radius
   real(kind_real) :: pkv(nl0max,0:nvmax)                     !< Forced vertical peakness
   real(kind_real) :: nlv(nl0max,0:nvmax)                     !< Forced vertical negative lobe parameter
   integer :: min_lev(0:nvmax)                                !< Minimum level
   integer :: max_lev(0:nvmax)                                !< Maximum level
   logical :: pos_def_test                                    !< Positive-definiteness test
   logical :: write_nicas_c0                                  !< Write NICAS fields on model grid (should be written via OOPS if .false.)
   logical :: write_nicas_grids                               !< Write NICAS grids

   ! dirac_param
   integer :: ndir                                            !< Number of Diracs
   real(kind_real) :: londir(ndirmax)                         !< Diracs longitudes [in degrees]
   real(kind_real) :: latdir(ndirmax)                         !< Diracs latitudes [in degrees]
   integer :: levdir(ndirmax)                                 !< Diracs level
   integer :: ivdir(ndirmax)                                  !< Diracs variable indices

   ! output_param
   integer :: full_grid_smoother_nn                           !< Number of neighbors for the full grid smoother
   integer :: nldwv                                           !< Number of local diagnostics profiles to write (for local_diag = .true.)
   integer :: img_ldwv(nldwvmax)                              !< Index on model grid of the local diagnostics profiles to write
   real(kind_real) :: lon_ldwv(nldwvmax)                      !< Longitudes of the local diagnostics profiles to write [in degrees]
   real(kind_real) :: lat_ldwv(nldwvmax)                      !< Latitudes of the local diagnostics profiles to write [in degrees]
   character(len=1024),dimension(nldwvmax) :: name_ldwv       !< Name of the local diagnostics profiles to write

   ! wind_param
   character(len=1024) :: wind_streamfunction                 !< Streamfunction variable name
   character(len=1024) :: wind_velocity_potential             !< Velocity potential variable name
   character(len=1024) :: wind_zonal                          !< Zonal wind variable name
   character(len=1024) :: wind_meridional                     !< Meridional variable name
   integer :: wind_nlon                                       !< Number of longitudes for the regular grid
   integer :: wind_nlat                                       !< Number of latitudes for the regular grid
   integer :: wind_nsg                                        !< Half-width of the Savitzky-Golay to compute derivatives
   real(kind_real) :: wind_inflation                          !< Wind inflation to compensate the Savitzky-Golay smoothing

   ! helpers
   logical :: fname_var_used                                  !< Flag activated if a variance file is specified
   logical :: fname_vbal_cov_used                             !< Flag activated if a vertical covariance file is specified
   logical :: fname_mom_used                                  !< Flag activated if a moments file is specified
contains
   procedure :: init => nam_init
   procedure :: read => nam_read
   procedure :: bcast => nam_bcast
   procedure :: from_conf => nam_from_conf
   procedure :: check => nam_check
   procedure :: write => nam_write
   procedure :: io_key_value => nam_io_key_value
end type nam_type

private
public :: nvmax,nl0max,nc3max,nscalesmax,ndirmax,nldwvmax,niokvmax,nvbalmax
public :: nam_type

contains

!----------------------------------------------------------------------
! Subroutine: nam_init
!> Intialize
!----------------------------------------------------------------------
subroutine nam_init(nam,nproc)

implicit none

! Passed variable
class(nam_type),intent(out) :: nam !< Namelist
integer,intent(in) :: nproc        !< Number of MPI task

! Local variable
integer :: isub,il0,iv,i,ildwv

! Set name
@:set_name(nam_init)

! Probe in
@:probe_in()

! general_param default
nam%datadir = '.'
nam%prefix = ''
nam%model = 'online'
nam%verbosity = 'all'
nam%colorlog = .false.
nam%default_seed = .true.
nam%repro = .true.
nam%rth = 1.0e-12_kind_real
nam%parallel_io = .true.
nam%nprocio = min(nproc,nprociomax)
nam%universe_rad = pi*req
nam%use_cgal = .false.

! driver_param default
nam%method = ''
nam%strategy = ''
nam%new_normality = .false.
nam%new_vbal_cov = .false.
nam%update_vbal_cov = .false.
nam%load_vbal_cov = .false.
nam%write_vbal_cov = .false.
nam%new_vbal = .false.
nam%load_vbal = .false.
nam%write_vbal = .false.
nam%new_var = .false.
nam%update_var = .false.
nam%load_var = .false.
nam%write_var = .false.
nam%new_mom = .false.
nam%update_mom = .false.
nam%load_mom = .false.
nam%write_mom = .false.
nam%new_hdiag = .false.
nam%write_hdiag = .false.
nam%new_lct = .false.
nam%write_lct = .false.
nam%load_cmat = .false.
nam%write_cmat = .false.
nam%new_nicas = .false.
nam%load_nicas_local = .false.
nam%load_nicas_global = .false.
nam%write_nicas_local = .false.
nam%write_nicas_global = .false.
nam%new_wind = .false.
nam%load_wind_local = .false.
nam%write_wind_local = .false.
nam%check_vbal = .false.
nam%check_adjoints = .false.
nam%check_dirac = .false.
nam%check_randomization = .false.
nam%check_consistency = .false.
nam%check_optimality = .false.
nam%check_no_point_mpi = .false.
nam%check_no_point_mask = .false.
nam%check_set_param_cor = .false.
nam%check_set_param_hyb = .false.
nam%check_set_param_lct = .false.
nam%check_get_param_stddev = .false.
nam%check_get_param_cor = .false.
nam%check_get_param_hyb = .false.
nam%check_get_param_Dloc = .false.
nam%check_get_param_lct = .false.
nam%check_apply_vbal = .false.
nam%check_apply_stddev = .false.
nam%check_apply_nicas = .false.

! files_param default
do isub=0,nsubmax
   nam%fname_var(isub) = ''
end do
nam%fname_samp = ''
do isub=0,nsubmax
   nam%fname_vbal_cov(isub) = ''
end do
nam%fname_vbal = ''
do isub=0,nsubmax
   nam%fname_mom(isub) = ''
end do
nam%fname_cmat = ''
nam%fname_nicas = ''
nam%fname_wind = ''

! model_param default
nam%nl0 = 0
do il0=1,nl0max
   nam%levs(il0) = il0
end do
nam%lev2d = 'first'
nam%logpres = .false.
nam%nv = 0
do iv=1,nvmax
   nam%variables(iv) = ''
end do
nam%variable_change = ''
nam%nomask = .false.
do i=1,niokvmax
   nam%io_keys(i) = ''
   nam%io_values(i) = ''
end do
nam%qg_redundant = .false.
nam%qg_regional = .false.
nam%qg_urban = .false.

! ens1_param default
nam%ens1_ne = 0
nam%ens1_nsub = 1

! ens2_param default
nam%ens2_ne = 0
nam%ens2_nsub = 1

! sampling_param default
nam%load_samp_local = .false.
nam%load_samp_global = .false.
nam%write_samp_local = .false.
nam%write_samp_global = .false.
nam%write_samp_grids = .false.
nam%mask_type = 'none'
do iv=1,nvmax
   nam%mask_lu(iv) = 'lower'
   nam%mask_th(iv) = zero
end do
nam%ncontig_th = 0
nam%mask_check = .false.
nam%diag_draw_type = 'random_uniform'
nam%Lcoast = zero
nam%rcoast = zero
nam%nc1 = 0
nam%nc2 = 0
nam%nc3 = 0
nam%dc = zero
nam%nl0r = 0
nam%irmax = 10000

! diag_param default
nam%ne = 0
nam%gen_kurt_th = huge_real
nam%gau_approx = .false.
nam%avg_nbins = 0
do iv=1,nvbalmax
   nam%vbal_block(iv) = .false.
end do
nam%vbal_rad = zero
nam%vbal_dlat = zero
do iv=1,nvbalmax
   nam%vbal_diag_auto(iv) = .false.
end do
do iv=1,nvbalmax
   nam%vbal_diag_reg(iv) = .false.
end do
nam%vbal_pseudo_inv = .false.
nam%vbal_pseudo_inv_mmax = 0
nam%vbal_pseudo_inv_var_th = zero
nam%forced_var = .false.
nam%stddev = zero
nam%var_filter = .false.
nam%var_niter = -1
nam%var_npass = -1
nam%var_rhflt = zero
nam%local_diag = .false.
nam%local_rad = zero
nam%local_dlat = zero

! fit_param default
nam%diag_rhflt = zero
nam%diag_rvflt = zero
nam%fit_dl0 = 1
nam%peakness = .false.
nam%negative_lobe = .false.
nam%diag_sqrt = .false.
nam%lct_nscales = 0
nam%lct_scale_ratio = ten
nam%lct_cor_min = half
nam%lct_diag = .false.
nam%lct_qc_th = zero
nam%lct_qc_max = one
nam%lct_write_cor = .false.

! nicas_param default
nam%nonunit_diag = .false.
nam%resol = zero
nam%nc1max = 15000
nam%nicas_draw_type = 'random_uniform'
nam%network = .false.
nam%forced_radii = .false.
nam%rh = -one
nam%pkh = pk(ipkhdef)
nam%rv = -one
nam%pkv = pk(ipkvdef)
nam%nlv = zero
nam%min_lev = 1
nam%max_lev = nl0max
nam%pos_def_test = .false.
nam%write_nicas_c0 = .true.
nam%write_nicas_grids = .false.

! dirac_param default
nam%ndir = 0
nam%londir = zero
nam%latdir = zero
nam%levdir = 0
nam%ivdir = 0

! output_param default
nam%full_grid_smoother_nn = 0
nam%nldwv = 0
nam%img_ldwv = 0
nam%lon_ldwv = zero
nam%lat_ldwv = zero
do ildwv=1,nldwvmax
   nam%name_ldwv(ildwv) = ''
end do

! wind_param default
nam%wind_streamfunction = 'stream_function'
nam%wind_velocity_potential = 'velocity_potential'
nam%wind_zonal = 'eastward_wind'
nam%wind_meridional = 'northward_wind'
nam%wind_nlon = 0
nam%wind_nlat = 0
nam%wind_nsg = 0
nam%wind_inflation = one

! Probe out
@:probe_out()

end subroutine nam_init

!----------------------------------------------------------------------
! Subroutine: nam_read
!> Read
!----------------------------------------------------------------------
subroutine nam_read(nam,mpl,namelname)

implicit none

! Passed variable
class(nam_type),intent(inout) :: nam     !< Namelist
type(mpl_type),intent(inout) :: mpl      !< MPI data
character(len=*),intent(in) :: namelname !< Namelist name

! Local variables
integer :: isub,il0,iv,i,ildwv,lunit

! Namelist variables
character(len=1024) :: datadir
character(len=1024) :: prefix
character(len=1024) :: model
character(len=1024) :: verbosity
logical :: colorlog
logical :: default_seed
logical :: repro
real(kind_real) :: rth
logical :: parallel_io
integer :: nprocio
real(kind_real) :: universe_rad
logical :: use_cgal
character(len=1024) :: method
character(len=1024) :: strategy
logical :: new_normality
logical :: new_vbal_cov
logical :: update_vbal_cov
logical :: load_vbal_cov
logical :: write_vbal_cov
logical :: new_vbal
logical :: load_vbal
logical :: write_vbal
logical :: new_var
logical :: update_var
logical :: load_var
logical :: write_var
logical :: new_mom
logical :: update_mom
logical :: load_mom
logical :: write_mom
logical :: new_hdiag
logical :: write_hdiag
logical :: new_lct
logical :: write_lct
logical :: load_cmat
logical :: write_cmat
logical :: new_nicas
logical :: load_nicas_local
logical :: load_nicas_global
logical :: write_nicas_local
logical :: write_nicas_global
logical :: new_wind
logical :: load_wind_local
logical :: write_wind_local
logical :: check_vbal
logical :: check_adjoints
logical :: check_dirac
logical :: check_randomization
logical :: check_consistency
logical :: check_optimality
logical :: check_no_point_mpi
logical :: check_no_point_mask
logical :: check_set_param_cor
logical :: check_set_param_hyb
logical :: check_set_param_lct
logical :: check_get_param_stddev
logical :: check_get_param_cor
logical :: check_get_param_hyb
logical :: check_get_param_Dloc
logical :: check_get_param_lct
logical :: check_apply_vbal
logical :: check_apply_stddev
logical :: check_apply_nicas
character(len=1024),dimension(0:nsubmax) :: fname_var
character(len=1024) :: fname_samp
character(len=1024),dimension(0:nsubmax) :: fname_vbal_cov
character(len=1024) :: fname_vbal
character(len=1024),dimension(0:nsubmax) :: fname_mom
character(len=1024) :: fname_cmat
character(len=1024) :: fname_nicas
character(len=1024) :: fname_wind
integer :: nl0
integer :: levs(nl0max)
character(len=1024) :: lev2d
logical :: logpres
integer :: nv
character(len=1024),dimension(nvmax) :: variables
character(len=1024) :: variable_change
logical :: nomask
character(len=1024),dimension(niokvmax) :: io_keys
character(len=1024),dimension(niokvmax) :: io_values
logical :: qg_redundant
logical :: qg_regional
logical :: qg_urban
integer :: ens1_ne
integer :: ens1_nsub
integer :: ens2_ne
integer :: ens2_nsub
logical :: load_samp_local
logical :: load_samp_global
logical :: write_samp_local
logical :: write_samp_global
logical :: write_samp_grids
character(len=1024) :: mask_type
character(len=1024),dimension(nvmax) :: mask_lu
real(kind_real),dimension(nvmax) :: mask_th
integer :: ncontig_th
logical :: mask_check
character(len=1024) :: diag_draw_type
real(kind_real) :: Lcoast
real(kind_real) :: rcoast
integer :: nc1
integer :: nc2
integer :: nc3
real(kind_real) :: dc
integer :: nl0r
integer :: irmax
integer :: ne
real(kind_real) :: gen_kurt_th
logical :: gau_approx
integer :: avg_nbins
logical :: vbal_block(nvbalmax)
real(kind_real) :: vbal_rad
real(kind_real) :: vbal_dlat
logical :: vbal_diag_auto(nvbalmax)
logical :: vbal_diag_reg(nvbalmax)
logical :: vbal_pseudo_inv
integer :: vbal_pseudo_inv_mmax
real(kind_real) :: vbal_pseudo_inv_var_th
logical :: forced_var
real(kind_real) :: stddev(nl0max,nvmax)
logical :: var_filter
integer :: var_niter
integer :: var_npass
real(kind_real) :: var_rhflt(nl0max,nvmax)
logical :: local_diag
real(kind_real) :: local_rad
real(kind_real) :: local_dlat
real(kind_real) :: diag_rhflt
real(kind_real) :: diag_rvflt
integer :: fit_dl0
logical :: peakness
logical :: negative_lobe
logical :: diag_sqrt
integer :: lct_nscales
real(kind_real) :: lct_scale_ratio
real(kind_real) :: lct_cor_min
logical :: lct_diag(nscalesmax)
real(kind_real) :: lct_qc_th
real(kind_real) :: lct_qc_max
logical :: lct_write_cor
logical :: nonunit_diag
real(kind_real) :: resol
integer :: nc1max
character(len=1024) :: nicas_draw_type
logical :: network
logical :: forced_radii
real(kind_real) :: rh(nl0max,0:nvmax)
real(kind_real) :: pkh(nl0max,0:nvmax)
real(kind_real) :: rv(nl0max,0:nvmax)
real(kind_real) :: pkv(nl0max,0:nvmax)
real(kind_real) :: nlv(nl0max,0:nvmax)
integer :: min_lev(0:nvmax)
integer :: max_lev(0:nvmax)
logical :: pos_def_test
logical :: write_nicas_c0
logical :: write_nicas_grids
integer :: ndir
real(kind_real) :: londir(ndirmax)
real(kind_real) :: latdir(ndirmax)
integer :: levdir(ndirmax)
integer :: ivdir(ndirmax)
integer :: full_grid_smoother_nn
integer :: nldwv
integer :: img_ldwv(nldwvmax)
real(kind_real) :: lon_ldwv(nldwvmax)
real(kind_real) :: lat_ldwv(nldwvmax)
character(len=1024),dimension(nldwvmax) :: name_ldwv
character(len=1024) :: wind_streamfunction
character(len=1024) :: wind_velocity_potential
character(len=1024) :: wind_zonal
character(len=1024) :: wind_meridional
integer :: wind_nlon
integer :: wind_nlat
integer :: wind_nsg
real(kind_real) :: wind_inflation

! Namelist blocks
namelist/general_param/ &
 & datadir, &
 & prefix, &
 & model, &
 & verbosity, &
 & colorlog, &
 & default_seed, &
 & repro, &
 & rth, &
 & parallel_io, &
 & nprocio, &
 & universe_rad, &
 & use_cgal
namelist/driver_param/ &
 & method, &
 & strategy, &
 & new_normality, &
 & new_vbal_cov, &
 & update_vbal_cov, &
 & load_vbal_cov, &
 & write_vbal_cov, &
 & new_vbal, &
 & load_vbal, &
 & write_vbal, &
 & new_var, &
 & update_var, &
 & load_var, &
 & write_var, &
 & new_mom, &
 & update_mom, &
 & load_mom, &
 & write_mom, &
 & new_hdiag, &
 & write_hdiag, &
 & new_lct, &
 & write_lct, &
 & load_cmat, &
 & write_cmat, &
 & new_nicas, &
 & load_nicas_local, &
 & load_nicas_global, &
 & write_nicas_local, &
 & write_nicas_global, &
 & new_wind, &
 & load_wind_local, &
 & write_wind_local, &
 & check_vbal, &
 & check_adjoints, &
 & check_dirac, &
 & check_randomization, &
 & check_consistency, &
 & check_optimality, &
 & check_no_point_mpi, &
 & check_no_point_mask, &
 & check_set_param_cor, &
 & check_set_param_hyb, &
 & check_set_param_lct, &
 & check_get_param_stddev, &
 & check_get_param_cor, &
 & check_get_param_hyb, &
 & check_get_param_Dloc, &
 & check_get_param_lct, &
 & check_apply_vbal, &
 & check_apply_stddev, &
 & check_apply_nicas
namelist/files_param/ &
 & fname_var, &
 & fname_samp, &
 & fname_vbal_cov, &
 & fname_vbal, &
 & fname_mom, &
 & fname_cmat, &
 & fname_nicas, &
 & fname_wind
namelist/model_param/ &
 & nl0, &
 & levs, &
 & lev2d, &
 & logpres, &
 & nv, &
 & variables, &
 & variable_change, &
 & nomask, &
 & io_keys, &
 & io_values, &
 & qg_redundant, &
 & qg_regional, &
 & qg_urban
namelist/ens1_param/ &
 & ens1_ne, &
 & ens1_nsub
namelist/ens2_param/ &
 & ens2_ne, &
 & ens2_nsub
namelist/sampling_param/ &
 & load_samp_local, &
 & load_samp_global, &
 & write_samp_local, &
 & write_samp_global, &
 & write_samp_grids, &
 & mask_type, &
 & mask_lu, &
 & mask_th, &
 & ncontig_th, &
 & mask_check, &
 & diag_draw_type, &
 & Lcoast, &
 & rcoast, &
 & nc1, &
 & nc2, &
 & nc3, &
 & dc, &
 & nl0r, &
 & irmax
namelist/diag_param/ &
 & ne, &
 & gen_kurt_th, &
 & gau_approx, &
 & avg_nbins, &
 & vbal_block, &
 & vbal_rad, &
 & vbal_dlat, &
 & vbal_diag_auto, &
 & vbal_diag_reg, &
 & vbal_pseudo_inv, &
 & vbal_pseudo_inv_mmax, &
 & vbal_pseudo_inv_var_th, &
 & forced_var, &
 & stddev, &
 & var_filter, &
 & var_niter, &
 & var_npass, &
 & var_rhflt, &
 & local_diag, &
 & local_rad, &
 & local_dlat
namelist/fit_param/ &
 & diag_rhflt, &
 & diag_rvflt, &
 & fit_dl0, &
 & peakness, &
 & negative_lobe, &
 & diag_sqrt, &
 & lct_nscales, &
 & lct_scale_ratio, &
 & lct_cor_min, &
 & lct_diag, &
 & lct_qc_th, &
 & lct_qc_max, &
 & lct_write_cor
namelist/nicas_param/ &
 & nonunit_diag, &
 & resol, &
 & nc1max, &
 & nicas_draw_type, &
 & network, &
 & forced_radii, &
 & rh, &
 & pkh, &
 & rv, &
 & pkv, &
 & nlv, &
 & min_lev, &
 & max_lev, &
 & pos_def_test, &
 & write_nicas_c0, &
 & write_nicas_grids, &
 & ndir, &
 & londir, &
 & latdir, &
 & levdir, &
 & ivdir
namelist/output_param/ &
 & full_grid_smoother_nn, &
 & nldwv, &
 & img_ldwv, &
 & lon_ldwv, &
 & lat_ldwv, &
 & name_ldwv
namelist/wind_param/ &
 & wind_streamfunction, &
 & wind_velocity_potential, &
 & wind_zonal, &
 & wind_meridional, &
 & wind_nlon, &
 & wind_nlat, &
 & wind_nsg, &
 & wind_inflation

if (mpl%main) then
   ! general_param default
   datadir = '.'
   prefix = ''
   model = 'online'
   verbosity = 'all'
   colorlog = .false.
   default_seed = .true.
   repro = .true.
   rth = 1.0e-12_kind_real
   parallel_io = .true.
   nprocio = min(mpl%nproc,nprociomax)
   universe_rad = pi*req
   use_cgal = .false.

   ! driver_param default
   method = ''
   strategy = ''
   new_normality = .false.
   new_vbal_cov = .false.
   update_vbal_cov = .false.
   load_vbal_cov = .false.
   write_vbal_cov = .false.
   new_vbal = .false.
   load_vbal = .false.
   write_vbal = .true.
   new_var = .false.
   update_var = .false.
   load_var = .false.
   write_var = .true.
   new_mom = .false.
   update_mom = .false.
   load_mom = .false.
   write_mom = .false.
   new_hdiag = .false.
   write_hdiag = .true.
   new_lct = .false.
   write_lct = .true.
   load_cmat = .false.
   write_cmat = .true.
   new_nicas = .false.
   load_nicas_local = .false.
   load_nicas_global = .false.
   write_nicas_local = .true.
   write_nicas_global = .true.
   new_wind = .false.
   load_wind_local = .false.
   write_wind_local = .true.
   check_vbal = .false.
   check_adjoints = .false.
   check_dirac = .false.
   check_randomization = .false.
   check_consistency = .false.
   check_optimality = .false.
   check_no_point_mpi = .false.
   check_no_point_mask = .false.
   check_set_param_cor = .false.
   check_set_param_hyb = .false.
   check_set_param_lct = .false.
   check_get_param_stddev = .false.
   check_get_param_cor = .false.
   check_get_param_hyb = .false.
   check_get_param_Dloc = .false.
   check_get_param_lct = .false.
   check_apply_vbal = .false.
   check_apply_stddev = .false.
   check_apply_nicas = .false.

   ! files_param default
   do isub=0,nsubmax
      fname_var(isub) = ''
   end do
   fname_samp = ''
   do isub=0,nsubmax
      fname_vbal_cov(isub) = ''
   end do
   fname_vbal = ''
   do isub=0,nsubmax
      fname_mom(isub) = ''
   end do
   fname_cmat = ''
   fname_nicas = ''
   fname_wind = ''

   ! model_param default
   nl0 = 0
   do il0=1,nl0max
      levs(il0) = il0
   end do
   lev2d = 'first'
   logpres = .false.
   nv = 0
   do iv=1,nvmax
      variables(iv) = ''
   end do
   variable_change = ''
   nomask = .false.
   do i=1,niokvmax
      io_keys(i) = ''
      io_values(i) = ''
   end do
   qg_redundant = .false.
   qg_regional = .false.
   qg_urban = .false.

   ! ens1_param default
   ens1_ne = 0
   ens1_nsub = 1

   ! ens2_param default
   ens2_ne = 0
   ens2_nsub = 1

   ! sampling_param default
   load_samp_local = .false.
   load_samp_global = .false.
   write_samp_local = .false.
   write_samp_global = .false.
   write_samp_grids = .false.
   mask_type = 'none'
   do iv=1,nvmax
      mask_lu(iv) = 'lower'
      mask_th(iv) = zero
   end do
   ncontig_th = 0
   mask_check = .false.
   diag_draw_type = 'random_uniform'
   Lcoast = zero
   rcoast = zero
   nc1 = 0
   nc2 = 0
   nc3 = 0
   dc = zero
   nl0r = 0
   irmax = 10000

   ! diag_param default
   ne = 0
   gen_kurt_th = huge_real
   gau_approx = .false.
   avg_nbins = 0
   do iv=1,nvbalmax
      vbal_block(iv) = .false.
   end do
   vbal_rad = zero
   vbal_dlat = zero
   do iv=1,nvbalmax
      vbal_diag_auto(iv) = .true.
   end do
   do iv=1,nvbalmax
      vbal_diag_reg(iv) = .true.
   end do
   vbal_pseudo_inv = .false.
   vbal_pseudo_inv_mmax = 0
   vbal_pseudo_inv_var_th = zero
   forced_var = .false.
   stddev = zero
   var_filter = .false.
   var_niter = -1
   var_npass = -1
   var_rhflt = zero
   local_diag = .false.
   local_rad = zero
   local_dlat = zero

   ! fit_param default
   diag_rhflt = zero
   diag_rvflt = zero
   fit_dl0 = 1
   peakness = .false.
   negative_lobe = .false.
   diag_sqrt = .false.
   lct_nscales = 0
   lct_scale_ratio = ten
   lct_cor_min = half
   lct_diag = .false.
   lct_qc_th = zero
   lct_qc_max = one
   lct_write_cor = .false.

   ! nicas_param default
   nonunit_diag = .false.
   resol = zero
   nc1max = 15000
   nicas_draw_type = 'random_uniform'
   network = .false.
   forced_radii = .false.
   rh = -one
   pkh = pk(ipkhdef)
   rv = -one
   pkv = pk(ipkvdef)
   nlv = zero
   min_lev = 1
   max_lev = nl0max
   pos_def_test = .false.
   write_nicas_c0 = .true.
   write_nicas_grids = .false.

   ! dirac_param default
   ndir = 0
   londir = zero
   latdir = zero
   levdir = 0
   ivdir = 0

   ! output_param default
   full_grid_smoother_nn = 0
   nldwv = 0
   img_ldwv = 0
   lon_ldwv = zero
   lat_ldwv = zero
   do ildwv=1,nldwvmax
      name_ldwv(ildwv) = ''
   end do

   ! wind_param default
   wind_streamfunction = 'stream_function'
   wind_velocity_potential = 'velocity_potential'
   wind_zonal = 'eastward_wind'
   wind_meridional = 'northward_wind'
   wind_nlon = 0
   wind_nlat = 0
   wind_nsg = 0
   wind_inflation = one

   ! Check maximum sizes
   if (nam%nl0>nl0max) call mpl%abort('${subr}$','nl0 is too large')
   if (nam%nv>nvmax) call mpl%abort('${subr}$','nv is too large')
   if (nam%nc3>nc3max) call mpl%abort('${subr}$','nc3 is too large')
   if (nam%lct_nscales>nscalesmax) call mpl%abort('${subr}$','lct_nscales is too large')
   if (nam%ndir>ndirmax) call mpl%abort('${subr}$','ndir is too large')
   if (nam%nldwv>nldwvmax) call mpl%abort('${subr}$','nldwv is too large')

   ! Open namelist
   call mpl%newunit(lunit)
   open(unit=lunit,file=namelname,status='old',action='read')

   ! general_param
   read(lunit,nml=general_param)
   nam%datadir = datadir
   nam%prefix = prefix
   nam%model = model
   nam%verbosity = verbosity
   nam%colorlog = colorlog
   nam%default_seed = default_seed
   nam%repro = repro
   nam%rth = rth
   nam%parallel_io = parallel_io
   nam%nprocio = nprocio
   nam%universe_rad = universe_rad
   nam%use_cgal = use_cgal

   ! driver_param
   read(lunit,nml=driver_param)
   nam%method = method
   nam%strategy = strategy
   nam%new_normality = new_normality
   nam%new_vbal_cov = new_vbal_cov
   nam%update_vbal_cov = update_vbal_cov
   nam%load_vbal_cov = load_vbal_cov
   nam%write_vbal_cov = write_vbal_cov
   nam%new_vbal = new_vbal
   nam%load_vbal = load_vbal
   nam%write_vbal = write_vbal
   nam%new_var = new_var
   nam%update_var = update_var
   nam%load_var = load_var
   nam%write_var = write_var
   nam%new_mom = new_mom
   nam%update_mom = update_mom
   nam%load_mom = load_mom
   nam%write_mom = write_mom
   nam%new_hdiag = new_hdiag
   nam%write_hdiag = write_hdiag
   nam%new_lct = new_lct
   nam%write_lct = write_lct
   nam%load_cmat = load_cmat
   nam%write_cmat = write_cmat
   nam%new_nicas = new_nicas
   nam%load_nicas_local = load_nicas_local
   nam%load_nicas_global = load_nicas_global
   nam%write_nicas_local = write_nicas_local
   nam%write_nicas_global = write_nicas_global
   nam%new_wind = new_wind
   nam%load_wind_local = load_wind_local
   nam%write_wind_local = write_wind_local
   nam%check_vbal = check_vbal
   nam%check_adjoints = check_adjoints
   nam%check_dirac = check_dirac
   nam%check_randomization = check_randomization
   nam%check_consistency = check_consistency
   nam%check_optimality = check_optimality
   nam%check_no_point_mpi = check_no_point_mpi
   nam%check_no_point_mask = check_no_point_mask
   nam%check_set_param_cor = check_set_param_cor
   nam%check_set_param_hyb = check_set_param_hyb
   nam%check_set_param_lct = check_set_param_lct
   nam%check_get_param_stddev = check_get_param_stddev
   nam%check_get_param_cor = check_get_param_cor
   nam%check_get_param_hyb = check_get_param_hyb
   nam%check_get_param_Dloc = check_get_param_Dloc
   nam%check_get_param_lct = check_get_param_lct
   nam%check_apply_vbal = check_apply_vbal
   nam%check_apply_stddev = check_apply_stddev
   nam%check_apply_nicas = check_apply_nicas

   ! files_param
   nam%fname_var = fname_var
   nam%fname_samp = fname_samp
   nam%fname_vbal_cov = fname_vbal_cov
   nam%fname_vbal = fname_vbal
   nam%fname_mom = fname_mom
   nam%fname_cmat = fname_cmat
   nam%fname_nicas = fname_nicas
   nam%fname_wind = fname_wind

   ! model_param
   read(lunit,nml=model_param)
   nam%nl0 = nl0
   nam%levs = levs
   nam%lev2d = lev2d
   nam%logpres = logpres
   nam%nv = nv
   nam%variables = variables
   nam%variable_change = variable_change
   nam%nomask = nomask
   nam%io_keys = io_keys
   nam%io_values = io_values
   nam%qg_redundant = qg_redundant
   nam%qg_regional = qg_regional
   nam%qg_urban = qg_urban

   ! ens1_param
   read(lunit,nml=ens1_param)
   nam%ens1_ne = ens1_ne
   nam%ens1_nsub = ens1_nsub

   ! ens2_param
   read(lunit,nml=ens2_param)
   nam%ens2_ne = ens2_ne
   nam%ens2_nsub = ens2_nsub

   ! sampling_param
   read(lunit,nml=sampling_param)
   nam%load_samp_local = load_samp_local
   nam%load_samp_global = load_samp_global
   nam%write_samp_local = write_samp_local
   nam%write_samp_global = write_samp_global
   nam%write_samp_grids = write_samp_grids
   nam%mask_type = mask_type
   nam%mask_lu = mask_lu
   nam%mask_th = mask_th
   nam%ncontig_th = ncontig_th
   nam%mask_check = mask_check
   nam%diag_draw_type = diag_draw_type
   nam%Lcoast = Lcoast
   nam%rcoast = rcoast
   nam%nc1 = nc1
   nam%nc2 = nc2
   nam%nc3 = nc3
   nam%dc = dc
   nam%nl0r = nl0r
   nam%irmax = irmax

   ! diag_param
   read(lunit,nml=diag_param)
   nam%ne = ne
   nam%gen_kurt_th = gen_kurt_th
   nam%gau_approx = gau_approx
   nam%avg_nbins = avg_nbins
   nam%vbal_block = vbal_block
   nam%vbal_rad = vbal_rad
   nam%vbal_dlat = vbal_dlat
   nam%vbal_diag_auto = vbal_diag_auto
   nam%vbal_diag_reg = vbal_diag_reg
   nam%vbal_pseudo_inv = vbal_pseudo_inv
   nam%vbal_pseudo_inv_mmax = vbal_pseudo_inv_mmax
   nam%vbal_pseudo_inv_var_th = vbal_pseudo_inv_var_th
   nam%forced_var = forced_var
   nam%stddev = stddev
   nam%var_filter = var_filter
   nam%var_niter = var_niter
   nam%var_npass = var_npass
   nam%var_rhflt = var_rhflt
   nam%local_diag = local_diag
   nam%local_rad = local_rad
   nam%local_dlat = local_dlat

   ! fit_param
   read(lunit,nml=fit_param)
   nam%diag_rhflt = diag_rhflt
   nam%diag_rvflt = diag_rvflt
   nam%fit_dl0 = fit_dl0
   nam%peakness = peakness
   nam%negative_lobe = negative_lobe
   nam%diag_sqrt = diag_sqrt
   nam%lct_nscales = lct_nscales
   nam%lct_scale_ratio = lct_scale_ratio
   nam%lct_cor_min = lct_cor_min
   nam%lct_diag = lct_diag
   nam%lct_qc_th = lct_qc_th
   nam%lct_qc_max = lct_qc_max
   nam%lct_write_cor = lct_write_cor

   ! nicas_param
   read(lunit,nml=nicas_param)
   nam%nonunit_diag = nonunit_diag
   nam%resol = resol
   nam%nc1max = nc1max
   nam%nicas_draw_type = nicas_draw_type
   nam%network = network
   nam%forced_radii = forced_radii
   nam%rh = rh
   nam%pkh = pkh
   nam%rv = rv
   nam%pkv = pkv
   nam%nlv = nlv
   nam%min_lev = min_lev
   nam%max_lev = max_lev
   nam%pos_def_test = pos_def_test
   nam%write_nicas_c0 = write_nicas_c0
   nam%write_nicas_grids = write_nicas_grids

   ! dirac_param
   nam%ndir = ndir
   nam%londir = londir
   nam%latdir = latdir
   nam%levdir = levdir
   nam%ivdir = ivdir

   ! output_param
   read(lunit,nml=output_param)
   nam%full_grid_smoother_nn = full_grid_smoother_nn
   nam%nldwv = nldwv
   nam%img_ldwv = img_ldwv
   nam%lon_ldwv = lon_ldwv
   nam%lat_ldwv = lat_ldwv
   nam%name_ldwv = name_ldwv

   ! wind_param
   nam%wind_streamfunction = wind_streamfunction
   nam%wind_velocity_potential = wind_velocity_potential
   nam%wind_zonal = wind_zonal
   nam%wind_meridional = wind_meridional
   nam%wind_nlon = wind_nlon
   nam%wind_nlat = wind_nlat
   nam%wind_nsg = wind_nsg
   nam%wind_inflation = wind_inflation

   ! Close namelist
   close(unit=lunit)
end if

end subroutine nam_read

!----------------------------------------------------------------------
! Subroutine: nam_bcast
!> Broadcast
!----------------------------------------------------------------------
subroutine nam_bcast(nam,mpl)

implicit none

! Passed variable
class(nam_type),intent(inout) :: nam !< Namelist
type(mpl_type),intent(inout) :: mpl  !< MPI data

! Set name
@:set_name(nam_bcast)

! Probe in
@:probe_in()

! general_param
call mpl%f_comm%broadcast(nam%datadir,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%prefix,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%model,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%verbosity,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%colorlog,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%default_seed,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%repro,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%rth,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%parallel_io,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%nprocio,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%universe_rad,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%use_cgal,mpl%rootproc-1)

! driver_param
call mpl%f_comm%broadcast(nam%method,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%strategy,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%new_normality,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%new_vbal_cov,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%update_vbal_cov,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%load_vbal_cov,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%write_vbal_cov,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%new_vbal,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%load_vbal,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%write_vbal,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%new_var,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%update_var,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%load_var,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%write_var,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%new_mom,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%update_mom,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%load_mom,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%write_mom,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%new_hdiag,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%write_hdiag,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%new_lct,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%write_lct,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%load_cmat,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%write_cmat,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%new_nicas,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%load_nicas_local,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%load_nicas_global,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%write_nicas_local,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%write_nicas_global,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%new_wind,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%load_wind_local,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%write_wind_local,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%check_vbal,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%check_adjoints,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%check_dirac,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%check_randomization,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%check_consistency,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%check_optimality,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%check_no_point_mpi,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%check_no_point_mask,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%check_set_param_cor,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%check_set_param_hyb,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%check_set_param_lct,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%check_get_param_stddev,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%check_get_param_cor,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%check_get_param_hyb,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%check_get_param_Dloc,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%check_get_param_lct,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%check_apply_vbal,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%check_apply_stddev,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%check_apply_nicas,mpl%rootproc-1)

! files_param
call mpl%broadcast(nam%fname_var,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%fname_samp,mpl%rootproc-1)
call mpl%broadcast(nam%fname_vbal_cov,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%fname_vbal,mpl%rootproc-1)
call mpl%broadcast(nam%fname_mom,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%fname_cmat,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%fname_nicas,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%fname_wind,mpl%rootproc-1)

! model_param
call mpl%f_comm%broadcast(nam%nl0,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%levs,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%lev2d,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%logpres,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%nv,mpl%rootproc-1)
call mpl%broadcast(nam%variables,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%variable_change,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%nomask,mpl%rootproc-1)
call mpl%broadcast(nam%io_keys,mpl%rootproc-1)
call mpl%broadcast(nam%io_values,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%qg_redundant,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%qg_regional,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%qg_urban,mpl%rootproc-1)

! ens1_param
call mpl%f_comm%broadcast(nam%ens1_ne,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%ens1_nsub,mpl%rootproc-1)

! ens2_param
call mpl%f_comm%broadcast(nam%ens2_ne,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%ens2_nsub,mpl%rootproc-1)

! sampling_param
call mpl%f_comm%broadcast(nam%load_samp_local,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%load_samp_global,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%write_samp_local,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%write_samp_global,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%write_samp_grids,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%mask_type,mpl%rootproc-1)
call mpl%broadcast(nam%mask_lu,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%mask_th,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%ncontig_th,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%mask_check,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%diag_draw_type,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%Lcoast,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%rcoast,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%nc1,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%nc2,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%nc3,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%dc,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%nl0r,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%irmax,mpl%rootproc-1)

! diag_param
call mpl%f_comm%broadcast(nam%ne,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%gen_kurt_th,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%gau_approx,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%avg_nbins,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%vbal_block,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%vbal_rad,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%vbal_dlat,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%vbal_diag_auto,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%vbal_diag_reg,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%vbal_pseudo_inv,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%vbal_pseudo_inv_mmax,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%vbal_pseudo_inv_var_th,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%forced_var,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%stddev,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%var_filter,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%var_niter,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%var_npass,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%var_rhflt,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%local_diag,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%local_rad,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%local_dlat,mpl%rootproc-1)

! fit_param
call mpl%f_comm%broadcast(nam%diag_rhflt,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%diag_rvflt,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%fit_dl0,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%peakness,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%negative_lobe,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%diag_sqrt,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%lct_nscales,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%lct_scale_ratio,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%lct_cor_min,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%lct_diag,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%lct_qc_th,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%lct_qc_max,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%lct_write_cor,mpl%rootproc-1)

! nicas_param
call mpl%f_comm%broadcast(nam%nonunit_diag,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%resol,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%nc1max,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%nicas_draw_type,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%network,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%forced_radii,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%rh,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%pkh,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%rv,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%pkv,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%nlv,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%min_lev,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%max_lev,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%pos_def_test,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%write_nicas_c0,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%write_nicas_grids,mpl%rootproc-1)

! dirac_param
call mpl%f_comm%broadcast(nam%ndir,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%londir,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%latdir,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%levdir,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%ivdir,mpl%rootproc-1)

! output_param
call mpl%f_comm%broadcast(nam%full_grid_smoother_nn,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%nldwv,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%img_ldwv,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%lon_ldwv,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%lat_ldwv,mpl%rootproc-1)
call mpl%broadcast(nam%name_ldwv,mpl%rootproc-1)

! wind_param
call mpl%f_comm%broadcast(nam%wind_streamfunction,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%wind_velocity_potential,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%wind_zonal,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%wind_meridional,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%wind_nlon,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%wind_nlat,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%wind_nsg,mpl%rootproc-1)
call mpl%f_comm%broadcast(nam%wind_inflation,mpl%rootproc-1)

! Probe out
@:probe_out()

end subroutine nam_bcast

!----------------------------------------------------------------------
! Subroutine: nam_from_conf
!> Intialize from configuration
!----------------------------------------------------------------------
subroutine nam_from_conf(nam,comm,conf)

implicit none

! Passed variable
class(nam_type),intent(inout) :: nam         !< Namelist
type(fckit_mpi_comm),intent(in) :: comm      !< FCKIT MPI communicator wrapper
type(fckit_configuration),intent(in) :: conf !< Configuration

! Local variables
integer :: iv
integer,allocatable :: integer_array(:)
real(kind_real),allocatable :: real_array(:)
logical,allocatable :: logical_array(:)
character(len=:),allocatable :: str
character(len=:),allocatable :: str_array(:)
type(fckit_configuration) :: subconf

! Set name
@:set_name(nam_from_conf)

! Probe in
@:probe_in()

! general_param
if (conf%has('datadir')) then
   call conf%get_or_die('datadir',str)
   nam%datadir = str
end if
if (conf%has('prefix')) then
   call conf%get_or_die('prefix',str)
   nam%prefix = str
end if
if (conf%has('model')) then
   call conf%get_or_die('model',str)
   nam%model = str
end if
if (conf%has('verbosity')) then
   call conf%get_or_die('verbosity',str)
   nam%verbosity = str
end if
if (conf%has('colorlog')) call conf%get_or_die('colorlog',nam%colorlog)
if (conf%has('default_seed')) call conf%get_or_die('default_seed',nam%default_seed)
if (conf%has('repro')) call conf%get_or_die('repro',nam%repro)
if (conf%has('rth')) call conf%get_or_die('rth',nam%rth)
if (conf%has('parallel_io')) call conf%get_or_die('parallel_io',nam%parallel_io)
if (conf%has('nprocio')) call conf%get_or_die('nprocio',nam%nprocio)
if (conf%has('universe_rad')) call conf%get_or_die('universe_rad',nam%universe_rad)
if (conf%has('use_cgal')) call conf%get_or_die('use_cgal',nam%use_cgal)

! driver_param
if (conf%has('method')) then
   call conf%get_or_die('method',str)
   nam%method = str
end if
if (conf%has('strategy')) then
   call conf%get_or_die('strategy',str)
   nam%strategy = str
end if
if (conf%has('new_normality')) call conf%get_or_die('new_normality',nam%new_normality)
if (conf%has('new_vbal_cov')) call conf%get_or_die('new_vbal_cov',nam%new_vbal_cov)
if (conf%has('update_vbal_cov')) call conf%get_or_die('update_vbal_cov',nam%update_vbal_cov)
if (conf%has('load_vbal_cov')) call conf%get_or_die('load_vbal_cov',nam%load_vbal_cov)
if (conf%has('write_vbal_cov')) call conf%get_or_die('write_vbal_cov',nam%write_vbal_cov)
if (conf%has('new_vbal')) call conf%get_or_die('new_vbal',nam%new_vbal)
if (conf%has('load_vbal')) call conf%get_or_die('load_vbal',nam%load_vbal)
if (conf%has('write_vbal')) call conf%get_or_die('write_vbal',nam%write_vbal)
if (conf%has('new_var')) call conf%get_or_die('new_var',nam%new_var)
if (conf%has('update_var')) call conf%get_or_die('update_var',nam%update_var)
if (conf%has('load_var')) call conf%get_or_die('load_var',nam%load_var)
if (conf%has('write_var')) call conf%get_or_die('write_var',nam%write_var)
if (conf%has('new_mom')) call conf%get_or_die('new_mom',nam%new_mom)
if (conf%has('update_mom')) call conf%get_or_die('update_mom',nam%update_mom)
if (conf%has('load_mom')) call conf%get_or_die('load_mom',nam%load_mom)
if (conf%has('write_mom')) call conf%get_or_die('write_mom',nam%write_mom)
if (conf%has('new_hdiag')) call conf%get_or_die('new_hdiag',nam%new_hdiag)
if (conf%has('write_hdiag')) call conf%get_or_die('write_hdiag',nam%write_hdiag)
if (conf%has('new_lct')) call conf%get_or_die('new_lct',nam%new_lct)
if (conf%has('write_lct')) call conf%get_or_die('write_lct',nam%write_lct)
if (conf%has('load_cmat')) call conf%get_or_die('load_cmat',nam%load_cmat)
if (conf%has('write_cmat')) call conf%get_or_die('write_cmat',nam%write_cmat)
if (conf%has('new_nicas')) call conf%get_or_die('new_nicas',nam%new_nicas)
if (conf%has('load_nicas_local')) call conf%get_or_die('load_nicas_local',nam%load_nicas_local)
if (conf%has('load_nicas_global')) call conf%get_or_die('load_nicas_global',nam%load_nicas_global)
if (conf%has('write_nicas_local')) call conf%get_or_die('write_nicas_local',nam%write_nicas_local)
if (conf%has('write_nicas_global')) call conf%get_or_die('write_nicas_global',nam%write_nicas_global)
if (conf%has('new_wind')) call conf%get_or_die('new_wind',nam%new_wind)
if (conf%has('load_wind_local')) call conf%get_or_die('load_wind_local',nam%load_wind_local)
if (conf%has('write_wind_local')) call conf%get_or_die('write_wind_local',nam%write_wind_local)
if (conf%has('check_vbal')) call conf%get_or_die('check_vbal',nam%check_vbal)
if (conf%has('check_adjoints')) call conf%get_or_die('check_adjoints',nam%check_adjoints)
if (conf%has('check_dirac')) call conf%get_or_die('check_dirac',nam%check_dirac)
if (conf%has('check_randomization')) call conf%get_or_die('check_randomization',nam%check_randomization)
if (conf%has('check_consistency')) call conf%get_or_die('check_consistency',nam%check_consistency)
if (conf%has('check_optimality')) call conf%get_or_die('check_optimality',nam%check_optimality)
if (conf%has('check_no_point_mpi')) call conf%get_or_die('check_no_point_mpi',nam%check_no_point_mpi)
if (conf%has('check_no_point_mask')) call conf%get_or_die('check_no_point_mask',nam%check_no_point_mask)
if (conf%has('check_set_param_cor')) call conf%get_or_die('check_set_param_cor',nam%check_set_param_cor)
if (conf%has('check_set_param_hyb')) call conf%get_or_die('check_set_param_hyb',nam%check_set_param_hyb)
if (conf%has('check_set_param_lct')) call conf%get_or_die('check_set_param_lct',nam%check_set_param_lct)
if (conf%has('check_get_param_stddev')) call conf%get_or_die('check_get_param_stddev',nam%check_get_param_stddev)
if (conf%has('check_get_param_cor')) call conf%get_or_die('check_get_param_cor',nam%check_get_param_cor)
if (conf%has('check_get_param_hyb')) call conf%get_or_die('check_get_param_hyb',nam%check_get_param_hyb)
if (conf%has('check_get_param_Dloc')) call conf%get_or_die('check_get_param_Dloc',nam%check_get_param_Dloc)
if (conf%has('check_get_param_lct')) call conf%get_or_die('check_get_param_lct',nam%check_get_param_lct)
if (conf%has('check_apply_vbal')) call conf%get_or_die('check_apply_vbal',nam%check_apply_vbal)
if (conf%has('check_apply_stddev')) call conf%get_or_die('check_apply_stddev',nam%check_apply_stddev)
if (conf%has('check_apply_nicas')) call conf%get_or_die('check_apply_nicas',nam%check_apply_nicas)

! files_param
if (conf%has('fname_var')) then
   call conf%get_or_die('fname_var',str_array)
   if (size(str_array)>nsubmax) then
      write(output_unit,'(a,i4)') '!!! ABORT in nam_from_conf: fname_var size should be smaller than ',nsubmax
      call flush(output_unit)
      call comm%abort(1)
   end if
   nam%fname_var(1:size(str_array)) = str_array
end if
if (conf%has('fname_samp')) then
   call conf%get_or_die('fname_samp',str)
   nam%fname_samp = str
end if
if (conf%has('fname_vbal_cov')) then
   call conf%get_or_die('fname_vbal_cov',str_array)
   if (size(str_array)>nsubmax) then
      write(output_unit,'(a,i4)') '!!! ABORT in nam_from_conf: fname_vbal_cov size should be smaller than ',nsubmax
      call flush(output_unit)
      call comm%abort(1)
   end if
   nam%fname_vbal_cov(1:size(str_array)) = str_array
end if
if (conf%has('fname_vbal')) then
   call conf%get_or_die('fname_vbal',str)
   nam%fname_vbal = str
end if
if (conf%has('fname_mom')) then
   call conf%get_or_die('fname_mom',str_array)
   if (size(str_array)>nsubmax) then
      write(output_unit,'(a,i4)') '!!! ABORT in nam_from_conf: fname_mom size should be smaller than ',nsubmax
      call flush(output_unit)
      call comm%abort(1)
   end if
   nam%fname_mom(1:size(str_array)) = str_array
end if
if (conf%has('fname_cmat')) then
   call conf%get_or_die('fname_cmat',str)
   nam%fname_cmat = str
end if
if (conf%has('fname_nicas')) then
   call conf%get_or_die('fname_nicas',str)
   nam%fname_nicas = str
end if
if (conf%has('fname_wind')) then
   call conf%get_or_die('fname_wind',str)
   nam%fname_wind = str
end if

! model_param
if (conf%has('nl0')) call conf%get_or_die('nl0',nam%nl0)
if (conf%has('levs')) then
   call conf%get_or_die('levs',integer_array)
   if (size(integer_array)>nl0max) then
      write(output_unit,'(a,i4)') '!!! ABORT in nam_from_conf: levs size should be smaller than ',nl0max
      call flush(output_unit)
      call comm%abort(1)
   end if
   nam%levs(1:size(integer_array)) = integer_array
end if
if (conf%has('lev2d')) then
   call conf%get_or_die('lev2d',str)
   nam%lev2d = str
end if
if (conf%has('logpres')) call conf%get_or_die('logpres',nam%logpres)
if (conf%has('nv')) call conf%get_or_die('nv',nam%nv)
if (conf%has('variables')) then
   call conf%get_or_die('variables',str_array)
   if (size(str_array)>nvmax) then
      write(output_unit,'(a,i4)') '!!! ABORT in nam_from_conf: variables size should be smaller than ',nvmax
      call flush(output_unit)
      call comm%abort(1)
   end if
   nam%variables(1:size(str_array)) = str_array
end if
if (conf%has('variable_change')) then
   call conf%get_or_die('variable_change',str)
   nam%variable_change = str
end if
if (conf%has('nomask')) call conf%get_or_die('nomask',nam%nomask)
if (conf%has('io_keys')) then
   call conf%get_or_die('io_keys',str_array)
   if (size(str_array)>niokvmax) then
      write(output_unit,'(a,i4)') '!!! ABORT in nam_from_conf: io_keys size should be smaller than ',niokvmax
      call flush(output_unit)
      call comm%abort(1)
   end if
   nam%io_keys(1:size(str_array)) = str_array
end if
if (conf%has('io_values')) then
   call conf%get_or_die('io_values',str_array)
   if (size(str_array)>niokvmax) then
      write(output_unit,'(a,i4)') '!!! ABORT in nam_from_conf: io_values size should be smaller than ',niokvmax
      call flush(output_unit)
      call comm%abort(1)
   end if
   nam%io_values(1:size(str_array)) = str_array
end if
if (conf%has('qg_redundant')) call conf%get_or_die('qg_redundant',nam%qg_redundant)
if (conf%has('qg_regional')) call conf%get_or_die('qg_regional',nam%qg_regional)
if (conf%has('qg_urban')) call conf%get_or_die('qg_urban',nam%qg_urban)

! ens1_param
if (conf%has('ens1_ne')) call conf%get_or_die('ens1_ne',nam%ens1_ne)
if (conf%has('ens1_nsub')) call conf%get_or_die('ens1_nsub',nam%ens1_nsub)

! ens2_param
if (conf%has('ens2_ne')) call conf%get_or_die('ens2_ne',nam%ens2_ne)
if (conf%has('ens2_nsub')) call conf%get_or_die('ens2_nsub',nam%ens2_nsub)

! sampling_param
if (conf%has('load_samp_local')) call conf%get_or_die('load_samp_local',nam%load_samp_local)
if (conf%has('load_samp_global')) call conf%get_or_die('load_samp_global',nam%load_samp_global)
if (conf%has('write_samp_local')) call conf%get_or_die('write_samp_local',nam%write_samp_local)
if (conf%has('write_samp_global')) call conf%get_or_die('write_samp_global',nam%write_samp_global)
if (conf%has('write_samp_grids')) call conf%get_or_die('write_samp_grids',nam%write_samp_grids)
if (conf%has('mask_type')) then
   call conf%get_or_die('mask_type',str)
   nam%mask_type = str
end if
if (conf%has('mask_lu')) then
   call conf%get_or_die('mask_lu',str_array)
   if (size(str_array)>nvmax) then
      write(output_unit,'(a,i4)') '!!! ABORT in nam_from_conf: mask_lu size should be smaller than ',nvmax
      call flush(output_unit)
      call comm%abort(1)
   end if
   nam%mask_lu(1:size(str_array)) = str_array
end if
if (conf%has('mask_th')) then
   call conf%get_or_die('mask_th',real_array)
   if (size(real_array)>nvmax) then
      write(output_unit,'(a,i4)') '!!! ABORT in nam_from_conf: mask_th size should be smaller than ',nvmax
      call flush(output_unit)
      call comm%abort(1)
   end if
   nam%mask_th(1:size(real_array)) = real_array
end if
if (conf%has('ncontig_th')) call conf%get_or_die('ncontig_th',nam%ncontig_th)
if (conf%has('mask_check')) call conf%get_or_die('mask_check',nam%mask_check)
if (conf%has('diag_draw_type')) then
   call conf%get_or_die('diag_draw_type',str)
   nam%diag_draw_type = str
end if
if (conf%has('Lcoast')) call conf%get_or_die('Lcoast',nam%Lcoast)
if (conf%has('rcoast')) call conf%get_or_die('rcoast',nam%rcoast)
if (conf%has('nc1')) call conf%get_or_die('nc1',nam%nc1)
if (conf%has('nc2')) call conf%get_or_die('nc2',nam%nc2)
if (conf%has('nc3')) call conf%get_or_die('nc3',nam%nc3)
if (conf%has('dc')) call conf%get_or_die('dc',nam%dc)
if (conf%has('nl0r')) call conf%get_or_die('nl0r',nam%nl0r)
if (conf%has('irmax')) call conf%get_or_die('irmax',nam%irmax)

! diag_param
if (conf%has('ne')) call conf%get_or_die('ne',nam%ne)
if (conf%has('gen_kurt_th')) call conf%get_or_die('gen_kurt_th',nam%gen_kurt_th)
if (conf%has('gau_approx')) call conf%get_or_die('gau_approx',nam%gau_approx)
if (conf%has('avg_nbins')) call conf%get_or_die('avg_nbins',nam%avg_nbins)
if (conf%has('vbal_block')) then
   call conf%get_or_die('vbal_block',logical_array)
   if (size(logical_array)>nvbalmax) then
      write(output_unit,'(a,i4)') '!!! ABORT in nam_from_conf: vbal_block size should be smaller than ',nvbalmax
      call flush(output_unit)
      call comm%abort(1)
   end if
   nam%vbal_block(1:size(logical_array)) = logical_array
end if
if (conf%has('vbal_rad')) call conf%get_or_die('vbal_rad',nam%vbal_rad)
if (conf%has('vbal_dlat')) call conf%get_or_die('vbal_dlat',nam%vbal_dlat)
if (conf%has('vbal_diag_auto')) then
   call conf%get_or_die('vbal_diag_auto',logical_array)
   if (size(logical_array)>nvbalmax) then
      write(output_unit,'(a,i4)') '!!! ABORT in nam_from_conf: vbal_diag_auto size should be smaller than ',nvbalmax
      call flush(output_unit)
      call comm%abort(1)
   end if
   nam%vbal_diag_auto(1:size(logical_array)) = logical_array
end if
if (conf%has('vbal_diag_reg')) then
   call conf%get_or_die('vbal_diag_reg',logical_array)
   if (size(logical_array)>nvbalmax) then
      write(output_unit,'(a,i4)') '!!! ABORT in nam_from_conf: vbal_diag_reg size should be smaller than ',nvbalmax
      call flush(output_unit)
      call comm%abort(1)
   end if
   nam%vbal_diag_reg(1:size(logical_array)) = logical_array
end if
if (conf%has('vbal_pseudo_inv')) call conf%get_or_die('vbal_pseudo_inv',nam%vbal_pseudo_inv)
if (conf%has('vbal_pseudo_inv_mmax')) call conf%get_or_die('vbal_pseudo_inv_mmax',nam%vbal_pseudo_inv_mmax)
if (conf%has('vbal_pseudo_inv_var_th')) call conf%get_or_die('vbal_pseudo_inv_var_th',nam%vbal_pseudo_inv_var_th)
if (conf%has('forced_var')) call conf%get_or_die('forced_var',nam%forced_var)
if (conf%has('stddev')) then
   call conf%get_or_die('stddev',subconf)
   do iv=1,nam%nv
      if (subconf%has(nam%variables(iv))) then
         call subconf%get_or_die(nam%variables(iv),real_array)
         if (size(real_array)>nl0max) then
            write(output_unit,'(a,a,a,i4)') '!!! ABORT in nam_from_conf: stddev-',trim(nam%variables(iv)), &
 & ' size should be smaller than ',nl0max
            call flush(output_unit)
            call comm%abort(1)
         end if
         if (size(real_array)==1) then
            nam%stddev(:,iv) = real_array(1)
         else
            nam%stddev(1:size(real_array),iv) = real_array
         end if
      end if
   end do
end if
if (conf%has('var_filter')) call conf%get_or_die('var_filter',nam%var_filter)
if (conf%has('var_niter')) call conf%get_or_die('var_niter',nam%var_niter)
if (conf%has('var_npass')) call conf%get_or_die('var_npass',nam%var_npass)
if (conf%has('var_rhflt')) then
   call conf%get_or_die('var_rhflt',subconf)
   do iv=1,nam%nv
      if (subconf%has(nam%variables(iv))) then
         call subconf%get_or_die(nam%variables(iv),real_array)
         if (size(real_array)>nl0max) then
            write(output_unit,'(a,a,a,i4)') '!!! ABORT in nam_from_conf: var_rhflt-',trim(nam%variables(iv)), &
 & ' size should be smaller than ',nl0max
            call flush(output_unit)
            call comm%abort(1)
         end if
         if (size(real_array)==1) then
            nam%var_rhflt(:,iv) = real_array(1)
         else
            nam%var_rhflt(1:size(real_array),iv) = real_array
         end if
      end if
   end do
end if
if (conf%has('local_diag')) call conf%get_or_die('local_diag',nam%local_diag)
if (conf%has('local_rad')) call conf%get_or_die('local_rad',nam%local_rad)
if (conf%has('local_dlat')) call conf%get_or_die('local_dlat',nam%local_dlat)

! fit_param
if (conf%has('diag_rhflt')) call conf%get_or_die('diag_rhflt',nam%diag_rhflt)
if (conf%has('diag_rvflt')) call conf%get_or_die('diag_rvflt',nam%diag_rvflt)
if (conf%has('fit_dl0')) call conf%get_or_die('fit_dl0',nam%fit_dl0)
if (conf%has('peakness')) call conf%get_or_die('peakness',nam%peakness)
if (conf%has('negative_lobe')) call conf%get_or_die('negative_lobe',nam%negative_lobe)
if (conf%has('diag_sqrt')) call conf%get_or_die('diag_sqrt',nam%diag_sqrt)
if (conf%has('lct_nscales')) call conf%get_or_die('lct_nscales',nam%lct_nscales)
if (conf%has('lct_scale_ratio')) call conf%get_or_die('lct_scale_ratio',nam%lct_scale_ratio)
if (conf%has('lct_cor_min')) call conf%get_or_die('lct_cor_min',nam%lct_cor_min)
if (conf%has('lct_diag')) then
   call conf%get_or_die('lct_diag',logical_array)
   if (size(logical_array)>nscalesmax) then
      write(output_unit,'(a,i4)') '!!! ABORT in nam_from_conf: lct_diag size should be smaller than ',nscalesmax
      call flush(output_unit)
      call comm%abort(1)
   end if
   nam%lct_diag(1:size(logical_array)) = logical_array
end if
if (conf%has('lct_qc_th')) call conf%get_or_die('lct_qc_th',nam%lct_qc_th)
if (conf%has('lct_qc_max')) call conf%get_or_die('lct_qc_max',nam%lct_qc_max)
if (conf%has('lct_write_cor')) call conf%get_or_die('lct_write_cor',nam%lct_write_cor)

! nicas_param
if (conf%has('nonunit_diag')) call conf%get_or_die('nonunit_diag',nam%nonunit_diag)
if (conf%has('resol')) call conf%get_or_die('resol',nam%resol)
if (conf%has('nc1max')) call conf%get_or_die('nc1max',nam%nc1max)
if (conf%has('nicas_draw_type')) then
   call conf%get_or_die('nicas_draw_type',str)
   nam%nicas_draw_type = str
end if
if (conf%has('network')) call conf%get_or_die('network',nam%network)
if (conf%has('forced_radii')) call conf%get_or_die('forced_radii',nam%forced_radii)
if (conf%has('rh')) then
   call conf%get_or_die('rh',subconf)
   if (subconf%has('common')) then
      call subconf%get_or_die('common',real_array)
      if (size(real_array)>nl0max) then
         write(output_unit,'(a,i4)') '!!! ABORT in nam_from_conf: rh-common size should be smaller than ',nl0max
         call flush(output_unit)
         call comm%abort(1)
      end if
      if (size(real_array)==1) then
         nam%rh(:,0) = real_array(1)
      else
         nam%rh(1:size(real_array),0) = real_array
      end if
   end if
   do iv=1,nam%nv
      if (subconf%has(nam%variables(iv))) then
         call subconf%get_or_die(nam%variables(iv),real_array)
         if (size(real_array)>nl0max) then
            write(output_unit,'(a,a,a,i4)') '!!! ABORT in nam_from_conf: rh-',trim(nam%variables(iv)), &
 & ' size should be smaller than ',nl0max
            call flush(output_unit)
            call comm%abort(1)
         end if
         if (size(real_array)==1) then
            nam%rh(:,iv) = real_array(1)
         else
            nam%rh(1:size(real_array),iv) = real_array
         end if
      end if
   end do
end if
if (conf%has('pkh')) then
   call conf%get_or_die('pkh',subconf)
   if (subconf%has('common')) then
      call subconf%get_or_die('common',real_array)
      if (size(real_array)>nl0max) then
         write(output_unit,'(a,i4)') '!!! ABORT in nam_from_conf: pkh-common size should be smaller than ',nl0max
         call flush(output_unit)
         call comm%abort(1)
      end if
      if (size(real_array)==1) then
         nam%pkh(:,0) = real_array(1)
      else
         nam%pkh(1:size(real_array),0) = real_array
      end if
   end if
   do iv=1,nam%nv
      if (subconf%has(nam%variables(iv))) then
         call subconf%get_or_die(nam%variables(iv),real_array)
         if (size(real_array)>nl0max) then
            write(output_unit,'(a,a,a,i4)') '!!! ABORT in nam_from_conf: pkh-',trim(nam%variables(iv)), &
 & ' size should be smaller than ',nl0max
            call flush(output_unit)
            call comm%abort(1)
         end if
         if (size(real_array)==1) then
            nam%pkh(:,iv) = real_array(1)
         else
            nam%pkh(1:size(real_array),iv) = real_array
         end if
      end if
   end do
end if
if (conf%has('rv')) then
   call conf%get_or_die('rv',subconf)
   if (subconf%has('common')) then
      call subconf%get_or_die('common',real_array)
      if (size(real_array)>nl0max) then
         write(output_unit,'(a,i4)') '!!! ABORT in nam_from_conf: rv-common size should be smaller than ',nl0max
         call flush(output_unit)
         call comm%abort(1)
      end if
      if (size(real_array)==1) then
         nam%rv(:,0) = real_array(1)
      else
         nam%rv(1:size(real_array),0) = real_array
      end if
   end if
   do iv=1,nam%nv
      if (subconf%has(nam%variables(iv))) then
         call subconf%get_or_die(nam%variables(iv),real_array)
         if (size(real_array)>nl0max) then
            write(output_unit,'(a,a,a,i4)') '!!! ABORT in nam_from_conf: rv-',trim(nam%variables(iv)), &
 & ' size should be smaller than ',nl0max
            call flush(output_unit)
            call comm%abort(1)
         end if
         if (size(real_array)==1) then
            nam%rv(:,iv) = real_array(1)
         else
            nam%rv(1:size(real_array),iv) = real_array
         end if
      end if
   end do
end if
if (conf%has('pkv')) then
   call conf%get_or_die('pkv',subconf)
   if (subconf%has('common')) then
      call subconf%get_or_die('common',real_array)
      if (size(real_array)>nl0max) then
         write(output_unit,'(a,i4)') '!!! ABORT in nam_from_conf: pkv-common size should be smaller than ',nl0max
         call flush(output_unit)
         call comm%abort(1)
      end if
      if (size(real_array)==1) then
         nam%pkv(:,0) = real_array(1)
      else
         nam%pkv(1:size(real_array),0) = real_array
      end if
   end if
   do iv=1,nam%nv
      if (subconf%has(nam%variables(iv))) then
         call subconf%get_or_die(nam%variables(iv),real_array)
         if (size(real_array)>nl0max) then
            write(output_unit,'(a,a,a,i4)') '!!! ABORT in nam_from_conf: pkv-',trim(nam%variables(iv)), &
 & ' size should be smaller than ',nl0max
            call flush(output_unit)
            call comm%abort(1)
         end if
         if (size(real_array)==1) then
            nam%pkv(:,iv) = real_array(1)
         else
            nam%pkv(1:size(real_array),iv) = real_array
         end if
      end if
   end do
end if
if (conf%has('nlv')) then
   call conf%get_or_die('nlv',subconf)
   if (subconf%has('common')) then
      call subconf%get_or_die('common',real_array)
      if (size(real_array)>nl0max) then
         write(output_unit,'(a,i4)') '!!! ABORT in nam_from_conf: nlv-common size should be smaller than ',nl0max
         call flush(output_unit)
         call comm%abort(1)
      end if
      if (size(real_array)==1) then
         nam%nlv(:,0) = real_array(1)
      else
         nam%nlv(1:size(real_array),0) = real_array
      end if
   end if
   do iv=1,nam%nv
      if (subconf%has(nam%variables(iv))) then
         call subconf%get_or_die(nam%variables(iv),real_array)
         if (size(real_array)>nl0max) then
            write(output_unit,'(a,a,a,i4)') '!!! ABORT in nam_from_conf: nlv-',trim(nam%variables(iv)), &
 & ' size should be smaller than ',nl0max
            call flush(output_unit)
            call comm%abort(1)
         end if
         if (size(real_array)==1) then
            nam%nlv(:,iv) = real_array(1)
         else
            nam%nlv(1:size(real_array),iv) = real_array
         end if
      end if
   end do
end if
if (conf%has('min_lev')) then
   call conf%get_or_die('min_lev',subconf)
   if (subconf%has('common')) call subconf%get_or_die('common',nam%min_lev(0))
   do iv=1,nam%nv
      if (subconf%has(nam%variables(iv))) call subconf%get_or_die(nam%variables(iv),nam%min_lev(iv))
   end do
end if
if (conf%has('max_lev')) then
   call conf%get_or_die('max_lev',subconf)
   if (subconf%has('common')) call subconf%get_or_die('common',nam%max_lev(0))
   do iv=1,nam%nv
      if (subconf%has(nam%variables(iv))) call subconf%get_or_die(nam%variables(iv),nam%max_lev(iv))
   end do
end if
if (conf%has('pos_def_test')) call conf%get_or_die('pos_def_test',nam%pos_def_test)
if (conf%has('write_nicas_c0')) call conf%get_or_die('write_nicas_c0',nam%write_nicas_c0)
if (conf%has('write_nicas_grids')) call conf%get_or_die('write_nicas_grids',nam%write_nicas_grids)

! dirac_param
if (conf%has('ndir')) call conf%get_or_die('ndir',nam%ndir)
if (conf%has('londir')) then
   call conf%get_or_die('londir',real_array)
   if (size(real_array)>ndirmax) then
      write(output_unit,'(a,i4)') '!!! ABORT in nam_from_conf: londir size should be smaller than ',ndirmax
      call flush(output_unit)
      call comm%abort(1)
   end if
   nam%londir(1:size(real_array)) = real_array
end if
if (conf%has('latdir')) then
   call conf%get_or_die('latdir',real_array)
   if (size(real_array)>ndirmax) then
      write(output_unit,'(a,i4)') '!!! ABORT in nam_from_conf: latdir size should be smaller than ',ndirmax
      call flush(output_unit)
      call comm%abort(1)
   end if
   nam%latdir(1:size(real_array)) = real_array
end if
if (conf%has('levdir')) then
   call conf%get_or_die('levdir',integer_array)
   if (size(real_array)>ndirmax) then
      write(output_unit,'(a,i4)') '!!! ABORT in nam_from_conf: levdir size should be smaller than ',ndirmax
      call flush(output_unit)
      call comm%abort(1)
   end if
   nam%levdir(1:size(integer_array)) = integer_array
end if
if (conf%has('ivdir')) then
   call conf%get_or_die('ivdir',integer_array)
   if (size(real_array)>ndirmax) then
      write(output_unit,'(a,i4)') '!!! ABORT in nam_from_conf: ivdir size should be smaller than ',ndirmax
      call flush(output_unit)
      call comm%abort(1)
   end if
   nam%ivdir(1:size(integer_array)) = integer_array
end if

! output_param
if (conf%has('full_grid_smoother_nn')) call conf%get_or_die('full_grid_smoother_nn',nam%full_grid_smoother_nn)
if (conf%has('nldwv')) call conf%get_or_die('nldwv',nam%nldwv)
if (conf%has('img_ldwv')) then
   call conf%get_or_die('img_ldwv',integer_array)
   if (size(integer_array)>nldwvmax) then
      write(output_unit,'(a,i4)') '!!! ABORT in nam_from_conf: img_ldwv size should be smaller than ',nldwvmax
      call flush(output_unit)
      call comm%abort(1)
   end if
   nam%img_ldwv(1:size(integer_array)) = integer_array
end if
if (conf%has('lon_ldwv')) then
   call conf%get_or_die('lon_ldwv',real_array)
   if (size(real_array)>nldwvmax) then
      write(output_unit,'(a,i4)') '!!! ABORT in nam_from_conf: lon_ldwv size should be smaller than ',nldwvmax
      call flush(output_unit)
      call comm%abort(1)
   end if
   nam%lon_ldwv(1:size(real_array)) = real_array
end if
if (conf%has('lat_ldwv')) then
   call conf%get_or_die('lat_ldwv',real_array)
   if (size(real_array)>nldwvmax) then
      write(output_unit,'(a,i4)') '!!! ABORT in nam_from_conf: lat_ldwv size should be smaller than ',nldwvmax
      call flush(output_unit)
      call comm%abort(1)
   end if
   nam%lat_ldwv(1:size(real_array)) = real_array
end if
if (conf%has('name_ldwv')) then
   call conf%get_or_die('name_ldwv',str_array)
   if (size(real_array)>nldwvmax) then
      write(output_unit,'(a,i4)') '!!! ABORT in nam_from_conf: name_ldwv size should be smaller than ',nldwvmax
      call flush(output_unit)
      call comm%abort(1)
   end if
   nam%name_ldwv(1:size(str_array)) = str_array
end if

! wind_param
if (conf%has('wind_streamfunction')) then
   call conf%get_or_die('wind_streamfunction',str)
   nam%wind_streamfunction = str
end if
if (conf%has('wind_velocity_potential')) then
   call conf%get_or_die('wind_velocity_potential',str)
   nam%wind_velocity_potential = str
end if
if (conf%has('wind_zonal')) then
   call conf%get_or_die('wind_zonal',str)
   nam%wind_zonal = str
end if
if (conf%has('wind_meridional')) then
   call conf%get_or_die('wind_meridional',str)
   nam%wind_meridional = str
end if
if (conf%has('wind_nlon')) call conf%get_or_die('wind_nlon',nam%wind_nlon)
if (conf%has('wind_nlat')) call conf%get_or_die('wind_nlat',nam%wind_nlat)
if (conf%has('wind_nsg')) call conf%get_or_die('wind_nsg',nam%wind_nsg)
if (conf%has('wind_inflation')) call conf%get_or_die('wind_inflation',nam%wind_inflation)

! Probe out
@:probe_out()

end subroutine nam_from_conf

!----------------------------------------------------------------------
! Subroutine: nam_check
!> Check namelist parameters
!----------------------------------------------------------------------
subroutine nam_check(nam,mpl)

implicit none

! Passed variable
class(nam_type),intent(inout) :: nam !< Namelist
type(mpl_type),intent(inout) :: mpl  !< MPI data

! Local variables
integer :: isub,iv,ivmin,ivmax,i,il0,idir,ildwv
character(len=2) :: ivchar,ildwvchar

! Set name
@:set_name(nam_check)

! Probe in
@:probe_in()

! Check maximum sizes
if (nam%nl0>nl0max) call mpl%abort('${subr}$','nl0 is too large')
if (nam%nv>nvmax) call mpl%abort('${subr}$','nv is too large')
if (nam%ens1_nsub>nsubmax) call mpl%abort('${subr}$','ens1_nsub is too large')
if (nam%ens2_nsub>nsubmax) call mpl%abort('${subr}$','ens2_nsub is too large')
if (nam%nc3>nc3max) call mpl%abort('${subr}$','nc3 is too large')
if (nam%lct_nscales>nscalesmax) call mpl%abort('${subr}$','lct_nscales is too large')
if (nam%ndir>ndirmax) call mpl%abort('${subr}$','ndir is too large')
if (nam%nldwv>nldwvmax) call mpl%abort('${subr}$','nldwv is too large')

! Namelist parameters normalization (meters to radians and degrees to radians)
nam%universe_rad = nam%universe_rad/req
nam%Lcoast = nam%Lcoast/req
nam%dc = nam%dc/req
nam%vbal_rad = nam%vbal_rad/req
nam%vbal_dlat = nam%vbal_dlat*deg2rad
nam%var_rhflt = nam%var_rhflt/req
nam%local_rad = nam%local_rad/req
nam%local_dlat = nam%local_dlat*deg2rad
nam%diag_rhflt = nam%diag_rhflt/req
nam%rh = nam%rh/req
if (nam%ndir>0) nam%londir(1:nam%ndir) = nam%londir(1:nam%ndir)*deg2rad
if (nam%ndir>0) nam%latdir(1:nam%ndir) = nam%latdir(1:nam%ndir)*deg2rad
if (nam%nldwv>0) nam%lon_ldwv(1:nam%nldwv) = nam%lon_ldwv(1:nam%nldwv)*deg2rad
if (nam%nldwv>0) nam%lat_ldwv(1:nam%nldwv) = nam%lat_ldwv(1:nam%nldwv)*deg2rad

! Forced parameters for backward compatibility
if ((nam%new_hdiag.or.nam%new_lct).and.(.not.(nam%update_mom.or.nam%load_mom))) nam%new_mom = .true.
if (nam%new_lct) nam%local_rad = 1.0e-12_kind_real

! Check general_param
if (trim(nam%datadir)=='') call mpl%abort('${subr}$','datadir not specified')
if (trim(nam%prefix)=='') call mpl%abort('${subr}$','prefix not specified')
select case (trim(nam%model))
case ('aro','arp','fv3','gem','geos','gfs','ifs','mpas','nemo','norcpm','online','qg','res','wrf')
case default
   call mpl%abort('${subr}$','wrong model')
end select
select case (trim(nam%verbosity))
case ('all','main','none')
case default
   call mpl%abort('${subr}$','wrong verbosity level')
end select
if (nam%repro) then
  if (nam%rth<zero) call mpl%abort('${subr}$','rth should be non-negative')
end if
if (nam%nprocio<1) call mpl%abort('${subr}$','number of I/O tasks should be positive')
if (nam%nprocio>mpl%nproc) then
   call mpl%warning('${subr}$','number of I/O tasks should be smaller than the total number of tasks, resetting nprocio')
   nam%nprocio = mpl%nproc
end if

! Check driver_param
if (nam%new_hdiag.or.nam%check_optimality) then
   select case (trim(nam%method))
   case ('cor','loc','hyb-avg','hyb-rnd','dual-ens')
   case default
      call mpl%abort('${subr}$','wrong method')
   end select
end if
if (nam%new_lct) then
   if (trim(nam%method)/='cor') call mpl%abort('${subr}$','cor method required for new_lct')
end if
if (nam%new_hdiag.or.nam%new_lct.or.nam%load_cmat.or.nam%new_nicas.or.nam%load_nicas_local.or.nam%load_nicas_global) then
   select case (trim(nam%strategy))
   case ('diag_all','common','common_weighted','specific_univariate','specific_multivariate')
   case default
      call mpl%abort('${subr}$','wrong strategy')
   end select
end if
if (nam%new_vbal_cov.and.nam%update_vbal_cov) call mpl%abort('${subr}$','new_vbal_cov and update_vbal_cov are exclusive')
if (nam%new_vbal_cov.and.nam%load_vbal_cov) call mpl%abort('${subr}$','new_vbal_cov and load_vbal_cov are exclusive')
if (nam%load_vbal_cov.and.nam%update_vbal_cov) call mpl%abort('${subr}$','load_vbal_cov and update_vbal_cov are exclusive')
if (nam%load_vbal_cov.and.(.not.nam%new_vbal)) call mpl%abort('${subr}$','new_vbal required for load_vbal_cov')
if (nam%load_vbal.and.(nam%new_vbal_cov.or.nam%load_vbal_cov.or.nam%update_vbal_cov)) call mpl%abort('${subr}$', &
 & 'load_vbal is inconsistent with new_vbal_cov, load_vbal_cov or update_vbal_cov')
if (nam%new_vbal.and.nam%load_vbal) call mpl%abort('${subr}$','new_vbal and load_vbal are exclusive')
if (nam%new_var.and.nam%update_var) call mpl%abort('${subr}$','new_var and update_var are exclusive')
if (nam%new_var.and.nam%load_var) call mpl%abort('${subr}$','new_var and load_var are exclusive')
if (nam%load_var.and.nam%update_var) call mpl%abort('${subr}$','load_var and update_var are exclusive')
if (nam%new_mom.and.nam%update_mom) call mpl%abort('${subr}$','new_mom and update_mom are exclusive')
if (nam%new_mom.and.nam%load_mom) call mpl%abort('${subr}$','new_mom and load_mom are exclusive')
if (nam%load_mom.and.nam%update_mom) call mpl%abort('${subr}$','load_mom and update_mom are exclusive')
if (nam%new_hdiag.and.nam%new_lct) call mpl%abort('${subr}$','new_hdiag and new_lct are exclusive')
if ((nam%new_hdiag.or.nam%new_lct).and.nam%load_cmat) call mpl%abort('${subr}$','new_hdiag or new_lct and load_cmat are exclusive')
if (nam%new_nicas.and.(nam%load_nicas_local.or.nam%load_nicas_global)) &
 & call mpl%abort('${subr}$','new_nicas and load_nicas_local/load_nicas_global are exclusive')
if (nam%check_vbal.and..not.(nam%new_vbal.or.nam%load_vbal)) &
 & call mpl%abort('${subr}$','new_vbal or load_vbal required for check_vbal')
if ((nam%new_hdiag.or.nam%new_lct).and.(.not.(nam%new_mom.or.nam%update_mom.or.nam%load_mom))) &
 & call mpl%abort('${subr}$','new_mom, update_mom or load_mom required for new_hdiag and new_lct')
if (nam%check_dirac.and..not.(nam%new_vbal.or.nam%load_vbal.or.nam%new_nicas.or.nam%load_nicas_local.or.nam%load_nicas_global)) &
 & call mpl%abort('${subr}$','new or load for vbal or nicas required for check_dirac')
if (nam%check_randomization) then
   if (trim(nam%method)/='cor') call mpl%abort('${subr}$','cor method required for check_randomization')
   if (.not.nam%new_nicas) call mpl%abort('${subr}$','new_nicas required for check_randomization')
end if
if (nam%check_consistency) then
   if (trim(nam%method)/='cor') call mpl%abort('${subr}$','cor method required for check_consistency')
   if (.not.nam%new_nicas) call mpl%abort('${subr}$','new_nicas required for check_consistency')
end if
if (nam%check_optimality) then
   if (trim(nam%method)/='cor') call mpl%abort('${subr}$','cor method required for check_optimality')
   if (.not.nam%new_nicas) call mpl%abort('${subr}$','new_nicas required for check_optimality')
   if (.not.nam%write_hdiag) call mpl%abort('${subr}$','write_hdiag required for check_optimality')
end if
if (nam%check_no_point_mpi.and.nam%check_no_point_mask) &
 & call mpl%abort('${subr}$','check_no_point_mpi and check_no_point_mask are exclusive')
if ((nam%check_set_param_cor.or.nam%check_set_param_cor.or.nam%check_set_param_cor).and..not.nam%new_nicas) &
 & call mpl%abort('${subr}$','new_nicas required for check_set_param_[...]')
if (nam%check_get_param_stddev.and..not.(nam%new_var.or.nam%update_var)) &
 & call mpl%abort('${subr}$','new_var or update_var required for check_get_param_stddev')
if (nam%check_get_param_cor.and..not.(nam%new_hdiag.and.(trim(nam%method)=='cor'))) &
 & call mpl%abort('${subr}$','new_hdiag and cor method required for check_get_param_cor')
if (nam%check_get_param_hyb.and..not.(nam%new_hdiag.and.(trim(nam%method)=='hyb-avg'))) &
 & call mpl%abort('${subr}$','new_hdiag and hyb-avg method required for check_get_param_hyb')
if (nam%check_get_param_Dloc.and..not.(nam%new_hdiag.and.(trim(nam%method)=='loc'))) &
 & call mpl%abort('${subr}$','new_hdiag and loc method required for check_get_param_Dloc')
if (nam%check_get_param_lct.and..not.(nam%new_lct.and.(nam%lct_nscales==2))) &
 & call mpl%abort('${subr}$','new_lct and lct_nscales = 2 required for check_get_param_lct')
if (nam%check_apply_vbal.and..not.(nam%new_vbal.or.nam%load_vbal)) &
 & call mpl%abort('${subr}$','new_vbal or load_vbal required for check_apply_vbal')
if (nam%check_apply_stddev.and..not.(nam%new_var.or.nam%update_var.or.nam%load_var)) &
 & call mpl%abort('${subr}$','new_var, update_var or load_var required for check_apply_stddev')
if (nam%check_apply_nicas.and..not.(nam%new_nicas.or.nam%load_nicas_local.or.nam%load_nicas_global)) &
 & call mpl%abort('${subr}$','new_nicas or load_nicas_local/load_nicas_global required for check_apply_nicas')

! Check and set files_param
nam%fname_var_used = any(nam%fname_var/='')
nam%fname_var(0) = trim(nam%prefix)//'_var'
do isub=1,nsubmax
   if (nam%fname_var(isub)=='') write(nam%fname_var(isub),'(a,a,i6.6)') trim(nam%fname_var(0)),'_',isub
end do
if (nam%fname_samp=='') nam%fname_samp = trim(nam%prefix)//'_sampling'
nam%fname_vbal_cov_used = any(nam%fname_vbal_cov/='')
nam%fname_vbal_cov(0) = trim(nam%prefix)//'_vbal_cov'
do isub=1,nsubmax
   if (nam%fname_vbal_cov(isub)=='') write(nam%fname_vbal_cov(isub),'(a,a,i6.6)') trim(nam%fname_vbal_cov(0)),'_',isub
end do
if (nam%fname_vbal=='') nam%fname_vbal = trim(nam%prefix)//'_vbal'
nam%fname_mom_used = any(nam%fname_mom/='')
nam%fname_mom(0) = trim(nam%prefix)//'_mom'
do isub=1,nsubmax
   if (nam%fname_mom(isub)=='') write(nam%fname_mom(isub),'(a,a,i6.6)') trim(nam%fname_mom(0)),'_',isub
end do
if (nam%fname_cmat=='') nam%fname_cmat = trim(nam%prefix)//'_cmat'
if (nam%fname_nicas=='') nam%fname_nicas = trim(nam%prefix)//'_nicas'
if (nam%fname_wind=='') nam%fname_wind = trim(nam%prefix)//'_wind'

! Check model_param
if (nam%nl0<=0) call mpl%abort('${subr}$','nl0 should be positive')
do il0=1,nam%nl0
   if (nam%levs(il0)<=0) call mpl%abort('${subr}$','levs should be positive')
   if (count(nam%levs(1:nam%nl0)==nam%levs(il0))>1) call mpl%abort('${subr}$','redundant levels')
end do
if ((trim(nam%lev2d)/='first').and.(trim(nam%lev2d)/='last')) call mpl%abort('${subr}$','wrong lev2d value')
if (nam%new_vbal_cov.or.nam%load_vbal_cov.or.nam%new_vbal.or.nam%load_vbal.or.nam%new_var.or.nam%update_var.or.nam%load_var.or. &
 & nam%new_hdiag.or.nam%new_lct.or.nam%load_cmat.or.nam%new_nicas.or.nam%load_nicas_local.or.nam%load_nicas_global) then
   if (nam%nv<=0) call mpl%abort('${subr}$','nv should be positive')
   do iv=1,nam%nv
      write(ivchar,'(i2.2)') iv
      if (trim(nam%variables(iv))=='') call mpl%abort('${subr}$','variables not specified for variable '//ivchar)
   end do
   do i=1,niokvmax
      if (((trim(nam%io_keys(i))/='').and.(trim(nam%io_values(i))=='')).or. &
 & ((trim(nam%io_keys(i))=='').and.(trim(nam%io_values(i))/=''))) &
 & call mpl%abort('${subr}$','io_keys and io_values are not consistent')
   end do
end if
if (nam%qg_redundant.and.nam%qg_regional) call mpl%abort('${subr}$','qg_redundant and qg_regional are exclusive')
if (nam%qg_redundant.and.nam%qg_urban) call mpl%abort('${subr}$','qg_redundant and qg_urban are exclusive')
if (nam%qg_regional.and.nam%qg_urban) call mpl%abort('${subr}$','qg_regional and qg_urban are exclusive')

! Check ens1_param
if (nam%new_normality.or.nam%new_vbal_cov.or.nam%update_vbal_cov.or.(nam%new_vbal.and.(.not.nam%load_vbal_cov)) &
 & .or.(nam%new_var.and.(.not.nam%forced_var)).or.nam%update_var.or.nam%new_mom.or.nam%update_mom &
 & .or.nam%check_randomization.or.nam%check_consistency.or.nam%check_optimality) then
   if (nam%ens1_nsub<1) call mpl%abort('${subr}$','ens1_nsub should be positive')
   if (mod(nam%ens1_ne,nam%ens1_nsub)/=0) call mpl%abort('${subr}$','ens1_nsub should be a divider of ens1_ne')
   if (nam%ens1_ne/nam%ens1_nsub<=3) call mpl%abort('${subr}$','ens1_ne/ens1_nsub should be larger than 3')
end if

! Check ens2_param
if ((nam%new_mom.or.nam%update_mom).and.((trim(nam%method)=='hyb-rnd').or.(trim(nam%method)=='dual-ens'))) then
   if (nam%ens2_nsub<1) call mpl%abort('${subr}$','ens2_nsub should be non-negative')
   if (mod(nam%ens2_ne,nam%ens2_nsub)/=0) call mpl%abort('${subr}$','ens2_nsub should be a divider of ens2_ne')
   if (nam%ens2_ne/nam%ens2_nsub<=3) call mpl%abort('${subr}$','ens2_ne/ens2_nsub should be larger than 3')
end if

! Check sampling_param
if (nam%new_vbal_cov.or.nam%new_vbal.or.nam%new_hdiag.or.nam%new_lct.or.nam%check_consistency.or.nam%check_optimality) then
   if (nam%load_samp_local.and.nam%load_samp_global) call mpl%abort('${subr}$','load_samp_local and load_samp_global are exclusive')
   if (nam%load_samp_local.and.nam%write_samp_local) &
 & call mpl%abort('${subr}$','load_samp_local and write_samp_local are exclusive')
   if (nam%load_samp_global.and.nam%write_samp_global) &
 & call mpl%abort('${subr}$','load_samp_global and write_samp_global are exclusive')
   select case (trim(nam%diag_draw_type))
   case ('random_uniform')
   case ('random_coast')
      if (.not.(nam%Lcoast>zero)) call mpl%abort ('${subr}$','Lcoast should be positive')
      if (.not.(nam%rcoast>zero)) call mpl%abort ('${subr}$','rcoast should be positive')
   case ('octahedral')
      if (nam%nldwv>0) call mpl%abort('${subr}$','no local diagnostics with an octahedral draw')
   case default
      call mpl%abort('${subr}$','wrong diag_draw_type')
   end select
   select case (trim(nam%mask_type))
   case ('ldwv')
      if (nam%nldwv<=0) call mpl%abort('${subr}$','nldwv should not be negative for mask_type = ldwv')
   case ('stddev')
      do iv=1,nam%nv
         select case (trim(nam%mask_lu(iv)))
         case ('lower','upper')
         case default
            call mpl%abort('${subr}$','wrong mask_lu')
         end select
      end do
   end select
   if ((.not.(nam%load_samp_local.or.nam%load_samp_global)).and.(nam%nc1<3)) &
 & call mpl%abort('${subr}$','nc1 should be larger than 2')
   if (nam%new_vbal.or.(nam%new_hdiag.and.nam%local_diag)) then
      if ((.not.(nam%load_samp_local.or.nam%load_samp_global)).and.(nam%nc2<0)) &
 & call mpl%abort('${subr}$','nc2 should be non-negative')
   else
      if ((.not.(nam%load_samp_local.or.nam%load_samp_global)).and.(nam%nc2<0)) then
          call mpl%warning('${subr}$','nc2 should be set non-negative, resetting nc2 to zero')
          nam%nc2 = 0
      end if
   end if
   if (nam%new_lct) then
      if (nam%nc2/=nam%nc1) then
         call mpl%warning('${subr}$','nc2 should be equal to nc1 for new_lct, resetting nc2 to nc1')
         nam%nc2 = nam%nc1
      end if
   end if
else
   if (nam%write_samp_grids) call mpl%abort('${subr}$','new_vbal_cov, new_vbal, new_hdiag, new_lct, check_consistency or '// &
 & 'check_optimality required for write_samp_grids')
end if
if (nam%load_vbal_cov.and.(.not.(nam%load_samp_local.or.nam%load_samp_global))) &
 & call mpl%abort('${subr}$','load_vbal_cov requires load_samp_local/global')
if (nam%write_vbal_cov.and.(.not.(nam%load_samp_local.or.nam%load_samp_global)) &
 & .and.(.not.(nam%write_samp_local.or.nam%write_samp_global))) &
 & call mpl%abort('${subr}$','write_vbal_cov requires write_samp_local/global if load_samp_local/global is not activated')
if (nam%load_vbal.and.(.not.(nam%load_samp_local.or.nam%load_samp_global))) &
 & call mpl%abort('${subr}$','load_vbal requires load_samp_local/global')
 if (nam%write_vbal.and.(.not.(nam%load_samp_local.or.nam%load_samp_global)) &
 & .and.(.not.(nam%write_samp_local.or.nam%write_samp_global))) &
 & call mpl%abort('${subr}$','write_vbal requires write_samp_local/global if load_samp_local/global is not activated')
if (nam%new_hdiag.or.nam%check_consistency.or.nam%check_optimality) then
   if (nam%nc3<=0) call mpl%abort('${subr}$','nc3 should be positive')
   if (.not.(nam%dc>zero)) call mpl%abort('${subr}$','dc should be positive')
   if (nam%nl0r<1) call mpl%abort ('${subr}$','nl0r should be positive')
   if (.not.(nam%load_samp_local.or.nam%load_samp_global)) then
      if (nam%irmax<1) call mpl%abort ('${subr}$','irmax should be positive')
   end if
end if
if (nam%new_lct) then
   if (nam%nc3<=0) call mpl%abort('${subr}$','nc3 should be positive')
   if (nam%nl0r<1) call mpl%abort ('${subr}$','nl0r should be positive')
   if (.not.(nam%load_samp_local.or.nam%load_samp_global)) then
      if (nam%irmax<1) call mpl%abort ('${subr}$','irmax should be positive')
   end if
end if

! Check diag_param
if (nam%new_vbal) then
   if (.not.((nam%vbal_rad>zero).or.(nam%vbal_dlat>zero))) call mpl%abort('${subr}$', &
 & 'vbal_rad or vbal_dlat should be positive')
   if ((nam%vbal_rad>zero).and.(nam%vbal_dlat>zero)) call mpl%abort('${subr}$', &
 & 'vbal_rad and vbal_dlat cannot be positive at the same time')
   if (nam%vbal_pseudo_inv) then
      if ((nam%vbal_pseudo_inv_mmax<=0).and.(.not.nam%vbal_pseudo_inv_var_th>zero)) call mpl%abort('${subr}$', &
 & 'dominant mode or variance threshold should be positive for pseudo-inverse')
   end if
end if
if (nam%new_var) then
   if (nam%forced_var) then
      do iv=1,nam%nv
         do il0=1,nam%nl0
            if (.not.(nam%stddev(il0,iv)>zero)) call mpl%abort('${subr}$','stddev should be positive')
         end do
      end do
      if (nam%var_filter) call mpl%abort('${subr}$','var_filter forbidden for forced_var')
   end if
   if (nam%var_filter) then
      if ((nam%var_niter>0).and.(nam%var_npass>0)) call mpl%abort('${subr}$','var_niter or var_npass only should be non-negative')
      if ((nam%var_niter>0).and.(nam%var_npass>0)) &
 & call mpl%abort('${subr}$','var_niter or var_npass should not be positive at te same time')
      if ((nam%var_niter>0).or.(nam%var_npass>0)) then
         do iv=1,nam%nv
            do il0=1,nam%nl0
               if (.not.(nam%var_rhflt(il0,iv)>zero)) call mpl%abort('${subr}$','var_rhflt should be positive')
            end do
         end do
      end if
   end if
end if
if (nam%new_hdiag.or.nam%check_consistency.or.nam%check_optimality) then
   select case (trim(nam%method))
   case ('loc','hyb-avg','hyb-rnd','dual-ens')
      if (nam%ne<=3) call mpl%abort('${subr}$','ne should be larger than 3')
   end select
   if (.not.(nam%gen_kurt_th>zero)) call mpl%abort('${subr}$','gen_kurt_th should be positive')
   if (nam%local_diag) then
      if (.not.((nam%local_rad>zero).or.(nam%local_dlat>zero))) call mpl%abort('${subr}$', &
 & 'local_rad or local_dlat should be positive')
      if ((nam%local_rad>zero).and.(nam%local_dlat>zero)) call mpl%abort('${subr}$', &
 & 'local_rad and local_dlat cannot be positive at the same time')
   end if
end if

! Check fit_param
if (nam%new_hdiag.or.nam%new_lct.or.nam%check_consistency.or.nam%check_optimality) then
   if (nam%diag_rhflt<zero) call mpl%abort('${subr}$','diag_rhflt should be non-negative')
   if (nam%diag_rvflt<zero) call mpl%abort('${subr}$','diag_rvflt should be non-negative')
   if (nam%fit_dl0<=0) call mpl%abort('${subr}$','fit_dl0 should be postive')
end if
if (nam%new_lct) then
   if (nam%lct_nscales<=0) call mpl%abort('${subr}$','lct_nscales should be postive')
   if (.not.(nam%lct_scale_ratio>zero)) call mpl%abort('${subr}$','lct_scale_ratio should be postive')
   if (nam%lct_cor_min<0) call mpl%abort('${subr}$','lct_cor_min should be non-negative')
   if ((nam%lct_qc_th<-one).or.(nam%lct_qc_th>one)) call mpl%abort('${subr}$','lct_qc_th should be between -1 and 1')
   if ((nam%lct_qc_max<-one).or.(nam%lct_qc_max>one)) call mpl%abort('${subr}$','lct_qc_max should be between -1 and 1')
end if

! Check ensemble sizes
if (nam%new_hdiag) then
   if (trim(nam%method)/='cor') then
      if (nam%ne>nam%ens1_ne) call mpl%warning('${subr}$','ensemble size larger than ens1_ne (might enhance sampling noise)')
      select case (trim(nam%method))
      case ('hyb-avg','hyb-rnd','dual-ens')
         if (nam%ne>nam%ens2_ne) call mpl%warning('${subr}$','ensemble size larger than ens2_ne (might enhance sampling noise)')
      end select
   end if
end if

! Check nicas_param
if (nam%new_nicas.or.nam%load_nicas_local.or.nam%load_nicas_global) then
   if (nam%nonunit_diag) then
      if (nam%method=='cor') call mpl%abort('${subr}$', &
 & 'nonunit_diag is inconsistent with correlation, use variance operator instead')
   end if
   if (nam%check_randomization) then
      if (.not.nam%forced_radii) call mpl%abort('${subr}$','forced_radii required for check_randomization')
   end if
   if (nam%check_consistency) then
      if (.not.nam%forced_radii) call mpl%abort('${subr}$','forced_radii required for check_consistency')
   end if
   if (nam%check_optimality) then
      if (.not.nam%forced_radii) call mpl%abort('${subr}$','forced_radii required for check_optimality')
   end if
   if (nam%new_nicas) then
      if (.not.(nam%resol>zero)) call mpl%abort('${subr}$','resol should be positive')
      if (nam%nc1max<=0) call mpl%abort('${subr}$','nc1max should be positive')
   end if
   if (nam%forced_radii) then
      if (nam%new_hdiag) then
         select case (trim(nam%method))
         case ('hyb-avg','hyb-rnd')
         case default
           call mpl%abort('${subr}$','new_diag forbidden for forced_radii (except for static hybridization)')
         end select
      end if
      if (nam%new_lct.or.nam%load_cmat) call mpl%abort('${subr}$','new_lct and load_cmat forbidden for forced_radii')
      if ((trim(nam%strategy)=='common').or.(trim(nam%strategy)=='common_weighted')) then
         ivmin = 0
         ivmax = 0
      else
         ivmin = 1
         ivmax = nam%nv
      end if
      do iv=ivmin,ivmax
         do il0=1,nam%nl0
            if (nam%rh(il0,iv)<zero) call mpl%abort('${subr}$','rh should be non-negative')
            if ((nam%pkh(il0,iv)<pkmin).or.(nam%pkh(il0,iv)>pkmax)) call mpl%abort('${subr}$','pkh is out of bounds')
            if (nam%rv(il0,iv)<zero) call mpl%abort('${subr}$','rv should be non-negative')
            if ((nam%pkv(il0,iv)<pkmin).or.(nam%pkv(il0,iv)>pkmax)) call mpl%abort('${subr}$','pkv is out of bounds')
            if ((nam%nlv(il0,iv)<nlmin).or.(nam%nlv(il0,iv)>nlmax)) call mpl%abort('${subr}$','nlv is out of bounds')
         end do
      end do
   end if
   select case (trim(nam%nicas_draw_type))
   case ('random_uniform')
   case ('random_coast')
      if (.not.(nam%Lcoast>zero)) call mpl%abort ('${subr}$','Lcoast should be positive')
      if (.not.(nam%rcoast>zero)) call mpl%abort ('${subr}$','rcoast should be positive')
   case ('octahedral')
      if (nam%nldwv>0) call mpl%abort('${subr}$','no local diagnostics with an octahedral draw')
   case default
      call mpl%abort('${subr}$','wrong nicas_draw_type')
   end select
end if
if (nam%write_nicas_grids.and.(.not.(nam%new_nicas.or.nam%load_nicas_global))) &
 & call mpl%abort('${subr}$','new_nicas or load_nicas_global required for write_nicas_grids')
if (nam%load_nicas_local.and.nam%write_nicas_global) &
 & call mpl%abort('${subr}$','load_nicas_local and write_nicas_global are exclusive')

! Check dirac_param
if (nam%check_dirac) then
   if (nam%ndir<1) call mpl%abort('${subr}$','ndir should be positive')
   do idir=1,nam%ndir
      if ((nam%londir(idir)<-pi).or.(nam%londir(idir)>pi)) call mpl%abort('${subr}$','londir should lie between -180 and 180')
      if ((nam%latdir(idir)<-half*pi).or.(nam%latdir(idir)>half*pi)) call mpl%abort('${subr}$','latdir should lie between -90 and 90')
      if (.not.any(nam%levs(1:nam%nl0)==nam%levdir(idir))) call mpl%abort('${subr}$','wrong level for a Dirac')
      if ((nam%ivdir(idir)<1).or.(nam%ivdir(idir)>nam%nv)) call mpl%abort('${subr}$','wrong variable for a Dirac')
   end do
end if

! Check output_param
if (nam%new_hdiag) then
   if (nam%nldwv<0) call mpl%abort('${subr}$','nldwv should be non-negative')
   if (nam%nldwv>0) then
      if (.not.nam%local_diag) call mpl%abort('${subr}$','local_diag required for nldwv>0')
         if (.not.all(nam%img_ldwv(1:nam%nldwv)>0)) then
         if (any(nam%lon_ldwv(1:nam%nldwv)<-pi).or.any(nam%lon_ldwv(1:nam%nldwv)>pi)) &
 & call mpl%abort('${subr}$','lon_ldwv should lie between -180 and 180')
         if (any(nam%lat_ldwv(1:nam%nldwv)<-half*pi).or.any(nam%lat_ldwv(1:nam%nldwv)>half*pi)) &
 & call mpl%abort('${subr}$','lat_ldwv should lie between -90 and 90')
         do ildwv=1,nam%nldwv
            write(ildwvchar,'(i2.2)') ildwv
            if (trim(nam%name_ldwv(ildwv))=='') call mpl%abort('${subr}$','name_ldwv not specified for profile '//ildwvchar)
         end do
      end if
   end if
end if

! Check wind_param
if (nam%new_wind) then
   if (nam%wind_nlon<3) call mpl%abort('${subr}$','wind_nlon should be larger than 3')
   if (nam%wind_nlat<3) call mpl%abort('${subr}$','wind_nlat should be larger than 3')
   if (nam%wind_nsg<1) call mpl%abort('${subr}$','wind_nsg should be positive')
   if (nam%wind_inflation<one) call mpl%abort('${subr}$','wind_inflation should be larger than 1')
end if

! Probe out
@:probe_out()

end subroutine nam_check

!----------------------------------------------------------------------
! Subroutine: nam_write
!> Write namelist parameters into a log file or into a NetCDF file
!----------------------------------------------------------------------
subroutine nam_write(nam,mpl)

implicit none

! Passed variable
class(nam_type),intent(in) :: nam   !< Namelist
type(mpl_type),intent(inout) :: mpl !< MPI data

! Local variables
real(kind_real) :: real_array(nam%nl0*(nam%nv+1))
real(kind_real),allocatable :: londir(:),latdir(:),lon_ldwv(:),lat_ldwv(:)

! Set name
@:set_name(nam_write)

! Probe in
@:probe_in()

! general_param
write(mpl%info,'(a7,a)') '','General parameters'
call mpl%flush
call mpl%write('datadir',nam%datadir)
call mpl%write('prefix',nam%prefix)
call mpl%write('model',nam%model)
call mpl%write('verbosity',nam%verbosity)
call mpl%write('colorlog',nam%colorlog)
call mpl%write('default_seed',nam%default_seed)
call mpl%write('repro',nam%repro)
call mpl%write('rth',nam%rth)
call mpl%write('parallel_io',nam%parallel_io)
call mpl%write('nprocio',nam%nprocio)
call mpl%write('universe_rad',nam%universe_rad*req)
call mpl%write('use_cgal',nam%use_cgal)

! driver_param
write(mpl%info,'(a7,a)') '','Driver parameters'
call mpl%flush
call mpl%write('method',nam%method)
call mpl%write('strategy',nam%strategy)
call mpl%write('new_normality',nam%new_normality)
call mpl%write('new_vbal_cov',nam%new_vbal_cov)
call mpl%write('update_vbal_cov',nam%update_vbal_cov)
call mpl%write('load_vbal_cov',nam%load_vbal_cov)
call mpl%write('write_vbal_cov',nam%write_vbal_cov)
call mpl%write('new_vbal',nam%new_vbal)
call mpl%write('load_vbal',nam%load_vbal)
call mpl%write('write_vbal',nam%write_vbal)
call mpl%write('new_var',nam%new_var)
call mpl%write('update_var',nam%update_var)
call mpl%write('load_var',nam%load_var)
call mpl%write('write_var',nam%write_var)
call mpl%write('new_mom',nam%new_mom)
call mpl%write('update_mom',nam%update_mom)
call mpl%write('load_mom',nam%load_mom)
call mpl%write('write_mom',nam%write_mom)
call mpl%write('new_hdiag',nam%new_hdiag)
call mpl%write('write_hdiag',nam%write_hdiag)
call mpl%write('new_lct',nam%new_lct)
call mpl%write('write_lct',nam%write_lct)
call mpl%write('load_cmat',nam%load_cmat)
call mpl%write('write_cmat',nam%write_cmat)
call mpl%write('new_nicas',nam%new_nicas)
call mpl%write('load_nicas_local',nam%load_nicas_local)
call mpl%write('load_nicas_global',nam%load_nicas_global)
call mpl%write('write_nicas_local',nam%write_nicas_local)
call mpl%write('write_nicas_global',nam%write_nicas_global)
call mpl%write('new_wind',nam%new_wind)
call mpl%write('load_wind_local',nam%load_wind_local)
call mpl%write('write_wind_local',nam%write_wind_local)
call mpl%write('check_vbal',nam%check_vbal)
call mpl%write('check_adjoints',nam%check_adjoints)
call mpl%write('check_dirac',nam%check_dirac)
call mpl%write('check_randomization',nam%check_randomization)
call mpl%write('check_consistency',nam%check_consistency)
call mpl%write('check_optimality',nam%check_optimality)
call mpl%write('check_no_point_mpi',nam%check_no_point_mpi)
call mpl%write('check_no_point_mask',nam%check_no_point_mask)
call mpl%write('check_set_param_cor',nam%check_set_param_cor)
call mpl%write('check_set_param_hyb',nam%check_set_param_hyb)
call mpl%write('check_set_param_lct',nam%check_set_param_lct)
call mpl%write('check_get_param_stddev',nam%check_get_param_stddev)
call mpl%write('check_get_param_cor',nam%check_get_param_cor)
call mpl%write('check_get_param_hyb',nam%check_get_param_hyb)
call mpl%write('check_get_param_Dloc',nam%check_get_param_Dloc)
call mpl%write('check_get_param_lct',nam%check_get_param_lct)
call mpl%write('check_apply_vbal',nam%check_apply_vbal)
call mpl%write('check_apply_stddev',nam%check_apply_stddev)
call mpl%write('check_apply_nicas',nam%check_apply_nicas)

! files_param
call mpl%write('fname_var',count(nam%fname_var/=''),nam%fname_var(0:count(nam%fname_var/='')-1))
call mpl%write('fname_samp',nam%fname_samp)
call mpl%write('fname_vbal_cov',count(nam%fname_vbal_cov/=''),nam%fname_vbal_cov(0:count(nam%fname_vbal_cov/='')-1))
call mpl%write('fname_vbal',nam%fname_vbal)
call mpl%write('fname_mom',count(nam%fname_mom/=''),nam%fname_mom(0:count(nam%fname_mom/='')-1))
call mpl%write('fname_cmat',nam%fname_cmat)
call mpl%write('fname_nicas',nam%fname_nicas)
call mpl%write('fname_wind',nam%fname_wind)

! model_param
write(mpl%info,'(a7,a)') '','Model parameters'
call mpl%flush
call mpl%write('nl0',nam%nl0)
call mpl%write('levs',nam%nl0,nam%levs(1:nam%nl0))
call mpl%write('lev2d',nam%lev2d)
call mpl%write('logpres',nam%logpres)
call mpl%write('nv',nam%nv)
call mpl%write('variables',nam%nv,nam%variables(1:nam%nv))
call mpl%write('variable_change',nam%variable_change)
call mpl%write('nomask',nam%nomask)
call mpl%write('io_keys',count(nam%io_keys/=''),nam%io_keys(1:count(nam%io_keys/='')))
call mpl%write('io_values',count(nam%io_values/=''),nam%io_values(1:count(nam%io_values/='')))
call mpl%write('qg_redundant',nam%qg_redundant)
call mpl%write('qg_regional',nam%qg_regional)
call mpl%write('qg_urban',nam%qg_urban)

! ens1_param
write(mpl%info,'(a7,a)') '','Ensemble 1 parameters'
call mpl%flush
call mpl%write('ens1_ne',nam%ens1_ne)
call mpl%write('ens1_nsub',nam%ens1_nsub)

! ens2_param
write(mpl%info,'(a7,a)') '','Ensemble 2 parameters'
call mpl%flush
call mpl%write('ens2_ne',nam%ens2_ne)
call mpl%write('ens2_nsub',nam%ens2_nsub)

! sampling_param
write(mpl%info,'(a7,a)') '','Sampling parameters'
call mpl%flush
call mpl%write('load_samp_local',nam%load_samp_local)
call mpl%write('load_samp_global',nam%load_samp_global)
call mpl%write('write_samp_local',nam%write_samp_local)
call mpl%write('write_samp_global',nam%write_samp_global)
call mpl%write('write_samp_grids',nam%write_samp_grids)
call mpl%write('mask_type',nam%mask_type)
call mpl%write('mask_lu',nam%nv,nam%mask_lu(1:nam%nv))
call mpl%write('mask_th',nam%nv,nam%mask_th(1:nam%nv))
call mpl%write('ncontig_th',nam%ncontig_th)
call mpl%write('mask_check',nam%mask_check)
call mpl%write('diag_draw_type',nam%diag_draw_type)
call mpl%write('Lcoast',nam%Lcoast*req)
call mpl%write('rcoast',nam%rcoast)
call mpl%write('nc1',nam%nc1)
call mpl%write('nc2',nam%nc2)
call mpl%write('nc3',nam%nc3)
call mpl%write('dc',nam%dc*req)
call mpl%write('nl0r',nam%nl0r)
call mpl%write('irmax',nam%irmax)

! diag_param
write(mpl%info,'(a7,a)') '','Diagnostics parameters'
call mpl%flush
call mpl%write('ne',nam%ne)
call mpl%write('gen_kurt_th',nam%gen_kurt_th)
call mpl%write('gau_approx',nam%gau_approx)
call mpl%write('avg_nbins',nam%avg_nbins)
call mpl%write('vbal_block',nam%nv*(nam%nv-1)/2,nam%vbal_block(1:nam%nv*(nam%nv-1)/2))
call mpl%write('vbal_rad',nam%vbal_rad*req)
call mpl%write('vbal_dlat',nam%vbal_dlat*rad2deg)
call mpl%write('vbal_diag_auto',nam%nv*(nam%nv-1)/2,nam%vbal_diag_auto(1:nam%nv*(nam%nv-1)/2))
call mpl%write('vbal_diag_reg',nam%nv*(nam%nv-1)/2,nam%vbal_diag_reg(1:nam%nv*(nam%nv-1)/2))
call mpl%write('vbal_pseudo_inv',nam%vbal_pseudo_inv)
call mpl%write('vbal_pseudo_inv_mmax',nam%vbal_pseudo_inv_mmax)
call mpl%write('vbal_pseudo_inv_var_th',nam%vbal_pseudo_inv_var_th)
call mpl%write('forced_var',nam%forced_var)
real_array(1:nam%nl0*nam%nv) = reshape(nam%stddev(1:nam%nl0,1:nam%nv),(/nam%nl0*nam%nv/))
call mpl%write('stddev',nam%nl0*nam%nv,real_array(1:nam%nl0*nam%nv))
call mpl%write('var_filter',nam%var_filter)
call mpl%write('var_niter',nam%var_niter)
call mpl%write('var_npass',nam%var_npass)
real_array(1:nam%nl0*nam%nv) = reshape(nam%var_rhflt(1:nam%nl0,1:nam%nv),(/nam%nl0*nam%nv/))
call mpl%write('var_rhflt',nam%nl0*nam%nv,real_array)
call mpl%write('local_diag',nam%local_diag)
call mpl%write('local_rad',nam%local_rad*req)
call mpl%write('local_dlat',nam%local_dlat*rad2deg)

! fit_param
write(mpl%info,'(a7,a)') '','Fit parameters'
call mpl%flush
call mpl%write('diag_rhflt',nam%diag_rhflt*req)
call mpl%write('diag_rvflt',nam%diag_rvflt)
call mpl%write('fit_dl0',nam%fit_dl0)
call mpl%write('peakness',nam%peakness)
call mpl%write('negative_lobe',nam%negative_lobe)
call mpl%write('diag_sqrt',nam%diag_sqrt)
call mpl%write('lct_nscales',nam%lct_nscales)
call mpl%write('lct_scale_ratio',nam%lct_scale_ratio)
call mpl%write('lct_cor_min',nam%lct_cor_min)
call mpl%write('lct_diag',nam%lct_nscales,nam%lct_diag(1:nam%lct_nscales))
call mpl%write('lct_qc_th',nam%lct_qc_th)
call mpl%write('lct_qc_max',nam%lct_qc_max)
call mpl%write('lct_write_cor',nam%lct_write_cor)

! nicas_param
write(mpl%info,'(a7,a)') '','NICAS parameters'
call mpl%flush
call mpl%write('nonunit_diag',nam%nonunit_diag)
call mpl%write('resol',nam%resol)
call mpl%write('nc1max',nam%nc1max)
call mpl%write('nicas_draw_type',nam%nicas_draw_type)
call mpl%write('network',nam%network)
call mpl%write('forced_radii',nam%forced_radii)
real_array(1:nam%nl0*(nam%nv+1)) = reshape(nam%rh(1:nam%nl0,0:nam%nv),(/nam%nl0*(nam%nv+1)/))
call mpl%write('rh',nam%nl0*(nam%nv+1),real_array(1:nam%nl0*(nam%nv+1)))
real_array(1:nam%nl0*(nam%nv+1)) = reshape(nam%pkh(1:nam%nl0,0:nam%nv),(/nam%nl0*(nam%nv+1)/))
call mpl%write('pkh',nam%nl0*(nam%nv+1),real_array(1:nam%nl0*(nam%nv+1)))
real_array(1:nam%nl0*(nam%nv+1)) = reshape(nam%rv(1:nam%nl0,0:nam%nv),(/nam%nl0*(nam%nv+1)/))
call mpl%write('rv',nam%nl0*(nam%nv+1),real_array(1:nam%nl0*(nam%nv+1)))
real_array(1:nam%nl0*(nam%nv+1)) = reshape(nam%pkv(1:nam%nl0,0:nam%nv),(/nam%nl0*(nam%nv+1)/))
call mpl%write('pkv',nam%nl0*(nam%nv+1),real_array(1:nam%nl0*(nam%nv+1)))
real_array(1:nam%nl0*(nam%nv+1)) = reshape(nam%nlv(1:nam%nl0,0:nam%nv),(/nam%nl0*(nam%nv+1)/))
call mpl%write('nlv',nam%nl0*(nam%nv+1),real_array(1:nam%nl0*(nam%nv+1)))
call mpl%write('min_lev',nam%nv+1,nam%min_lev(0:nam%nv))
call mpl%write('max_lev',nam%nv+1,nam%max_lev(0:nam%nv))
call mpl%write('pos_def_test',nam%pos_def_test)
call mpl%write('write_nicas_c0',nam%write_nicas_c0)
call mpl%write('write_nicas_grids',nam%write_nicas_grids)

! dirac_param
write(mpl%info,'(a7,a)') '','Dirac parameters'
call mpl%flush
call mpl%write('ndir',nam%ndir)
allocate(londir(nam%ndir))
allocate(latdir(nam%ndir))
if (nam%ndir>0) then
   londir = nam%londir(1:nam%ndir)*rad2deg
   latdir = nam%latdir(1:nam%ndir)*rad2deg
end if
call mpl%write('londir',nam%ndir,londir)
call mpl%write('latdir',nam%ndir,latdir)
call mpl%write('levdir',nam%ndir,nam%levdir(1:nam%ndir))
call mpl%write('ivdir',nam%ndir,nam%ivdir(1:nam%ndir))

! output_param
write(mpl%info,'(a7,a)') '','Output parameters'
call mpl%flush
call mpl%write('full_grid_smoother_nn',nam%full_grid_smoother_nn)
call mpl%write('nldwv',nam%nldwv)
call mpl%write('img_ldwv',nam%nldwv,nam%img_ldwv(1:nam%nldwv))
allocate(lon_ldwv(nam%nldwv))
allocate(lat_ldwv(nam%nldwv))
if (nam%nldwv>0) then
   lon_ldwv = nam%lon_ldwv(1:nam%nldwv)*rad2deg
   lat_ldwv = nam%lat_ldwv(1:nam%nldwv)*rad2deg
end if
call mpl%write('lon_ldwv',nam%nldwv,lon_ldwv)
call mpl%write('lat_ldwv',nam%nldwv,lat_ldwv)
call mpl%write('name_ldwv',nam%nldwv,nam%name_ldwv(1:nam%nldwv))

! wind_param
write(mpl%info,'(a7,a)') '','Wind parameters'
call mpl%flush
call mpl%write('wind_streamfunction',nam%wind_streamfunction)
call mpl%write('wind_velocity_potential',nam%wind_velocity_potential)
call mpl%write('wind_zonal',nam%wind_zonal)
call mpl%write('wind_meridional',nam%wind_meridional)
call mpl%write('wind_nlon',nam%wind_nlon)
call mpl%write('wind_nlat',nam%wind_nlat)
call mpl%write('wind_nsg',nam%wind_nsg)
call mpl%write('wind_inflation',nam%wind_inflation)

! Release memory
deallocate(londir)
deallocate(latdir)
deallocate(lon_ldwv)
deallocate(lat_ldwv)

! Probe out
@:probe_out()

end subroutine nam_write

!----------------------------------------------------------------------
! Subroutine: nam_io_key_value
!> Get I/O value from key
!----------------------------------------------------------------------
subroutine nam_io_key_value(nam,io_key,io_value)

implicit none

! Passed variable
class(nam_type),intent(in) :: nam           !< Namelist
character(len=*),intent(in) :: io_key       !< I/O key
character(len=1024),intent(out) :: io_value !< I/O value

! Local variables
integer :: i

! Set name
@:set_name(nam_io_key_value)

! Probe in
@:probe_in()

! Loop over I/O key-value couples
io_value = io_key
do i=1,niokvmax
   if (trim(nam%io_keys(i))==trim(io_key)) then
      io_value = nam%io_values(i)
      exit
   end if
end do

! Probe out
@:probe_out()

end subroutine nam_io_key_value

end module type_nam
