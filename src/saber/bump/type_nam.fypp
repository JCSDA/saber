#:include '../generics.fypp'
#:include '../instrumentation.fypp'
!----------------------------------------------------------------------
! Module: type_nam
!> Namelist derived type
! Author: Benjamin Menetrier
! Licensing: this code is distributed under the CeCILL-C license
! Copyright 2015-... UCAR, CERFACS, METEO-FRANCE and IRIT
!----------------------------------------------------------------------
module type_nam

use fckit_configuration_module, only: fckit_configuration
use tools_const, only: zero,hundredth,half,one,ten,hundred,pi,req,deg2rad,rad2deg
use tools_kinds, only: kind_real,kind_int,huge_real
use tools_func, only: cholesky
use tools_repro, only: eq
use type_mpl, only: mpl_type
@:use_probe()

implicit none

integer,parameter :: nsubmax = 99                 !< Maximum number of sub-ensembles
integer,parameter :: nvmax = 99                   !< Maximum number of variables
integer,parameter :: nl0max = 300                 !< Maximum number of levels
integer,parameter :: nc3max = 100                 !< Maximum number of distance classes
integer,parameter :: nc4max = 24                  !< Maximum number of angular sectors
integer,parameter :: nscalesmax = 5               !< Maximum number of scales
integer,parameter :: ndirmax = 99                 !< Maximum number of diracs
integer,parameter :: nprociomax = 20              !< Maximum number of I/O tasks
integer,parameter :: niokvmax = 99                !< Maximum number of I/O key-values
integer,parameter :: nvbalmax = nvmax*(nvmax-1)/2 !< Maximum number of vertical balance blocks

type nam_type
   logical :: default_seed                                    !< Default seed for random numbers
   logical :: repro_ops                                       !< Reproducibility operators
   real(kind_real) :: repro_th                                !< Reproducibility threshold
   real(kind_real) :: universe_radius                         !< Universe radius [in meters]

   ! I/O section
   character(len=1024) :: datadir                             !< Data directory
   character(len=1024) :: prefix                              !< Files prefix
   logical :: parallel_netcdf                                 !< Parallel NetCDF I/O
   integer :: nprocio                                         !< Number of I/O tasks
   character(len=1024),dimension(niokvmax) :: alias_code      !< Alias keys in code
   character(len=1024),dimension(niokvmax) :: alias_file      !< Alias values in file
   character(len=1024) :: fname_samp                          !< Sampling file
   character(len=1024),dimension(0:nsubmax) :: fname_vbal_cov !< Vertical covariance files
   logical :: fname_vbal_cov_used                             !< Flag activated if a vertical covariance file is specified
   character(len=1024) :: fname_vbal                          !< Vertical balance file
   character(len=1024),dimension(0:nsubmax) :: fname_mom      !< Moments files
   logical :: fname_mom_used                                  !< Flag activated if a moments file is specified
   character(len=1024) :: fname_nicas                         !< NICAS file
   character(len=1024) :: fname_wind                          !< Wind transform file

   ! Drivers section
   logical :: compute_cov1                                    !< Compute covariance, ensemble 1
   logical :: compute_cov2                                    !< Compute covariance, ensemble 2
   logical :: compute_cor1                                    !< Compute correlation, ensemble 1
   logical :: compute_cor2                                    !< Compute correlation, ensemble 2
   logical :: compute_loc1                                    !< Compute localization, ensemble 1
   logical :: compute_loc2                                    !< Compute localization, ensemble 2
   logical :: compute_hyb                                     !< Compute hybrid weights
   logical :: new_hdiag                                       !< Compute diagnostics
   character(len=1024) :: hybrid_source                       !< Hybrid term source ('randomized static' or 'lowres ensemble')
   character(len=1024) :: strategy                            !< Multivariate strategy ('diag_all', 'common', 'common_weighted', 'specific_univariate' or 'specific_multivariate')
   logical :: iterative_algo                                  !< Iterative algorithm (ensemble members loaded sequentially)
   logical :: new_normality                                   !< New normality test
   logical :: load_samp_local                                 !< Load local sampling
   logical :: load_samp_global                                !< Load global sampling
   logical :: write_samp_local                                !< Write local sampling
   logical :: write_samp_global                               !< Write global sampling
   logical :: write_samp_grids                                !< Write sampling grids
   logical :: new_vbal_cov                                    !< New vertical covariance
   logical :: load_vbal_cov                                   !< Load local vertical covariance
   logical :: write_vbal_cov                                  !< Write local vertical covariancee
   logical :: new_vbal                                        !< Compute vertical balance operator
   logical :: load_vbal                                       !< Load local vertical balance operator
   logical :: write_vbal                                      !< Write vertical balance operator
   logical :: new_var                                         !< Compute variance
   logical :: new_mom                                         !< Compute moments
   logical :: load_mom                                        !< Load sampling moments
   logical :: write_mom                                       !< Write sampling moments
   logical :: write_hdiag                                     !< Write diagnostics
   logical :: write_hdiag_detail                              !< Write components detail
   logical :: new_nicas                                       !< Compute NICAS parameters
   logical :: load_nicas_local                                !< Load local NICAS parameters
   logical :: load_nicas_global                               !< Load global NICAS parameters
   logical :: write_nicas_local                               !< Write local NICAS parameters
   logical :: write_nicas_global                              !< Write global NICAS parameters
   logical :: write_nicas_grids                               !< Write NICAS grids
   logical :: new_wind                                        !< Compute wind transform
   logical :: load_wind_local                                 !< Load local wind transform
   logical :: write_wind_local                                !< Write local wind transform
   logical :: check_vbal                                      !< Test vertical balance inverse
   logical :: check_adjoints                                  !< Test adjoints
   integer :: check_normalization                             !< Test NICAS normalization (number of tests)
   logical :: check_dirac                                     !< Test NICAS application on diracs
   logical :: check_randomization                             !< Test NICAS randomization
   logical :: check_consistency                               !< Test HDIAG-NICAS consistency
   logical :: check_optimality                                !< Test HDIAG optimality

   ! Model section
   integer :: nl0                                             !< Number of levels
   character(len=1024) :: lev2d                               !< Level for 2D variables ('first' or 'last')
   integer :: nv                                              !< Number of variables
   character(len=1024),dimension(nvmax) :: variables          !< Variables names
   logical :: mask_check                                      !< Check that sampling couples and interpolations do not cross mask boundaries

   ! Ensemble sizes
   integer :: ens1_ne                                         !< Ensemble 1 size
   integer :: ens1_nsub                                       !< Ensemble 1 sub-ensembles number
   integer :: ens2_ne                                         !< Ensemble 2 size
   integer :: ens2_nsub                                       !< Ensemble 2 sub-ensembles number

   ! Sampling section
   integer :: nc1                                             !< Computation grid size
   integer :: nc2                                             !< Diagnostic grid size
   integer :: nc3                                             !< Number of distance classes
   integer :: nc4                                             !< Number of angular sectors
   real(kind_real) :: dc                                      !< Class size, should be larger than the typical grid cell size [in meters]
   integer :: nl0r                                            !< Reduced number of levels for diagnostics
   logical :: local_diag                                      !< Activate local diagnostics
   real(kind_real) :: local_rad                               !< Local diagnostics calculation radius [in meters]
   real(kind_real) :: local_dlat                              !< Local diagnostics calculation latitude band half-width [in degrees]
   character(len=1024) :: samp_draw_type                      !< Diagnostic draw type ('random' or 'octahedral')
   integer :: irmax                                           !< Maximum number of random number draws
   character(len=2) :: samp_interp_type                       !< Sampling C2B to C0A interpolation type ('c0': C0 mesh-based, 'c1': C1 mesh-based or 'si': smooth interpolation)
   integer :: nmask                                           !< Number of masks
   character(len=1024),allocatable :: mask_type(:)            !< Mask restriction type
   real(kind_real),allocatable :: mask_th(:)                  !< Mask threshold
   character(len=1024),allocatable :: mask_lu(:)              !< Mask threshold side ('lower' if mask_th is the lower bound, resp. 'upper')
   character(len=1024),allocatable :: mask_variable(:)        !< Mask variable
   integer :: ncontig_th                                      !< Threshold on vertically contiguous points for sampling mask (0 to skip the test)

   ! Localization section
   integer :: ne                                              !< Ensemble size
   integer :: ne_lr                                           !< Ensemble size of the low-resolution term (ensemble 2)
   logical :: gau_approx                                      !< Gaussian approximation for asymptotic quantities
   real(kind_real) :: gen_kurt_th                             !< Threshold on generalized kurtosis (3.0 = Gaussian distribution)
   integer :: avg_nbins                                       !< Number of bins for averaged statistics histograms

   ! Vertical balance section
   logical,allocatable :: vbal_block(:,:)                     !< Activation of vertical balance
   logical,allocatable :: vbal_diag_auto(:,:)                 !< Diagonal auto-covariance for the inversion
   logical,allocatable :: vbal_diag_reg(:,:)                  !< Diagonal regression
   real(kind_real),allocatable :: vbal_id_coef(:,:)           !< Scalar coefficients for identity vertical balance
   logical :: vbal_pseudo_inv                                 !< Pseudo-inverse for auto-covariance
   integer :: vbal_pseudo_inv_mmax                            !< Dominant mode for pseudo-inverse
   real(kind_real) :: vbal_pseudo_inv_var_th                  !< Variance threshold to compute the dominant mode for pseudo-inverse
   logical :: vbal_id                                         !< Identity vertical balance for tests

   ! Variance section
   logical :: forced_var                                      !< Force specific variance
   real(kind_real) :: stddev(nl0max,0:nvmax)                  !< Forced standard-deviation
   logical :: var_filter                                      !< Filter variance
   integer :: var_niter                                       !< Number of iterations for the variance filtering (0 for uniform variance)
   integer :: var_npass                                       !< Number of passes for the variance filtering (0 for uniform variance)
   real(kind_real) :: var_rhflt(nl0max,0:nvmax)               !< Variance initial filtering support radius [in meters]

   ! Optimality test section
   integer :: optimality_nfac                                 !< Number of length-scale factors for optimization
   real(kind_real) :: optimality_delta                        !< Increments of length-scale factors for optimization
   integer :: optimality_ntest                                !< Number of test vectors for optimization

   ! Fit section
   real(kind_real) :: diag_rhflt                              !< Horizontal filtering suport radius [in meters]
   real(kind_real) :: diag_rvflt                              !< Vertical filtering support radius
   integer :: fit_dl0                                         !< Number of levels between interpolation levels
   integer :: fit_ncmp                                        !< Number of components in the fit function

   ! Local profiles section
   integer :: nldwv                                           !< Number of local diagnostics profiles to write (for local_diag = .true.)
   real(kind_real),allocatable :: lon_ldwv(:)                 !< Longitudes of the local diagnostics profiles to write [in degrees]
   real(kind_real),allocatable :: lat_ldwv(:)                 !< Latitudes of the local diagnostics profiles to write [in degrees]
   character(len=1024),allocatable :: name_ldwv(:)            !< Name of the local diagnostics profiles to write

   ! NICAS section
   real(kind_real) :: resol                                   !< Resolution
   integer :: nc1max                                          !< Maximum size of the Sc1 subset
   character(len=1024) :: nicas_draw_type                     !< NICAS draw type ('random' or 'octahedral')
   logical :: forced_radii                                    !< Force specific support radii
   real(kind_real) :: rh(nl0max,0:nvmax)                      !< Forced horizontal support radius [in meters]
   real(kind_real) :: rv(nl0max,0:nvmax)                      !< Forced vertical support radius
   integer :: min_lev(0:nvmax)                                !< Minimum level
   integer :: max_lev(0:nvmax)                                !< Maximum level
   real(kind_real),allocatable :: loc_wgt_sqrt(:,:)           !< Weights square-root for the 'common_weighted' strategy
   character(len=2),dimension(0:nvmax) :: nicas_interp_type   !< NICAS C1B to C0A interpolation type ('c0': C0 mesh-based, 'c1': C1 mesh-based or 'si': smooth interpolation)
   logical :: pos_def_test                                    !< Positive-definiteness test
   logical :: interp_test                                     !< Horizontal NICAS interpolation test

   ! Wind section
   character(len=1024) :: wind_streamfunction                 !< Streamfunction variable name
   character(len=1024) :: wind_velocity_potential             !< Velocity potential variable name
   character(len=1024) :: wind_zonal                          !< Zonal wind variable name
   character(len=1024) :: wind_meridional                     !< Meridional variable name
   integer :: wind_nlon                                       !< Number of longitudes for the regular grid
   integer :: wind_nlat                                       !< Number of latitudes for the regular grid
   integer :: wind_nsg                                        !< Half-width of the Savitzky-Golay to compute derivatives
   real(kind_real) :: wind_inflation                          !< Wind inflation to compensate the Savitzky-Golay smoothing

   ! Dirac section
   integer :: ndir                                            !< Number of Diracs
   real(kind_real) :: londir(ndirmax)                         !< Diracs longitudes [in degrees]
   real(kind_real) :: latdir(ndirmax)                         !< Diracs latitudes [in degrees]
   integer :: levdir(ndirmax)                                 !< Diracs level
   integer :: ivdir(ndirmax)                                  !< Diracs variable indices
contains
   procedure :: init => nam_init
   procedure :: from_conf => nam_from_conf
   procedure :: check => nam_check
   procedure :: alias => nam_alias
   #:for dtype in dtypes_ir
      procedure :: nam_get_value_${dtype}$
   #:endfor
@:init_procedure(2)
   generic :: get_value => &
   #:for dtype in dtypes_ir
@:add_procedure(nam_get_value_${dtype}$)
   #:endfor
   #:for dtype in dtypes_ir
      procedure :: nam_get_value_or_profile_${dtype}$
   #:endfor
@:init_procedure(2)
   generic :: get_value_or_profile => &
   #:for dtype in dtypes_ir
@:add_procedure(nam_get_value_or_profile_${dtype}$)
   #:endfor
end type nam_type

interface get
   #:for dtype in dtypes_irls
      module procedure nam_get_${dtype}$
   #:endfor
end interface

private
public :: nvmax,nl0max,nc3max,nscalesmax,ndirmax,niokvmax,nvbalmax
public :: nam_type

contains

!----------------------------------------------------------------------
! Subroutine: nam_init
!> Intialize
!----------------------------------------------------------------------
subroutine nam_init(nam,mpl)

implicit none

! Passed variable
class(nam_type),intent(out) :: nam !< Namelist
type(mpl_type),intent(in) :: mpl   !< MPI data

! Local variable
integer :: isub,il0,iv,i,ildwv

! Set name
@:set_name(nam_init)

! Probe in
@:probe_in()

! General section default
nam%default_seed = .true.
nam%repro_ops = .true.
nam%repro_th = 1.0e-12_kind_real
nam%universe_radius = pi*req

! I/O section default
nam%datadir = '.'
nam%prefix = ''
nam%parallel_netcdf = .true.
nam%nprocio = min(mpl%nproc,nprociomax)
do i=1,niokvmax
   nam%alias_code(i) = ''
   nam%alias_file(i) = ''
end do
nam%fname_samp = ''
do isub=0,nsubmax
   nam%fname_vbal_cov(isub) = ''
end do
nam%fname_vbal = ''
do isub=0,nsubmax
   nam%fname_mom(isub) = ''
end do
nam%fname_nicas = ''
nam%fname_wind = ''

! Drivers section default
nam%compute_cov1 = .false.
nam%compute_cov2 = .false.
nam%compute_cor1 = .false.
nam%compute_cor2 = .false.
nam%compute_loc1 = .false.
nam%compute_loc2 = .false.
nam%compute_hyb = .false.
nam%new_hdiag = .false.
nam%hybrid_source = ''
nam%strategy = ''
nam%iterative_algo = .false.
nam%new_normality = .false.
nam%load_samp_local = .false.
nam%load_samp_global = .false.
nam%write_samp_local = .false.
nam%write_samp_global = .false.
nam%write_samp_grids = .false.
nam%new_vbal_cov = .false.
nam%load_vbal_cov = .false.
nam%write_vbal_cov = .false.
nam%new_vbal = .false.
nam%load_vbal = .false.
nam%write_vbal = .false.
nam%new_var = .false.
nam%new_mom = .false.
nam%load_mom = .false.
nam%write_mom = .false.
nam%write_hdiag = .false.
nam%write_hdiag_detail = .false.
nam%new_nicas = .false.
nam%load_nicas_local = .false.
nam%load_nicas_global = .false.
nam%write_nicas_local = .false.
nam%write_nicas_global = .false.
nam%write_nicas_grids = .false.
nam%new_wind = .false.
nam%load_wind_local = .false.
nam%write_wind_local = .false.
nam%check_vbal = .false.
nam%check_adjoints = .false.
nam%check_normalization = 0
nam%check_dirac = .false.
nam%check_randomization = .false.
nam%check_consistency = .false.
nam%check_optimality = .false.

! Model section default
nam%nl0 = 0
nam%lev2d = 'first'
nam%nv = 0
do iv=1,nvmax
   nam%variables(iv) = ''
end do
nam%mask_check = .false.

! Ensemble sizes section default
nam%ens1_ne = 0
nam%ens1_nsub = 1
nam%ens2_ne = 0
nam%ens2_nsub = 1

! Sampling section default
nam%nc1 = 0
nam%nc2 = 0
nam%nc3 = 0
nam%nc4 = 1
nam%dc = zero
nam%nl0r = 0
nam%local_diag = .false.
nam%local_rad = zero
nam%local_dlat = zero
nam%samp_draw_type = 'random'
nam%irmax = 10000
nam%samp_interp_type = 'c0'
nam%nmask = 0
nam%ncontig_th = 0

! Localization section default
nam%ne = 0
nam%ne_lr = 0
nam%gau_approx = .false.
nam%gen_kurt_th = huge_real
nam%avg_nbins = 0

! Vertical balance section
nam%vbal_pseudo_inv = .false.
nam%vbal_pseudo_inv_mmax = 0
nam%vbal_pseudo_inv_var_th = zero
nam%vbal_id = .false.

! Variance section
nam%forced_var = .false.
nam%stddev = zero
nam%var_filter = .false.
nam%var_niter = -1
nam%var_npass = -1
nam%var_rhflt = zero

! Optimality test section
nam%optimality_nfac = 1
nam%optimality_delta = 0.05_kind_real
nam%optimality_ntest = 10

! Fit section
nam%diag_rhflt = zero
nam%diag_rvflt = zero
nam%fit_dl0 = 1
nam%fit_ncmp = 1

! Local profiles section
nam%nldwv = 0

! NICAS section
nam%resol = zero
nam%nc1max = 15000
nam%nicas_draw_type = 'random'
nam%forced_radii = .false.
nam%rh = -one
nam%rv = -one
nam%min_lev = 1
nam%max_lev = nl0max
nam%nicas_interp_type = 'c0'
nam%pos_def_test = .false.
nam%interp_test = .false.

! Wind section
nam%wind_streamfunction = 'stream_function'
nam%wind_velocity_potential = 'velocity_potential'
nam%wind_zonal = 'eastward_wind'
nam%wind_meridional = 'northward_wind'
nam%wind_nlon = 0
nam%wind_nlat = 0
nam%wind_nsg = 0
nam%wind_inflation = one

! Dirac section
nam%ndir = 0
nam%londir = zero
nam%latdir = zero
nam%levdir = 0
nam%ivdir = 0

! Helpers
nam%fname_vbal_cov_used = .false.
nam%fname_mom_used = .false.


! Probe out
@:probe_out()

end subroutine nam_init

!----------------------------------------------------------------------
! Subroutine: nam_from_conf
!> Intialize from configuration
!----------------------------------------------------------------------
subroutine nam_from_conf(nam,mpl,conf)

implicit none

! Passed variable
class(nam_type),intent(inout) :: nam         !< Namelist
type(mpl_type),intent(inout) :: mpl          !< MPI data
type(fckit_configuration),intent(in) :: conf !< Configuration

! Local variables
integer :: iv,jv,iconf,rank,itest,it,ivv,jvv
integer,allocatable :: integer_array(:),vbal_order(:)
real(kind_real) :: real_scalar
real(kind_real),allocatable :: real_array(:),loc_wgt(:,:)
logical :: color_log,found,valid
logical,allocatable :: logical_array(:)
character(len=1024) :: message,param,blockname
character(len=:),allocatable :: str,str_bal,str_unbal
character(len=:),allocatable :: str_array(:),str_array_row(:),str_array_col(:)
type(fckit_configuration) :: section,subconf
type(fckit_configuration),allocatable :: confs(:)

! Set name
@:set_name(nam_from_conf)

! Probe in
@:probe_in()

! General section
if (conf%has('general')) then
   call conf%get_or_die('general',section)
   if (section%has('color log')) then
      call section%get_or_die('color log',color_log)
      if (color_log) then
         mpl%black = char(27)//'[0;0m'
         mpl%green = char(27)//'[0;32m'
         mpl%peach = char(27)//'[1;91m'
         mpl%aqua = char(27)//'[1;36m'
         mpl%purple = char(27)//'[1;35m'
         mpl%wng_color = char(27)//'[0;37;42;1m'
      end if
   end if
   call get(section,'testing',mpl%testing)
   call get(section,'default seed',nam%default_seed)
   call get(section,'reproducibility operators',nam%repro_ops)
   call get(section,'reproducibility threshold',nam%repro_th)
   call get(section,'universe length-scale',nam%universe_radius)
end if

! I/O param
if (conf%has('io')) then
   call conf%get_or_die('io',section)
   call get(section,'data directory',nam%datadir)
   call get(section,'files prefix',nam%prefix)
   call get(section,'parallel netcdf',nam%parallel_netcdf)
   call get(section,'io task number',nam%nprocio)
   if (section%has('alias')) then
      call section%get_or_die('alias',confs)
      if (size(confs)>niokvmax) then
         write(message,'(a,i4)') 'alias size should be smaller than ',niokvmax
         call mpl%abort('${subr}$',message)
      end if
      do iconf=1,size(confs)
         call confs(iconf)%get_or_die('in code',str)
         nam%alias_code(iconf) = str
         call confs(iconf)%get_or_die('in file',str)
         nam%alias_file(iconf) = str
      end do
   end if
   call get(section,'overriding sampling file',nam%fname_samp)
   if (section%has('overriding vertical covariance file')) then
      call section%get_or_die('overriding vertical covariance file',str_array)
      if (size(str_array)>nsubmax) then
         write(message,'(a,i4)') 'fname_vbal_cov size should be smaller than ',nsubmax
         call mpl%abort('${subr}$',message)
      end if
      nam%fname_vbal_cov(1:size(str_array)) = str_array
   end if
   call get(section,'overriding vertical balance file',nam%fname_vbal)
   if (section%has('overriding moments file')) then
      call section%get_or_die('overriding moments file',str_array)
      if (size(str_array)>nsubmax) then
         write(message,'(a,i4)') 'fname_mom size should be smaller than ',nsubmax
         call mpl%abort('${subr}$',message)
      end if
      nam%fname_mom(1:size(str_array)) = str_array
   end if
   call get(section,'overriding nicas file',nam%fname_nicas)
   call get(section,'overriding psichitouv file',nam%fname_wind)
end if
   
! Drivers section
if (conf%has('drivers')) then
   call conf%get_or_die('drivers',section)
   call get(section,'compute covariance',nam%compute_cov1)
   call get(section,'compute lowres covariance',nam%compute_cov2)
   call get(section,'compute correlation',nam%compute_cor1)
   call get(section,'compute lowres correlation',nam%compute_cor2)
   call get(section,'compute localization',nam%compute_loc1)
   call get(section,'compute lowres localization',nam%compute_loc2)
   call get(section,'compute hybrid weights',nam%compute_hyb)
   call get(section,'hybrid source',nam%hybrid_source)
   call get(section,'multivariate strategy',nam%strategy)
   call get(section,'iterative algorithm',nam%iterative_algo)
   call get(section,'compute normality',nam%new_normality)
   call get(section,'load local sampling',nam%load_samp_local)
   call get(section,'load global sampling',nam%load_samp_global)
   call get(section,'write local sampling',nam%write_samp_local)
   call get(section,'write global sampling',nam%write_samp_global)
   call get(section,'write sampling grids',nam%write_samp_grids)
   call get(section,'compute vertical covariance',nam%new_vbal_cov)
   call get(section,'load vertical covariance',nam%load_vbal_cov)
   call get(section,'write vertical covariance',nam%write_vbal_cov)
   call get(section,'compute vertical balance',nam%new_vbal)
   call get(section,'load vertical balance',nam%load_vbal)
   call get(section,'write vertical balance',nam%write_vbal)
   call get(section,'compute variance',nam%new_var)
   call get(section,'compute moments',nam%new_mom)
   call get(section,'load moments',nam%load_mom)
   call get(section,'write moments',nam%write_mom)
   call get(section,'write diagnostics',nam%write_hdiag)
   call get(section,'write diagnostics detail',nam%write_hdiag_detail)
   call get(section,'compute nicas',nam%new_nicas)
   call get(section,'load local nicas',nam%load_nicas_local)
   call get(section,'load global nicas',nam%load_nicas_global)
   call get(section,'write local nicas',nam%write_nicas_local)
   call get(section,'write global nicas',nam%write_nicas_global)
   call get(section,'write nicas grids',nam%write_nicas_grids)
   call get(section,'compute psichitouv',nam%new_wind)
   call get(section,'load local psichitouv',nam%load_wind_local)
   call get(section,'write local psichitouv',nam%write_wind_local)
   call get(section,'vertical balance inverse test',nam%check_vbal)
   call get(section,'adjoints test',nam%check_adjoints)
   call get(section,'normalization test',nam%check_normalization)
   call get(section,'internal dirac test',nam%check_dirac)
   call get(section,'randomization test',nam%check_randomization)
   call get(section,'internal consistency test',nam%check_consistency)
   call get(section,'localization optimality test',nam%check_optimality)
end if

! Model section
if (conf%has('model')) then
   call conf%get_or_die('model',section)
   call get(section,'level for 2d variables',nam%lev2d)
   if (section%has('variables')) then
      call section%get_or_die('variables',str_array)
      if (size(str_array)>nvmax) then
         write(message,'(a,i4)') 'variables size should be smaller than ',nvmax
         call mpl%abort('${subr}$',message)
      end if
      nam%variables(1:size(str_array)) = str_array
      nam%nv = size(str_array)
   end if
   call get(section,'do not cross mask boundaries',nam%mask_check)
end if

! Ensemble sizes
if (conf%has('ensemble sizes')) then
   call conf%get_or_die('ensemble sizes',section)
   call get(section,'total ensemble size',nam%ens1_ne)
   call get(section,'sub-ensembles',nam%ens1_nsub)
   call get(section,'total lowres ensemble size',nam%ens2_ne)
   call get(section,'lowres sub-ensembles',nam%ens2_nsub)
end if

! Sampling section
if (conf%has('sampling')) then
   call conf%get_or_die('sampling',section)
   call get(section,'computation grid size',nam%nc1)
   call get(section,'diagnostic grid size',nam%nc2)
   call get(section,'distance classes',nam%nc3)
   call get(section,'angular sectors',nam%nc4)
   call get(section,'distance class width',nam%dc)
   call get(section,'reduced levels',nam%nl0r)
   call get(section,'local diagnostic',nam%local_diag)
   call get(section,'averaging length-scale',nam%local_rad)
   call get(section,'averaging latitude width',nam%local_dlat)
   call get(section,'grid type',nam%samp_draw_type)
   call get(section,'max number of draws',nam%irmax)
   call get(section,'interpolation type',nam%samp_interp_type)
   if (section%has('masks')) then
      call section%get_or_die('masks',confs)

      ! Count masks
      nam%nmask = size(confs)

      ! Allocation
      allocate(nam%mask_type(nam%nmask))
      allocate(nam%mask_th(nam%nmask))
      allocate(nam%mask_lu(nam%nmask))
      allocate(nam%mask_variable(nam%nmask))

      ! Initialization
      do iconf=1,size(confs)
         nam%mask_type(iconf) = ''
         nam%mask_th(iconf) = mpl%msv%valr
         nam%mask_lu(iconf) = ''
         nam%mask_variable(iconf) = ''
      end do

      ! Get values
      do iconf=1,size(confs)
         call get(confs(iconf),'type',nam%mask_type(iconf))
         call get(confs(iconf),'threshold',nam%mask_th(iconf))
         call get(confs(iconf),'side',nam%mask_lu(iconf))
         call get(confs(iconf),'variable',nam%mask_variable(iconf))
      end do
   end if
   call get(section,'contiguous levels threshold',nam%ncontig_th)
end if

! Localization section
if (conf%has('localization')) then
   call conf%get_or_die('localization',section)
   call get(section,'target ensemble size',nam%ne)
   call get(section,'target lowres ensemble size',nam%ne_lr)
   call get(section,'gaussian approximation',nam%gau_approx)
   call get(section,'generalized kurtosis threshold',nam%gen_kurt_th)
   call get(section,' histogram bins',nam%avg_nbins)
end if

! Vertical balance section
if (conf%has('vertical balance')) then
   call conf%get_or_die('vertical balance',section)
   if (section%has('vbal')) then
      call section%get_or_die('vbal',confs)

      ! Allocation
      allocate(nam%vbal_block(nam%nv,nam%nv))
      allocate(nam%vbal_diag_auto(nam%nv,nam%nv))
      allocate(nam%vbal_diag_reg(nam%nv,nam%nv))
      allocate(nam%vbal_id_coef(nam%nv,nam%nv))
      allocate(vbal_order(nam%nv))
   
      ! Get initial matrix
      nam%vbal_block = .false.
      do iconf=1,size(confs)
         call confs(iconf)%get_or_die('balanced variable',str_bal)
         call confs(iconf)%get_or_die('unbalanced variable',str_unbal)
         found = .false.
         do jv=1,nam%nv
            do iv=1,nam%nv
               if ((str_bal==nam%variables(iv)).and.(str_unbal==nam%variables(jv))) then
                  if (iv==jv) then
                     call mpl%abort('${subr}$','vbal item should be off-diagonal')
                  else
                     if (nam%vbal_block(iv,jv)) then
                        call mpl%abort('${subr}$','redundant vbal item')
                     else
                        nam%vbal_block(iv,jv) = .true.
                        found = .true.
                     end if
                  end if
               end if
            end do
         end do
         if (.not.found) call mpl%abort('${subr}$','wrong vbal item')
      end do
   
      ! Get vbal variables order
      vbal_order = 0
      rank = 0
   
      ! Independent variables first
      do iv=1,nam%nv
         if (count(nam%vbal_block(iv,:))==0) then
            rank = rank+1
            vbal_order(rank) = iv
         end if
      end do
   
      ! Find least-dependent variables progressively
      iv = 0
      itest = 0
      do while (any(vbal_order==0))
         ! Check number of iterations
         itest = itest+1
         if (itest>nam%nv**2) call mpl%abort('${subr}$','inconsistent vbal items')
   
         ! Increment variable index
         iv = iv+1
         if (iv>nam%nv) iv = 1
   
         if (.not.any(vbal_order(1:rank)==iv)) then
            ! Check variable dependencies
            valid = .true.
            do jv=1,nam%nv
               if (nam%vbal_block(iv,jv)) then
                  if (.not.any(vbal_order(1:rank)==jv)) valid = .false.
               end if
            end do
   
            ! Check if variable can be added now
            if (valid) then
               rank = rank+1
               vbal_order(rank) = iv
            end if
         end if
      end do
   
      ! Reorder variables
      nam%variables(1:nam%nv) = nam%variables(vbal_order)
      nam%vbal_block = nam%vbal_block(vbal_order,vbal_order)
   
      ! Set section
      do iconf=1,size(confs)
         call confs(iconf)%get_or_die('balanced variable',str_bal)
         call confs(iconf)%get_or_die('unbalanced variable',str_unbal)
         do jv=1,nam%nv
            do iv=1,nam%nv
               if ((str_bal==nam%variables(iv)).and.(str_unbal==nam%variables(jv))) then
                  call confs(iconf)%get_or_die('diagonal autocovariance',nam%vbal_diag_auto(iv,jv))
                  call confs(iconf)%get_or_die('diagonal regression',nam%vbal_diag_reg(iv,jv))
                  call confs(iconf)%get_or_die('identity block weight',nam%vbal_id_coef(iv,jv))
               end if
            end do
         end do
      end do
   
      ! Release memory
      deallocate(vbal_order)
   end if
   call get(section,'pseudo inverse',nam%vbal_pseudo_inv)
   call get(section,'dominant mode',nam%vbal_pseudo_inv_mmax)
   call get(section,'variance threshold',nam%vbal_pseudo_inv_var_th)
   call get(section,'identity blocks',nam%vbal_id)
end if

! Variance section
if (conf%has('variance')) then
   call conf%get_or_die('variance',section)
   call get(section,'explicit stddev',nam%forced_var)
   call nam%get_value_or_profile(mpl,section,'stddev',nam%stddev)
   call get(section,'objective filtering',nam%var_filter)
   call get(section,'filtering iterations',nam%var_niter)
   call get(section,'filtering passes',nam%var_npass)
   call nam%get_value_or_profile(mpl,section,'initial length-scale',nam%var_rhflt)
end if

! Optimality test section
if (conf%has('optimality test')) then
   call conf%get_or_die('optimality test',section)
   call get(section,'half number of factors',nam%optimality_nfac)
   call get(section,'optimality_delta',nam%optimality_delta)
   call get(section,'optimality_ntest',nam%optimality_ntest)
end if

! Fit section
if (conf%has('fit')) then
   call conf%get_or_die('fit',section)
   call get(section,'horizontal filtering length-scale',nam%diag_rhflt)
   call get(section,'vertical filtering length-scale',nam%diag_rvflt)
   call get(section,'vertical stride',nam%fit_dl0)
   call get(section,'number of components',nam%fit_ncmp)
end if

! Local profiles section
if (conf%has('local profiles')) then
   call conf%get_or_die('local profiles',confs)

   ! Number of profiles
   nam%nldwv = size(confs)

   if (nam%nldwv>0) then
      ! Allocation
      allocate(nam%lon_ldwv(nam%nldwv))
      allocate(nam%lat_ldwv(nam%nldwv))
      allocate(nam%name_ldwv(nam%nldwv))

      ! Initialization
      nam%lon_ldwv = mpl%msv%valr
      nam%lat_ldwv = mpl%msv%valr
      nam%name_ldwv = ''

      do iconf=1,size(confs)
         call get(confs(iconf),'longitude',nam%lon_ldwv(iconf))
         call get(confs(iconf),'latitude',nam%lat_ldwv(iconf))
         call get(confs(iconf),'name',nam%name_ldwv(iconf))
      end do
   end if
end if

! NICAS section
if (conf%has('nicas')) then
   call conf%get_or_die('nicas',section)
   call get(section,'resolution',nam%resol)
   call get(section,'max horizontal grid size',nam%nc1max)
   call get(section,'grid type',nam%nicas_draw_type)
   call get(section,'explicit length-scales',nam%forced_radii)
   call nam%get_value_or_profile(mpl,section,'horizontal length-scale',nam%rh)
   call nam%get_value_or_profile(mpl,section,'vertical length-scale',nam%rv)
   if (section%has('common localization weights')) then
      call section%get_or_die('common localization weights',confs)

      ! Allocation
      allocate(loc_wgt(nam%nv,nam%nv))
      allocate(nam%loc_wgt_sqrt(nam%nv,nam%nv))
   
      ! Copy positive weights and set non-specified values to one
      loc_wgt = -one
      do iconf=1,size(confs)
         ! Get row and column variables, and the value
         call confs(iconf)%get_or_die('row variables',str_array_row)
         call confs(iconf)%get_or_die('column variables',str_array_col)
         call confs(iconf)%get_or_die('value',real_scalar)

         ! Loop over row and column values
         do ivv=1,size(str_array_row)
            do jvv=1,size(str_array_col)
               do iv=2,nam%nv
                  do jv=1,iv-1
                     if ((str_array_row(ivv)==nam%variables(iv)).and.(str_array_row(ivv)==nam%variables(iv))) then
                        loc_wgt(iv,jv) = real_scalar
                        loc_wgt(jv,iv) = real_scalar
                     end if
                  end do
               end do
            end do
         end do
      end do
   
      ! Set missing values to one
      do jv=1,nam%nv
         do iv=1,nam%nv
            if (eq(loc_wgt(iv,jv),-one)) loc_wgt = one
         end do
      end do
      
      ! Cholesky decomposition
      call cholesky(mpl,nam%nv,loc_wgt,nam%loc_wgt_sqrt)
   
      ! Release memory
      deallocate(loc_wgt)
   end if
   call nam%get_value(section,'minimum level',nam%min_lev)
   call nam%get_value(section,'maximum level',nam%max_lev)
   if (section%has('interpolation type')) then
      call section%get_or_die('interpolation type',confs)
      do iconf=1,size(confs)
         call confs(iconf)%get_or_die('variables',str_array)
         call confs(iconf)%get_or_die('type',str)
         do it=1,size(str_array)
            if (str_array(it)=='common') nam%nicas_interp_type(0) = str
            do iv=1,nam%nv
               if (str_array(it)==nam%variables(iv)) nam%nicas_interp_type(iv) = str
            end do
         end do
      end do
   end if
   call get(section,'positive-definiteness test',nam%pos_def_test)
   call get(section,'horizontal interpolation test',nam%interp_test)
end if

! Wind section
if (conf%has('wind')) then
   call conf%get_or_die('wind',section)
   if (section%has('wind_streamfunction')) then
      call section%get_or_die('wind_streamfunction',str)
      nam%wind_streamfunction = str
   end if
   if (section%has('wind_velocity_potential')) then
      call section%get_or_die('wind_velocity_potential',str)
      nam%wind_velocity_potential = str
   end if
   if (section%has('wind_zonal')) then
      call section%get_or_die('wind_zonal',str)
      nam%wind_zonal = str
   end if
   if (section%has('wind_meridional')) then
      call section%get_or_die('wind_meridional',str)
      nam%wind_meridional = str
   end if
   if (section%has('wind_nlon')) call section%get_or_die('wind_nlon',nam%wind_nlon)
   if (section%has('wind_nlat')) call section%get_or_die('wind_nlat',nam%wind_nlat)
   if (section%has('wind_nsg')) call section%get_or_die('wind_nsg',nam%wind_nsg)
   if (section%has('wind_inflation')) call section%get_or_die('wind_inflation',nam%wind_inflation)
end if

! Dirac section
if (conf%has('dirac')) then
   call conf%get_or_die('dirac',confs)
   nam%ndir = 0
   do iconf=1,size(confs)
      call confs(iconf)%get_or_die('variable',str)
      do iv=1,nam%nv
         if (str==nam%variables(iv)) then
            nam%ndir = nam%ndir+1
            nam%ivdir(nam%ndir) = iv
            call confs(iconf)%get_or_die('longitude',nam%londir(nam%ndir))
            call confs(iconf)%get_or_die('latitude',nam%latdir(nam%ndir))
            call confs(iconf)%get_or_die('level',nam%levdir(nam%ndir))
         end if
      end do
   end do
end if

! Helpers / internal parameters
nam%new_hdiag = nam%compute_cov1.or.nam%compute_cor1.or.nam%compute_loc1.or. &
 & nam%compute_cov2.or.nam%compute_cor2.or.nam%compute_loc2.or.nam%compute_hyb
if (conf%has('model')) then
   call conf%get_or_die('model',section)
   if (section%has('nl0')) call section%get_or_die('nl0',nam%nl0)
end if
if (conf%has('msvalr')) call conf%get_or_die('msvalr',mpl%msv%valr)

! Probe out
@:probe_out()

end subroutine nam_from_conf

!----------------------------------------------------------------------
! Subroutine: nam_check
!> Check namelist parameters
!----------------------------------------------------------------------
subroutine nam_check(nam,mpl)

implicit none

! Passed variable
class(nam_type),intent(inout) :: nam !< Namelist
type(mpl_type),intent(inout) :: mpl  !< MPI data

! Local variables
integer :: isub,iv,ivmin,ivmax,i,il0,idir,ildwv,jv,imask
character(len=2) :: ivchar,ildwvchar

! Set name
@:set_name(nam_check)

! Probe in
@:probe_in()

! Check maximum sizes
if (nam%nl0>nl0max) call mpl%abort('${subr}$','nl0 is too large')
if (nam%nv>nvmax) call mpl%abort('${subr}$','nv is too large')
if (nam%ens1_nsub>nsubmax) call mpl%abort('${subr}$','ens1_nsub is too large')
if (nam%ens2_nsub>nsubmax) call mpl%abort('${subr}$','ens2_nsub is too large')
if (nam%nc3>nc3max) call mpl%abort('${subr}$','nc3 is too large')
if (nam%nc4>nc4max) call mpl%abort('${subr}$','nc4 is too large')
if (nam%ndir>ndirmax) call mpl%abort('${subr}$','ndir is too large')

! Namelist parameters normalization (meters to radians and degrees to radians)
nam%universe_radius = nam%universe_radius/req
nam%dc = nam%dc/req
nam%var_rhflt = nam%var_rhflt/req
nam%local_rad = nam%local_rad/req
nam%local_dlat = nam%local_dlat*deg2rad
nam%diag_rhflt = nam%diag_rhflt/req
nam%rh = nam%rh/req
if (nam%ndir>0) nam%londir(1:nam%ndir) = nam%londir(1:nam%ndir)*deg2rad
if (nam%ndir>0) nam%latdir(1:nam%ndir) = nam%latdir(1:nam%ndir)*deg2rad
if (nam%nldwv>0) nam%lon_ldwv = nam%lon_ldwv*deg2rad
if (nam%nldwv>0) nam%lat_ldwv = nam%lat_ldwv*deg2rad

! Forced parameters for backward compatibility
if (nam%prefix/='') nam%prefix = trim(nam%prefix)//'_'

! General section
if (nam%repro_ops) then
  if (nam%repro_th<zero) call mpl%abort('${subr}$','repro_th should be non-negative')
end if

! Drivers section
if ((nam%new_hdiag.or.nam%check_optimality).and.nam%compute_hyb) then
   select case (nam%hybrid_source)
   case ('randomized static', 'lowres ensemble')
   case default
      call mpl%abort('${subr}$','wrong hybrid source')
   end select
end if
if (nam%new_hdiag.or.nam%new_nicas.or.nam%load_nicas_local.or.nam%load_nicas_global) then
   select case (nam%strategy)
   case ('diag_all','common','common_weighted','specific_univariate','specific_multivariate')
   case default
      call mpl%abort('${subr}$','wrong strategy')
   end select
end if
if (nam%load_samp_local.and.nam%load_samp_global) call mpl%abort('${subr}$','load_samp_local and load_samp_global are exclusive')
if (nam%load_samp_local.and.nam%write_samp_local) &
 & call mpl%abort('${subr}$','load_samp_local and write_samp_local are exclusive')
if (nam%load_samp_global.and.nam%write_samp_global) &
 & call mpl%abort('${subr}$','load_samp_global and write_samp_global are exclusive')
if (nam%write_samp_grids.and.(.not.(nam%new_vbal_cov.or.nam%new_vbal.or.nam%new_hdiag.or.nam%check_optimality))) &
 & call mpl%abort('${subr}$','new_vbal_cov, new_vbal or new_hdiag required for write_samp_grids')
if (nam%new_vbal_cov.and.nam%load_vbal_cov) call mpl%abort('${subr}$','new_vbal_cov and load_vbal_cov are exclusive')
if (nam%load_vbal_cov.and.(.not.nam%new_vbal)) call mpl%abort('${subr}$','new_vbal required for load_vbal_cov')
if (nam%load_vbal.and.(nam%new_vbal_cov.or.nam%load_vbal_cov)) call mpl%abort('${subr}$', &
 & 'load_vbal is inconsistent with new_vbal_cov, or load_vbal_cov')
if (nam%new_vbal.and.nam%load_vbal) call mpl%abort('${subr}$','new_vbal and load_vbal are exclusive')
if (nam%load_vbal_cov.and.(.not.(nam%load_samp_local.or.nam%load_samp_global))) &
 & call mpl%abort('${subr}$','load_vbal_cov requires load_samp_local/global')
if (nam%write_vbal_cov.and.(.not.(nam%load_samp_local.or.nam%load_samp_global)) &
 & .and.(.not.(nam%write_samp_local.or.nam%write_samp_global))) &
 & call mpl%abort('${subr}$','write_vbal_cov requires write_samp_local/global if load_samp_local/global is not activated')
if (nam%load_vbal.and.(.not.(nam%load_samp_local.or.nam%load_samp_global))) &
 & call mpl%abort('${subr}$','load_vbal requires load_samp_local/global')
 if (nam%write_vbal.and.(.not.(nam%load_samp_local.or.nam%load_samp_global)) &
 & .and.(.not.(nam%write_samp_local.or.nam%write_samp_global))) &
 & call mpl%abort('${subr}$','write_vbal requires write_samp_local/global if load_samp_local/global is not activated')
if (nam%new_mom.and.nam%load_mom) call mpl%abort('${subr}$','new_mom and load_mom are exclusive')
if (nam%load_mom.and.(.not.nam%load_samp_local)) call mpl%abort('${subr}$','load_mom requires load_samp_local')
if (nam%new_nicas.and.(nam%load_nicas_local.or.nam%load_nicas_global)) &
 & call mpl%abort('${subr}$','new_nicas and load_nicas_local/load_nicas_global are exclusive')
if (nam%check_vbal.and..not.(nam%new_vbal.or.nam%load_vbal)) &
 & call mpl%abort('${subr}$','new_vbal or load_vbal required for check_vbal')
if (nam%new_hdiag.and.(.not.(nam%new_mom.or.nam%load_mom))) &
 & call mpl%abort('${subr}$','new_mom or load_mom required for new_hdiag')
if (nam%write_hdiag_detail.and.(nam%fit_ncmp==1)) call mpl%abort('${subr}$', &
 & 'fit_ncmp should be larger than 1 for write_hdiag_detail')
if (nam%load_nicas_local.and.nam%write_nicas_global) &
 & call mpl%abort('${subr}$','load_nicas_local and write_nicas_global are exclusive')
if (nam%write_nicas_grids.and.(.not.(nam%new_nicas.or.nam%load_nicas_global))) &
 & call mpl%abort('${subr}$','new_nicas or load_nicas_global required for write_nicas_grids')
if (nam%check_dirac.and..not.(nam%new_vbal.or.nam%load_vbal.or.(nam%new_hdiag.and.nam%write_hdiag).or.nam%new_nicas &
 & .or.nam%load_nicas_local.or.nam%load_nicas_global)) call mpl%abort('${subr}$','check_dirac not available')
if (nam%check_randomization) then
   if (.not.nam%new_nicas) call mpl%abort('${subr}$','new_nicas required for check_randomization')
end if
if (nam%check_consistency) then
   if (.not.nam%compute_cor1) call mpl%abort('${subr}$','cor method required for check_consistency')
   if (nam%new_nicas) call mpl%abort('${subr}$','new_nicas forbidden for check_consistency')
end if
if (nam%check_optimality) then
   if (.not.nam%compute_loc1) call mpl%abort('${subr}$','loc method required for check_optimality')
   if (nam%new_nicas) call mpl%abort('${subr}$','new_nicas forbidden for check_optimality')
end if

! I/O section
if (nam%datadir=='') call mpl%abort('${subr}$','datadir not specified')
if (nam%nprocio<1) call mpl%abort('${subr}$','number of I/O tasks should be positive')
if (nam%nprocio>mpl%nproc) then
   call mpl%warning('${subr}$','number of I/O tasks should be smaller than the total number of tasks, resetting nprocio')
   nam%nprocio = mpl%nproc
end if
if (nam%fname_samp=='') nam%fname_samp = trim(nam%prefix)//'sampling'
nam%fname_vbal_cov_used = any(nam%fname_vbal_cov/='')
nam%fname_vbal_cov(0) = trim(nam%prefix)//'vbal_cov'
do isub=1,nsubmax
   if (nam%fname_vbal_cov(isub)=='') write(nam%fname_vbal_cov(isub),'(a,a,i6.6)') trim(nam%fname_vbal_cov(0)),'_',isub
end do
if (nam%fname_vbal=='') nam%fname_vbal = trim(nam%prefix)//'vbal'
nam%fname_mom_used = any(nam%fname_mom/='')
nam%fname_mom(0) = trim(nam%prefix)//'mom'
do isub=1,nsubmax
   if (nam%fname_mom(isub)=='') write(nam%fname_mom(isub),'(a,a,i6.6)') trim(nam%fname_mom(0)),'_',isub
end do
if (nam%fname_nicas=='') nam%fname_nicas = trim(nam%prefix)//'nicas'
if (nam%fname_wind=='') nam%fname_wind = trim(nam%prefix)//'wind'

! Model section
if (nam%nl0<=0) call mpl%abort('${subr}$','nl0 should be positive')
if ((nam%lev2d/='first').and.(nam%lev2d/='last')) call mpl%abort('${subr}$','wrong lev2d value')

! Ensemble sizes section
if ((nam%new_normality.or.nam%new_vbal_cov.or.(nam%new_vbal.and.(.not.nam%load_vbal_cov)) &
 & .or.(nam%new_var.and.(.not.nam%forced_var)).or.nam%new_mom &
 & .or.nam%check_randomization.or.nam%check_optimality).and.(nam%compute_cov1.or.nam%compute_cor1.or.nam%compute_loc1)) then
   if (nam%ens1_nsub<1) call mpl%abort('${subr}$','ens1_nsub should be positive')
   if (mod(nam%ens1_ne,nam%ens1_nsub)/=0) call mpl%abort('${subr}$','ens1_nsub should be a divider of ens1_ne')
   if (nam%ens1_ne/nam%ens1_nsub<=3) call mpl%abort('${subr}$','ens1_ne/ens1_nsub should be larger than 3')
end if
if (nam%new_mom.and.(nam%compute_cov2.or.nam%compute_cor2.or.nam%compute_loc2)) then
   if (nam%ens2_nsub<1) call mpl%abort('${subr}$','ens2_nsub should be non-negative')
   if (mod(nam%ens2_ne,nam%ens2_nsub)/=0) call mpl%abort('${subr}$','ens2_nsub should be a divider of ens2_ne')
   if (nam%ens2_ne/nam%ens2_nsub<=3) call mpl%abort('${subr}$','ens2_ne/ens2_nsub should be larger than 3')
end if
if (nam%compute_loc1.and.(nam%ne>nam%ens1_ne)) call mpl%warning('${subr}$', &
 & 'ensemble size larger than ens1_ne (might enhance sampling noise)')
if (nam%compute_loc2.and.(nam%ne_lr>nam%ens2_ne)) call mpl%warning('${subr}$', &
 & 'ensemble size larger than ens2_ne (might enhance sampling noise)')

! Sampling section
if (nam%new_vbal_cov.or.nam%new_vbal.or.nam%new_hdiag.or.nam%check_optimality) then
   if ((.not.(nam%load_samp_local.or.nam%load_samp_global)).and.(nam%nc1<3)) &
 & call mpl%abort('${subr}$','nc1 should be larger than 2')
   if (nam%new_vbal.or.(nam%new_hdiag.and.nam%local_diag)) then
      if ((.not.(nam%load_samp_local.or.nam%load_samp_global)).and.(nam%nc2<0)) &
 & call mpl%abort('${subr}$','nc2 should be non-negative')
   else
      if ((.not.(nam%load_samp_local.or.nam%load_samp_global)).and.(nam%nc2<0)) then
          call mpl%warning('${subr}$','nc2 should be set non-negative, resetting nc2 to zero')
          nam%nc2 = 0
      end if
   end if
end if
select case (nam%samp_draw_type)
case ('random')
case ('octahedral')
   if (nam%nldwv>0) call mpl%abort('${subr}$','no local diagnostics with an octahedral draw')
case default
   call mpl%abort('${subr}$','wrong samp_draw_type')
end select
if (nam%new_hdiag.or.nam%check_optimality) then
   if (nam%nc3<=0) call mpl%abort('${subr}$','nc3 should be positive')
   if (nam%nc4<=0) call mpl%abort('${subr}$','nc4 should be positive')
   if ((nam%nc4>1).and.(mod(nam%nc4,2)==1)) call mpl%abort('${subr}$','nc4 should be even')
   if (.not.(nam%dc>zero)) call mpl%abort('${subr}$','dc should be positive')
   if (nam%nl0r<1) call mpl%abort ('${subr}$','nl0r should be positive')
end if
if (nam%local_diag) then
   if (.not.((nam%local_rad>zero).or.(nam%local_dlat>zero))) call mpl%abort('${subr}$', &
 & 'local_rad or local_dlat should be positive')
   if ((nam%local_rad>zero).and.(nam%local_dlat>zero)) call mpl%abort('${subr}$', &
 & 'local_rad and local_dlat cannot be positive at the same time')
end if
if (.not.(nam%load_samp_local.or.nam%load_samp_global)) then
   if (nam%irmax<1) call mpl%abort ('${subr}$','irmax should be positive')
end if
select case (nam%samp_interp_type)
case ('c0','c1','si')
case default
   call mpl%abort('${subr}$','wrong sampling interpolation type')
end select
do imask=1,nam%nmask
   select case (nam%mask_type(imask))
   case ('none')
   case ('ldwv')
      if (nam%nldwv<=0) call mpl%abort('${subr}$','nldwv should not be negative for mask_type = ldwv')
   case ('stddev','input')
      if (mpl%msv%is(nam%mask_th(imask))) call mpl%abort('${subr}$','missing mask threshold')
      select case (nam%mask_lu(imask))
      case ('lower','upper')
      case default
         call mpl%abort('${subr}$','wrong mask_lu')
      end select
      if (nam%mask_variable(imask)=='') call mpl%abort('${subr}$','missing mask variable')
    end select
end do

! Localization section
if (nam%new_hdiag.or.nam%check_optimality) then
   if (nam%compute_loc1.and.(nam%ne<=3)) call mpl%abort('${subr}$','ne should be larger than 3')
   if (nam%compute_loc2.and.(nam%ne_lr<=3)) call mpl%abort('${subr}$','ne_lr should be larger than 3')
   if (.not.(nam%gen_kurt_th>zero)) call mpl%abort('${subr}$','gen_kurt_th should be positive')
end if

! Vertical balance section
if (nam%new_vbal) then
   if (.not.((nam%local_rad>zero).or.(nam%local_dlat>zero))) call mpl%abort('${subr}$', &
 & 'local_rad or local_dlat should be positive')
   if ((nam%local_rad>zero).and.(nam%local_dlat>zero)) call mpl%abort('${subr}$', &
 & 'local_rad and local_dlat cannot be positive at the same time')
   if (nam%vbal_pseudo_inv) then
      if ((nam%vbal_pseudo_inv_mmax<=0).and.(.not.nam%vbal_pseudo_inv_var_th>zero)) call mpl%abort('${subr}$', &
 & 'dominant mode or variance threshold should be positive for pseudo-inverse')
   end if
end if

! Variance section
if (nam%new_var) then
   if (nam%forced_var) then
      do iv=1,nam%nv
         do il0=1,nam%nl0
            if (.not.(nam%stddev(il0,iv)>zero)) call mpl%abort('${subr}$','stddev should be positive')
         end do
      end do
      if (nam%var_filter) call mpl%abort('${subr}$','var_filter forbidden for forced_var')
   end if
   if (nam%var_filter) then
      if ((nam%var_niter>0).and.(nam%var_npass>0)) call mpl%abort('${subr}$','var_niter or var_npass only should be non-negative')
      if ((nam%var_niter>0).and.(nam%var_npass>0)) &
 & call mpl%abort('${subr}$','var_niter or var_npass should not be positive at te same time')
      if ((nam%var_niter>0).or.(nam%var_npass>0)) then
         do iv=1,nam%nv
            do il0=1,nam%nl0
               if (.not.(nam%var_rhflt(il0,iv)>zero)) call mpl%abort('${subr}$','var_rhflt should be positive')
            end do
         end do
      end if
   end if
end if

! Optimality test section
if (nam%check_optimality) then
   if (nam%optimality_nfac<1) call mpl%abort('${subr}$','optimality_nfac should be positive')
   if (.not.(nam%optimality_delta>zero)) call mpl%abort('${subr}$','optimality_delta should be positive')
   if (nam%optimality_ntest<1) call mpl%abort('${subr}$','optimality_ntest should be positive')
end if

! Fit section
if (nam%new_hdiag.or.nam%check_optimality) then
   if (nam%diag_rhflt<zero) call mpl%abort('${subr}$','diag_rhflt should be non-negative')
   if (nam%diag_rvflt<zero) call mpl%abort('${subr}$','diag_rvflt should be non-negative')
   if (nam%fit_dl0<=0) call mpl%abort('${subr}$','fit_dl0 should be postive')
   if (nam%fit_ncmp<=0) call mpl%abort('${subr}$','fit_ncmp should be postive')
end if

! Local profiles section
if (nam%new_hdiag) then
   if (nam%nldwv<0) call mpl%abort('${subr}$','nldwv should be non-negative')
   if (nam%nldwv>0) then
      if (.not.nam%local_diag) call mpl%abort('${subr}$','local_diag required for nldwv>0')
      if (any(nam%lon_ldwv(1:nam%nldwv)<-pi).or.any(nam%lon_ldwv(1:nam%nldwv)>pi)) &
 & call mpl%abort('${subr}$','lon_ldwv should lie between -180 and 180')
      if (any(nam%lat_ldwv(1:nam%nldwv)<-half*pi).or.any(nam%lat_ldwv(1:nam%nldwv)>half*pi)) &
 & call mpl%abort('${subr}$','lat_ldwv should lie between -90 and 90')
      do ildwv=1,nam%nldwv
         write(ildwvchar,'(i2.2)') ildwv
         if (nam%name_ldwv(ildwv)=='') call mpl%abort('${subr}$','name_ldwv not specified for profile '//ildwvchar)
      end do
   end if
end if

! NICAS section
if (nam%new_nicas.or.nam%load_nicas_local.or.nam%load_nicas_global) then
   if ((nam%strategy=='common').or.(nam%strategy=='common_weighted')) then
      ivmin = 0
      ivmax = 0
   else
      ivmin = 1
      ivmax = nam%nv
   end if
   if (nam%check_randomization) then
      if (.not.nam%forced_radii) call mpl%abort('${subr}$','forced_radii required for check_randomization')
   end if
   if (nam%check_consistency) then
      if (.not.nam%forced_radii) call mpl%abort('${subr}$','forced_radii required for check_consistency')
   end if
   if (nam%check_optimality) then
      if (.not.nam%forced_radii) call mpl%abort('${subr}$','forced_radii required for check_optimality')
   end if
   if (nam%new_nicas) then
      if (.not.(nam%resol>zero)) call mpl%abort('${subr}$','resol should be positive')
      if (nam%nc1max<=0) call mpl%abort('${subr}$','nc1max should be positive')
   end if
   if (nam%forced_radii) then
      do iv=ivmin,ivmax
         do il0=1,nam%nl0
            if (nam%rh(il0,iv)<zero) call mpl%abort('${subr}$','rh should be non-negative')
            if (nam%rv(il0,iv)<zero) call mpl%abort('${subr}$','rv should be non-negative')
         end do
      end do
   end if
   if (nam%strategy=='common_weighted') then
      if (.not.allocated(nam%loc_wgt_sqrt)) call mpl%abort('${subr}$','loc_wgt should be specified for common_weighted')
   end if
   select case (nam%nicas_draw_type)
   case ('random')
   case ('octahedral')
      if (nam%nldwv>0) call mpl%abort('${subr}$','no local diagnostics with an octahedral draw')
   case default
      call mpl%abort('${subr}$','wrong nicas_draw_type')
   end select
   do iv=ivmin,ivmax
      select case (nam%nicas_interp_type(iv))
      case ('c0','c1','si')
      case default
         call mpl%abort('${subr}$','wrong nicas_interp_type')
      end select
   end do
end if

! Dirac section
if (nam%check_dirac) then
   do idir=1,nam%ndir
      if ((nam%londir(idir)<-pi).or.(nam%londir(idir)>pi)) call mpl%abort('${subr}$','londir should lie between -180 and 180')
      if ((nam%latdir(idir)<-half*pi).or.(nam%latdir(idir)>half*pi)) call mpl%abort('${subr}$','latdir should lie between -90 and 90')
      if ((nam%ivdir(idir)<1).or.(nam%ivdir(idir)>nam%nv)) call mpl%abort('${subr}$','wrong variable for a Dirac')
   end do
end if

! Wind section
if (nam%new_wind) then
   if (nam%wind_nlon<3) call mpl%abort('${subr}$','wind_nlon should be larger than 3')
   if (nam%wind_nlat<3) call mpl%abort('${subr}$','wind_nlat should be larger than 3')
   if (nam%wind_nsg<1) call mpl%abort('${subr}$','wind_nsg should be positive')
   if (nam%wind_inflation<one) call mpl%abort('${subr}$','wind_inflation should be larger than 1')
end if

! Probe out
@:probe_out()

end subroutine nam_check

!----------------------------------------------------------------------
! Subroutine: nam_alias
!> Get alias value from key
!----------------------------------------------------------------------
subroutine nam_alias(nam,key,val)

implicit none

! Passed variable
class(nam_type),intent(in) :: nam      !< Namelist
character(len=*),intent(in) :: key     !< Alias key
character(len=1024),intent(out) :: val !< Alias value

! Local variables
integer :: i

! Set name
@:set_name(nam_alias)

! Probe in
@:probe_in()

! Loop over I/O key-value couples
val = key
do i=1,niokvmax
   if (nam%alias_code(i)==key) then
      val = nam%alias_file(i)
      exit
   end if
end do

! Probe out
@:probe_out()

end subroutine nam_alias

#:for dtype in dtypes_irls
!----------------------------------------------------------------------
! Subroutine: nam_get_${dtype}$
!> Get value
!----------------------------------------------------------------------
subroutine nam_get_${dtype}$(section,key,val)

implicit none

! Passed variable
type(fckit_configuration),intent(in) :: section !< Configuration section
character(len=*),intent(in) :: key              !< Key
${ftype[dtype]}$,intent(inout) :: val           !< Value (already initialized)

! Local variables
character(len=:),allocatable :: str

! Set name
@:set_name(nam_get_${dtype}$)

! Probe in
@:probe_in()

if (section%has(key)) then
   #:if dtype == "string"
      call section%get_or_die(key, str)
      val = str
   #:else
      call section%get_or_die(key, val)
   #:endif
end if

! Probe out
@:probe_out()

end subroutine nam_get_${dtype}$
#:endfor

#:for dtype in dtypes_ir
!----------------------------------------------------------------------
! Subroutine: nam_get_value_${dtype}$
!> Get value for all variables
!----------------------------------------------------------------------
subroutine nam_get_value_${dtype}$(nam,section,key,val)

implicit none

! Passed variable
class(nam_type),intent(inout) :: nam            !< Namelist
type(fckit_configuration),intent(in) :: section !< Configuration section
character(len=*),intent(in) :: key              !< Key
${ftype[dtype]}$,intent(out) :: val(0:nvmax)    !< Values

! Local variables
integer :: iconf,iv,it
${ftype[dtype]}$ :: scalar
character(len=:),allocatable :: str_array(:)
type(fckit_configuration),allocatable :: confs(:)

! Set name
@:set_name(nam_get_value_${dtype}$)

! Probe in
@:probe_in()

if (section%has(key)) then
   ! Get subconfigurations vector
   call section%get_or_die(key,confs)

   ! Loop over subconfigurations
   do iconf=1,size(confs)
      call confs(iconf)%get_or_die('variables',str_array)
      call confs(iconf)%get_or_die('value',scalar)
      do it=1,size(str_array)
         if (str_array(it)=='common') val(0) = scalar
         do iv=1,nam%nv
            if (str_array(it)==nam%variables(iv)) val(iv) = scalar
         end do
      end do
   end do
end if

! Probe out
@:probe_out()

end subroutine nam_get_value_${dtype}$
#:endfor

#:for dtype in dtypes_ir
!----------------------------------------------------------------------
! Subroutine: nam_get_value_or_profile_${dtype}$
!> Get value or profile for all variables
!----------------------------------------------------------------------
subroutine nam_get_value_or_profile_${dtype}$(nam,mpl,section,key,val)

implicit none

! Passed variable
class(nam_type),intent(inout) :: nam                !< Namelist
type(mpl_type),intent(inout) :: mpl                 !< MPI data
type(fckit_configuration),intent(in) :: section     !< Configuration section
character(len=*),intent(in) :: key                  !< Key
${ftype[dtype]}$,intent(out) :: val(nl0max,0:nvmax) !< Values

! Local variables
integer :: iconf,iv,it
${ftype[dtype]}$ :: scalar
${ftype[dtype]}$,allocatable :: array(:)
character(len=:),allocatable :: str_array(:)
character(len=1024) :: message
type(fckit_configuration),allocatable :: confs(:)

! Set name
@:set_name(nam_get_value_or_profile_${dtype}$)

! Probe in
@:probe_in()

if (section%has(key)) then
   ! Get subconfigurations vector
   call section%get_or_die(key,confs)

   ! Loop over subconfigurations
   do iconf=1,size(confs)
      call confs(iconf)%get_or_die('variables',str_array)
      if (confs(iconf)%has('value')) then
         call confs(iconf)%get_or_die('value',scalar)
         do it=1,size(str_array)
            if (str_array(it)=='common') val(:,0) = scalar
            do iv=1,nam%nv
               if (str_array(it)==nam%variables(iv)) val(:,iv) = scalar
            end do
         end do
      elseif (confs(iconf)%has('profile')) then
         call confs(iconf)%get_or_die('profile',array)
         if (size(array)>nl0max) then
            write(message,'(a,a,i4)') key,' profile size should be smaller than ',nl0max
            call mpl%abort('${subr}$',message)
         end if
         do it=1,size(str_array)
            if (str_array(it)=='common') val(1:size(array),0) = array
            do iv=1,nam%nv
               if (str_array(it)==nam%variables(iv)) val(1:size(array),iv) = array
            end do
         end do
      else
         call mpl%abort('${subr}$','missing value/profile in '//key)
      end if
   end do
end if

! Probe out
@:probe_out()

end subroutine nam_get_value_or_profile_${dtype}$
#:endfor

end module type_nam
