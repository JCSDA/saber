#:include '../generics.fypp'
#:include '../instrumentation.fypp'
!----------------------------------------------------------------------
! Module: type_nam
!> Namelist derived type
! Author: Benjamin Menetrier
! Licensing: this code is distributed under the CeCILL-C license
! Copyright 2015-... UCAR, CERFACS, METEO-FRANCE and IRIT
!----------------------------------------------------------------------
module type_nam

use fckit_configuration_module, only: fckit_configuration
use tools_const, only: zero,hundredth,half,one,ten,hundred,pi,req,deg2rad,rad2deg
use tools_kinds, only: kind_real,kind_int,huge_real
use tools_func, only: cholesky
use tools_repro, only: eq
use type_mpl, only: mpl_type
@:use_probe()

implicit none

integer,parameter :: nprociomax = 20 !< Maximum number of I/O tasks

type nam_type
   logical :: default_seed                                    !< Default seed for random numbers
   logical :: repro_ops                                       !< Reproducibility operators
   real(kind_real) :: repro_th                                !< Reproducibility threshold
   real(kind_real) :: universe_radius                         !< Universe radius [in meters]

   ! I/O section
   character(len=1024) :: datadir                             !< Data directory
   character(len=1024) :: prefix                              !< Files prefix
   logical :: parallel_netcdf                                 !< Parallel NetCDF I/O
   integer :: nprocio                                         !< Number of I/O tasks
   character(len=1024),allocatable :: alias_code(:)           !< Alias keys in code
   character(len=1024),allocatable :: alias_file(:)           !< Alias values in file
   character(len=1024) :: fname_samp                          !< Sampling file
   character(len=1024) :: fname_vbal_cov_default              !< Vertical covariance files default base
   character(len=1024),allocatable :: fname_vbal_cov(:)       !< Vertical covariance files
   character(len=1024) :: fname_vbal                          !< Vertical balance file
   character(len=1024) :: fname_mom_default                   !< Moments files default base
   character(len=1024),allocatable :: fname_mom1(:)           !< Moments files, ensemble 1
   character(len=1024),allocatable :: fname_mom2(:)           !< Moments files, ensemble 2
   character(len=1024) :: fname_nicas                         !< NICAS file
   character(len=1024) :: fname_wind                          !< Wind transform file

   ! Drivers section
   logical :: compute_cov1                                    !< Compute covariance, ensemble 1
   logical :: compute_cov2                                    !< Compute covariance, ensemble 2
   logical :: compute_cor1                                    !< Compute correlation, ensemble 1
   logical :: compute_cor2                                    !< Compute correlation, ensemble 2
   logical :: compute_loc1                                    !< Compute localization, ensemble 1
   logical :: compute_loc2                                    !< Compute localization, ensemble 2
   logical :: compute_hyb                                     !< Compute hybrid weights
   logical :: new_hdiag                                       !< Compute diagnostics
   character(len=1024) :: hybrid_source                       !< Hybrid term source ('randomized static' or 'lowres ensemble')
   character(len=1024) :: strategy                            !< Multivariate strategy ('diag_all', 'common', 'common_weighted', 'specific_univariate' or 'specific_multivariate')
   logical :: iterative_algo                                  !< Iterative algorithm (ensemble members loaded sequentially)
   logical :: new_normality                                   !< New normality test
   logical :: load_samp_local                                 !< Read local sampling
   logical :: load_samp_global                                !< Read global sampling
   logical :: write_samp_local                                !< Write local sampling
   logical :: write_samp_global                               !< Write global sampling
   logical :: write_samp_grids                                !< Write sampling grids
   logical :: new_vbal_cov                                    !< New vertical covariance
   logical :: load_vbal_cov                                   !< Read local vertical covariance
   logical :: write_vbal_cov                                  !< Write local vertical covariancee
   logical :: new_vbal                                        !< Compute vertical balance operator
   logical :: load_vbal                                       !< Read local vertical balance operator
   logical :: write_vbal                                      !< Write vertical balance operator
   logical :: new_var                                         !< Compute variance
   logical :: new_mom                                         !< Compute moments
   logical :: load_mom                                        !< Read sampling moments
   logical :: write_mom                                       !< Write sampling moments
   logical :: write_hdiag                                     !< Write diagnostics
   logical :: write_hdiag_detail                              !< Write components detail
   logical :: new_nicas                                       !< Compute NICAS parameters
   logical :: load_nicas_local                                !< Read local NICAS parameters
   logical :: load_nicas_global                               !< Read global NICAS parameters
   logical :: write_nicas_local                               !< Write local NICAS parameters
   logical :: write_nicas_global                              !< Write global NICAS parameters
   logical :: write_nicas_grids                               !< Write NICAS grids
   logical :: new_wind                                        !< Compute wind transform
   logical :: load_wind_local                                 !< Read local wind transform
   logical :: write_wind_local                                !< Write local wind transform
   logical :: check_vbal                                      !< Test vertical balance inverse
   logical :: check_adjoints                                  !< Test adjoints
   integer :: check_normalization                             !< Test NICAS normalization (number of tests)
   logical :: check_dirac                                     !< Test NICAS application on diracs
   logical :: check_randomization                             !< Test NICAS randomization
   logical :: check_consistency                               !< Test HDIAG-NICAS consistency
   logical :: check_optimality                                !< Test HDIAG optimality

   ! Model section
   integer :: nl0                                             !< Number of levels
   character(len=1024) :: lev2d                               !< Level for 2D variables ('first' or 'last')
   integer :: nv                                              !< Number of variables
   character(len=1024),allocatable :: variables(:)            !< Variables names
   logical :: mask_check                                      !< Check that sampling couples and interpolations do not cross mask boundaries

   ! Ensemble sizes
   integer :: ens1_ne                                         !< Ensemble 1 size
   integer :: ens1_nsub                                       !< Ensemble 1 sub-ensembles number
   integer :: ens2_ne                                         !< Ensemble 2 size
   integer :: ens2_nsub                                       !< Ensemble 2 sub-ensembles number

   ! Sampling section
   integer :: nc1                                             !< Computation grid size
   integer :: nc2                                             !< Diagnostic grid size
   integer :: nc3                                             !< Number of distance classes
   integer :: nc4                                             !< Number of angular sectors
   real(kind_real) :: dc                                      !< Class size, should be larger than the typical grid cell size [in meters]
   integer :: nl0r                                            !< Reduced number of levels for diagnostics
   logical :: local_diag                                      !< Activate local diagnostics
   real(kind_real) :: local_rad                               !< Local diagnostics calculation radius [in meters]
   real(kind_real) :: local_dlat                              !< Local diagnostics calculation latitude band half-width [in degrees]
   character(len=1024) :: samp_draw_type                      !< Diagnostic draw type ('random' or 'octahedral')
   integer :: irmax                                           !< Maximum number of random number draws
   character(len=2) :: samp_interp_type                       !< Sampling C2B to C0A interpolation type ('c0': C0 mesh-based, 'c1': C1 mesh-based or 'si': smooth interpolation)
   integer :: nmask                                           !< Number of masks
   character(len=1024),allocatable :: mask_type(:)            !< Mask restriction type
   real(kind_real),allocatable :: mask_th(:)                  !< Mask threshold
   character(len=1024),allocatable :: mask_lu(:)              !< Mask threshold side ('lower' if mask_th is the lower bound, resp. 'upper')
   character(len=1024),allocatable :: mask_variable(:)        !< Mask variable
   integer :: ncontig_th                                      !< Threshold on vertically contiguous points for sampling mask (0 to skip the test)

   ! Localization section
   integer :: ne                                              !< Ensemble size
   integer :: ne_lr                                           !< Ensemble size of the low-resolution term (ensemble 2)
   logical :: gau_approx                                      !< Gaussian approximation for asymptotic quantities
   real(kind_real) :: gen_kurt_th                             !< Threshold on generalized kurtosis (3.0 = Gaussian distribution)
   integer :: avg_nbins                                       !< Number of bins for averaged statistics histograms

   ! Vertical balance section
   logical,allocatable :: vbal_block(:,:)                     !< Activation of vertical balance
   logical,allocatable :: vbal_diag_auto(:,:)                 !< Diagonal auto-covariance for the inversion
   logical,allocatable :: vbal_diag_reg(:,:)                  !< Diagonal regression
   real(kind_real),allocatable :: vbal_id_coef(:,:)           !< Scalar coefficients for identity vertical balance
   logical :: vbal_pseudo_inv                                 !< Pseudo-inverse for auto-covariance
   integer :: vbal_pseudo_inv_mmax                            !< Dominant mode for pseudo-inverse
   real(kind_real) :: vbal_pseudo_inv_var_th                  !< Variance threshold to compute the dominant mode for pseudo-inverse
   logical :: vbal_id                                         !< Identity vertical balance for tests

   ! Variance section
   logical :: forced_var                                      !< Force specific variance
   real(kind_real),allocatable :: stddev(:,:)                 !< Forced standard-deviation
   logical :: var_filter                                      !< Filter variance
   integer :: var_niter                                       !< Number of iterations for the variance filtering (0 for uniform variance)
   integer :: var_npass                                       !< Number of passes for the variance filtering (0 for uniform variance)
   real(kind_real),allocatable :: var_rhflt(:,:)              !< Variance initial filtering support radius [in meters]

   ! Optimality test section
   integer :: optimality_nfac                                 !< Number of length-scale factors for optimization
   real(kind_real) :: optimality_delta                        !< Increments of length-scale factors for optimization
   integer :: optimality_ntest                                !< Number of test vectors for optimization

   ! Fit section
   real(kind_real) :: diag_rhflt                              !< Horizontal filtering suport radius [in meters]
   real(kind_real) :: diag_rvflt                              !< Vertical filtering support radius
   integer :: fit_dl0                                         !< Number of levels between interpolation levels
   integer :: fit_ncmp                                        !< Number of components in the fit function

   ! Local profiles section
   integer :: nldwv                                           !< Number of local diagnostics profiles to write (for local_diag = .true.)
   real(kind_real),allocatable :: lon_ldwv(:)                 !< Longitudes of the local diagnostics profiles to write [in degrees]
   real(kind_real),allocatable :: lat_ldwv(:)                 !< Latitudes of the local diagnostics profiles to write [in degrees]
   character(len=1024),allocatable :: name_ldwv(:)            !< Name of the local diagnostics profiles to write

   ! NICAS section
   real(kind_real) :: resol                                   !< Resolution
   integer :: nc1max                                          !< Maximum size of the Sc1 subset
   character(len=1024) :: nicas_draw_type                     !< NICAS draw type ('random' or 'octahedral')
   logical :: forced_radii                                    !< Force specific support radii
   real(kind_real),allocatable :: rh(:,:)                     !< Forced horizontal support radius [in meters]
   real(kind_real),allocatable :: rv(:,:)                     !< Forced vertical support radius
   integer,allocatable :: min_lev(:)                          !< Minimum level
   integer,allocatable :: max_lev(:)                          !< Maximum level
   real(kind_real),allocatable :: loc_wgt_sqrt(:,:)           !< Weights square-root for the 'common_weighted' strategy
   character(len=2),allocatable :: nicas_interp_type(:)       !< NICAS C1B to C0A interpolation type ('c0': C0 mesh-based, 'c1': C1 mesh-based or 'si': smooth interpolation)
   logical :: pos_def_test                                    !< Positive-definiteness test
   logical :: interp_test                                     !< Horizontal NICAS interpolation test

   ! Wind section
   character(len=1024) :: wind_streamfunction                 !< Streamfunction variable name
   character(len=1024) :: wind_velocity_potential             !< Velocity potential variable name
   character(len=1024) :: wind_eastward                       !< Eastward wind variable name
   character(len=1024) :: wind_northward                      !< Northward wind variable name
   integer :: wind_nlon                                       !< Number of longitudes for the regular grid
   integer :: wind_nlat                                       !< Number of latitudes for the regular grid
   integer :: wind_nsg                                        !< Half-width of the Savitzky-Golay to compute derivatives
   real(kind_real) :: wind_inflation                          !< Wind inflation to compensate the Savitzky-Golay smoothing

   ! Dirac section
   integer :: ndir                                            !< Number of Diracs
   real(kind_real),allocatable :: londir(:)                   !< Diracs longitudes [in degrees]
   real(kind_real),allocatable :: latdir(:)                   !< Diracs latitudes [in degrees]
   integer,allocatable :: levdir(:)                           !< Diracs level
   integer,allocatable :: ivdir(:)                            !< Diracs variable indices
contains
   procedure :: from_conf => nam_from_conf
   procedure :: check => nam_check
   procedure :: alias => nam_alias
   #:for dtype in dtypes_ir
      procedure :: nam_get_value_${dtype}$
   #:endfor
@:init_procedure(2)
   generic :: get_value => &
   #:for dtype in dtypes_ir
@:add_procedure(nam_get_value_${dtype}$)
   #:endfor
   #:for dtype in dtypes_ir
      procedure :: nam_get_value_or_profile_${dtype}$
   #:endfor
@:init_procedure(2)
   generic :: get_value_or_profile => &
   #:for dtype in dtypes_ir
@:add_procedure(nam_get_value_or_profile_${dtype}$)
   #:endfor
end type nam_type

interface print_section
   module procedure nam_print_section
end interface

interface get
   #:for dtype in dtypes_irls
      module procedure nam_get_${dtype}$
   #:endfor
end interface

private
public :: nam_type

contains

!----------------------------------------------------------------------
! Subroutine: nam_from_conf
!> Intialize from configuration
!----------------------------------------------------------------------
subroutine nam_from_conf(nam,mpl,conf)

implicit none

! Passed variable
class(nam_type),intent(inout) :: nam         !< Namelist
type(mpl_type),intent(inout) :: mpl          !< MPI data
type(fckit_configuration),intent(in) :: conf !< Configuration

! Local variables
integer :: iv,jv,iconf,rank,itest,it,ivv,jvv
integer,allocatable :: integer_array(:),vbal_order(:)
real(kind_real) :: real_scalar
real(kind_real),allocatable :: real_array(:),loc_wgt(:,:)
logical :: color_log,found,valid
logical,allocatable :: logical_array(:)
character(len=1024) :: message,param,blockname
character(len=:),allocatable :: str,str_bal,str_unbal
character(len=:),allocatable :: str_array(:),str_array_row(:),str_array_col(:)

type(fckit_configuration) :: section
type(fckit_configuration),allocatable :: confs(:)

! Set name
@:set_name(nam_from_conf)

! Probe in
@:probe_in()

! Missing value
if (conf%has('msvalr')) call get(conf,'msvalr',-999.0_kind_real,mpl%msv%valr)
write(mpl%info,'(a)') '-------------------------------------------------------------------'
call mpl%flush
write(mpl%info,'(a)') '--- Missing values'
call mpl%flush
write(mpl%info,'(a4,a,e15.8)') '','Real:    ',mpl%msv%valr 
call mpl%flush
write(mpl%info,'(a4,a,i6)') '','Integer: ',mpl%msv%vali
call mpl%flush

! Configuration parameters
write(mpl%info,'(a)') '-------------------------------------------------------------------'
call mpl%flush
write(mpl%info,'(a)') '--- Configuration parameters'
call mpl%flush

! General section
if (conf%has('general')) then
   call conf%get_or_die('general',section)
   call print_section(mpl,section,'General')
else
   section = fckit_configuration()
end if
if (section%has('color log')) then
   call section%get_or_die('color log',color_log)
   if (color_log) then
      mpl%black = char(27)//'[0;0m'
      mpl%green = char(27)//'[0;32m'
      mpl%peach = char(27)//'[1;91m'
      mpl%aqua = char(27)//'[1;36m'
      mpl%purple = char(27)//'[1;35m'
      mpl%wng_color = char(27)//'[0;37;42;1m'
   end if
end if
call get(section,'testing',.false.,mpl%testing)
call get(section,'default seed',.true.,nam%default_seed)
call get(section,'reproducibility operators',.true.,nam%repro_ops)
call get(section,'reproducibility threshold',1.0e-12_kind_real,nam%repro_th)
call get(section,'universe length-scale',pi*req,nam%universe_radius)

! I/O param
if (conf%has('io')) then
   call conf%get_or_die('io',section)
   call print_section(mpl,section,'I/O')
else
   section = fckit_configuration()
end if
call get(section,'data directory','.',nam%datadir)
call get(section,'files prefix','',nam%prefix)
call get(section,'parallel netcdf',.true.,nam%parallel_netcdf)
call get(section,'io task number',min(mpl%nproc,nprociomax),nam%nprocio)
if (section%has('alias')) then
   call section%get_or_die('alias',confs)
   allocate(nam%alias_code(size(confs)))
   allocate(nam%alias_file(size(confs)))
   do iconf=1,size(confs)
      call confs(iconf)%get_or_die('in code',str)
      nam%alias_code(iconf) = str
      call confs(iconf)%get_or_die('in file',str)
      nam%alias_file(iconf) = str
   end do
end if
call get(section,'overriding sampling file','',nam%fname_samp)
nam%fname_vbal_cov_default = ''
if (section%has('overriding vertical covariance file')) then
   call section%get_or_die('overriding vertical covariance file',str_array)
   allocate(nam%fname_vbal_cov(size(str_array)))
   nam%fname_vbal_cov = str_array
end if
call get(section,'overriding vertical balance file','',nam%fname_vbal)
nam%fname_mom_default = ''
if (section%has('overriding moments file')) then
   call section%get_or_die('overriding moments file',str_array)
   allocate(nam%fname_mom1(size(str_array)))
   nam%fname_mom1 = str_array
end if
if (section%has('overriding lowres moments file')) then
   call section%get_or_die('overriding lowres moments file',str_array)
   allocate(nam%fname_mom2(size(str_array)))
   nam%fname_mom2 = str_array
end if
call get(section,'overriding nicas file','',nam%fname_nicas)
call get(section,'overriding psichitouv file','',nam%fname_wind)


! Drivers section
if (conf%has('drivers')) then
   call conf%get_or_die('drivers',section)
   call print_section(mpl,section,'Drivers')
else
   section = fckit_configuration()
end if
call get(section,'compute covariance',.false.,nam%compute_cov1)
call get(section,'compute lowres covariance',.false.,nam%compute_cov2)
call get(section,'compute correlation',.false.,nam%compute_cor1)
call get(section,'compute lowres correlation',.false.,nam%compute_cor2)
call get(section,'compute localization',.false.,nam%compute_loc1)
call get(section,'compute lowres localization',.false.,nam%compute_loc2)
call get(section,'compute hybrid weights',.false.,nam%compute_hyb)
nam%new_hdiag = nam%compute_cov1.or.nam%compute_cor1.or.nam%compute_loc1.or. &
 & nam%compute_cov2.or.nam%compute_cor2.or.nam%compute_loc2.or.nam%compute_hyb
call get(section,'hybrid source','',nam%hybrid_source)
call get(section,'multivariate strategy','',nam%strategy)
call get(section,'iterative algorithm',.false.,nam%iterative_algo)
call get(section,'compute normality',.false.,nam%new_normality)
call get(section,'read local sampling',.false.,nam%load_samp_local)
call get(section,'read global sampling',.false.,nam%load_samp_global)
call get(section,'write local sampling',.false.,nam%write_samp_local)
call get(section,'write global sampling',.false.,nam%write_samp_global)
call get(section,'write sampling grids',.false.,nam%write_samp_grids)
call get(section,'compute vertical covariance',.false.,nam%new_vbal_cov)
call get(section,'read vertical covariance',.false.,nam%load_vbal_cov)
call get(section,'write vertical covariance',.false.,nam%write_vbal_cov)
call get(section,'compute vertical balance',.false.,nam%new_vbal)
call get(section,'read vertical balance',.false.,nam%load_vbal)
call get(section,'write vertical balance',.false.,nam%write_vbal)
call get(section,'compute variance',.false.,nam%new_var)
call get(section,'compute moments',.false.,nam%new_mom)
call get(section,'read moments',.false.,nam%load_mom)
call get(section,'write moments',.false.,nam%write_mom)
call get(section,'write diagnostics',.false.,nam%write_hdiag)
call get(section,'write diagnostics detail',.false.,nam%write_hdiag_detail)
call get(section,'compute nicas',.false.,nam%new_nicas)
call get(section,'read local nicas',.false.,nam%load_nicas_local)
call get(section,'read global nicas',.false.,nam%load_nicas_global)
call get(section,'write local nicas',.false.,nam%write_nicas_local)
call get(section,'write global nicas',.false.,nam%write_nicas_global)
call get(section,'write nicas grids',.false.,nam%write_nicas_grids)
call get(section,'compute psichitouv',.false.,nam%new_wind)
call get(section,'read local psichitouv',.false.,nam%load_wind_local)
call get(section,'write local psichitouv',.false.,nam%write_wind_local)
call get(section,'vertical balance inverse test',.false.,nam%check_vbal)
call get(section,'adjoints test',.false.,nam%check_adjoints)
call get(section,'normalization test',0,nam%check_normalization)
call get(section,'internal dirac test',.false.,nam%check_dirac)
call get(section,'randomization test',.false.,nam%check_randomization)
call get(section,'internal consistency test',.false.,nam%check_consistency)
call get(section,'localization optimality test',.false.,nam%check_optimality)

! Model section
if (conf%has('model')) then
   call conf%get_or_die('model',section)
   call print_section(mpl,section,'Model')
else
   section = fckit_configuration()
end if
call get(section,'nl0',0,nam%nl0)
call get(section,'level for 2d variables','first',nam%lev2d)
if (section%has('variables')) then
   call section%get_or_die('variables',str_array)
   nam%nv = size(str_array)
   allocate(nam%variables(nam%nv))      
   nam%variables = str_array
else
   nam%nv = 0
end if
call get(section,'do not cross mask boundaries',.false.,nam%mask_check)

! Ensemble sizes
if (conf%has('ensemble sizes')) then
   call conf%get_or_die('ensemble sizes',section)
   call print_section(mpl,section,'Ensemble sizes')
else
   section = fckit_configuration()
end if
call get(section,'total ensemble size',0,nam%ens1_ne)
call get(section,'sub-ensembles',1,nam%ens1_nsub)
call get(section,'total lowres ensemble size',0,nam%ens2_ne)
call get(section,'lowres sub-ensembles',1,nam%ens2_nsub)

! Sampling section
if (conf%has('sampling')) then
   call conf%get_or_die('sampling',section)
   call print_section(mpl,section,'Sampling')
else
   section = fckit_configuration()
end if
call get(section,'computation grid size',0,nam%nc1)
call get(section,'diagnostic grid size',0,nam%nc2)
call get(section,'distance classes',0,nam%nc3)
call get(section,'angular sectors',1,nam%nc4)
call get(section,'distance class width',zero,nam%dc)
call get(section,'reduced levels',0,nam%nl0r)
call get(section,'local diagnostic',.false.,nam%local_diag)
call get(section,'averaging length-scale',zero,nam%local_rad)
call get(section,'averaging latitude width',zero,nam%local_dlat)
call get(section,'grid type','random',nam%samp_draw_type)
call get(section,'max number of draws',10000,nam%irmax)
call get(section,'interpolation type','c0',nam%samp_interp_type)
if (section%has('masks')) then
   call section%get_or_die('masks',confs)

   ! Count masks
   nam%nmask = size(confs)

   ! Allocation
   allocate(nam%mask_type(nam%nmask))
   allocate(nam%mask_th(nam%nmask))
   allocate(nam%mask_lu(nam%nmask))
   allocate(nam%mask_variable(nam%nmask))

   ! Initialization
   do iconf=1,size(confs)
      nam%mask_type(iconf) = ''
      nam%mask_th(iconf) = mpl%msv%valr
      nam%mask_lu(iconf) = ''
      nam%mask_variable(iconf) = ''
   end do

   ! Get values
   do iconf=1,size(confs)
      call get(confs(iconf),'type','',nam%mask_type(iconf))
      call get(confs(iconf),'threshold',mpl%msv%valr,nam%mask_th(iconf))
      call get(confs(iconf),'side','',nam%mask_lu(iconf))
      call get(confs(iconf),'variable','',nam%mask_variable(iconf))
   end do
else
   nam%nmask = 0
end if
call get(section,'contiguous levels threshold',0,nam%ncontig_th)

! Localization section
if (conf%has('localization')) then
   call conf%get_or_die('localization',section)
   call print_section(mpl,section,'Localization')
else
   section = fckit_configuration()
end if
call get(section,'target ensemble size',0,nam%ne)
call get(section,'target lowres ensemble size',0,nam%ne_lr)
call get(section,'gaussian approximation',.false.,nam%gau_approx)
call get(section,'generalized kurtosis threshold',huge_real,nam%gen_kurt_th)
call get(section,' histogram bins',0,nam%avg_nbins)

! Vertical balance section
if (conf%has('vertical balance')) then
   call conf%get_or_die('vertical balance',section)
   call print_section(mpl,section,'Vertical balance')
else
   section = fckit_configuration()
end if
if (section%has('vbal')) then
   call section%get_or_die('vbal',confs)

   ! Allocation
   allocate(nam%vbal_block(nam%nv,nam%nv))
   allocate(nam%vbal_diag_auto(nam%nv,nam%nv))
   allocate(nam%vbal_diag_reg(nam%nv,nam%nv))
   allocate(nam%vbal_id_coef(nam%nv,nam%nv))
   allocate(vbal_order(nam%nv))

   ! Get initial matrix
   nam%vbal_block = .false.
   do iconf=1,size(confs)
      call confs(iconf)%get_or_die('balanced variable',str_bal)
      call confs(iconf)%get_or_die('unbalanced variable',str_unbal)
      found = .false.
      do jv=1,nam%nv
         do iv=1,nam%nv
            if ((str_bal==nam%variables(iv)).and.(str_unbal==nam%variables(jv))) then
               if (iv==jv) then
                  call mpl%abort('${subr}$','vbal item should be off-diagonal')
               else
                  if (nam%vbal_block(iv,jv)) then
                     call mpl%abort('${subr}$','redundant vbal item')
                  else
                     nam%vbal_block(iv,jv) = .true.
                     found = .true.
                  end if
               end if
            end if
         end do
      end do
      if (.not.found) call mpl%abort('${subr}$','wrong vbal item')
   end do

   ! Get vbal variables order
   vbal_order = 0
   rank = 0

   ! Independent variables first
   do iv=1,nam%nv
      if (count(nam%vbal_block(iv,:))==0) then
         rank = rank+1
         vbal_order(rank) = iv
      end if
   end do

   ! Find least-dependent variables progressively
   iv = 0
   itest = 0
   do while (any(vbal_order==0))
      ! Check number of iterations
      itest = itest+1
      if (itest>nam%nv**2) call mpl%abort('${subr}$','inconsistent vbal items')

      ! Increment variable index
      iv = iv+1
      if (iv>nam%nv) iv = 1

      if (.not.any(vbal_order(1:rank)==iv)) then
         ! Check variable dependencies
         valid = .true.
         do jv=1,nam%nv
            if (nam%vbal_block(iv,jv)) then
               if (.not.any(vbal_order(1:rank)==jv)) valid = .false.
            end if
         end do

         ! Check if variable can be added now
         if (valid) then
            rank = rank+1
            vbal_order(rank) = iv
         end if
      end if
   end do

   ! Reorder variables
   nam%variables(1:nam%nv) = nam%variables(vbal_order)
   nam%vbal_block = nam%vbal_block(vbal_order,vbal_order)

   ! Set section
   do iconf=1,size(confs)
      call confs(iconf)%get_or_die('balanced variable',str_bal)
      call confs(iconf)%get_or_die('unbalanced variable',str_unbal)
      do jv=1,nam%nv
         do iv=1,nam%nv
            if ((str_bal==nam%variables(iv)).and.(str_unbal==nam%variables(jv))) then
               call confs(iconf)%get_or_die('diagonal autocovariance',nam%vbal_diag_auto(iv,jv))
               call confs(iconf)%get_or_die('diagonal regression',nam%vbal_diag_reg(iv,jv))
               call confs(iconf)%get_or_die('identity block weight',nam%vbal_id_coef(iv,jv))
            end if
         end do
      end do
   end do

   ! Release memory
   deallocate(vbal_order)
end if
call get(section,'pseudo inverse',.false.,nam%vbal_pseudo_inv)
call get(section,'dominant mode',0,nam%vbal_pseudo_inv_mmax)
call get(section,'variance threshold',zero,nam%vbal_pseudo_inv_var_th)
call get(section,'identity blocks',.false.,nam%vbal_id)

! Variance section
if (conf%has('variance')) then
   call conf%get_or_die('variance',section)
   call print_section(mpl,section,'Variance')
else
   section = fckit_configuration()
end if
call get(section,'explicit stddev',.false.,nam%forced_var)
call nam%get_value_or_profile(mpl,section,'stddev',zero,nam%stddev)
call get(section,'objective filtering',.false.,nam%var_filter)
call get(section,'filtering iterations',-1,nam%var_niter)
call get(section,'filtering passes',-1,nam%var_npass)
call nam%get_value_or_profile(mpl,section,'initial length-scale',zero,nam%var_rhflt)

! Optimality test section
if (conf%has('optimality test')) then
   call conf%get_or_die('optimality test',section)
   call print_section(mpl,section,'Optimality test')
else
   section = fckit_configuration()
end if
call get(section,'half number of factors',1,nam%optimality_nfac)
call get(section,'optimality_delta',0.05_kind_real,nam%optimality_delta)
call get(section,'optimality_ntest',10,nam%optimality_ntest)

! Fit section
if (conf%has('fit')) then
   call conf%get_or_die('fit',section)
   call print_section(mpl,section,'Fit')
else
   section = fckit_configuration()
end if
call get(section,'horizontal filtering length-scale',zero,nam%diag_rhflt)
call get(section,'vertical filtering length-scale',zero,nam%diag_rvflt)
call get(section,'vertical stride',1,nam%fit_dl0)
call get(section,'number of components',1,nam%fit_ncmp)

! Local profiles section
if (conf%has('local profiles')) then
   call conf%get_or_die('local profiles',confs)
   call print_section(mpl,section,'Local profiles')
   nam%nldwv = size(confs)
   if (nam%nldwv>0) then
      ! Allocation
      allocate(nam%lon_ldwv(nam%nldwv))
      allocate(nam%lat_ldwv(nam%nldwv))
      allocate(nam%name_ldwv(nam%nldwv))

      ! Initialization
      nam%lon_ldwv = mpl%msv%valr
      nam%lat_ldwv = mpl%msv%valr
      nam%name_ldwv = ''

      do iconf=1,size(confs)
         call get(confs(iconf),'longitude',mpl%msv%valr,nam%lon_ldwv(iconf))
         call get(confs(iconf),'latitude',mpl%msv%valr,nam%lat_ldwv(iconf))
         call get(confs(iconf),'name','',nam%name_ldwv(iconf))
      end do
   end if
else
   nam%nldwv = 0
end if

! NICAS section
if (conf%has('nicas')) then
   call conf%get_or_die('nicas',section)
   call print_section(mpl,section,'NICAS')
else
   section = fckit_configuration()
end if
call get(section,'resolution',zero,nam%resol)
call get(section,'max horizontal grid size',15000,nam%nc1max)
call get(section,'grid type','random',nam%nicas_draw_type)
call get(section,'explicit length-scales',.false.,nam%forced_radii)
call nam%get_value_or_profile(mpl,section,'horizontal length-scale',-one,nam%rh)
call nam%get_value_or_profile(mpl,section,'vertical length-scale',-one,nam%rv)
if (section%has('common localization weights')) then
   call section%get_or_die('common localization weights',confs)

   ! Allocation
   allocate(loc_wgt(nam%nv,nam%nv))
   allocate(nam%loc_wgt_sqrt(nam%nv,nam%nv))

   ! Copy positive weights and set non-specified values to one
   loc_wgt = -one
   do iconf=1,size(confs)
      ! Get row and column variables, and the value
      call confs(iconf)%get_or_die('row variables',str_array_row)
      call confs(iconf)%get_or_die('column variables',str_array_col)
      call confs(iconf)%get_or_die('value',real_scalar)

      ! Loop over row and column values
      do ivv=1,size(str_array_row)
         do jvv=1,size(str_array_col)
            do iv=2,nam%nv
               do jv=1,iv-1
                  if ((str_array_row(ivv)==nam%variables(iv)).and.(str_array_row(ivv)==nam%variables(iv))) then
                     loc_wgt(iv,jv) = real_scalar
                     loc_wgt(jv,iv) = real_scalar
                  end if
               end do
            end do
         end do
      end do
   end do

   ! Set missing values to one
   do jv=1,nam%nv
      do iv=1,nam%nv
         if (eq(loc_wgt(iv,jv),-one)) loc_wgt = one
      end do
   end do
   
   ! Cholesky decomposition
   call cholesky(mpl,nam%nv,loc_wgt,nam%loc_wgt_sqrt)

   ! Release memory
   deallocate(loc_wgt)
end if
call nam%get_value(section,'minimum level',1,nam%min_lev)
call nam%get_value(section,'maximum level',nam%nl0,nam%max_lev)
allocate(nam%nicas_interp_type(0:nam%nv))
nam%nicas_interp_type = 'c0'
if (section%has('interpolation type')) then
   call section%get_or_die('interpolation type',confs)
   do iconf=1,size(confs)
      call confs(iconf)%get_or_die('variables',str_array)
      call confs(iconf)%get_or_die('type',str)
      do it=1,size(str_array)
         if (str_array(it)=='common') nam%nicas_interp_type(0) = str
         do iv=1,nam%nv
            if (str_array(it)==nam%variables(iv)) nam%nicas_interp_type(iv) = str
         end do
      end do
   end do
end if
call get(section,'positive-definiteness test',.false.,nam%pos_def_test)
call get(section,'horizontal interpolation test',.false.,nam%interp_test)

! Wind section
if (conf%has('psichitouv')) then
   call conf%get_or_die('psichitouv',section)
   call print_section(mpl,section,'Psichitouv')
else
   section = fckit_configuration()
end if
call get(section,'stream function','stream_function',nam%wind_streamfunction)
call get(section,'velocity potential','velocity_potential',nam%wind_velocity_potential)
call get(section,'eastward wind','eastward_wind',nam%wind_eastward)
call get(section,'northward wind','northward_wind',nam%wind_northward)
call get(section,'longitudes',0,nam%wind_nlon)
call get(section,'latitudes',0,nam%wind_nlat)
call get(section,'savitzky-golay half width',0,nam%wind_nsg)
call get(section,'wind inflation',one,nam%wind_inflation)

! Dirac section
if (conf%has('dirac')) then
   call conf%get_or_die('dirac',confs)
   call print_section(mpl,section,'Dirac')

   ! Count valid Dirac points
   nam%ndir = 0
   do iconf=1,size(confs)
      call confs(iconf)%get_or_die('variable',str)
      do iv=1,nam%nv
         if (str==nam%variables(iv)) nam%ndir = nam%ndir+1
      end do
   end do

   ! Allocation
   allocate(nam%londir(nam%ndir))
   allocate(nam%latdir(nam%ndir))
   allocate(nam%levdir(nam%ndir))
   allocate(nam%ivdir(nam%ndir))

   ! Initialization
   nam%ndir = 0
   do iconf=1,size(confs)
      call confs(iconf)%get_or_die('variable',str)
      do iv=1,nam%nv
         if (str==nam%variables(iv)) then
            nam%ndir = nam%ndir+1
            nam%ivdir(nam%ndir) = iv
            call confs(iconf)%get_or_die('longitude',nam%londir(nam%ndir))
            call confs(iconf)%get_or_die('latitude',nam%latdir(nam%ndir))
            call confs(iconf)%get_or_die('level',nam%levdir(nam%ndir))
         end if
      end do
   end do
else
   nam%ndir = 0
end if

! Probe out
@:probe_out()

end subroutine nam_from_conf

!----------------------------------------------------------------------
! Subroutine: nam_check
!> Check namelist parameters
!----------------------------------------------------------------------
subroutine nam_check(nam,mpl)

implicit none

! Passed variable
class(nam_type),intent(inout) :: nam !< Namelist
type(mpl_type),intent(inout) :: mpl  !< MPI data

! Local variables
integer :: isub,iv,ivmin,ivmax,i,il0,idir,ildwv,jv,imask
character(len=2) :: ivchar,ildwvchar

! Set name
@:set_name(nam_check)

! Probe in
@:probe_in()

! Namelist parameters normalization (meters to radians and degrees to radians)
nam%universe_radius = nam%universe_radius/req
nam%dc = nam%dc/req
if (allocated(nam%var_rhflt)) nam%var_rhflt = nam%var_rhflt/req
nam%local_rad = nam%local_rad/req
nam%local_dlat = nam%local_dlat*deg2rad
nam%diag_rhflt = nam%diag_rhflt/req
if (allocated(nam%rh)) nam%rh = nam%rh/req
if (nam%ndir>0) nam%londir = nam%londir*deg2rad
if (nam%ndir>0) nam%latdir = nam%latdir*deg2rad
if (nam%nldwv>0) nam%lon_ldwv = nam%lon_ldwv*deg2rad
if (nam%nldwv>0) nam%lat_ldwv = nam%lat_ldwv*deg2rad

! General section
if (nam%repro_ops) then
  if (nam%repro_th<zero) call mpl%abort('${subr}$','repro_th should be non-negative')
end if

! I/O section
if (nam%prefix/='') nam%prefix = trim(nam%prefix)//'_'
if (nam%datadir=='') call mpl%abort('${subr}$','datadir not specified')
if (nam%nprocio<1) call mpl%abort('${subr}$','number of I/O tasks should be positive')
if (nam%nprocio>mpl%nproc) then
   call mpl%warning('${subr}$','number of I/O tasks should be smaller than the total number of tasks, resetting nprocio')
   nam%nprocio = mpl%nproc
end if
if (nam%fname_samp=='') nam%fname_samp = trim(nam%prefix)//'sampling'
nam%fname_vbal_cov_default = trim(nam%prefix)//'vbal_cov'
if (allocated(nam%fname_vbal_cov)) then
   if (size(nam%fname_vbal_cov)<nam%ens1_nsub) call mpl%abort('${subr}$','not enough fname_vbal_cov items')
end if
if (nam%fname_vbal=='') nam%fname_vbal = trim(nam%prefix)//'vbal'
nam%fname_mom_default = trim(nam%prefix)//'mom'
if (allocated(nam%fname_mom1)) then
   if (size(nam%fname_mom1)<nam%ens1_nsub) call mpl%abort('${subr}$','not enough fname_mom1 items')
end if
if (allocated(nam%fname_mom2)) then
   if (size(nam%fname_mom2)<nam%ens2_nsub) call mpl%abort('${subr}$','not enough fname_mom2 items')
end if
if (nam%fname_nicas=='') nam%fname_nicas = trim(nam%prefix)//'nicas'
if (nam%fname_wind=='') nam%fname_wind = trim(nam%prefix)//'wind'

! Drivers section
if ((nam%new_hdiag.or.nam%check_optimality).and.nam%compute_hyb) then
   select case (nam%hybrid_source)
   case ('randomized static', 'lowres ensemble')
   case default
      call mpl%abort('${subr}$','wrong hybrid source')
   end select
end if
if (nam%new_hdiag.or.nam%new_nicas.or.nam%load_nicas_local.or.nam%load_nicas_global) then
   select case (nam%strategy)
   case ('diag_all','common','common_weighted','specific_univariate','specific_multivariate')
   case default
      call mpl%abort('${subr}$','wrong strategy')
   end select
end if
if (nam%load_samp_local.and.nam%load_samp_global) call mpl%abort('${subr}$','load_samp_local and load_samp_global are exclusive')
if (nam%load_samp_local.and.nam%write_samp_local) &
 & call mpl%abort('${subr}$','load_samp_local and write_samp_local are exclusive')
if (nam%load_samp_global.and.nam%write_samp_global) &
 & call mpl%abort('${subr}$','load_samp_global and write_samp_global are exclusive')
if (nam%write_samp_grids.and.(.not.(nam%new_vbal_cov.or.nam%new_vbal.or.nam%new_hdiag.or.nam%check_optimality))) &
 & call mpl%abort('${subr}$','new_vbal_cov, new_vbal or new_hdiag required for write_samp_grids')
if (nam%new_vbal_cov.and.nam%load_vbal_cov) call mpl%abort('${subr}$','new_vbal_cov and load_vbal_cov are exclusive')
if (nam%load_vbal_cov.and.(.not.nam%new_vbal)) call mpl%abort('${subr}$','new_vbal required for load_vbal_cov')
if (nam%load_vbal.and.(nam%new_vbal_cov.or.nam%load_vbal_cov)) call mpl%abort('${subr}$', &
 & 'load_vbal is inconsistent with new_vbal_cov, or load_vbal_cov')
if (nam%new_vbal.and.nam%load_vbal) call mpl%abort('${subr}$','new_vbal and load_vbal are exclusive')
if (nam%load_vbal_cov.and.(.not.(nam%load_samp_local.or.nam%load_samp_global))) &
 & call mpl%abort('${subr}$','load_vbal_cov requires load_samp_local/global')
if (nam%write_vbal_cov.and.(.not.(nam%load_samp_local.or.nam%load_samp_global)) &
 & .and.(.not.(nam%write_samp_local.or.nam%write_samp_global))) &
 & call mpl%abort('${subr}$','write_vbal_cov requires write_samp_local/global if load_samp_local/global is not activated')
if (nam%load_vbal.and.(.not.(nam%load_samp_local.or.nam%load_samp_global))) &
 & call mpl%abort('${subr}$','load_vbal requires load_samp_local/global')
 if (nam%write_vbal.and.(.not.(nam%load_samp_local.or.nam%load_samp_global)) &
 & .and.(.not.(nam%write_samp_local.or.nam%write_samp_global))) &
 & call mpl%abort('${subr}$','write_vbal requires write_samp_local/global if load_samp_local/global is not activated')
if (nam%new_mom.and.nam%load_mom) call mpl%abort('${subr}$','new_mom and load_mom are exclusive')
if (nam%load_mom.and.(.not.nam%load_samp_local)) call mpl%abort('${subr}$','load_mom requires load_samp_local')
if (nam%new_nicas.and.(nam%load_nicas_local.or.nam%load_nicas_global)) &
 & call mpl%abort('${subr}$','new_nicas and load_nicas_local/load_nicas_global are exclusive')
if (nam%check_vbal.and..not.(nam%new_vbal.or.nam%load_vbal)) &
 & call mpl%abort('${subr}$','new_vbal or load_vbal required for check_vbal')
if (nam%new_hdiag.and.(.not.(nam%new_mom.or.nam%load_mom))) &
 & call mpl%abort('${subr}$','new_mom or load_mom required for new_hdiag')
if (nam%write_hdiag_detail.and.(nam%fit_ncmp==1)) call mpl%abort('${subr}$', &
 & 'fit_ncmp should be larger than 1 for write_hdiag_detail')
if (nam%load_nicas_local.and.nam%write_nicas_global) &
 & call mpl%abort('${subr}$','load_nicas_local and write_nicas_global are exclusive')
if (nam%write_nicas_grids.and.(.not.(nam%new_nicas.or.nam%load_nicas_global))) &
 & call mpl%abort('${subr}$','new_nicas or load_nicas_global required for write_nicas_grids')
if (nam%check_dirac.and..not.(nam%new_vbal.or.nam%load_vbal.or.(nam%new_hdiag.and.nam%write_hdiag).or.nam%new_nicas &
 & .or.nam%load_nicas_local.or.nam%load_nicas_global)) call mpl%abort('${subr}$','check_dirac not available')
if (nam%check_randomization) then
   if (.not.nam%new_nicas) call mpl%abort('${subr}$','new_nicas required for check_randomization')
end if
if (nam%check_consistency) then
   if (.not.nam%compute_cor1) call mpl%abort('${subr}$','cor method required for check_consistency')
   if (nam%new_nicas) call mpl%abort('${subr}$','new_nicas forbidden for check_consistency')
end if
if (nam%check_optimality) then
   if (.not.nam%compute_loc1) call mpl%abort('${subr}$','loc method required for check_optimality')
   if (nam%new_nicas) call mpl%abort('${subr}$','new_nicas forbidden for check_optimality')
end if

! Model section
if (nam%nl0<=0) call mpl%abort('${subr}$','nl0 should be positive')
if ((nam%lev2d/='first').and.(nam%lev2d/='last')) call mpl%abort('${subr}$','wrong lev2d value')

! Ensemble sizes section
if ((nam%new_normality.or.nam%new_vbal_cov.or.(nam%new_vbal.and.(.not.nam%load_vbal_cov)) &
 & .or.(nam%new_var.and.(.not.nam%forced_var)).or.nam%new_mom &
 & .or.nam%check_randomization.or.nam%check_optimality).and.(nam%compute_cov1.or.nam%compute_cor1.or.nam%compute_loc1)) then
   if (nam%ens1_nsub<1) call mpl%abort('${subr}$','ens1_nsub should be positive')
   if (mod(nam%ens1_ne,nam%ens1_nsub)/=0) call mpl%abort('${subr}$','ens1_nsub should be a divider of ens1_ne')
   if (nam%ens1_ne/nam%ens1_nsub<=3) call mpl%abort('${subr}$','ens1_ne/ens1_nsub should be larger than 3')
end if
if (nam%new_mom.and.(nam%compute_cov2.or.nam%compute_cor2.or.nam%compute_loc2)) then
   if (nam%ens2_nsub<1) call mpl%abort('${subr}$','ens2_nsub should be non-negative')
   if (mod(nam%ens2_ne,nam%ens2_nsub)/=0) call mpl%abort('${subr}$','ens2_nsub should be a divider of ens2_ne')
   if (nam%ens2_ne/nam%ens2_nsub<=3) call mpl%abort('${subr}$','ens2_ne/ens2_nsub should be larger than 3')
end if
if (nam%compute_loc1.and.(nam%ne>nam%ens1_ne)) call mpl%warning('${subr}$', &
 & 'ensemble size larger than ens1_ne (might enhance sampling noise)')
if (nam%compute_loc2.and.(nam%ne_lr>nam%ens2_ne)) call mpl%warning('${subr}$', &
 & 'ensemble size larger than ens2_ne (might enhance sampling noise)')

! Sampling section
if (nam%new_vbal_cov.or.nam%new_vbal.or.nam%new_hdiag.or.nam%check_optimality) then
   if ((.not.(nam%load_samp_local.or.nam%load_samp_global)).and.(nam%nc1<3)) &
 & call mpl%abort('${subr}$','nc1 should be larger than 2')
   if (nam%new_vbal.or.(nam%new_hdiag.and.nam%local_diag)) then
      if ((.not.(nam%load_samp_local.or.nam%load_samp_global)).and.(nam%nc2<0)) &
 & call mpl%abort('${subr}$','nc2 should be non-negative')
   else
      if ((.not.(nam%load_samp_local.or.nam%load_samp_global)).and.(nam%nc2<0)) then
          call mpl%warning('${subr}$','nc2 should be set non-negative, resetting nc2 to zero')
          nam%nc2 = 0
      end if
   end if
end if
select case (nam%samp_draw_type)
case ('random')
case ('octahedral')
   if (nam%nldwv>0) call mpl%abort('${subr}$','no local diagnostics with an octahedral draw')
case default
   call mpl%abort('${subr}$','wrong samp_draw_type')
end select
if (nam%new_hdiag.or.nam%check_optimality) then
   if (nam%nc3<=0) call mpl%abort('${subr}$','nc3 should be positive')
   if (nam%nc4<=0) call mpl%abort('${subr}$','nc4 should be positive')
   if ((nam%nc4>1).and.(mod(nam%nc4,2)==1)) call mpl%abort('${subr}$','nc4 should be even')
   if (.not.(nam%dc>zero)) call mpl%abort('${subr}$','dc should be positive')
   if (nam%nl0r<1) call mpl%abort ('${subr}$','nl0r should be positive')
end if
if (nam%local_diag) then
   if (.not.((nam%local_rad>zero).or.(nam%local_dlat>zero))) call mpl%abort('${subr}$', &
 & 'local_rad or local_dlat should be positive')
   if ((nam%local_rad>zero).and.(nam%local_dlat>zero)) call mpl%abort('${subr}$', &
 & 'local_rad and local_dlat cannot be positive at the same time')
end if
if (.not.(nam%load_samp_local.or.nam%load_samp_global)) then
   if (nam%irmax<1) call mpl%abort ('${subr}$','irmax should be positive')
end if
select case (nam%samp_interp_type)
case ('c0','c1','si')
case default
   call mpl%abort('${subr}$','wrong sampling interpolation type')
end select
do imask=1,nam%nmask
   select case (nam%mask_type(imask))
   case ('none')
   case ('ldwv')
      if (nam%nldwv<=0) call mpl%abort('${subr}$','nldwv should not be negative for mask_type = ldwv')
   case ('stddev','input')
      if (mpl%msv%is(nam%mask_th(imask))) call mpl%abort('${subr}$','missing mask threshold')
      select case (nam%mask_lu(imask))
      case ('lower','upper')
      case default
         call mpl%abort('${subr}$','wrong mask_lu')
      end select
      if (nam%mask_variable(imask)=='') call mpl%abort('${subr}$','missing mask variable')
    end select
end do

! Localization section
if (nam%new_hdiag.or.nam%check_optimality) then
   if (nam%compute_loc1.and.(nam%ne<=3)) call mpl%abort('${subr}$','ne should be larger than 3')
   if (nam%compute_loc2.and.(nam%ne_lr<=3)) call mpl%abort('${subr}$','ne_lr should be larger than 3')
   if (.not.(nam%gen_kurt_th>zero)) call mpl%abort('${subr}$','gen_kurt_th should be positive')
end if

! Vertical balance section
if (nam%new_vbal) then
   if (.not.((nam%local_rad>zero).or.(nam%local_dlat>zero))) call mpl%abort('${subr}$', &
 & 'local_rad or local_dlat should be positive')
   if ((nam%local_rad>zero).and.(nam%local_dlat>zero)) call mpl%abort('${subr}$', &
 & 'local_rad and local_dlat cannot be positive at the same time')
   if (nam%vbal_pseudo_inv) then
      if ((nam%vbal_pseudo_inv_mmax<=0).and.(.not.nam%vbal_pseudo_inv_var_th>zero)) call mpl%abort('${subr}$', &
 & 'dominant mode or variance threshold should be positive for pseudo-inverse')
   end if
end if

! Variance section
if (nam%new_var) then
   if (nam%forced_var) then
      do iv=1,nam%nv
         do il0=1,nam%nl0
            if (.not.(nam%stddev(il0,iv)>zero)) call mpl%abort('${subr}$','stddev should be positive')
         end do
      end do
      if (nam%var_filter) call mpl%abort('${subr}$','var_filter forbidden for forced_var')
   end if
   if (nam%var_filter) then
      if ((nam%var_niter>0).and.(nam%var_npass>0)) call mpl%abort('${subr}$','var_niter or var_npass only should be non-negative')
      if ((nam%var_niter>0).and.(nam%var_npass>0)) &
 & call mpl%abort('${subr}$','var_niter or var_npass should not be positive at te same time')
      if ((nam%var_niter>0).or.(nam%var_npass>0)) then
         do iv=1,nam%nv
            do il0=1,nam%nl0
               if (.not.(nam%var_rhflt(il0,iv)>zero)) call mpl%abort('${subr}$','var_rhflt should be positive')
            end do
         end do
      end if
   end if
end if

! Optimality test section
if (nam%check_optimality) then
   if (nam%optimality_nfac<1) call mpl%abort('${subr}$','optimality_nfac should be positive')
   if (.not.(nam%optimality_delta>zero)) call mpl%abort('${subr}$','optimality_delta should be positive')
   if (nam%optimality_ntest<1) call mpl%abort('${subr}$','optimality_ntest should be positive')
end if

! Fit section
if (nam%new_hdiag.or.nam%check_optimality) then
   if (nam%diag_rhflt<zero) call mpl%abort('${subr}$','diag_rhflt should be non-negative')
   if (nam%diag_rvflt<zero) call mpl%abort('${subr}$','diag_rvflt should be non-negative')
   if (nam%fit_dl0<=0) call mpl%abort('${subr}$','fit_dl0 should be postive')
   if (nam%fit_ncmp<=0) call mpl%abort('${subr}$','fit_ncmp should be postive')
end if

! Local profiles section
if (nam%new_hdiag) then
   if (nam%nldwv<0) call mpl%abort('${subr}$','nldwv should be non-negative')
   if (nam%nldwv>0) then
      if (.not.nam%local_diag) call mpl%abort('${subr}$','local_diag required for nldwv>0')
      if (any(nam%lon_ldwv(1:nam%nldwv)<-pi).or.any(nam%lon_ldwv(1:nam%nldwv)>pi)) &
 & call mpl%abort('${subr}$','lon_ldwv should lie between -180 and 180')
      if (any(nam%lat_ldwv(1:nam%nldwv)<-half*pi).or.any(nam%lat_ldwv(1:nam%nldwv)>half*pi)) &
 & call mpl%abort('${subr}$','lat_ldwv should lie between -90 and 90')
      do ildwv=1,nam%nldwv
         write(ildwvchar,'(i2.2)') ildwv
         if (nam%name_ldwv(ildwv)=='') call mpl%abort('${subr}$','name_ldwv not specified for profile '//ildwvchar)
      end do
   end if
end if

! NICAS section
if (nam%new_nicas.or.nam%load_nicas_local.or.nam%load_nicas_global) then
   if ((nam%strategy=='common').or.(nam%strategy=='common_weighted')) then
      ivmin = 0
      ivmax = 0
   else
      ivmin = 1
      ivmax = nam%nv
   end if
   if (nam%check_randomization) then
      if (.not.nam%forced_radii) call mpl%abort('${subr}$','forced_radii required for check_randomization')
   end if
   if (nam%check_consistency) then
      if (.not.nam%forced_radii) call mpl%abort('${subr}$','forced_radii required for check_consistency')
   end if
   if (nam%check_optimality) then
      if (.not.nam%forced_radii) call mpl%abort('${subr}$','forced_radii required for check_optimality')
   end if
   if (nam%new_nicas) then
      if (.not.(nam%resol>zero)) call mpl%abort('${subr}$','resol should be positive')
      if (nam%nc1max<=0) call mpl%abort('${subr}$','nc1max should be positive')
   end if
   if (nam%forced_radii) then
      if (.not.(allocated(nam%rh).and.allocated(nam%rv))) then
      if (allocated(nam%rh).and.allocated(nam%rv)) call mpl%abort('${subr}$','rh and/or rv are missing')
         do iv=ivmin,ivmax
            do il0=1,nam%nl0
               if (nam%rh(il0,iv)<zero) call mpl%abort('${subr}$','rh should be non-negative')
               if (nam%rv(il0,iv)<zero) call mpl%abort('${subr}$','rv should be non-negative')
            end do
         end do
      end if
   end if
   if (nam%strategy=='common_weighted') then
      if (.not.allocated(nam%loc_wgt_sqrt)) call mpl%abort('${subr}$','loc_wgt should be specified for common_weighted')
   end if
   select case (nam%nicas_draw_type)
   case ('random')
   case ('octahedral')
      if (nam%nldwv>0) call mpl%abort('${subr}$','no local diagnostics with an octahedral draw')
   case default
      call mpl%abort('${subr}$','wrong nicas_draw_type')
   end select
   do iv=ivmin,ivmax
      select case (nam%nicas_interp_type(iv))
      case ('c0','c1','si')
      case default
         call mpl%abort('${subr}$','wrong nicas_interp_type')
      end select
   end do
end if

! Dirac section
if (nam%check_dirac) then
   do idir=1,nam%ndir
      if ((nam%londir(idir)<-pi).or.(nam%londir(idir)>pi)) call mpl%abort('${subr}$','londir should lie between -180 and 180')
      if ((nam%latdir(idir)<-half*pi).or.(nam%latdir(idir)>half*pi)) call mpl%abort('${subr}$','latdir should lie between -90 and 90')
      if ((nam%ivdir(idir)<1).or.(nam%ivdir(idir)>nam%nv)) call mpl%abort('${subr}$','wrong variable for a Dirac')
   end do
end if

! Wind section
if (nam%new_wind) then
   if (nam%wind_nlon<3) call mpl%abort('${subr}$','wind_nlon should be larger than 3')
   if (nam%wind_nlat<3) call mpl%abort('${subr}$','wind_nlat should be larger than 3')
   if (nam%wind_nsg<1) call mpl%abort('${subr}$','wind_nsg should be positive')
   if (nam%wind_inflation<one) call mpl%abort('${subr}$','wind_inflation should be larger than 1')
end if

! Probe out
@:probe_out()

end subroutine nam_check

!----------------------------------------------------------------------
! Subroutine: nam_alias
!> Get alias value from key
!----------------------------------------------------------------------
subroutine nam_alias(nam,key,val)

implicit none

! Passed variable
class(nam_type),intent(in) :: nam      !< Namelist
character(len=*),intent(in) :: key     !< Alias key
character(len=1024),intent(out) :: val !< Alias value

! Local variables
integer :: i

! Set name
@:set_name(nam_alias)

! Probe in
@:probe_in()

! Loop over I/O key-value couples
val = key
if (allocated(nam%alias_code)) then
   do i=1,size(nam%alias_code)
      if (nam%alias_code(i)==key) then
         val = nam%alias_file(i)
         exit
      end if
   end do
end if

! Probe out
@:probe_out()

end subroutine nam_alias

!----------------------------------------------------------------------
! Subroutine: nam_print_section
!> Print configuration section
!----------------------------------------------------------------------
subroutine nam_print_section(mpl,section,title)

implicit none

! Passed variable
type(mpl_type),intent(inout) :: mpl             !< MPI data
type(fckit_configuration),intent(in) :: section !< Configuration section
character(len=*),intent(in) :: title            !< Section title

! Local variable
integer :: str_size
character(len=:),allocatable :: str

! Set name
@:set_name(nam_print_section)

! Probe in
@:probe_in()

! Print title
write(mpl%info,'(a7,a,a)') '',trim(title),':'
call mpl%flush(.false.)

! Configuration string
str = section%json()
str_size = len(str)
do while (str_size>1024)
   write(mpl%info,'(a)') str(1:1024)
   call mpl%flush(.false.)
   str(1:str_size-1024) = str(1025:str_size)
   str_size = str_size-1024
end do
write(mpl%info,'(a)') str(1:str_size)
call mpl%flush

! Probe out
@:probe_out()

end subroutine nam_print_section

#:for dtype in dtypes_irls
!----------------------------------------------------------------------
! Subroutine: nam_get_${dtype}$
!> Get value
!----------------------------------------------------------------------
subroutine nam_get_${dtype}$(section,key,def,val)

implicit none

! Passed variable
type(fckit_configuration),intent(in) :: section !< Configuration section
character(len=*),intent(in) :: key              !< Key
${ftype[dtype]}$,intent(in) :: def              !< Default value
${ftype[dtype]}$,intent(out) :: val             !< Value

! Local variables
character(len=:),allocatable :: str

! Set name
@:set_name(nam_get_${dtype}$)

! Probe in
@:probe_in()

if (section%has(key)) then
   #:if dtype == "string"
      call section%get_or_die(key, str)
      val = str
   #:else
      call section%get_or_die(key, val)
   #:endif
else
   val = def
end if

! Probe out
@:probe_out()

end subroutine nam_get_${dtype}$
#:endfor

#:for dtype in dtypes_ir
!----------------------------------------------------------------------
! Subroutine: nam_get_value_${dtype}$
!> Get value for all variables
!----------------------------------------------------------------------
subroutine nam_get_value_${dtype}$(nam,section,key,def,val)

implicit none

! Passed variable
class(nam_type),intent(inout) :: nam                 !< Namelist
type(fckit_configuration),intent(in) :: section      !< Configuration section
character(len=*),intent(in) :: key                   !< Key
${ftype[dtype]}$,intent(in) :: def                   !< Default value
${ftype[dtype]}$,allocatable,intent(inout) :: val(:) !< Values

! Local variables
integer :: iconf,iv,it
${ftype[dtype]}$ :: scalar
character(len=:),allocatable :: str_array(:)
type(fckit_configuration),allocatable :: confs(:)

! Set name
@:set_name(nam_get_value_${dtype}$)

! Probe in
@:probe_in()

! Allocation
allocate(val(0:nam%nv))

! Initialization
val = def

if (section%has(key)) then 
   ! Get subconfigurations vector
   call section%get_or_die(key,confs)

   ! Loop over subconfigurations
   do iconf=1,size(confs)
      call confs(iconf)%get_or_die('variables',str_array)
      call confs(iconf)%get_or_die('value',scalar)
      do it=1,size(str_array)
         if (str_array(it)=='common') val(0) = scalar
         do iv=1,nam%nv
            if (str_array(it)==nam%variables(iv)) val(iv) = scalar
         end do
      end do
   end do
end if

! Probe out
@:probe_out()

end subroutine nam_get_value_${dtype}$
#:endfor

#:for dtype in dtypes_ir
!----------------------------------------------------------------------
! Subroutine: nam_get_value_or_profile_${dtype}$
!> Get value or profile for all variables
!----------------------------------------------------------------------
subroutine nam_get_value_or_profile_${dtype}$(nam,mpl,section,key,def,val)

implicit none

! Passed variable
class(nam_type),intent(inout) :: nam                   !< Namelist
type(mpl_type),intent(inout) :: mpl                    !< MPI data
type(fckit_configuration),intent(in) :: section        !< Configuration section
character(len=*),intent(in) :: key                     !< Key
${ftype[dtype]}$,intent(in) :: def                     !< Default value
${ftype[dtype]}$,allocatable,intent(inout) :: val(:,:) !< Values

! Local variables
integer :: iconf,iv,it
${ftype[dtype]}$ :: scalar
${ftype[dtype]}$,allocatable :: array(:)
character(len=:),allocatable :: str_array(:)
character(len=1024) :: message
type(fckit_configuration),allocatable :: confs(:)

! Set name
@:set_name(nam_get_value_or_profile_${dtype}$)

! Probe in
@:probe_in()

! Allocation
allocate(val(nam%nl0,0:nam%nv))

! Initialization
val = def

if (section%has(key)) then
   ! Get subconfigurations vector
   call section%get_or_die(key,confs)

   ! Loop over subconfigurations
   do iconf=1,size(confs)
      call confs(iconf)%get_or_die('variables',str_array)
      if (confs(iconf)%has('value')) then
         call confs(iconf)%get_or_die('value',scalar)
         do it=1,size(str_array)
            if (str_array(it)=='common') val(:,0) = scalar
            do iv=1,nam%nv
               if (str_array(it)==nam%variables(iv)) val(:,iv) = scalar
            end do
         end do
      elseif (confs(iconf)%has('profile')) then
         call confs(iconf)%get_or_die('profile',array)
         do it=1,size(str_array)
            if (str_array(it)=='common') val(1:size(array),0) = array
            do iv=1,nam%nv
               if (str_array(it)==nam%variables(iv)) val(1:size(array),iv) = array
            end do
         end do
      else
         call mpl%abort('${subr}$','missing value/profile in '//key)
      end if
   end do
end if

! Probe out
@:probe_out()

end subroutine nam_get_value_or_profile_${dtype}$
#:endfor

end module type_nam
