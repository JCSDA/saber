#:include '../instrumentation.fypp'
!----------------------------------------------------------------------
! Module: type_nam
!> Namelist derived type
! Author: Benjamin Menetrier
! Licensing: this code is distributed under the CeCILL-C license
! Copyright 2015-... UCAR, CERFACS, METEO-FRANCE and IRIT
!----------------------------------------------------------------------
module type_nam

use fckit_configuration_module, only: fckit_configuration
use tools_const, only: zero,hundredth,half,one,ten,hundred,pi,req,deg2rad,rad2deg
use tools_kinds, only: kind_real,huge_real
use tools_func, only: cholesky
use tools_repro, only: eq
use type_mpl, only: mpl_type
@:use_probe()

implicit none

integer,parameter :: nsubmax = 99                 !< Maximum number of sub-ensembles
integer,parameter :: nvmax = 99                   !< Maximum number of variables
integer,parameter :: nl0max = 300                 !< Maximum number of levels
integer,parameter :: nc3max = 100                 !< Maximum number of distance classes
integer,parameter :: nc4max = 24                  !< Maximum number of angular sectors
integer,parameter :: nscalesmax = 5               !< Maximum number of scales
integer,parameter :: ndirmax = 99                 !< Maximum number of diracs
integer,parameter :: nldwvmax = 20                !< Maximum number of local diagnostic profiles
integer,parameter :: nprociomax = 20              !< Maximum number of I/O tasks
integer,parameter :: niokvmax = 99                !< Maximum number of I/O key-values
integer,parameter :: nvbalmax = nvmax*(nvmax-1)/2 !< Maximum number of vertical balance blocks

type nam_type
   ! general_param
   character(len=1024) :: datadir                             !< Data directory
   character(len=1024) :: prefix                              !< Files prefix
   logical :: colorlog                                        !< Add colors to the log (for display on terminal)
   logical :: default_seed                                    !< Default seed for random numbers
   logical :: repro                                           !< Inter-compilers reproducibility
   real(kind_real) :: rth                                     !< Reproducibility threshold
   logical :: parallel_io                                     !< Parallel NetCDF I/O
   integer :: nprocio                                         !< Number of I/O processors
   real(kind_real) :: universe_rad                            !< Universe radius [in meters]

   ! driver_param
   character(len=1024) :: method                              !< Localization/hybridization to compute ('cor', 'loc', 'hyb-rnd' or 'hyb-ens')
   character(len=1024) :: strategy                            !< Localization strategy ('diag_all', 'common', 'common_weighted', 'specific_univariate' or 'specific_multivariate')
   logical :: new_normality                                   !< New normality test
   logical :: load_samp_local                                 !< Load local sampling
   logical :: load_samp_global                                !< Load global sampling
   logical :: write_samp_local                                !< Write local sampling
   logical :: write_samp_global                               !< Write global sampling
   logical :: write_samp_grids                                !< Write sampling grids
   logical :: new_vbal_cov                                    !< New vertical covariance
   logical :: update_vbal_cov                                 !< Update vertical covariance sequentially
   logical :: load_vbal_cov                                   !< Load local vertical covariance
   logical :: write_vbal_cov                                  !< Write local vertical covariancee
   logical :: new_vbal                                        !< Compute new vertical balance operator
   logical :: load_vbal                                       !< Load local vertical balance operator
   logical :: write_vbal                                      !< Write vertical balance operator
   logical :: new_var                                         !< Compute new variance
   logical :: update_var                                      !< Update variance sequentially
   logical :: new_mom                                         !< Compute new sampling moments
   logical :: update_mom                                      !< Update sampling moments sequentially
   logical :: load_mom                                        !< Load sampling moments
   logical :: write_mom                                       !< Write sampling moments
   logical :: new_hdiag                                       !< Compute new HDIAG diagnostics
   logical :: write_hdiag                                     !< Write HDIAG diagnostics
   logical :: write_hdiag_detail                              !< Write HDIAG components detail
   logical :: new_nicas                                       !< Compute new NICAS parameters
   logical :: load_nicas_local                                !< Load local NICAS parameters
   logical :: load_nicas_global                               !< Load global NICAS parameters
   logical :: write_nicas_local                               !< Write local NICAS parameters
   logical :: write_nicas_global                              !< Write global NICAS parameters
   logical :: new_wind                                        !< Compute wind transform
   logical :: load_wind_local                                 !< Load local wind transform
   logical :: write_wind_local                                !< Write local wind transform
   logical :: check_vbal                                      !< Test vertical balance inverse and adjoint
   logical :: check_adjoints                                  !< Test NICAS adjoints
   integer :: check_normalization                             !< Test NICAS normalization (number of tests)
   logical :: check_dirac                                     !< Test NICAS application on diracs
   logical :: check_randomization                             !< Test NICAS randomization
   logical :: check_consistency                               !< Test HDIAG-NICAS consistency
   logical :: check_optimality                                !< Test HDIAG optimality

   ! Files parameters
   character(len=1024),dimension(0:nsubmax) :: fname_var      !< Variance files
   character(len=1024) :: fname_samp                          !< Sampling file
   character(len=1024),dimension(0:nsubmax) :: fname_vbal_cov !< Vertical covariance files
   character(len=1024) :: fname_vbal                          !< Vertical balance file
   character(len=1024),dimension(0:nsubmax) :: fname_mom      !< Moments files
   character(len=1024) :: fname_nicas                         !< NICAS file
   character(len=1024) :: fname_wind                          !< Wind transform file

   ! Model parameters
   integer :: nl0                                             !< Number of levels
   integer :: levs(nl0max)                                    !< Levels
   character(len=1024) :: lev2d                               !< Level for 2D variables ('first' or 'last')
   integer :: nv                                              !< Number of variables
   character(len=1024),dimension(nvmax) :: variables          !< Variables names
   character(len=1024),dimension(niokvmax) :: io_keys         !< I/O keys
   character(len=1024),dimension(niokvmax) :: io_values       !< I/O values

   ! Ensemble sizes
   integer :: ens1_ne                                         !< Ensemble 1 size
   integer :: ens1_nsub                                       !< Ensemble 1 sub-ensembles number
   integer :: ens2_ne                                         !< Ensemble 2 size
   integer :: ens2_nsub                                       !< Ensemble 2 sub-ensembles number

   ! Mask parameters
   character(len=1024) :: mask_type                           !< Mask restriction type
   character(len=1024),dimension(nvmax) :: mask_lu            !< Mask threshold side ('lower' if mask_th is the lower bound, 'upper' if mask_th is the upper bound)
   real(kind_real),dimension(nvmax) :: mask_th                !< Mask threshold
   integer :: ncontig_th                                      !< Threshold on vertically contiguous points for sampling mask (0 to skip the test)
   logical :: mask_check                                      !< Check that sampling couples and interpolations do not cross mask boundaries

   ! Sampling parameters
   integer :: nc1                                             !< Number of sampling points
   integer :: nc2                                             !< Number of diagnostic points
   integer :: nc3                                             !< Number of horizontal classes
   integer :: nc4                                             !< Number of angular sectors
   real(kind_real) :: dc                                      !< Class size, should be larger than the typical grid cell size [in meters]
   integer :: nl0r                                            !< Reduced number of levels for diagnostics
   logical :: local_diag                                      !< Activate local diagnostics
   real(kind_real) :: local_rad                               !< Local diagnostics calculation radius [in meters]
   real(kind_real) :: local_dlat                              !< Local diagnostics calculation latitude band half-width [in degrees]
   character(len=1024) :: samp_draw_type                      !< Diagnostic draw type ('random' or 'octahedral')
   integer :: irmax                                           !< Maximum number of random number draws
   character(len=2) :: samp_interp_type                       !< Sampling C2B to C0A interpolation type ('c0': C0 mesh-based, 'c1': C1 mesh-based or 'si': smooth interpolation)

   ! Localization parameters
   integer :: ne                                              !< Ensemble size
   integer :: ne_lr                                           !< Ensemble size of the low-resolution term (ensemble 2)
   logical :: gau_approx                                      !< Gaussian approximation for asymptotic quantities
   real(kind_real) :: gen_kurt_th                             !< Threshold on generalized kurtosis (3.0 = Gaussian distribution)
   integer :: avg_nbins                                       !< Number of bins for averaged statistics histograms

   ! Vertical balance parameters
   real(kind_real) :: vbal_rad                                !< Vertical balance diagnostic radius [in meters]
   real(kind_real) :: vbal_dlat                               !< Vertical balance diagnostic latitude band half-width [in degrees]
   logical :: vbal_pseudo_inv                                 !< Pseudo-inverse for auto-covariance
   integer :: vbal_pseudo_inv_mmax                            !< Dominant mode for pseudo-inverse
   real(kind_real) :: vbal_pseudo_inv_var_th                  !< Variance threshold to compute the dominant mode for pseudo-inverse
   logical :: vbal_id                                         !< Identity vertical balance for tests

   ! Variance parameters
   logical :: forced_var                                      !< Force specific variance
   real(kind_real) :: stddev(nl0max,nvmax)                    !< Forced standard-deviation
   logical :: var_filter                                      !< Filter variance
   integer :: var_niter                                       !< Number of iterations for the variance filtering (0 for uniform variance)
   integer :: var_npass                                       !< Number of passes for the variance filtering (0 for uniform variance)
   real(kind_real) :: var_rhflt(nl0max,nvmax)                 !< Variance initial filtering support radius [in meters]

   ! Optimality test parameters
   integer :: optimality_nfac                                 !< Number of length-scale factors for optimization
   real(kind_real) :: optimality_delta                        !< Increments of length-scale factors for optimization
   integer :: optimality_ntest                                !< Number of test vectors for optimization

   ! Fit parameters
   real(kind_real) :: diag_rhflt                              !< Horizontal filtering suport radius [in meters]
   real(kind_real) :: diag_rvflt                              !< Vertical filtering support radius
   integer :: fit_dl0                                         !< Number of levels between interpolation levels
   integer :: fit_ncmp                                        !< Number of components in the fit function

   ! Local profiles parameters
   integer :: nldwv                                           !< Number of local diagnostics profiles to write (for local_diag = .true.)
   real(kind_real) :: lon_ldwv(nldwvmax)                      !< Longitudes of the local diagnostics profiles to write [in degrees]
   real(kind_real) :: lat_ldwv(nldwvmax)                      !< Latitudes of the local diagnostics profiles to write [in degrees]
   character(len=1024),dimension(nldwvmax) :: name_ldwv       !< Name of the local diagnostics profiles to write

   ! NICAS parameters
   real(kind_real) :: resol                                   !< Resolution
   integer :: nc1max                                          !< Maximum size of the Sc1 subset
   character(len=1024) :: nicas_draw_type                     !< NICAS draw type ('random' or 'octahedral')
   logical :: forced_radii                                    !< Force specific support radii
   real(kind_real) :: rh(nl0max,0:nvmax)                      !< Forced horizontal support radius [in meters]
   real(kind_real) :: rv(nl0max,0:nvmax)                      !< Forced vertical support radius
   integer :: min_lev(0:nvmax)                                !< Minimum level
   integer :: max_lev(0:nvmax)                                !< Maximum level
   character(len=2),dimension(0:nvmax) :: nicas_interp_type   !< NICAS C1B to C0A interpolation type ('c0': C0 mesh-based, 'c1': C1 mesh-based or 'si': smooth interpolation)
   logical :: pos_def_test                                    !< Positive-definiteness test
   logical :: write_nicas_grids                               !< Write NICAS grids
   logical :: interp_test                                     !< Horizontal NICAS interpolation test

   ! Dirac parameters
   integer :: ndir                                            !< Number of Diracs
   real(kind_real) :: londir(ndirmax)                         !< Diracs longitudes [in degrees]
   real(kind_real) :: latdir(ndirmax)                         !< Diracs latitudes [in degrees]
   integer :: levdir(ndirmax)                                 !< Diracs level
   integer :: ivdir(ndirmax)                                  !< Diracs variable indices

   ! Wind parameters
   character(len=1024) :: wind_streamfunction                 !< Streamfunction variable name
   character(len=1024) :: wind_velocity_potential             !< Velocity potential variable name
   character(len=1024) :: wind_zonal                          !< Zonal wind variable name
   character(len=1024) :: wind_meridional                     !< Meridional variable name
   integer :: wind_nlon                                       !< Number of longitudes for the regular grid
   integer :: wind_nlat                                       !< Number of latitudes for the regular grid
   integer :: wind_nsg                                        !< Half-width of the Savitzky-Golay to compute derivatives
   real(kind_real) :: wind_inflation                          !< Wind inflation to compensate the Savitzky-Golay smoothing

   ! Helpers
   logical :: fname_var_used                                  !< Flag activated if a variance file is specified
   logical :: fname_vbal_cov_used                             !< Flag activated if a vertical covariance file is specified
   logical :: fname_mom_used                                  !< Flag activated if a moments file is specified
   logical,allocatable :: vbal_block(:,:)                     !< Activation of vertical balance
   logical,allocatable :: vbal_diag_auto(:,:)                 !< Diagonal auto-covariance for the inversion
   logical,allocatable :: vbal_diag_reg(:,:)                  !< Diagonal regression
   real(kind_real),allocatable :: vbal_id_coef(:,:)           !< Scalar coefficients for identity vertical balance
   real(kind_real),allocatable :: loc_wgt_sqrt(:,:)           !< Weights square-root for the 'common_weighted' strategy
contains
   procedure :: init => nam_init
   procedure :: from_conf => nam_from_conf
   procedure :: check => nam_check
   procedure :: io_key_value => nam_io_key_value
end type nam_type

private
public :: nvmax,nl0max,nc3max,nscalesmax,ndirmax,nldwvmax,niokvmax,nvbalmax
public :: nam_type

contains

!----------------------------------------------------------------------
! Subroutine: nam_init
!> Intialize
!----------------------------------------------------------------------
subroutine nam_init(nam,mpl)

implicit none

! Passed variable
class(nam_type),intent(out) :: nam !< Namelist
type(mpl_type),intent(in) :: mpl   !< MPI data

! Local variable
integer :: isub,il0,iv,i,ildwv

! Set name
@:set_name(nam_init)

! Probe in
@:probe_in()

! general_param default
nam%datadir = '.'
nam%prefix = ''
nam%colorlog = .false.
nam%default_seed = .true.
nam%repro = .true.
nam%rth = 1.0e-12_kind_real
nam%parallel_io = .true.
nam%nprocio = min(mpl%nproc,nprociomax)
nam%universe_rad = pi*req

! driver_param default
nam%method = ''
nam%strategy = ''
nam%new_normality = .false.
nam%new_vbal_cov = .false.
nam%update_vbal_cov = .false.
nam%load_vbal_cov = .false.
nam%write_vbal_cov = .false.
nam%new_vbal = .false.
nam%load_vbal = .false.
nam%write_vbal = .false.
nam%new_var = .false.
nam%update_var = .false.
nam%new_mom = .false.
nam%update_mom = .false.
nam%load_mom = .false.
nam%write_mom = .false.
nam%new_hdiag = .false.
nam%write_hdiag = .false.
nam%new_nicas = .false.
nam%load_nicas_local = .false.
nam%load_nicas_global = .false.
nam%write_nicas_local = .false.
nam%write_nicas_global = .false.
nam%new_wind = .false.
nam%load_wind_local = .false.
nam%write_wind_local = .false.
nam%check_vbal = .false.
nam%check_adjoints = .false.
nam%check_normalization = 0
nam%check_dirac = .false.
nam%check_randomization = .false.
nam%check_consistency = .false.
nam%check_optimality = .false.

! files_param default
do isub=0,nsubmax
   nam%fname_var(isub) = ''
end do
nam%fname_samp = ''
do isub=0,nsubmax
   nam%fname_vbal_cov(isub) = ''
end do
nam%fname_vbal = ''
do isub=0,nsubmax
   nam%fname_mom(isub) = ''
end do
nam%fname_nicas = ''
nam%fname_wind = ''

! model_param default
nam%nl0 = 0
do il0=1,nl0max
   nam%levs(il0) = il0
end do
nam%lev2d = 'first'
nam%nv = 0
do iv=1,nvmax
   nam%variables(iv) = ''
end do
do i=1,niokvmax
   nam%io_keys(i) = ''
   nam%io_values(i) = ''
end do

! ens1_param default
nam%ens1_ne = 0
nam%ens1_nsub = 1

! ens2_param default
nam%ens2_ne = 0
nam%ens2_nsub = 1

! sampling_param default
nam%load_samp_local = .false.
nam%load_samp_global = .false.
nam%write_samp_local = .false.
nam%write_samp_global = .false.
nam%write_samp_grids = .false.
nam%mask_type = 'none'
do iv=1,nvmax
   nam%mask_lu(iv) = 'lower'
   nam%mask_th(iv) = zero
end do
nam%ncontig_th = 0
nam%mask_check = .false.
nam%samp_draw_type = 'random'
nam%nc1 = 0
nam%nc2 = 0
nam%nc3 = 0
nam%nc4 = 1
nam%dc = zero
nam%nl0r = 0
nam%irmax = 10000
nam%samp_interp_type = 'c0'

! diag_param default
nam%ne = 0
nam%ne_lr = 0
nam%gen_kurt_th = huge_real
nam%gau_approx = .false.
nam%avg_nbins = 0
nam%vbal_rad = zero
nam%vbal_dlat = zero
nam%vbal_pseudo_inv = .false.
nam%vbal_pseudo_inv_mmax = 0
nam%vbal_pseudo_inv_var_th = zero
nam%vbal_id = .false.
nam%forced_var = .false.
nam%stddev = zero
nam%var_filter = .false.
nam%var_niter = -1
nam%var_npass = -1
nam%var_rhflt = zero
nam%local_diag = .false.
nam%local_rad = zero
nam%local_dlat = zero
nam%optimality_nfac = 1
nam%optimality_delta = 0.05_kind_real
nam%optimality_ntest = 10

! fit_param default
nam%diag_rhflt = zero
nam%diag_rvflt = zero
nam%fit_dl0 = 1
nam%fit_ncmp = 1
nam%write_hdiag_detail = .false.

! nicas_param default
nam%resol = zero
nam%nc1max = 15000
nam%nicas_draw_type = 'random'
nam%forced_radii = .false.
nam%rh = -one
nam%rv = -one
nam%min_lev = 1
nam%max_lev = nl0max
nam%nicas_interp_type = 'c0'
nam%pos_def_test = .false.
nam%write_nicas_grids = .false.
nam%interp_test = .false.

! dirac_param default
nam%ndir = 0
nam%londir = zero
nam%latdir = zero
nam%levdir = 0
nam%ivdir = 0

! output_param default
nam%nldwv = 0
nam%lon_ldwv = zero
nam%lat_ldwv = zero
do ildwv=1,nldwvmax
   nam%name_ldwv(ildwv) = ''
end do

! wind_param default
nam%wind_streamfunction = 'stream_function'
nam%wind_velocity_potential = 'velocity_potential'
nam%wind_zonal = 'eastward_wind'
nam%wind_meridional = 'northward_wind'
nam%wind_nlon = 0
nam%wind_nlat = 0
nam%wind_nsg = 0
nam%wind_inflation = one

! helpers
nam%fname_var_used = .false.
nam%fname_vbal_cov_used = .false.
nam%fname_mom_used = .false.

! Probe out
@:probe_out()

end subroutine nam_init

!----------------------------------------------------------------------
! Subroutine: nam_from_conf
!> Intialize from configuration
!----------------------------------------------------------------------
subroutine nam_from_conf(nam,mpl,conf)

implicit none

! Passed variable
class(nam_type),intent(inout) :: nam         !< Namelist
type(mpl_type),intent(inout) :: mpl          !< MPI data
type(fckit_configuration),intent(in) :: conf !< Configuration

! Local variables
integer :: iv,jv,iconf,rank,itest
integer,allocatable :: integer_array(:),vbal_order(:)
real(kind_real),allocatable :: real_array(:),loc_wgt(:,:)
logical :: colorlog,found,valid
logical,allocatable :: logical_array(:)
character(len=1024) :: message,param,blockname
character(len=:),allocatable :: str,str_bal,str_unbal
character(len=:),allocatable :: str_array(:)
type(fckit_configuration) :: section,subconf
type(fckit_configuration),allocatable :: confs(:)

! Set name
@:set_name(nam_from_conf)

! Probe in
@:probe_in()

! General parameters
if (conf%has('general')) then
   call conf%get_or_die('general',section)
   if (section%has('datadir')) then
      call section%get_or_die('datadir',str)
      nam%datadir = str
   end if
   if (section%has('prefix')) then
      call section%get_or_die('prefix',str)
      nam%prefix = str
   end if
   if (section%has('colorlog')) then
      call section%get_or_die('colorlog',colorlog)
      if (colorlog) then
         mpl%black = char(27)//'[0;0m'
         mpl%green = char(27)//'[0;32m'
         mpl%peach = char(27)//'[1;91m'
         mpl%aqua = char(27)//'[1;36m'
         mpl%purple = char(27)//'[1;35m'
         mpl%wng_color = char(27)//'[0;37;42;1m'
      end if
   end if
   if (section%has('testing')) call section%get_or_die('testing',mpl%testing)
   if (section%has('default_seed')) call section%get_or_die('default_seed',nam%default_seed)
   if (section%has('repro')) call section%get_or_die('repro',nam%repro)
   if (section%has('rth')) call section%get_or_die('rth',nam%rth)
   if (section%has('parallel_io')) call section%get_or_die('parallel_io',nam%parallel_io)
   if (section%has('nprocio')) call section%get_or_die('nprocio',nam%nprocio)
   if (section%has('universe_rad')) call section%get_or_die('universe_rad',nam%universe_rad)
end if
   
! Drivers parameters
if (conf%has('drivers')) then
   call conf%get_or_die('drivers',section)
   if (section%has('method')) then
      call section%get_or_die('method',str)
      nam%method = str
   end if
   if (section%has('strategy')) then
      call section%get_or_die('strategy',str)
      nam%strategy = str
   end if
   if (section%has('new_normality')) call section%get_or_die('new_normality',nam%new_normality)
   if (section%has('load_samp_local')) call section%get_or_die('load_samp_local',nam%load_samp_local)
   if (section%has('load_samp_global')) call section%get_or_die('load_samp_global',nam%load_samp_global)
   if (section%has('write_samp_local')) call section%get_or_die('write_samp_local',nam%write_samp_local)
   if (section%has('write_samp_global')) call section%get_or_die('write_samp_global',nam%write_samp_global)
   if (section%has('write_samp_grids')) call section%get_or_die('write_samp_grids',nam%write_samp_grids)
   if (section%has('new_vbal_cov')) call section%get_or_die('new_vbal_cov',nam%new_vbal_cov)
   if (section%has('update_vbal_cov')) call section%get_or_die('update_vbal_cov',nam%update_vbal_cov)
   if (section%has('load_vbal_cov')) call section%get_or_die('load_vbal_cov',nam%load_vbal_cov)
   if (section%has('write_vbal_cov')) call section%get_or_die('write_vbal_cov',nam%write_vbal_cov)
   if (section%has('new_vbal')) call section%get_or_die('new_vbal',nam%new_vbal)
   if (section%has('load_vbal')) call section%get_or_die('load_vbal',nam%load_vbal)
   if (section%has('write_vbal')) call section%get_or_die('write_vbal',nam%write_vbal)
   if (section%has('new_var')) call section%get_or_die('new_var',nam%new_var)
   if (section%has('update_var')) call section%get_or_die('update_var',nam%update_var)
   if (section%has('new_mom')) call section%get_or_die('new_mom',nam%new_mom)
   if (section%has('update_mom')) call section%get_or_die('update_mom',nam%update_mom)
   if (section%has('load_mom')) call section%get_or_die('load_mom',nam%load_mom)
   if (section%has('write_mom')) call section%get_or_die('write_mom',nam%write_mom)
   if (section%has('new_hdiag')) call section%get_or_die('new_hdiag',nam%new_hdiag)
   if (section%has('write_hdiag')) call section%get_or_die('write_hdiag',nam%write_hdiag)
   if (section%has('write_hdiag_detail')) call section%get_or_die('write_hdiag_detail',nam%write_hdiag_detail)

   if (section%has('new_nicas')) call section%get_or_die('new_nicas',nam%new_nicas)
   if (section%has('load_nicas_local')) call section%get_or_die('load_nicas_local',nam%load_nicas_local)
   if (section%has('load_nicas_global')) call section%get_or_die('load_nicas_global',nam%load_nicas_global)
   if (section%has('write_nicas_local')) call section%get_or_die('write_nicas_local',nam%write_nicas_local)
   if (section%has('write_nicas_global')) call section%get_or_die('write_nicas_global',nam%write_nicas_global)
   if (section%has('new_wind')) call section%get_or_die('new_wind',nam%new_wind)
   if (section%has('load_wind_local')) call section%get_or_die('load_wind_local',nam%load_wind_local)
   if (section%has('write_wind_local')) call section%get_or_die('write_wind_local',nam%write_wind_local)
   if (section%has('check_vbal')) call section%get_or_die('check_vbal',nam%check_vbal)
   if (section%has('check_adjoints')) call section%get_or_die('check_adjoints',nam%check_adjoints)
   if (section%has('check_normalization')) call section%get_or_die('check_normalization',nam%check_normalization)
   if (section%has('check_dirac')) call section%get_or_die('check_dirac',nam%check_dirac)
   if (section%has('check_randomization')) call section%get_or_die('check_randomization',nam%check_randomization)
   if (section%has('check_consistency')) call section%get_or_die('check_consistency',nam%check_consistency)
   if (section%has('check_optimality')) call section%get_or_die('check_optimality',nam%check_optimality)
end if

! Files param
if (conf%has('files')) then
   call conf%get_or_die('files',section)
   if (section%has('fname_var')) then
      call section%get_or_die('fname_var',str_array)
      if (size(str_array)>nsubmax) then
         write(message,'(a,i4)') 'fname_var size should be smaller than ',nsubmax
         call mpl%abort('${subr}$',message)
      end if
      nam%fname_var(1:size(str_array)) = str_array
   end if
   if (section%has('fname_samp')) then
      call section%get_or_die('fname_samp',str)
      nam%fname_samp = str
   end if
   if (section%has('fname_vbal_cov')) then
      call section%get_or_die('fname_vbal_cov',str_array)
      if (size(str_array)>nsubmax) then
         write(message,'(a,i4)') 'fname_vbal_cov size should be smaller than ',nsubmax
         call mpl%abort('${subr}$',message)
      end if
      nam%fname_vbal_cov(1:size(str_array)) = str_array
   end if
   if (section%has('fname_vbal')) then
      call section%get_or_die('fname_vbal',str)
      nam%fname_vbal = str
   end if
   if (section%has('fname_mom')) then
      call section%get_or_die('fname_mom',str_array)
      if (size(str_array)>nsubmax) then
         write(message,'(a,i4)') 'fname_mom size should be smaller than ',nsubmax
         call mpl%abort('${subr}$',message)
      end if
      nam%fname_mom(1:size(str_array)) = str_array
   end if
   if (section%has('fname_nicas')) then
      call section%get_or_die('fname_nicas',str)
      nam%fname_nicas = str
   end if
   if (section%has('fname_wind')) then
      call section%get_or_die('fname_wind',str)
      nam%fname_wind = str
   end if
end if

! Model parameters
if (conf%has('model')) then
   call conf%get_or_die('model',section)
   if (section%has('nl0')) call section%get_or_die('nl0',nam%nl0)
   if (section%has('levs')) then
      call section%get_or_die('levs',integer_array)
      if (size(integer_array)>nl0max) then
         write(message,'(a,i4)') 'levs size should be smaller than ',nl0max
         call mpl%abort('${subr}$',message)
      end if
      nam%levs(1:size(integer_array)) = integer_array
   end if
   if (section%has('lev2d')) then
      call section%get_or_die('lev2d',str)
      nam%lev2d = str
   end if
   if (section%has('variables')) then
      call section%get_or_die('variables',str_array)
      if (size(str_array)>nvmax) then
         write(message,'(a,i4)') 'variables size should be smaller than ',nvmax
         call mpl%abort('${subr}$',message)
      end if
      nam%variables(1:size(str_array)) = str_array
      nam%nv = size(str_array)
   end if
   if (section%has('io_keys')) then
      call section%get_or_die('io_keys',str_array)
      if (size(str_array)>niokvmax) then
         write(message,'(a,i4)') 'io_keys size should be smaller than ',niokvmax
         call mpl%abort('${subr}$',message)
      end if
      nam%io_keys(1:size(str_array)) = str_array
   end if
   if (section%has('io_values')) then
      call section%get_or_die('io_values',str_array)
      if (size(str_array)>niokvmax) then
         write(message,'(a,i4)') 'io_values size should be smaller than ',niokvmax
         call mpl%abort('${subr}$',message)
      end if
      nam%io_values(1:size(str_array)) = str_array
   end if
end if

! Ensemble sizes
if (conf%has('ensemble sizes')) then
   call conf%get_or_die('ensemble sizes',section)
   if (section%has('ens1_ne')) call section%get_or_die('ens1_ne',nam%ens1_ne)
   if (section%has('ens1_nsub')) call section%get_or_die('ens1_nsub',nam%ens1_nsub)
   if (section%has('ens2_ne')) call section%get_or_die('ens2_ne',nam%ens2_ne)
   if (section%has('ens2_nsub')) call section%get_or_die('ens2_nsub',nam%ens2_nsub)
end if

! Mask parameters
if (conf%has('mask')) then
   call conf%get_or_die('mask',section)
   if (section%has('mask_type')) then
      call section%get_or_die('mask_type',str)
      nam%mask_type = str
   end if
   if (section%has('mask_lu')) then
      call section%get_or_die('mask_lu',str_array)
      if (size(str_array)>nvmax) then
         write(message,'(a,i4)') 'mask_lu size should be smaller than ',nvmax
         call mpl%abort('${subr}$',message)
      end if
      nam%mask_lu(1:size(str_array)) = str_array
   end if
   if (section%has('mask_th')) then
      call section%get_or_die('mask_th',real_array)
      if (size(real_array)>nvmax) then
         write(message,'(a,i4)') 'mask_th size should be smaller than ',nvmax
         call mpl%abort('${subr}$',message)
      end if
      nam%mask_th(1:size(real_array)) = real_array
   end if
   if (section%has('ncontig_th')) call section%get_or_die('ncontig_th',nam%ncontig_th)
   if (section%has('mask_check')) call section%get_or_die('mask_check',nam%mask_check)
end if

! Sampling parameters
if (conf%has('sampling')) then
   call conf%get_or_die('sampling',section)
   if (section%has('nc1')) call section%get_or_die('nc1',nam%nc1)
   if (section%has('nc2')) call section%get_or_die('nc2',nam%nc2)
   if (section%has('nc3')) call section%get_or_die('nc3',nam%nc3)
   if (section%has('nc4')) call section%get_or_die('nc4',nam%nc4)
   if (section%has('dc')) call section%get_or_die('dc',nam%dc)
   if (section%has('nl0r')) call section%get_or_die('nl0r',nam%nl0r)
   if (section%has('local_diag')) call section%get_or_die('local_diag',nam%local_diag)
   if (section%has('local_rad')) call section%get_or_die('local_rad',nam%local_rad)
   if (section%has('local_dlat')) call section%get_or_die('local_dlat',nam%local_dlat)
   if (section%has('samp_draw_type')) then
      call section%get_or_die('samp_draw_type',str)
      nam%samp_draw_type = str
   end if
   if (section%has('irmax')) call section%get_or_die('irmax',nam%irmax)
   if (section%has('samp_interp_type')) then
      call section%get_or_die('samp_interp_type',str)
      nam%samp_interp_type = str
   end if
end if

! Localization parameters
if (conf%has('localization')) then
   call conf%get_or_die('localization',section)
   if (section%has('ne')) call section%get_or_die('ne',nam%ne)
   if (section%has('ne_lr')) call section%get_or_die('ne_lr',nam%ne_lr)
   if (section%has('gau_approx')) call section%get_or_die('gau_approx',nam%gau_approx)
   if (section%has('gen_kurt_th')) call section%get_or_die('gen_kurt_th',nam%gen_kurt_th)
   if (section%has('avg_nbins')) call section%get_or_die('avg_nbins',nam%avg_nbins)
end if

! Vertical balance parameters
if (conf%has('vertical balance')) then
   call conf%get_or_die('vertical balance',section)
   if (section%has('vbal')) then
      call section%get_or_die('vbal',confs)

      ! Allocation
      allocate(nam%vbal_block(nam%nv,nam%nv))
      allocate(nam%vbal_diag_auto(nam%nv,nam%nv))
      allocate(nam%vbal_diag_reg(nam%nv,nam%nv))
      allocate(nam%vbal_id_coef(nam%nv,nam%nv))
      allocate(vbal_order(nam%nv))
   
      ! Get initial matrix
      nam%vbal_block = .false.
      do iconf=1,size(confs)
         call confs(iconf)%get_or_die('balanced',str_bal)
         call confs(iconf)%get_or_die('unbalanced',str_unbal)
         found = .false.
         do jv=1,nam%nv
            do iv=1,nam%nv
               if ((str_bal==nam%variables(iv)).and.(str_unbal==nam%variables(jv))) then
                  if (iv==jv) then
                     call mpl%abort('${subr}$','vbal item should be off-diagonal')
                  else
                     if (nam%vbal_block(iv,jv)) then
                        call mpl%abort('${subr}$','redundant vbal item')
                     else
                        nam%vbal_block(iv,jv) = .true.
                        found = .true.
                     end if
                  end if
               end if
            end do
         end do
         if (.not.found) call mpl%abort('${subr}$','wrong vbal item')
      end do
   
      ! Get vbal variables order
      vbal_order = 0
      rank = 0
   
      ! Independent variables first
      do iv=1,nam%nv
         if (count(nam%vbal_block(iv,:))==0) then
            rank = rank+1
            vbal_order(rank) = iv
         end if
      end do
   
      ! Find least-dependent variables progressively
      iv = 0
      itest = 0
      do while (any(vbal_order==0))
         ! Check number of iterations
         itest = itest+1
         if (itest>nam%nv**2) call mpl%abort('${subr}$','inconsistent vbal items')
   
         ! Increment variable index
         iv = iv+1
         if (iv>nam%nv) iv = 1
   
         if (.not.any(vbal_order(1:rank)==iv)) then
            ! Check variable dependencies
            valid = .true.
            do jv=1,nam%nv
               if (nam%vbal_block(iv,jv)) then
                  if (.not.any(vbal_order(1:rank)==jv)) valid = .false.
               end if
            end do
   
            ! Check if variable can be added now
            if (valid) then
               rank = rank+1
               vbal_order(rank) = iv
            end if
         end if
      end do
   
      ! Reorder variables
      nam%variables(1:nam%nv) = nam%variables(vbal_order)
      nam%vbal_block = nam%vbal_block(vbal_order,vbal_order)
   
      ! Set parameters
      do iconf=1,size(confs)
         call confs(iconf)%get_or_die('balanced',str_bal)
         call confs(iconf)%get_or_die('unbalanced',str_unbal)
         do jv=1,nam%nv
            do iv=1,nam%nv
               if ((str_bal==nam%variables(iv)).and.(str_unbal==nam%variables(jv))) then
                  call confs(iconf)%get_or_die('diag_auto',nam%vbal_diag_auto(iv,jv))
                  call confs(iconf)%get_or_die('diag_reg',nam%vbal_diag_reg(iv,jv))
                  call confs(iconf)%get_or_die('id_coef',nam%vbal_id_coef(iv,jv))
               end if
            end do
         end do
      end do
   
      ! Release memory
      deallocate(vbal_order)
   end if
   if (section%has('vbal_rad')) call section%get_or_die('vbal_rad',nam%vbal_rad)
   if (section%has('vbal_dlat')) call section%get_or_die('vbal_dlat',nam%vbal_dlat)
   if (section%has('vbal_pseudo_inv')) call section%get_or_die('vbal_pseudo_inv',nam%vbal_pseudo_inv)
   if (section%has('vbal_pseudo_inv_mmax')) call section%get_or_die('vbal_pseudo_inv_mmax',nam%vbal_pseudo_inv_mmax)
   if (section%has('vbal_pseudo_inv_var_th')) call section%get_or_die('vbal_pseudo_inv_var_th',nam%vbal_pseudo_inv_var_th)
   if (section%has('vbal_id')) call section%get_or_die('vbal_id',nam%vbal_id)
end if

! Variance parameters
if (conf%has('variance')) then
   call conf%get_or_die('variance',section)
   if (section%has('forced_var')) call section%get_or_die('forced_var',nam%forced_var)
   if (section%has('stddev')) then
      call section%get_or_die('stddev',subconf)
      do iv=1,nam%nv
         if (subconf%has(nam%variables(iv))) then
            call subconf%get_or_die(nam%variables(iv),real_array)
            if (size(real_array)>nl0max) then
               write(message,'(a,a,a,i4)') 'stddev-',trim(nam%variables(iv)),' size should be smaller than ',nl0max
               call mpl%abort('${subr}$',message)
            end if
            if (size(real_array)==1) then
               nam%stddev(:,iv) = real_array(1)
            else
               nam%stddev(1:size(real_array),iv) = real_array
            end if
         end if
      end do
   end if
   if (section%has('var_filter')) call section%get_or_die('var_filter',nam%var_filter)
   if (section%has('var_niter')) call section%get_or_die('var_niter',nam%var_niter)
   if (section%has('var_npass')) call section%get_or_die('var_npass',nam%var_npass)
   if (section%has('var_rhflt')) then
      call section%get_or_die('var_rhflt',subconf)
      do iv=1,nam%nv
         if (subconf%has(nam%variables(iv))) then
            call subconf%get_or_die(nam%variables(iv),real_array)
            if (size(real_array)>nl0max) then
               write(message,'(a,a,a,i4)') 'var_rhflt-',trim(nam%variables(iv)), &
    & ' size should be smaller than ',nl0max
               call mpl%abort('${subr}$',message)
            end if
            if (size(real_array)==1) then
               nam%var_rhflt(:,iv) = real_array(1)
            else
               nam%var_rhflt(1:size(real_array),iv) = real_array
            end if
         end if
      end do
   end if
end if

! Optimality test parameters
if (conf%has('optimality test')) then
   call conf%get_or_die('optimality test',section)
   if (section%has('optimality_nfac')) call section%get_or_die('optimality_nfac',nam%optimality_nfac)
   if (section%has('optimality_delta')) call section%get_or_die('optimality_delta',nam%optimality_delta)
   if (section%has('optimality_ntest')) call section%get_or_die('optimality_ntest',nam%optimality_ntest)
end if

! Fit parameters
if (conf%has('fit')) then
   call conf%get_or_die('fit',section)
   if (section%has('diag_rhflt')) call section%get_or_die('diag_rhflt',nam%diag_rhflt)
   if (section%has('diag_rvflt')) call section%get_or_die('diag_rvflt',nam%diag_rvflt)
   if (section%has('fit_dl0')) call section%get_or_die('fit_dl0',nam%fit_dl0)
   if (section%has('fit_ncmp')) call section%get_or_die('fit_ncmp',nam%fit_ncmp)
end if

! NICAS parameters
if (conf%has('nicas')) then
   call conf%get_or_die('nicas',section)
   if (section%has('resol')) call section%get_or_die('resol',nam%resol)
   if (section%has('nc1max')) call section%get_or_die('nc1max',nam%nc1max)
   if (section%has('nicas_draw_type')) then
      call section%get_or_die('nicas_draw_type',str)
      nam%nicas_draw_type = str
   end if
   if (section%has('forced_radii')) call section%get_or_die('forced_radii',nam%forced_radii)
   if (section%has('rh')) then
      call section%get_or_die('rh',subconf)
      if (subconf%has('common')) then
         call subconf%get_or_die('common',real_array)
         if (size(real_array)>nl0max) then
            write(message,'(a,i4)') 'rh-common size should be smaller than ',nl0max
            call mpl%abort('${subr}$',message)
         end if
         if (size(real_array)==1) then
            nam%rh(:,0) = real_array(1)
         else
            nam%rh(1:size(real_array),0) = real_array
         end if
      end if
      do iv=1,nam%nv
         if (subconf%has(nam%variables(iv))) then
            call subconf%get_or_die(nam%variables(iv),real_array)
            if (size(real_array)>nl0max) then
               write(message,'(a,a,a,i4)') 'rh-',trim(nam%variables(iv)), &
    & ' size should be smaller than ',nl0max
               call mpl%abort('${subr}$',message)
            end if
            if (size(real_array)==1) then
               nam%rh(:,iv) = real_array(1)
            else
               nam%rh(1:size(real_array),iv) = real_array
            end if
         end if
      end do
   end if
   if (section%has('rv')) then
      call section%get_or_die('rv',subconf)
      if (subconf%has('common')) then
         call subconf%get_or_die('common',real_array)
         if (size(real_array)>nl0max) then
            write(message,'(a,i4)') 'rv-common size should be smaller than ',nl0max
            call mpl%abort('${subr}$',message)
         end if
         if (size(real_array)==1) then
            nam%rv(:,0) = real_array(1)
         else
            nam%rv(1:size(real_array),0) = real_array
         end if
      end if
      do iv=1,nam%nv
         if (subconf%has(nam%variables(iv))) then
            call subconf%get_or_die(nam%variables(iv),real_array)
            if (size(real_array)>nl0max) then
               write(message,'(a,a,a,i4)') 'rv-',trim(nam%variables(iv)), &
    & ' size should be smaller than ',nl0max
               call mpl%abort('${subr}$',message)
            end if
            if (size(real_array)==1) then
               nam%rv(:,iv) = real_array(1)
            else
               nam%rv(1:size(real_array),iv) = real_array
            end if
         end if
      end do
   end if
   if (section%has('loc_wgt')) then
      call section%get_or_die('loc_wgt',subconf)
   
      ! Allocation
      allocate(loc_wgt(nam%nv,nam%nv))
      allocate(nam%loc_wgt_sqrt(nam%nv,nam%nv))
   
      ! Copy positive weights and set non-specified values to one
      loc_wgt = -one
      do jv=1,nam%nv
         do iv=1,jv
            blockname = trim(nam%variables(iv))//'-'//trim(nam%variables(jv))
            if (subconf%has(blockname)) then
               if (iv==jv) call mpl%abort('${subr}$','loc_wgt item should be off-diagonal')
               if (.not.eq(loc_wgt(iv,jv),-one)) call mpl%abort('${subr}$','redundant loc_wgt item')
               call subconf%get_or_die(blockname,loc_wgt(iv,jv))
               loc_wgt(jv,iv) = loc_wgt(iv,jv)
            end if
            blockname = trim(nam%variables(jv))//'-'//trim(nam%variables(iv))
            if (subconf%has(blockname)) then
               if (iv==jv) call mpl%abort('${subr}$','loc_wgt item should be off-diagonal')
               if (.not.eq(loc_wgt(iv,jv),-one)) call mpl%abort('${subr}$','redundant loc_wgt item')
               call subconf%get_or_die(blockname,loc_wgt(iv,jv))
               loc_wgt(jv,iv) = loc_wgt(iv,jv)
            end if
         end do
      end do
   
      ! Set missing values to one
      do jv=1,nam%nv
         do iv=1,nam%nv
            if (eq(loc_wgt(iv,jv),-one)) loc_wgt = one
         end do
      end do
      
      ! Cholesky decomposition
      call cholesky(mpl,nam%nv,loc_wgt,nam%loc_wgt_sqrt)
   
      ! Release memory
      deallocate(loc_wgt)
   end if
   if (section%has('min_lev')) then
      call section%get_or_die('min_lev',subconf)
      if (subconf%has('common')) call subconf%get_or_die('common',nam%min_lev(0))
      do iv=1,nam%nv
         if (subconf%has(nam%variables(iv))) call subconf%get_or_die(nam%variables(iv),nam%min_lev(iv))
      end do
   end if
   if (section%has('max_lev')) then
      call section%get_or_die('max_lev',subconf)
      if (subconf%has('common')) call subconf%get_or_die('common',nam%max_lev(0))
      do iv=1,nam%nv
         if (subconf%has(nam%variables(iv))) call subconf%get_or_die(nam%variables(iv),nam%max_lev(iv))
      end do
   end if
   if (section%has('nicas_interp_type')) then
      call section%get_or_die('nicas_interp_type',subconf)
      if (subconf%has('common')) then
         call subconf%get_or_die('common',str)
         nam%nicas_interp_type(0) = str
      end if
      do iv=1,nam%nv
         if (subconf%has(nam%variables(iv))) then
           call subconf%get_or_die(nam%variables(iv),str)
           nam%nicas_interp_type(iv) = str
         end if
      end do
   end if
   if (section%has('pos_def_test')) call section%get_or_die('pos_def_test',nam%pos_def_test)
   if (section%has('write_nicas_grids')) call section%get_or_die('write_nicas_grids',nam%write_nicas_grids)
   if (section%has('interp_test')) call section%get_or_die('interp_test',nam%interp_test)
end if

! Dirac parameters
if (conf%has('dirac')) then
   call conf%get_or_die('dirac',section)
   if (section%has('ndir')) call section%get_or_die('ndir',nam%ndir)
   if (section%has('londir')) then
      call section%get_or_die('londir',real_array)
      if (size(real_array)>ndirmax) then
         write(message,'(a,i4)') 'londir size should be smaller than ',ndirmax
         call mpl%abort('${subr}$',message)
      end if
      nam%londir(1:size(real_array)) = real_array
   end if
   if (section%has('latdir')) then
      call section%get_or_die('latdir',real_array)
      if (size(real_array)>ndirmax) then
         write(message,'(a,i4)') 'latdir size should be smaller than ',ndirmax
         call mpl%abort('${subr}$',message)
      end if
      nam%latdir(1:size(real_array)) = real_array
   end if
   if (section%has('levdir')) then
      call section%get_or_die('levdir',integer_array)
      if (size(real_array)>ndirmax) then
         write(message,'(a,i4)') 'levdir size should be smaller than ',ndirmax
         call mpl%abort('${subr}$',message)
      end if
      nam%levdir(1:size(integer_array)) = integer_array
   end if
   if (section%has('ivdir')) then
      call section%get_or_die('ivdir',integer_array)
      if (size(real_array)>ndirmax) then
         write(message,'(a,i4)') 'ivdir size should be smaller than ',ndirmax
         call mpl%abort('${subr}$',message)
      end if
      nam%ivdir(1:size(integer_array)) = integer_array
   end if
end if

! Local profiles parameters
if (conf%has('local profiles')) then
   call conf%get_or_die('local profiles',section)
   if (section%has('nldwv')) call section%get_or_die('nldwv',nam%nldwv)
   if (section%has('lon_ldwv')) then
      call section%get_or_die('lon_ldwv',real_array)
      if (size(real_array)>nldwvmax) then
         write(message,'(a,i4)') 'lon_ldwv size should be smaller than ',nldwvmax
         call mpl%abort('${subr}$',message)
      end if
      nam%lon_ldwv(1:size(real_array)) = real_array
   end if
   if (section%has('lat_ldwv')) then
      call section%get_or_die('lat_ldwv',real_array)
      if (size(real_array)>nldwvmax) then
         write(message,'(a,i4)') 'lat_ldwv size should be smaller than ',nldwvmax
         call mpl%abort('${subr}$',message)
      end if
      nam%lat_ldwv(1:size(real_array)) = real_array
   end if
   if (section%has('name_ldwv')) then
      call section%get_or_die('name_ldwv',str_array)
      if (size(real_array)>nldwvmax) then
         write(message,'(a,i4)') 'name_ldwv size should be smaller than ',nldwvmax
         call mpl%abort('${subr}$',message)
      end if
      nam%name_ldwv(1:size(str_array)) = str_array
   end if
end if

! Wind parameters
if (conf%has('wind')) then
   call conf%get_or_die('wind',section)
   if (section%has('wind_streamfunction')) then
      call section%get_or_die('wind_streamfunction',str)
      nam%wind_streamfunction = str
   end if
   if (section%has('wind_velocity_potential')) then
      call section%get_or_die('wind_velocity_potential',str)
      nam%wind_velocity_potential = str
   end if
   if (section%has('wind_zonal')) then
      call section%get_or_die('wind_zonal',str)
      nam%wind_zonal = str
   end if
   if (section%has('wind_meridional')) then
      call section%get_or_die('wind_meridional',str)
      nam%wind_meridional = str
   end if
   if (section%has('wind_nlon')) call section%get_or_die('wind_nlon',nam%wind_nlon)
   if (section%has('wind_nlat')) call section%get_or_die('wind_nlat',nam%wind_nlat)
   if (section%has('wind_nsg')) call section%get_or_die('wind_nsg',nam%wind_nsg)
   if (section%has('wind_inflation')) call section%get_or_die('wind_inflation',nam%wind_inflation)
end if

! Helpers
if (conf%has('msvalr')) call conf%get_or_die('msvalr',mpl%msv%valr)

! Probe out
@:probe_out()

end subroutine nam_from_conf

!----------------------------------------------------------------------
! Subroutine: nam_check
!> Check namelist parameters
!----------------------------------------------------------------------
subroutine nam_check(nam,mpl)

implicit none

! Passed variable
class(nam_type),intent(inout) :: nam !< Namelist
type(mpl_type),intent(inout) :: mpl  !< MPI data

! Local variables
integer :: isub,iv,ivmin,ivmax,i,il0,idir,ildwv,jv
character(len=2) :: ivchar,ildwvchar

! Set name
@:set_name(nam_check)

! Probe in
@:probe_in()

! Check maximum sizes
if (nam%nl0>nl0max) call mpl%abort('${subr}$','nl0 is too large')
if (nam%nv>nvmax) call mpl%abort('${subr}$','nv is too large')
if (nam%ens1_nsub>nsubmax) call mpl%abort('${subr}$','ens1_nsub is too large')
if (nam%ens2_nsub>nsubmax) call mpl%abort('${subr}$','ens2_nsub is too large')
if (nam%nc3>nc3max) call mpl%abort('${subr}$','nc3 is too large')
if (nam%nc4>nc4max) call mpl%abort('${subr}$','nc4 is too large')
if (nam%ndir>ndirmax) call mpl%abort('${subr}$','ndir is too large')
if (nam%nldwv>nldwvmax) call mpl%abort('${subr}$','nldwv is too large')

! Namelist parameters normalization (meters to radians and degrees to radians)
nam%universe_rad = nam%universe_rad/req
nam%dc = nam%dc/req
nam%vbal_rad = nam%vbal_rad/req
nam%vbal_dlat = nam%vbal_dlat*deg2rad
nam%var_rhflt = nam%var_rhflt/req
nam%local_rad = nam%local_rad/req
nam%local_dlat = nam%local_dlat*deg2rad
nam%diag_rhflt = nam%diag_rhflt/req
nam%rh = nam%rh/req
if (nam%ndir>0) nam%londir(1:nam%ndir) = nam%londir(1:nam%ndir)*deg2rad
if (nam%ndir>0) nam%latdir(1:nam%ndir) = nam%latdir(1:nam%ndir)*deg2rad
if (nam%nldwv>0) nam%lon_ldwv(1:nam%nldwv) = nam%lon_ldwv(1:nam%nldwv)*deg2rad
if (nam%nldwv>0) nam%lat_ldwv(1:nam%nldwv) = nam%lat_ldwv(1:nam%nldwv)*deg2rad

! Forced parameters for backward compatibility
if (nam%new_hdiag.and.(.not.(nam%update_mom.or.nam%load_mom))) nam%new_mom = .true.
if (nam%prefix/='') nam%prefix = trim(nam%prefix)//'_'

! Check general_param
if (nam%datadir=='') call mpl%abort('${subr}$','datadir not specified')
if (nam%repro) then
  if (nam%rth<zero) call mpl%abort('${subr}$','rth should be non-negative')
end if
if (nam%nprocio<1) call mpl%abort('${subr}$','number of I/O tasks should be positive')
if (nam%nprocio>mpl%nproc) then
   call mpl%warning('${subr}$','number of I/O tasks should be smaller than the total number of tasks, resetting nprocio')
   nam%nprocio = mpl%nproc
end if

! Check driver_param
if (nam%new_hdiag.or.nam%check_optimality) then
   select case (nam%method)
   case ('cor','loc','hyb-rnd','hyb-ens')
   case default
      call mpl%abort('${subr}$','wrong method')
   end select
end if
if (nam%new_hdiag.or.nam%new_nicas.or.nam%load_nicas_local.or.nam%load_nicas_global) then
   select case (nam%strategy)
   case ('diag_all','common','common_weighted','specific_univariate','specific_multivariate')
   case default
      call mpl%abort('${subr}$','wrong strategy')
   end select
end if
if (nam%new_vbal_cov.and.nam%update_vbal_cov) call mpl%abort('${subr}$','new_vbal_cov and update_vbal_cov are exclusive')
if (nam%new_vbal_cov.and.nam%load_vbal_cov) call mpl%abort('${subr}$','new_vbal_cov and load_vbal_cov are exclusive')
if (nam%load_vbal_cov.and.nam%update_vbal_cov) call mpl%abort('${subr}$','load_vbal_cov and update_vbal_cov are exclusive')
if (nam%load_vbal_cov.and.(.not.nam%new_vbal)) call mpl%abort('${subr}$','new_vbal required for load_vbal_cov')
if (nam%load_vbal.and.(nam%new_vbal_cov.or.nam%load_vbal_cov.or.nam%update_vbal_cov)) call mpl%abort('${subr}$', &
 & 'load_vbal is inconsistent with new_vbal_cov, load_vbal_cov or update_vbal_cov')
if (nam%new_vbal.and.nam%load_vbal) call mpl%abort('${subr}$','new_vbal and load_vbal are exclusive')
if (nam%new_var.and.nam%update_var) call mpl%abort('${subr}$','new_var and update_var are exclusive')
if (nam%new_mom.and.nam%update_mom) call mpl%abort('${subr}$','new_mom and update_mom are exclusive')
if (nam%new_mom.and.nam%load_mom) call mpl%abort('${subr}$','new_mom and load_mom are exclusive')
if (nam%load_mom.and.nam%update_mom) call mpl%abort('${subr}$','load_mom and update_mom are exclusive')
if (nam%load_mom.and.(.not.nam%load_samp_local)) call mpl%abort('${subr}$','load_mom requires load_samp_local')
if (nam%new_nicas.and.(nam%load_nicas_local.or.nam%load_nicas_global)) &
 & call mpl%abort('${subr}$','new_nicas and load_nicas_local/load_nicas_global are exclusive')
if (nam%check_vbal.and..not.(nam%new_vbal.or.nam%load_vbal)) &
 & call mpl%abort('${subr}$','new_vbal or load_vbal required for check_vbal')
if (nam%new_hdiag.and.(.not.(nam%new_mom.or.nam%update_mom.or.nam%load_mom))) &
 & call mpl%abort('${subr}$','new_mom, update_mom or load_mom required for new_hdiag')
if (nam%check_dirac.and..not.(nam%new_vbal.or.nam%load_vbal.or.(nam%new_hdiag.and.nam%write_hdiag).or.nam%new_nicas &
 & .or.nam%load_nicas_local.or.nam%load_nicas_global)) call mpl%abort('${subr}$','check_dirac not available')
if (nam%check_randomization) then
   if (nam%method/='cor') call mpl%abort('${subr}$','cor method required for check_randomization')
   if (.not.nam%new_nicas) call mpl%abort('${subr}$','new_nicas required for check_randomization')
end if
if (nam%check_consistency) then
   if (nam%method/='cor') call mpl%abort('${subr}$','cor method required for check_consistency')
   if (.not.nam%new_hdiag) call mpl%abort('${subr}$','new_hdiag required for check_consistency')
   if (nam%new_nicas) call mpl%abort('${subr}$','new_nicas forbidden for check_consistency')
end if
if (nam%check_optimality) then
   if (nam%method/='loc') call mpl%abort('${subr}$','loc method required for check_optimality')
   if (.not.nam%new_hdiag) call mpl%abort('${subr}$','new_hdiag required for check_optimality')
   if (nam%new_nicas) call mpl%abort('${subr}$','new_nicas forbidden for check_optimality')
end if

! Check and set files_param
nam%fname_var_used = any(nam%fname_var/='')
nam%fname_var(0) = trim(nam%prefix)//'var'
do isub=1,nsubmax
   if (nam%fname_var(isub)=='') write(nam%fname_var(isub),'(a,a,i6.6)') trim(nam%fname_var(0)),'_',isub
end do
if (nam%fname_samp=='') nam%fname_samp = trim(nam%prefix)//'sampling'
nam%fname_vbal_cov_used = any(nam%fname_vbal_cov/='')
nam%fname_vbal_cov(0) = trim(nam%prefix)//'vbal_cov'
do isub=1,nsubmax
   if (nam%fname_vbal_cov(isub)=='') write(nam%fname_vbal_cov(isub),'(a,a,i6.6)') trim(nam%fname_vbal_cov(0)),'_',isub
end do
if (nam%fname_vbal=='') nam%fname_vbal = trim(nam%prefix)//'vbal'
nam%fname_mom_used = any(nam%fname_mom/='')
nam%fname_mom(0) = trim(nam%prefix)//'mom'
do isub=1,nsubmax
   if (nam%fname_mom(isub)=='') write(nam%fname_mom(isub),'(a,a,i6.6)') trim(nam%fname_mom(0)),'_',isub
end do
if (nam%fname_nicas=='') nam%fname_nicas = trim(nam%prefix)//'nicas'
if (nam%fname_wind=='') nam%fname_wind = trim(nam%prefix)//'wind'

! Check model_param
if (nam%nl0<=0) call mpl%abort('${subr}$','nl0 should be positive')
do il0=1,nam%nl0
   if (nam%levs(il0)<=0) call mpl%abort('${subr}$','levs should be positive')
   if (count(nam%levs(1:nam%nl0)==nam%levs(il0))>1) call mpl%abort('${subr}$','duplicated levels')
end do
if ((nam%lev2d/='first').and.(nam%lev2d/='last')) call mpl%abort('${subr}$','wrong lev2d value')
if (nam%new_vbal_cov.or.nam%load_vbal_cov.or.nam%new_vbal.or.nam%load_vbal.or.nam%new_var.or.nam%update_var.or. &
 & nam%new_hdiag.or.nam%new_nicas.or.nam%load_nicas_local.or.nam%load_nicas_global) then
   do i=1,niokvmax
      if (((nam%io_keys(i)/='').and.(nam%io_values(i)=='')).or. &
 & ((nam%io_keys(i)=='').and.(nam%io_values(i)/=''))) &
 & call mpl%abort('${subr}$','io_keys and io_values are not consistent')
   end do
end if

! Check ens1_param
if (nam%new_normality.or.nam%new_vbal_cov.or.nam%update_vbal_cov.or.(nam%new_vbal.and.(.not.nam%load_vbal_cov)) &
 & .or.(nam%new_var.and.(.not.nam%forced_var)).or.nam%update_var.or.nam%new_mom.or.nam%update_mom &
 & .or.nam%check_randomization.or.nam%check_optimality) then
   if (nam%ens1_nsub<1) call mpl%abort('${subr}$','ens1_nsub should be positive')
   if (mod(nam%ens1_ne,nam%ens1_nsub)/=0) call mpl%abort('${subr}$','ens1_nsub should be a divider of ens1_ne')
   if (nam%ens1_ne/nam%ens1_nsub<=3) call mpl%abort('${subr}$','ens1_ne/ens1_nsub should be larger than 3')
end if

! Check ens2_param
if ((nam%new_mom.or.nam%update_mom).and.((nam%method=='hyb-rnd').or.(nam%method=='hyb-ens'))) then
   if (nam%ens2_nsub<1) call mpl%abort('${subr}$','ens2_nsub should be non-negative')
   if (mod(nam%ens2_ne,nam%ens2_nsub)/=0) call mpl%abort('${subr}$','ens2_nsub should be a divider of ens2_ne')
   if (nam%ens2_ne/nam%ens2_nsub<=3) call mpl%abort('${subr}$','ens2_ne/ens2_nsub should be larger than 3')
end if

! Check sampling_param
if (nam%new_vbal_cov.or.nam%new_vbal.or.nam%new_hdiag.or.nam%check_optimality) then
   if (nam%load_samp_local.and.nam%load_samp_global) call mpl%abort('${subr}$','load_samp_local and load_samp_global are exclusive')
   if (nam%load_samp_local.and.nam%write_samp_local) &
 & call mpl%abort('${subr}$','load_samp_local and write_samp_local are exclusive')
   if (nam%load_samp_global.and.nam%write_samp_global) &
 & call mpl%abort('${subr}$','load_samp_global and write_samp_global are exclusive')
   select case (nam%samp_draw_type)
   case ('random')
   case ('octahedral')
      if (nam%nldwv>0) call mpl%abort('${subr}$','no local diagnostics with an octahedral draw')
   case default
      call mpl%abort('${subr}$','wrong samp_draw_type')
   end select
   select case (nam%mask_type)
   case ('ldwv')
      if (nam%nldwv<=0) call mpl%abort('${subr}$','nldwv should not be negative for mask_type = ldwv')
   case ('stddev')
      do iv=1,nam%nv
         select case (nam%mask_lu(iv))
         case ('lower','upper')
         case default
            call mpl%abort('${subr}$','wrong mask_lu')
         end select
      end do
   end select
   if ((.not.(nam%load_samp_local.or.nam%load_samp_global)).and.(nam%nc1<3)) &
 & call mpl%abort('${subr}$','nc1 should be larger than 2')
   if (nam%new_vbal.or.(nam%new_hdiag.and.nam%local_diag)) then
      if ((.not.(nam%load_samp_local.or.nam%load_samp_global)).and.(nam%nc2<0)) &
 & call mpl%abort('${subr}$','nc2 should be non-negative')
   else
      if ((.not.(nam%load_samp_local.or.nam%load_samp_global)).and.(nam%nc2<0)) then
          call mpl%warning('${subr}$','nc2 should be set non-negative, resetting nc2 to zero')
          nam%nc2 = 0
      end if
   end if
else
   if (nam%write_samp_grids) call mpl%abort('${subr}$','new_vbal_cov, new_vbal or new_hdiag required for write_samp_grids')
end if
if (nam%load_vbal_cov.and.(.not.(nam%load_samp_local.or.nam%load_samp_global))) &
 & call mpl%abort('${subr}$','load_vbal_cov requires load_samp_local/global')
if (nam%write_vbal_cov.and.(.not.(nam%load_samp_local.or.nam%load_samp_global)) &
 & .and.(.not.(nam%write_samp_local.or.nam%write_samp_global))) &
 & call mpl%abort('${subr}$','write_vbal_cov requires write_samp_local/global if load_samp_local/global is not activated')
if (nam%load_vbal.and.(.not.(nam%load_samp_local.or.nam%load_samp_global))) &
 & call mpl%abort('${subr}$','load_vbal requires load_samp_local/global')
 if (nam%write_vbal.and.(.not.(nam%load_samp_local.or.nam%load_samp_global)) &
 & .and.(.not.(nam%write_samp_local.or.nam%write_samp_global))) &
 & call mpl%abort('${subr}$','write_vbal requires write_samp_local/global if load_samp_local/global is not activated')
if (nam%new_hdiag.or.nam%check_optimality) then
   if (nam%nc3<=0) call mpl%abort('${subr}$','nc3 should be positive')
   if (nam%nc4<=0) call mpl%abort('${subr}$','nc4 should be positive')
   if ((nam%nc4>1).and.(mod(nam%nc4,2)==1)) call mpl%abort('${subr}$','nc4 should be even')
   if (.not.(nam%dc>zero)) call mpl%abort('${subr}$','dc should be positive')
   if (nam%nl0r<1) call mpl%abort ('${subr}$','nl0r should be positive')
   if (.not.(nam%load_samp_local.or.nam%load_samp_global)) then
      if (nam%irmax<1) call mpl%abort ('${subr}$','irmax should be positive')
   end if
end if
select case (nam%samp_interp_type)
case ('c0','c1','si')
case default
   call mpl%abort('${subr}$','wrong sampling interpolation type')
end select

! Check diag_param
if (nam%new_vbal) then
   if (.not.((nam%vbal_rad>zero).or.(nam%vbal_dlat>zero))) call mpl%abort('${subr}$', &
 & 'vbal_rad or vbal_dlat should be positive')
   if ((nam%vbal_rad>zero).and.(nam%vbal_dlat>zero)) call mpl%abort('${subr}$', &
 & 'vbal_rad and vbal_dlat cannot be positive at the same time')
   if (nam%vbal_pseudo_inv) then
      if ((nam%vbal_pseudo_inv_mmax<=0).and.(.not.nam%vbal_pseudo_inv_var_th>zero)) call mpl%abort('${subr}$', &
 & 'dominant mode or variance threshold should be positive for pseudo-inverse')
   end if
end if
if (nam%new_var) then
   if (nam%forced_var) then
      do iv=1,nam%nv
         do il0=1,nam%nl0
            if (.not.(nam%stddev(il0,iv)>zero)) call mpl%abort('${subr}$','stddev should be positive')
         end do
      end do
      if (nam%var_filter) call mpl%abort('${subr}$','var_filter forbidden for forced_var')
   end if
   if (nam%var_filter) then
      if ((nam%var_niter>0).and.(nam%var_npass>0)) call mpl%abort('${subr}$','var_niter or var_npass only should be non-negative')
      if ((nam%var_niter>0).and.(nam%var_npass>0)) &
 & call mpl%abort('${subr}$','var_niter or var_npass should not be positive at te same time')
      if ((nam%var_niter>0).or.(nam%var_npass>0)) then
         do iv=1,nam%nv
            do il0=1,nam%nl0
               if (.not.(nam%var_rhflt(il0,iv)>zero)) call mpl%abort('${subr}$','var_rhflt should be positive')
            end do
         end do
      end if
   end if
end if
if (nam%new_hdiag.or.nam%check_optimality) then
   select case (nam%method)
   case ('loc','hyb-rnd','hyb-ens')
      if (nam%ne<=3) call mpl%abort('${subr}$','ne should be larger than 3')
   end select
   select case (nam%method)
   case ('hyb-rnd','hyb-ens')
      if (nam%ne_lr<=3) call mpl%abort('${subr}$','ne_lr should be larger than 3')
   end select
   if (.not.(nam%gen_kurt_th>zero)) call mpl%abort('${subr}$','gen_kurt_th should be positive')
   if (nam%local_diag) then
      if (.not.((nam%local_rad>zero).or.(nam%local_dlat>zero))) call mpl%abort('${subr}$', &
 & 'local_rad or local_dlat should be positive')
      if ((nam%local_rad>zero).and.(nam%local_dlat>zero)) call mpl%abort('${subr}$', &
 & 'local_rad and local_dlat cannot be positive at the same time')
   end if
end if
if (nam%check_optimality) then
   if (nam%optimality_nfac<1) call mpl%abort('${subr}$','optimality_nfac should be positive')
   if (.not.(nam%optimality_delta>zero)) call mpl%abort('${subr}$','optimality_delta should be positive')
   if (nam%optimality_ntest<1) call mpl%abort('${subr}$','optimality_ntest should be positive')
end if

! Check fit_param
if (nam%new_hdiag.or.nam%check_optimality) then
   if (nam%diag_rhflt<zero) call mpl%abort('${subr}$','diag_rhflt should be non-negative')
   if (nam%diag_rvflt<zero) call mpl%abort('${subr}$','diag_rvflt should be non-negative')
   if (nam%fit_dl0<=0) call mpl%abort('${subr}$','fit_dl0 should be postive')
   if (nam%fit_ncmp<=0) call mpl%abort('${subr}$','fit_ncmp should be postive')
   if (nam%write_hdiag_detail.and.(nam%fit_ncmp==1)) call mpl%abort('${subr}$', &
 & 'fit_ncmp should be larger than 1 for write_hdiag_detail')
end if

! Check ensemble sizes
if (nam%new_hdiag) then
   if (nam%method/='cor') then
      if (nam%ne>nam%ens1_ne) call mpl%warning('${subr}$','ensemble size larger than ens1_ne (might enhance sampling noise)')
      select case (nam%method)
      case ('hyb-rnd','hyb-ens')
         if (nam%ne_lr>nam%ens2_ne) call mpl%warning('${subr}$', &
 & 'hybrid ensemble size larger than ens2_ne (might enhance sampling noise)')
      end select
   end if
end if

! Check nicas_param
if (nam%new_nicas.or.nam%load_nicas_local.or.nam%load_nicas_global) then
   if ((nam%strategy=='common').or.(nam%strategy=='common_weighted')) then
      ivmin = 0
      ivmax = 0
   else
      ivmin = 1
      ivmax = nam%nv
   end if
   if (nam%check_randomization) then
      if (.not.nam%forced_radii) call mpl%abort('${subr}$','forced_radii required for check_randomization')
   end if
   if (nam%check_consistency) then
      if (.not.nam%forced_radii) call mpl%abort('${subr}$','forced_radii required for check_consistency')
   end if
   if (nam%check_optimality) then
      if (.not.nam%forced_radii) call mpl%abort('${subr}$','forced_radii required for check_optimality')
   end if
   if (nam%new_nicas) then
      if (.not.(nam%resol>zero)) call mpl%abort('${subr}$','resol should be positive')
      if (nam%nc1max<=0) call mpl%abort('${subr}$','nc1max should be positive')
   end if
   if (nam%forced_radii) then
      if (nam%new_hdiag.and.(.not.(nam%check_consistency.or.nam%check_optimality))) then
         select case (nam%method)
         case ('hyb-rnd')
         case default
           call mpl%abort('${subr}$','new_hdiag forbidden for forced_radii in this case')
         end select
      end if
      do iv=ivmin,ivmax
         do il0=1,nam%nl0
            if (nam%rh(il0,iv)<zero) call mpl%abort('${subr}$','rh should be non-negative')
            if (nam%rv(il0,iv)<zero) call mpl%abort('${subr}$','rv should be non-negative')
         end do
      end do
   end if
   if (nam%strategy=='common_weighted') then
      if (.not.allocated(nam%loc_wgt_sqrt)) call mpl%abort('${subr}$','loc_wgt should be specified for common_weighted')
   end if
   select case (nam%nicas_draw_type)
   case ('random')
   case ('octahedral')
      if (nam%nldwv>0) call mpl%abort('${subr}$','no local diagnostics with an octahedral draw')
   case default
      call mpl%abort('${subr}$','wrong nicas_draw_type')
   end select
   do iv=ivmin,ivmax
      select case (nam%nicas_interp_type(iv))
      case ('c0','c1','si')
      case default
         call mpl%abort('${subr}$','wrong nicas_interp_type')
      end select
   end do
end if
if (nam%write_nicas_grids.and.(.not.(nam%new_nicas.or.nam%load_nicas_global))) &
 & call mpl%abort('${subr}$','new_nicas or load_nicas_global required for write_nicas_grids')
if (nam%interp_test.and.(.not.(nam%new_nicas.or.nam%load_nicas_global))) &
 & call mpl%abort('${subr}$','new_nicas or load_nicas_global required for interp_test')
if (nam%load_nicas_local.and.nam%write_nicas_global) &
 & call mpl%abort('${subr}$','load_nicas_local and write_nicas_global are exclusive')

! Check dirac_param
if (nam%check_dirac) then
   if (nam%ndir<1) call mpl%abort('${subr}$','ndir should be positive')
   do idir=1,nam%ndir
      if ((nam%londir(idir)<-pi).or.(nam%londir(idir)>pi)) call mpl%abort('${subr}$','londir should lie between -180 and 180')
      if ((nam%latdir(idir)<-half*pi).or.(nam%latdir(idir)>half*pi)) call mpl%abort('${subr}$','latdir should lie between -90 and 90')
      if (.not.any(nam%levs(1:nam%nl0)==nam%levdir(idir))) call mpl%abort('${subr}$','wrong level for a Dirac')
      if ((nam%ivdir(idir)<1).or.(nam%ivdir(idir)>nam%nv)) call mpl%abort('${subr}$','wrong variable for a Dirac')
   end do
end if

! Check output_param
if (nam%new_hdiag) then
   if (nam%nldwv<0) call mpl%abort('${subr}$','nldwv should be non-negative')
   if (nam%nldwv>0) then
      if (.not.nam%local_diag) call mpl%abort('${subr}$','local_diag required for nldwv>0')
      if (any(nam%lon_ldwv(1:nam%nldwv)<-pi).or.any(nam%lon_ldwv(1:nam%nldwv)>pi)) &
 & call mpl%abort('${subr}$','lon_ldwv should lie between -180 and 180')
      if (any(nam%lat_ldwv(1:nam%nldwv)<-half*pi).or.any(nam%lat_ldwv(1:nam%nldwv)>half*pi)) &
 & call mpl%abort('${subr}$','lat_ldwv should lie between -90 and 90')
      do ildwv=1,nam%nldwv
         write(ildwvchar,'(i2.2)') ildwv
         if (nam%name_ldwv(ildwv)=='') call mpl%abort('${subr}$','name_ldwv not specified for profile '//ildwvchar)
      end do
   end if
end if

! Check wind_param
if (nam%new_wind) then
   if (nam%wind_nlon<3) call mpl%abort('${subr}$','wind_nlon should be larger than 3')
   if (nam%wind_nlat<3) call mpl%abort('${subr}$','wind_nlat should be larger than 3')
   if (nam%wind_nsg<1) call mpl%abort('${subr}$','wind_nsg should be positive')
   if (nam%wind_inflation<one) call mpl%abort('${subr}$','wind_inflation should be larger than 1')
end if

! Probe out
@:probe_out()

end subroutine nam_check

!----------------------------------------------------------------------
! Subroutine: nam_io_key_value
!> Get I/O value from key
!----------------------------------------------------------------------
subroutine nam_io_key_value(nam,io_key,io_value)

implicit none

! Passed variable
class(nam_type),intent(in) :: nam           !< Namelist
character(len=*),intent(in) :: io_key       !< I/O key
character(len=1024),intent(out) :: io_value !< I/O value

! Local variables
integer :: i

! Set name
@:set_name(nam_io_key_value)

! Probe in
@:probe_in()

! Loop over I/O key-value couples
io_value = io_key
do i=1,niokvmax
   if (nam%io_keys(i)==io_key) then
      io_value = nam%io_values(i)
      exit
   end if
end do

! Probe out
@:probe_out()

end subroutine nam_io_key_value

end module type_nam
