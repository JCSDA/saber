#:include '../instrumentation.fypp'
#:include '../generics.fypp'
!----------------------------------------------------------------------
! Module: tools_gc99
!> Gaspari and Cohn (1999)-inspired functions and their square-roots
! Author: Benjamin Menetrier
! Licensing: this code is distributed under the CeCILL-C license
! Copyright 2015-... UCAR, CERFACS, METEO-FRANCE and IRIT
! WARNING: this module is generated by the python script
!            tools/saber_fit_function.py
!          to modify this module, update and rerun the python script
! 2015-... UCAR, CERFACS, METEO-FRANCE and IRIT
!----------------------------------------------------------------------
module tools_gc99

use tools_const, only: zero,half,one,two
use tools_kinds, only: kind_real
use tools_netcdf, only: open_file,inquire_dim_size,get_att,inquire_var,get_var,close_file
use tools_repro, only: rth,eq,inf,sup
use type_mpl, only: mpl_type
@:use_probe()

implicit none

! Public parameters
logical :: fit_allocated = .false.
integer,parameter :: nnd = 51
integer,parameter :: npk = 31
integer,parameter :: nnl = 7
integer,parameter :: nscaleth = 7
integer,parameter :: ipkhdef = 13
integer,parameter :: ipkvdef = 1
real(kind_real),parameter :: ndmin = 0.00000000_kind_real
real(kind_real),parameter :: ndmax = 1.00000000_kind_real
real(kind_real),parameter :: pkmin = -2.00000000_kind_real
real(kind_real),parameter :: pkmax = 4.00000000_kind_real
real(kind_real),parameter :: pkhdef = 0.40000000_kind_real
real(kind_real),parameter :: pkvdef = -2.00000000_kind_real
real(kind_real),parameter :: nlmin = 0.00000000_kind_real
real(kind_real),parameter :: nlmax = 6.00000000_kind_real
real(kind_real),parameter :: dnd = 0.02000000_kind_real
real(kind_real),parameter :: dpk = 0.20000000_kind_real
real(kind_real),parameter :: dnl = 1.00000000_kind_real
real(kind_real),parameter :: scalethmin = 0.20000000_kind_real
real(kind_real),parameter :: scalethmax = 0.80000000_kind_real
real(kind_real),allocatable :: pk(:)
real(kind_real),allocatable :: nl(:)
real(kind_real),allocatable :: scaleth(:)
real(kind_real),allocatable :: scaleh(:,:)
real(kind_real),allocatable :: func_hor(:,:)
real(kind_real),allocatable :: scalev(:,:,:)
real(kind_real),allocatable :: func_ver(:,:,:)

interface fit_setup
   module procedure gc99_fit_setup
end interface
interface fit_dealloc
   module procedure gc99_fit_dealloc
end interface
interface fit_func
   module procedure gc99_fit_func
end interface
interface fit_func_sqrt
   module procedure gc99_fit_func_sqrt
end interface

private
public :: npk,nnl,nscaleth,scaleth,ipkhdef,ipkvdef,pkmin,pkmax,pkhdef,pkvdef,nlmin,nlmax,scalethmin,scalethmax,dpk,dnl
public :: pk,nl,scaleh,scalev
public :: fit_setup,fit_dealloc,fit_func,fit_func_sqrt

contains

!----------------------------------------------------------------------
! Subroutine: gc99_fit_setup
!> Fit setup
!----------------------------------------------------------------------
subroutine gc99_fit_setup(mpl)

! Passed variables
type(mpl_type),intent(inout) :: mpl !< MPI data

! Local variables
integer :: ncid,pk_id,nl_id,scaleth_id,scaleh_id,func_hor_id,scalev_id,func_ver_id
character(len=1024) :: filename 

! Set name
@:set_name(gc99_fit_setup)

! Probe in
@:probe_in()

if (.not.fit_allocated) then
   if (mpl%main) then
      ! Get file name
      filename = '${_FILE_}$.nc'

      ! Open file
      ncid = open_file(mpl,filename,0,.true.)
   end if

   ! Allocation
   allocate(pk(npk))
   allocate(nl(nnl))
   allocate(scaleth(nscaleth))
   allocate(scaleh(npk,nscaleth))
   allocate(func_hor(npk,nnd))
   allocate(scalev(nnl,npk,nscaleth))
   allocate(func_ver(nnl,npk,nnd))

   if (mpl%main) then
      ! Inquire variable
      pk_id = inquire_var(mpl,ncid,'pk')
      nl_id = inquire_var(mpl,ncid,'nl')
      scaleth_id = inquire_var(mpl,ncid,'scaleth')
      scaleh_id = inquire_var(mpl,ncid,'scaleh')
      func_hor_id = inquire_var(mpl,ncid,'func_hor')
      scalev_id = inquire_var(mpl,ncid,'scalev')
      func_ver_id = inquire_var(mpl,ncid,'func_ver')

      ! Read variable
      call get_var(mpl,ncid,pk_id,pk)
      call get_var(mpl,ncid,nl_id,nl)
      call get_var(mpl,ncid,scaleth_id,scaleth)
      call get_var(mpl,ncid,scaleh_id,scaleh)
      call get_var(mpl,ncid,func_hor_id,func_hor)
      call get_var(mpl,ncid,scalev_id,scalev)
      call get_var(mpl,ncid,func_ver_id,func_ver)

      ! Close file
      call close_file(mpl,ncid)
   end if

   ! Broadcast variables
   call mpl%f_comm%broadcast(pk,mpl%rootproc-1)
   call mpl%f_comm%broadcast(nl,mpl%rootproc-1)
   call mpl%f_comm%broadcast(scaleth,mpl%rootproc-1)
   call mpl%f_comm%broadcast(scaleh,mpl%rootproc-1)
   call mpl%f_comm%broadcast(func_hor,mpl%rootproc-1)
   call mpl%f_comm%broadcast(scalev,mpl%rootproc-1)
   call mpl%f_comm%broadcast(func_ver,mpl%rootproc-1)

   ! Set flag
   fit_allocated = .true.
end if

! Probe out
@:probe_out()

end subroutine gc99_fit_setup

!----------------------------------------------------------------------
! Subroutine: gc99_fit_dealloc
!> Fit setup
!----------------------------------------------------------------------
subroutine gc99_fit_dealloc()

! Set name
@:set_name(gc99_fit_dealloc)

! Probe in
@:probe_in()

! Release memory
if (allocated(pk)) deallocate(pk)
if (allocated(nl)) deallocate(nl)
if (allocated(scaleth)) deallocate(scaleth)
if (allocated(scaleh)) deallocate(scaleh)
if (allocated(func_hor)) deallocate(func_hor)
if (allocated(scalev)) deallocate(scalev)
if (allocated(func_ver)) deallocate(func_ver)

! Reset flag
fit_allocated = .false.

! Probe out
@:probe_out()

end subroutine gc99_fit_dealloc

!----------------------------------------------------------------------
! Function: gc99_fit_func
!> Fit function
!----------------------------------------------------------------------
function gc99_fit_func(mpl,dir,nd,pk,nl) result(value)

! Passed variables
type(mpl_type),intent(inout) :: mpl !< MPI data
character(len=*),intent(in) :: dir  !< Direction
real(kind_real),intent(in) :: nd    !< Normalized distance
real(kind_real),intent(in) :: pk    !< Peakness
real(kind_real),intent(in) :: nl    !< Negative lobe parameter

! Returned variable
real(kind_real) :: value

! Local variables
integer :: indm,indp,ipkm,ipkp,inlm,inlp
real(kind_real) :: bnd,bpk,bnl,rndm,rndp,rpkm,rpkp,rnlm,rnlp

! Set name
@:set_name(gc99_fit_func)

! Probe in
@:probe_in()

! Check bounds
if (inf(nd,zero)) call mpl%abort('${subr}$','negative normalized distance')
if (inf(pk,pkmin).or.sup(pk,pkmax)) call mpl%abort('${subr}$','peakness out of bounds')
if (inf(nl,nlmin).or.sup(nl,nlmax)) call mpl%abort('${subr}$','negative lobe out of bounds')

if (eq(nd,zero)) then
   ! Origin
   value = one
elseif (sup(nd,one)) then
   ! Out of support
   value = zero
else
   ! Bounded values
   bnd = max(ndmin,min(nd,ndmax))
   bpk = max(pkmin,min(pk,pkmax))
   bnl = max(nlmin,min(nl,nlmax))

   ! Indices
   indm = floor(bnd/dnd)+1
   if (indm==nnd) then
      indp = indm
   else
      indp = indm+1
   end if
   ipkm = floor((bpk-pkmin)/dpk)+1
   if (ipkm==npk) then
      ipkp = ipkm
   else
      ipkp = ipkm+1
   end if
   inlm = floor((bnl-nlmin)/dnl)+1
   if (inlm==nnl) then
      inlp = inlm
   else
      inlp = inlm+1
   end if

   ! Coefficients
   if (indm==nnd) then
      rndm = one
   else
      rndm = real(indp-1,kind_real)-bnd/dnd
   end if
   rndp = (one-rndm)
   if (ipkm==npk) then
      rpkm = one
   else
      rpkm = real(ipkp-1,kind_real)-(bpk-pkmin)/dpk
   end if
   rpkp = (one-rpkm)
   if (inlm==nnl) then
      rnlm = one
   else
      rnlm = real(inlp-1,kind_real)-(bnl-nlmin)/dnl
   end if
   rnlp = (one-rnlm)

   ! Interpolated value
   if (dir=='hor') then
      ! Horizontal fit function
      value = rndm*rpkm*func_hor(ipkm,indm) &
 & +rndp*rpkm*func_hor(ipkm,indp) &
 & +rndm*rpkp*func_hor(ipkp,indm) &
 & +rndp*rpkp*func_hor(ipkp,indp)
   elseif (dir=='ver') then
      ! Vertical fit function
      value = rndm*rpkm*rnlm*func_ver(inlm,ipkm,indm) &
 & +rndp*rpkm*rnlm*func_ver(inlm,ipkm,indp) &
 & +rndm*rpkp*rnlm*func_ver(inlm,ipkp,indm) &
 & +rndp*rpkp*rnlm*func_ver(inlm,ipkp,indp) &
 & +rndm*rpkm*rnlp*func_ver(inlp,ipkm,indm) &
 & +rndp*rpkm*rnlp*func_ver(inlp,ipkm,indp) &
 & +rndm*rpkp*rnlp*func_ver(inlp,ipkp,indm) &
 & +rndp*rpkp*rnlp*func_ver(inlp,ipkp,indp)
   else
      call mpl%abort('${subr}$','wrong direction: '//dir)
   end if
end if

! Probe out
@:probe_out()

end function gc99_fit_func

!----------------------------------------------------------------------
! Function: gc99_fit_func_sqrt
!> Fit function function square-root
!----------------------------------------------------------------------
function gc99_fit_func_sqrt(mpl,nd,pk,nl) result(value)

! Passed variables
type(mpl_type),intent(inout) :: mpl !< MPI data
real(kind_real),intent(in) :: nd    !< Normalized distance
real(kind_real),intent(in) :: pk    !< Peakness
real(kind_real),intent(in) :: nl    !< Negative lobe parameter

! Returned variable
real(kind_real) :: value

! Set name
@:set_name(gc99_fit_func_sqrt)

! Probe in
@:probe_in()

! Check bounds
if (inf(nd,zero)) call mpl%abort('${subr}$','negative normalized distance')

if (eq(nd,zero)) then
   ! Origin
   value = one
elseif (sup(nd,half)) then
   ! Out of support
   value = zero
else
   if (pk>zero) then
      value = (one-two*nd)/(one+two*nd*(pk+pk**4))
   else
      value = one-(two*nd)**(one+pk**2)
   end if
   if (sup(nl,zero)) value = value*(one-(two*nd*nl)**2)*(one-two*nd)
end if

! Probe out
@:probe_out()

end function gc99_fit_func_sqrt

end module tools_gc99
