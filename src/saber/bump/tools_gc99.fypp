#:include '../instrumentation.fypp'
#:include '../generics.fypp'
!----------------------------------------------------------------------
! Module: tools_gc99
!> Gaspari and Cohn (1999)-inspired functions and their square-roots
! Author: Benjamin Menetrier
! Licensing: this code is distributed under the CeCILL-C license
! Copyright 2015-... UCAR, CERFACS, METEO-FRANCE and IRIT
! WARNING: this module is generated by the python script
!            tools/saber_fit_function.py
!          to modify this module, update and rerun the python script
! 2015-... UCAR, CERFACS, METEO-FRANCE and IRIT
!----------------------------------------------------------------------
module tools_gc99

use tools_const, only: zero,half,one,two
use tools_kinds, only: kind_real
use tools_netcdf, only: open_file,inquire_dim_size,get_att,inquire_var,get_var,close_file
use tools_repro, only: rth,eq,inf,infeq,sup
use type_mpl, only: mpl_type
@:use_probe()

implicit none

! Public parameters
logical :: fit_allocated = .false.
integer,parameter :: nnd = 51
integer,parameter :: nscaleth = 8
real(kind_real),parameter :: ndmin = 0.00000000_kind_real
real(kind_real),parameter :: ndmax = 1.00000000_kind_real
real(kind_real),parameter :: dnd = 0.02000000_kind_real
real(kind_real),parameter :: scalethmin = 0.20000000_kind_real
real(kind_real),parameter :: scalethmax = 0.90000000_kind_real
real(kind_real),allocatable :: scaleth(:)
real(kind_real),allocatable :: scaleh(:)
real(kind_real),allocatable :: func_hor(:)
real(kind_real),allocatable :: scalev(:)
real(kind_real),allocatable :: func_ver(:)

interface fit_setup
   module procedure gc99_fit_setup
end interface
interface fit_dealloc
   module procedure gc99_fit_dealloc
end interface
interface fit_func
   module procedure gc99_fit_func
end interface
interface fit_func_sqrt
   module procedure gc99_fit_func_sqrt
end interface

private
public :: nscaleth,scaleth,scalethmin,scalethmax
public :: scaleh,scalev
public :: fit_setup,fit_dealloc,fit_func,fit_func_sqrt

contains

!----------------------------------------------------------------------
! Subroutine: gc99_fit_setup
!> Fit setup
!----------------------------------------------------------------------
subroutine gc99_fit_setup(mpl)

! Passed variables
type(mpl_type),intent(inout) :: mpl !< MPI data

! Local variables
integer :: ncid,scaleth_id,scaleh_id,func_hor_id,scalev_id,func_ver_id
character(len=1024) :: filename

! Set name
@:set_name(gc99_fit_setup)

! Probe in
@:probe_in()

if (.not.fit_allocated) then
   if (mpl%main) then
      ! Get file name
      filename = '${_FILE_}$.nc'

      ! Open file
      ncid = open_file(mpl,filename,0,.true.)
   end if

   ! Allocation
   allocate(scaleth(nscaleth))
   allocate(scaleh(nscaleth))
   allocate(func_hor(nnd))
   allocate(scalev(nscaleth))
   allocate(func_ver(nnd))

   if (mpl%main) then
      ! Inquire variable
      scaleth_id = inquire_var(mpl,ncid,'scaleth')
      scaleh_id = inquire_var(mpl,ncid,'scaleh')
      func_hor_id = inquire_var(mpl,ncid,'func_hor')
      scalev_id = inquire_var(mpl,ncid,'scalev')
      func_ver_id = inquire_var(mpl,ncid,'func_ver')

      ! Read variable
      call get_var(mpl,ncid,scaleth_id,scaleth)
      call get_var(mpl,ncid,scaleh_id,scaleh)
      call get_var(mpl,ncid,func_hor_id,func_hor)
      call get_var(mpl,ncid,scalev_id,scalev)
      call get_var(mpl,ncid,func_ver_id,func_ver)

      ! Close file
      call close_file(mpl,ncid)
   end if

   ! Broadcast variables
   call mpl%f_comm%broadcast(scaleth,mpl%rootproc-1)
   call mpl%f_comm%broadcast(scaleh,mpl%rootproc-1)
   call mpl%f_comm%broadcast(func_hor,mpl%rootproc-1)
   call mpl%f_comm%broadcast(scalev,mpl%rootproc-1)
   call mpl%f_comm%broadcast(func_ver,mpl%rootproc-1)

   ! Set flag
   fit_allocated = .true.
end if

! Probe out
@:probe_out()

end subroutine gc99_fit_setup

!----------------------------------------------------------------------
! Subroutine: gc99_fit_dealloc
!> Fit setup
!----------------------------------------------------------------------
subroutine gc99_fit_dealloc()

! Set name
@:set_name(gc99_fit_dealloc)

! Probe in
@:probe_in()

! Release memory
if (allocated(scaleth)) deallocate(scaleth)
if (allocated(scaleh)) deallocate(scaleh)
if (allocated(func_hor)) deallocate(func_hor)
if (allocated(scalev)) deallocate(scalev)
if (allocated(func_ver)) deallocate(func_ver)

! Reset flag
fit_allocated = .false.

! Probe out
@:probe_out()

end subroutine gc99_fit_dealloc

!----------------------------------------------------------------------
! Function: gc99_fit_func
!> Fit function
!----------------------------------------------------------------------
function gc99_fit_func(mpl,dir,nd) result(value)

! Passed variables
type(mpl_type),intent(inout) :: mpl !< MPI data
character(len=*),intent(in) :: dir  !< Direction
real(kind_real),intent(in) :: nd    !< Normalized distance

! Returned variable
real(kind_real) :: value

! Local variables
integer :: indm,indp
real(kind_real) :: rndm,rndp

! Set name
@:set_name(gc99_fit_func)

! Probe in
@:probe_in()

! Check bounds
if (inf(nd,zero)) call mpl%abort('${subr}$','negative normalized distance')

! Initialization
value = zero

if (eq(nd,zero)) then
   ! Origin
   value = one
elseif (infeq(nd,one)) then
   ! Indices
   indm = floor(nd/dnd)+1
   if (indm==nnd) then
      indp = indm
   else
      indp = indm+1
   end if

   ! Coefficients
   if (indm==nnd) then
      rndm = one
   else
      rndm = real(indp-1,kind_real)-nd/dnd
   end if
   rndp = (one-rndm)

   ! Interpolated value
   if (dir=='hor') then
      ! Horizontal fit function
      value = rndm*func_hor(indm)+rndp*func_hor(indp)
   elseif (dir=='ver') then
      ! Vertical fit function
      value = rndm*func_ver(indm)+rndp*func_ver(indp)
   else
      call mpl%abort('${subr}$','wrong direction: '//dir)
   end if
end if

! Probe out
@:probe_out()

end function gc99_fit_func

!----------------------------------------------------------------------
! Function: gc99_fit_func_sqrt
!> Fit function function square-root
!----------------------------------------------------------------------
function gc99_fit_func_sqrt(mpl,nd) result(value)

! Passed variables
type(mpl_type),intent(inout) :: mpl !< MPI data
real(kind_real),intent(in) :: nd    !< Normalized distance

! Returned variable
real(kind_real) :: value

! Set name
@:set_name(gc99_fit_func_sqrt)

! Probe in
@:probe_in()

! Check bounds
if (inf(nd,zero)) call mpl%abort('${subr}$','negative normalized distance')

! Initialization
value = zero

if (eq(nd,zero)) then
   ! Origin
   value = one
elseif (infeq(nd,half)) then
   value = one-(two*nd)
end if

! Probe out
@:probe_out()

end function gc99_fit_func_sqrt

end module tools_gc99
