#:include 'generics.fypp'
#:include 'instrumentation.fypp'
!----------------------------------------------------------------------
! Module: type_geom
!> Geometry derived type
! Author: Benjamin Menetrier
! Licensing: this code is distributed under the CeCILL-C license
! Copyright 2015-... UCAR, CERFACS, METEO-FRANCE and IRIT
!----------------------------------------------------------------------
module type_geom

use atlas_module, only: atlas_config,atlas_connectivity,atlas_field,atlas_functionspace, &
 & atlas_functionspace_nodecolumns,atlas_functionspace_pointcloud,atlas_functionspace_structuredcolumns,atlas_json,atlas_mesh, &
 & atlas_mesh_nodes,atlas_projection,atlas_structuredgrid
! TODO(Benjamin): This should be removed once spack-stack uses the ATLAS version where this interface is merged
use atlas_buildnode2cellconnectivity, only: atlas_build_node_to_cell_connectivity
use fckit_mpi_module, only: fckit_mpi_sum,fckit_mpi_min,fckit_mpi_max,fckit_mpi_status
!$ use omp_lib
use tools_atlas, only: get_grid,field_to_array,get_atlas_functionspace_size
use tools_const, only: zero,quarter,half,one,two,three,four,hundred,pi,req,deg2rad,rad2deg,reqkm
use tools_func, only: fletcher32,lonlatmod,grid_hash,independent_levels,sphere_dist,lonlat2xyz,xyz2lonlat,cart_dist, &
 & vector_product,area,cx_to_cxa,cx_to_proc,cx_to_cxu,convert_l2i,convert_i2l,zss_maxval,zss_minval,zss_sum,zss_count
use tools_kinds, only: kind_int,kind_real,huge_real,huge_int
use tools_qsort, only: qsort
use tools_repro, only: inf,sup,eq,infeq,supeq,indist,repro_th
use type_bnda, only: bnda_type
use type_com, only: com_type
use type_fieldset, only: fieldset_type
use type_hull, only: hull_type
use type_io, only: io_type
use type_linop, only: linop_type
use type_mesh, only: mesh_type
use type_mpl, only: mpl_type
use type_nam, only: nam_type
@:use_probe()
use type_rng, only: rng_type
use type_tree, only: tree_type

implicit none

! Geometry derived type
type geom_type
   ! Number of processors
   integer :: nproc                                   !< Number of processors

   ! Input metadata
   logical,allocatable :: owned_mga(:,:)              !< Owned vs Halo/BC

   ! Domain type
   logical :: global                                  !< Global grid flag (regional if false)

   ! Regional work grid
   type(atlas_config) :: aconfig_work_grid            !< Work grid configuration
   type(atlas_projection) :: aproj_work               !< Work grid projection
   real(kind_real) :: lon_center                      !< Work grid center longitude
   real(kind_real) :: lat_center                      !< Work grid center latitude
   real(kind_real) :: xmin                            !< Computational work grid minimum x value
   real(kind_real) :: xmax                            !< Computational work grid maximum x value
   real(kind_real) :: ymin                            !< Computational work grid minimum y value
   real(kind_real) :: ymax                            !< Computational work grid maximum y value

   ! Geometry data on model grid, halo A
   integer :: nmga                                    !< Halo A size for model grid
   real(kind_real),allocatable :: lon_mga(:)          !< Longitudes
   real(kind_real),allocatable :: lat_mga(:)          !< Latitudes
   real(kind_real),allocatable :: vert_coord_mga(:,:) !< Generalized vertical coordinate
   logical,allocatable :: gmask_mga(:,:)              !< Geometry mask
   type(atlas_functionspace) :: afunctionspace_mg     !< ATLAS function space of model grid

   ! Link between model grid and subset Sc0 on halo A
   integer,allocatable :: c0a_to_mga(:)               !< Subset Sc0 to model grid on halo A

   ! Geometry data on model grid, global
   integer :: nmg                                     !< Number of model grid points

   ! Universe
   logical,allocatable :: myuniverse(:)               !< MPI tasks in the universe of the local task

   ! Geometry data on subset Sc0, halo A
   integer,allocatable :: proc_to_nc0a(:)             !< Processor to halo A size for subset Sc0
   integer :: nc0a                                    !< Halo A size for subset Sc0
   logical :: same_grid                               !< Same grid and distribution flag
   real(kind_real),allocatable :: lon_c0a(:)          !< Longitudes
   real(kind_real),allocatable :: lat_c0a(:)          !< Latitudes
   real(kind_real),allocatable :: vert_coord_c0a(:,:) !< Generalized vertical coordinate
   logical,allocatable :: gmask_c0a(:,:)              !< Geometry mask
   logical,allocatable :: gmask_hor_c0a(:)            !< Union of horizontal geometry masks
   real(kind_real),allocatable :: mdist_c0a(:,:)      !< Minimum distance to mask

   ! Geometry data on subset Sc0, universe
   integer,allocatable :: proc_to_nc0u(:)             !< Processor to universe size for subset Sc0
   integer :: nc0u                                    !< Universe size for subset Sc0
   real(kind_real),allocatable :: lon_c0u(:)          !< Longitudes
   real(kind_real),allocatable :: lat_c0u(:)          !< Latitudes
   real(kind_real),allocatable :: vert_coord_c0u(:,:) !< Generalized vertical coordinate
   logical,allocatable :: gmask_c0u(:,:)              !< Geometry mask
   logical,allocatable :: gmask_hor_c0u(:)            !< Union of horizontal geometry masks
   real(kind_real),allocatable :: mdist_c0u(:,:)      !< Minimum distance to mask

   ! Geometry data on subset Sc0, global
   integer :: nc0                                     !< Number of subset Sc0 points
   integer,allocatable :: proc_to_c0_offset(:)        !< Processor to offset on subset Sc0
   integer,allocatable :: nc0_gmask(:)                !< Horizontal mask size on subset Sc0
   real(kind_real) :: area                            !< Domain area
   real(kind_real),allocatable :: area_ver_c0(:)      !< Area profile on subset Sc0
   real(kind_real) :: area_max_c0                     !< Area maximum on subset Sc0

   ! Link between halo A and universe on subset Sc0
   integer,allocatable :: c0a_to_c0u(:)               !< Halo A to universe on subset Sc0
   integer,allocatable :: c0u_to_c0a(:)               !< Universe to halo A on subset Sc0
   type(com_type) :: com_AU                           !< Communication between halo A and universe on subset Sc0

   ! Link between halo A and global on subset Sc0
   integer,allocatable :: c0a_to_c0(:)                !< Subset Sc0, halo A to global

   ! Link between universe and global on subset Sc0
   integer,allocatable :: c0u_to_c0(:)                !< Subset Sc0, universe to global

   ! Number of levels
   integer :: nl0                                     !< Number of levels in subset Sl0
   integer,allocatable :: l0rl0_to_l0(:,:)            !< Reduced level to level
   integer,allocatable :: il0rz(:)                    !< Reduced level at zero separation
   integer :: nl0i                                    !< Number of independent levels in subset Sl0
   integer,allocatable :: l0_to_l0i(:)                !< Levels to independent levels in Sl0
   integer,allocatable :: l0i_to_l0(:)                !< Independent levels to level in Sl0

   ! Other fields
   real(kind_real),allocatable :: vert_coordavg(:)    !< Averaged vertical coordinate
   real(kind_real),allocatable :: disth(:)            !< Horizontal distance
   real(kind_real),allocatable :: as(:)               !< Angular sectors
   real(kind_real) :: das                             !< Angular sector width

   ! Tree
   type(tree_type) :: tree_c0u                        !< Tree on subset Sc0, universe

   ! Boundaries
   type(bnda_type) :: bnda_c0u                        !< Boundaries on subset Sc0, universe

   ! Hull
   type(hull_type) :: hull_c0u                        !< Domain hull on subset Sc0, universe

   ! Dirac fields for variables
   integer :: ndir                                    !< Number of valid Dirac points
   real(kind_real),allocatable :: londir(:)           !< Dirac longitude
   real(kind_real),allocatable :: latdir(:)           !< Dirac latitude
   integer,allocatable :: iprocdir(:)                 !< Dirac processor
   integer,allocatable :: ic0adir(:)                  !< Dirac gridpoint
   integer,allocatable :: il0dir(:)                   !< Dirac level
   integer,allocatable :: ivdir(:)                    !< Dirac field index
   integer,allocatable :: inbdir(:,:)                 !< Neighboring dirac index

   ! I/O
   type(io_type) :: io                                !< Subset Sc0 I/O

   ! Allocation flag
   logical :: allocated                               !< Allocation flag
contains
   procedure :: partial_dealloc => geom_partial_dealloc
   procedure :: dealloc => geom_dealloc
   procedure :: setup => geom_setup
   procedure :: from_atlas => geom_from_atlas
   procedure :: setup_universe => geom_setup_universe
   procedure :: setup_c0 => geom_setup_c0
   procedure :: geom_index_from_lonlat_r0
   procedure :: geom_index_from_lonlat_r1
   generic :: index_from_lonlat => geom_index_from_lonlat_r0,geom_index_from_lonlat_r1
   procedure :: setup_dirac => geom_setup_dirac
   #:for dtype in dtypes_irl
      procedure :: geom_copy_c0a_to_mga_${dtype}$_single
      procedure :: geom_copy_c0a_to_mga_${dtype}$_all
      procedure :: geom_copy_mga_to_c0a_${dtype}$_single
      procedure :: geom_copy_mga_to_c0a_${dtype}$_all
   #:endfor
@:init_procedure(6)
   generic :: copy_c0a_to_mga => &
   #:for dtype in dtypes_irl
@:add_procedure(geom_copy_c0a_to_mga_${dtype}$_single)
@:add_procedure(geom_copy_c0a_to_mga_${dtype}$_all)
   #:endfor
@:init_procedure(6)
   generic :: copy_mga_to_c0a => &
   #:for dtype in dtypes_irl
@:add_procedure(geom_copy_mga_to_c0a_${dtype}$_single)
@:add_procedure(geom_copy_mga_to_c0a_${dtype}$_all)
   #:endfor
   procedure :: fieldset_to_c0 => geom_fieldset_to_c0
   procedure :: c0_to_fieldset => geom_c0_to_fieldset
   procedure :: rand_point => geom_rand_point
   procedure :: initialize_sampling => geom_initialize_sampling
   procedure :: define_test_vectors => geom_define_test_vectors
   procedure :: c0_to_c0a => geom_c0_to_c0a
   procedure :: c0_to_proc => geom_c0_to_proc
   procedure :: c0_to_c0u => geom_c0_to_c0u
end type geom_type

integer,parameter :: nzoom = 10          !< Number of zoom iteration to compute the work grid
integer,parameter :: ntest = 10         !< Number of test values to compute the work grid
integer,parameter :: nfacmin = 4        !< Minimum size factor for the first subsampling
integer,parameter :: nsmax = 1000000    !< Maximum sampling size
logical,parameter :: parallel = .false. !< Parallel sampling (can be slow because of communications)
integer,parameter :: ntry = 10          !< Number of random points generated for sampling selection
real(kind_real),parameter :: frep = 0.2 !< Extra-points removal factor

private
public :: geom_type

contains

!----------------------------------------------------------------------
! Subroutine: geom_partial_dealloc
!> Release memory (partial)
!----------------------------------------------------------------------
subroutine geom_partial_dealloc(geom)

implicit none

! Passed variables
class(geom_type),intent(inout) :: geom !< Geometry

! Set name
@:set_name(geom_partial_dealloc)

! Probe in
@:probe_in()

! Release memory
if (allocated(geom%l0rl0_to_l0)) deallocate(geom%l0rl0_to_l0)
if (allocated(geom%il0rz)) deallocate(geom%il0rz)
if (allocated(geom%lon_mga)) deallocate(geom%lon_mga)
if (allocated(geom%lat_mga)) deallocate(geom%lat_mga)
if (allocated(geom%vert_coord_mga)) deallocate(geom%vert_coord_mga)
if (allocated(geom%myuniverse)) deallocate(geom%myuniverse)
if (allocated(geom%proc_to_nc0a)) deallocate(geom%proc_to_nc0a)
if (allocated(geom%gmask_hor_c0a)) deallocate(geom%gmask_hor_c0a)
if (allocated(geom%mdist_c0a)) deallocate(geom%mdist_c0a)
if (allocated(geom%proc_to_nc0u)) deallocate(geom%proc_to_nc0u)
if (allocated(geom%lon_c0u)) deallocate(geom%lon_c0u)
if (allocated(geom%lat_c0u)) deallocate(geom%lat_c0u)
if (allocated(geom%vert_coord_c0u)) deallocate(geom%vert_coord_c0u)
if (allocated(geom%gmask_c0u)) deallocate(geom%gmask_c0u)
if (allocated(geom%gmask_hor_c0u)) deallocate(geom%gmask_hor_c0u)
if (allocated(geom%mdist_c0u)) deallocate(geom%mdist_c0u)
if (allocated(geom%proc_to_c0_offset)) deallocate(geom%proc_to_c0_offset)
if (allocated(geom%c0a_to_c0u)) deallocate(geom%c0a_to_c0u)
if (allocated(geom%c0u_to_c0a)) deallocate(geom%c0u_to_c0a)
call geom%com_AU%dealloc
if (allocated(geom%c0a_to_c0)) deallocate(geom%c0a_to_c0)
if (allocated(geom%c0u_to_c0)) deallocate(geom%c0u_to_c0)
if (allocated(geom%nc0_gmask)) deallocate(geom%nc0_gmask)
if (allocated(geom%l0i_to_l0)) deallocate(geom%l0i_to_l0)
if (allocated(geom%area_ver_c0)) deallocate(geom%area_ver_c0)
if (allocated(geom%vert_coordavg)) deallocate(geom%vert_coordavg)
if (allocated(geom%disth)) deallocate(geom%disth)
if (allocated(geom%as)) deallocate(geom%as)
call geom%tree_c0u%dealloc
call geom%bnda_c0u%dealloc
call geom%hull_c0u%dealloc
if (allocated(geom%londir)) deallocate(geom%londir)
if (allocated(geom%latdir)) deallocate(geom%latdir)
if (allocated(geom%iprocdir)) deallocate(geom%iprocdir)
if (allocated(geom%ic0adir)) deallocate(geom%ic0adir)
if (allocated(geom%il0dir)) deallocate(geom%il0dir)
if (allocated(geom%ivdir)) deallocate(geom%ivdir)
if (allocated(geom%inbdir)) deallocate(geom%inbdir)

! Probe out
@:probe_out()

end subroutine geom_partial_dealloc

!----------------------------------------------------------------------
! Subroutine: geom_dealloc
!> Release memory
!----------------------------------------------------------------------
subroutine geom_dealloc(geom)

implicit none

! Passed variables
class(geom_type),intent(inout) :: geom !< Geometry

! Set name
@:set_name(geom_dealloc)

! Probe in
@:probe_in()

! Release memory
call geom%partial_dealloc
call geom%afunctionspace_mg%final()
if (allocated(geom%gmask_mga)) deallocate(geom%gmask_mga)
if (allocated(geom%c0a_to_mga)) deallocate(geom%c0a_to_mga)
if (allocated(geom%lon_c0a)) deallocate(geom%lon_c0a)
if (allocated(geom%lat_c0a)) deallocate(geom%lat_c0a)
if (allocated(geom%vert_coord_c0a)) deallocate(geom%vert_coord_c0a)
if (allocated(geom%gmask_c0a)) deallocate(geom%gmask_c0a)
if (allocated(geom%l0_to_l0i)) deallocate(geom%l0_to_l0i)
call geom%io%dealloc
geom%allocated = .false.

! Probe out
@:probe_out()

end subroutine geom_dealloc

!----------------------------------------------------------------------
! Subroutine: geom_setup
!> Setup geometry
!----------------------------------------------------------------------
subroutine geom_setup(geom,mpl,rng,nam,afunctionspace,fieldset)

implicit none

! Passed variables
class(geom_type),intent(inout) :: geom                 !< Geometry
type(mpl_type),intent(inout) :: mpl                    !< MPI data
type(rng_type),intent(inout) :: rng                    !< Random number generator
type(nam_type),intent(in) :: nam                       !< Namelist
type(atlas_functionspace),intent(in) :: afunctionspace !< ATLAS function space
type(fieldset_type),intent(in),optional :: fieldset    !< Fieldset containing geometry elements

! Local variables
integer :: il0,jl0off,jl0r,jc3,jc4,iproc
integer,allocatable :: order_c0(:),order_c0a(:)
real(kind_real),allocatable :: lon_c0(:),lat_c0(:)
type(mesh_type) :: mesh_c0u

! Set name
@:set_name(geom_setup)

! Probe in
@:probe_in()

! Number of processors
geom%nproc = mpl%nproc

! Number of levels
geom%nl0 = nam%nl0

! Reduced number of levels
allocate(geom%l0rl0_to_l0(nam%nl0r,geom%nl0))
allocate(geom%il0rz(geom%nl0))
do il0=1,geom%nl0
   jl0off = il0-(nam%nl0r-1)/2-1
   if (jl0off<1) jl0off = 0
   if (jl0off+nam%nl0r>geom%nl0) jl0off = geom%nl0-nam%nl0r
   do jl0r=1,nam%nl0r
      geom%l0rl0_to_l0(jl0r,il0) = jl0off+jl0r
      if (geom%l0rl0_to_l0(jl0r,il0)==il0) geom%il0rz(il0) = jl0r
   end do
end do

! Copy function space pointer
if (present(fieldset)) then
   call geom%from_atlas(mpl,nam,afunctionspace,fieldset)
else
   call geom%from_atlas(mpl,nam,afunctionspace)
end if

! Setup subset Sc0
call geom%setup_c0(mpl)

! Setup universe
call geom%setup_universe(mpl,rng,nam)

! Setup tree
write(mpl%info,'(a7,a)') '','Setup tree'
call mpl%flush
call geom%tree_c0u%init(geom%nc0u,geom%lon_c0u,geom%lat_c0u)

! Setup hull
write(mpl%info,'(a7,a)') '','Setup hull'
call mpl%flush
if (geom%global.and.all(geom%myuniverse)) then
   geom%hull_c0u%radius = mpl%msv%valr
else
   call geom%hull_c0u%init(mpl,geom%nc0u,geom%lon_c0u,geom%lat_c0u,nam%universe_radius)
end if

if (nam%mask_check) then
   ! Setup boundaries
   write(mpl%info,'(a7,a)') '','Setup boundaries'
   call mpl%flush
   call mesh_c0u%init(mpl,rng,geom%nc0u,geom%lon_c0u,geom%lat_c0u)
   call geom%bnda_c0u%init(mpl,geom%nc0u,geom%nl0,geom%gmask_hor_c0u,geom%gmask_c0u,mesh_c0u)
end if

! Setup horizontal distance
write(mpl%info,'(a7,a)') '','Setup horizontal distance'
call mpl%flush
allocate(geom%disth(nam%nc3))
do jc3=1,nam%nc3
   geom%disth(jc3) = real(jc3-1,kind_real)*nam%dc
end do
if (maxval(geom%disth)>nam%universe_radius) call mpl%abort('${subr}$','horizontal distance larger than universe radius')

! Setup angular sector
write(mpl%info,'(a7,a)') '','Setup angular sector'
call mpl%flush
allocate(geom%as(nam%nc4))
geom%das = pi/real(nam%nc4,kind_real)
do jc4=1,nam%nc4
   geom%as(jc4) = -pi*half+real(jc4-1,kind_real)*geom%das
end do

! Setup dirac points
call geom%setup_dirac(mpl,nam)

! Set allocation flag
geom%allocated = .true.

if (((nam%new_nicas.or.nam%load_nicas_local).and.nam%write_nicas_global).or.nam%load_nicas_global) then
   ! Allocation
   if (mpl%main) then
      allocate(lon_c0(geom%nc0))
      allocate(lat_c0(geom%nc0))
      allocate(order_c0(geom%nc0))
   else
      allocate(lon_c0(0))
      allocate(lat_c0(0))
      allocate(order_c0(0))
   end if
   allocate(order_c0a(geom%nc0a))

   ! Communication
   call mpl%loc_to_glb(geom%nc0a,geom%nc0,geom%c0a_to_c0,geom%lon_c0a,lon_c0)
   call mpl%loc_to_glb(geom%nc0a,geom%nc0,geom%c0a_to_c0,geom%lat_c0a,lat_c0)

   ! Compute global order
   if (mpl%main) call qsort(geom%nc0,lon_c0,lat_c0,order_c0,.false.)
   call mpl%glb_to_loc(geom%nc0a,geom%nc0,geom%c0a_to_c0,order_c0,order_c0a)

   ! Setup fields output
   call geom%io%init(mpl,7,'0',geom%nc0,geom%nc0a,geom%c0a_to_c0,geom%proc_to_c0_offset,order_c0a)

   ! Release memory
   deallocate(lon_c0)
   deallocate(lat_c0)
   deallocate(order_c0)
   deallocate(order_c0a)
end if

! Print summary
write(mpl%info,'(a7,a)') '','Geometry summary:'
call mpl%flush
write(mpl%info,'(a10,a,i8)') '','Model grid size:         ',geom%nmg
call mpl%flush
write(mpl%test,'(a10,a,i8)') '','Subset Sc0 size:         ',geom%nc0
call mpl%flush
write(mpl%info,'(a10,a,i6,a,f6.2,a)') '','Number of duplicated points (halo):    ',(geom%nmg-geom%nc0), &
 & ' (',real(geom%nmg-geom%nc0,kind_real)/real(geom%nmg,kind_real)*hundred,'%)'
call mpl%flush
write(mpl%test,'(a10,a,e10.3,a)') '','Domain area (% of Earth area):',hundred*geom%area_max_c0/(four*pi),'%'
call mpl%flush
write(mpl%info,'(a10,a)') '','Valid points (% of total domain):'
call mpl%flush
do il0=1,geom%nl0
   write(mpl%test,'(a13,a,i3,a,f5.1,a)') '','Level ',il0,' ~> ', &
 & hundred*real(geom%nc0_gmask(il0),kind_real)/real(geom%nc0,kind_real),'%'
   call mpl%flush
end do
write(mpl%info,'(a10,a)') '','Vertical coordinate:'
call mpl%flush
do il0=1,geom%nl0
   write(mpl%test,'(a13,a,i3,a,e10.3,a)') '','Level ',il0,' ~> ',geom%vert_coordavg(il0),' vert. coord.'
   call mpl%flush
end do
write(mpl%info,'(a10,a)') '','Distribution (local / universe):'
call mpl%flush
do iproc=1,mpl%nproc
   write(mpl%info,'(a13,a,i6,a,i8,a,i8)') '','Task ',iproc,': ',geom%proc_to_nc0a(iproc),' / ',geom%proc_to_nc0u(iproc)
   call mpl%flush
end do

! Reset random seed if necessary
call rng%reseed

! Probe out
@:probe_out()

end subroutine geom_setup

!----------------------------------------------------------------------
! Subroutine: geom_from_atlas
!> Set geometry from fieldset
!----------------------------------------------------------------------
subroutine geom_from_atlas(geom,mpl,nam,afunctionspace,fieldset)

implicit none

! Passed variables
class(geom_type),intent(inout) :: geom                 !< Geometry
type(mpl_type),intent(inout) :: mpl                    !< MPI data
type(nam_type),intent(in) :: nam                       !< Namelist
type(atlas_functionspace),intent(in) :: afunctionspace !< ATLAS function space
type(fieldset_type),intent(in),optional :: fieldset    !< Fieldset

! Local variables
integer :: il0,imga,ny,nx_inf,nx_sup,ib,ix,iy,jb,ncorner,iproc
integer :: imga_bnd(4),proc_to_ncorner(mpl%nproc),opposite_index(1)
integer :: izoom,isplon,isplat,irota,idir,istart
integer,pointer :: ghost(:)
real(kind_real) :: lon0,lat0,dist,maxdist,xcen,ycen,area_124,area_234,dist_12,dist_23,dist_34,dist_41
real(kind_real) :: lonlat(2),lonlat_bnd(2,4),vbnd(3,4),vp(3),v1(3),v2(3),cp(3),cd(3),v_tmp(3),vbnd_cen(3),dist_with_1(3)
real(kind_real) :: lonlat_bnd_tmp(2),lonlat_bnd_test(2,4),lonlat_bnd_opt(2,4),delta_lon_work,delta_lat_work
real(kind_real) :: splon_min,splon_max,splon_delta,splon,splon_opt,splat_min,splat_max,splat_delta,splat,splat_opt
real(kind_real) :: rota_min,rota_max,rota_delta,rota,rota_opt,dist_maxmin,dist_max,dist_test
real(kind_real) :: north,south,east,west,east_sym,west_sym,east_pos,west_pos,delta_sym,delta_pos
real(kind_real),pointer :: real_ptr(:,:)
type(atlas_config) :: aconfig_grid,aconfig_domain,aconfig_proj,aconfig_work_grid,aconfig_work_proj
type(atlas_field) :: afield,afield_lonlat,afield_ghost
type(atlas_functionspace_nodecolumns) :: afunctionspace_nc
type(atlas_functionspace_pointcloud) :: afunctionspace_pc
type(atlas_functionspace_structuredcolumns) :: afunctionspace_sc
type(atlas_structuredgrid) :: agrid_sc,agrid_work
type(atlas_mesh) :: amesh
type(atlas_mesh_nodes) :: anodes
type(atlas_connectivity) :: aconnectivity
character(len=:),allocatable :: domain_type

! Set name
@:set_name(geom_from_atlas)

! Probe in
@:probe_in()

! Copy function space
geom%afunctionspace_mg = atlas_functionspace(afunctionspace%c_ptr())

! Get number of points
geom%nmga = get_atlas_functionspace_size(mpl,geom%afunctionspace_mg)

! Total number of points
call mpl%f_comm%allreduce(geom%nmga,geom%nmg,fckit_mpi_sum())

! Allocation
allocate(geom%owned_mga(geom%nmga,1))
allocate(geom%vert_coord_mga(geom%nmga,geom%nl0))
allocate(geom%gmask_mga(geom%nmga,geom%nl0))
allocate(geom%lon_mga(geom%nmga))
allocate(geom%lat_mga(geom%nmga))

! Default values
geom%owned_mga = .true.
do il0=1,geom%nl0
   geom%vert_coord_mga(:,il0) = real(il0,kind_real)
end do
geom%gmask_mga = .true.

if (present(fieldset)) then
   ! Get owned vs halo/BC field
   if (fieldset%has_field('owned')) then
      afield = fieldset%field('owned')
      call field_to_array(afield,mpl,geom%owned_mga)
      call afield%final()
   end if

   ! Get vertical coordinate
   if (nam%vert_coord_name /= '') then
      afield = fieldset%field(nam%vert_coord_name)
      call field_to_array(afield,mpl,geom%vert_coord_mga)
      call afield%final()
   end if

   ! Get geometry mask
   if (nam%gmask_name /= '') then
      afield = fieldset%field(nam%gmask_name)
      call field_to_array(afield,mpl,geom%gmask_mga)
      call afield%final()
   end if
end if

! Get lon/lat
select case (afunctionspace%name())
case ('NodeColumns')
   ! Get node columns function space
   afunctionspace_nc = afunctionspace

   ! Get lon/lat field
   anodes = afunctionspace_nc%nodes()
   afield_lonlat = anodes%lonlat()
   call afield_lonlat%data(real_ptr)
   if (geom%nmga>0) then
      geom%lon_mga = real_ptr(1,:)*deg2rad
      geom%lat_mga = real_ptr(2,:)*deg2rad
   end if
case ('PointCloud')
   ! Get point cloud function space
   afunctionspace_pc = afunctionspace

   ! Get lon/lat field
   afield_lonlat = afunctionspace_pc%lonlat()
   call afield_lonlat%data(real_ptr)
   if (geom%nmga>0) then
     geom%lon_mga = real_ptr(1,:)*deg2rad
     geom%lat_mga = real_ptr(2,:)*deg2rad
   end if
case ('StructuredColumns')
   ! Get structured columns function space
   afunctionspace_sc = afunctionspace

   ! Get lon/lat
   afield_lonlat = afunctionspace_sc%xy()
   call afield_lonlat%data(real_ptr)
   if (geom%nmga>0) then
     geom%lon_mga = real_ptr(1,:)*deg2rad
     geom%lat_mga = real_ptr(2,:)*deg2rad
   end if
case default
   call mpl%abort('${subr}$','wrong function space: '//afunctionspace%name())
end select

! Enforce proper bounds
do imga=1,geom%nmga
   if (geom%owned_mga(imga,1)) call lonlatmod(geom%lon_mga(imga),geom%lat_mga(imga))
end do

! Get other grid properties
if (mpl%main) then
   lon0 = geom%lon_mga(1)
   lat0 = geom%lat_mga(1)
end if
call mpl%f_comm%broadcast(lon0, mpl%rootproc-1)
call mpl%f_comm%broadcast(lat0, mpl%rootproc-1)
maxdist = zero
do imga=1,geom%nmga
   if (maxdist<pi) then
      call sphere_dist(lon0,lat0,geom%lon_mga(imga),geom%lat_mga(imga),dist)
      if (dist>maxdist) maxdist = dist
   end if
end do
call mpl%f_comm%allreduce(maxdist,fckit_mpi_max())
if (supeq(maxdist,half*pi)) then
   ! Global domain
   geom%global = .true.
   geom%area = four*pi
else
   ! Regional domain
   geom%global = .false.

   select case (afunctionspace%name())
   case ('StructuredColumns')
      ! Get structured columns function space
      afunctionspace_sc = afunctionspace

      ! Get structured grid
      agrid_sc = afunctionspace_sc%grid()
      ny = agrid_sc%ny()
      nx_inf = agrid_sc%nx(1)
      nx_sup = agrid_sc%nx(ny)
      if (nx_inf/=nx_sup) call mpl%abort('${subr}$','unexpected grid shape')

      ! Get corners coordinates
      lonlat_bnd(:,1) = agrid_sc%lonlat(1,1)*deg2rad
      lonlat_bnd(:,2) = agrid_sc%lonlat(nx_inf,1)*deg2rad
      lonlat_bnd(:,3) = agrid_sc%lonlat(nx_sup,ny)*deg2rad
      lonlat_bnd(:,4) = agrid_sc%lonlat(1,ny)*deg2rad
   case ('NodeColumns')
      ! Get node columns function space
      afunctionspace_nc = afunctionspace

      ! Get mesh
      amesh = afunctionspace_nc%mesh()

      ! Create node to cell connectivity
      call atlas_build_node_to_cell_connectivity(amesh)

      ! Get connectivity
      aconnectivity = anodes%cell_connectivity()

      ! Get ghost field
      afield_ghost = anodes%ghost()
      call afield_ghost%data(ghost)

      ! Loop over nodes to find corners
      ncorner = 0
      imga_bnd = mpl%msv%vali
      do imga=1,aconnectivity%rows()
         if ((ghost(imga)==0).and.(aconnectivity%cols(imga)==1)) then
            ncorner = ncorner+1
            imga_bnd(ncorner) = imga
         end if
      end do

      ! Communication
      call mpl%f_comm%allgather(ncorner,proc_to_ncorner)

      if (sum(proc_to_ncorner)==4) then
         ! Define corners coordinates
         jb = 1
         lonlat_bnd = zero
         do iproc=1,mpl%nproc
            do ib=1,proc_to_ncorner(iproc)
               if (iproc==mpl%myproc) then
                  lonlat_bnd(1,jb) = geom%lon_mga(imga_bnd(ib))
                  lonlat_bnd(2,jb) = geom%lat_mga(imga_bnd(ib))
               end if
               jb = jb+1
            end do
         end do
         call mpl%f_comm%allreduce(lonlat_bnd,fckit_mpi_sum())
      else
         ! Assuming a non-rotated domain, not over pole
         call mpl%warning('${subr}$','cannot find corners, assuming a non-rotated domain, not over pole')

         ! Get bounds
         north = maxval(geom%lat_mga)
         south = minval(geom%lat_mga)
         east_sym = maxval(geom%lon_mga)
         west_sym = minval(geom%lon_mga)
         east_pos = maxval(geom%lon_mga+pi)
         west_pos = minval(geom%lon_mga+pi)

         ! Communication
         call mpl%f_comm%allreduce(north,fckit_mpi_max())
         call mpl%f_comm%allreduce(south,fckit_mpi_min())
         call mpl%f_comm%allreduce(east_sym,fckit_mpi_max())
         call mpl%f_comm%allreduce(west_sym,fckit_mpi_min())
         call mpl%f_comm%allreduce(east_pos,fckit_mpi_max())
         call mpl%f_comm%allreduce(west_pos,fckit_mpi_min())

         ! Deal with periodicity
         delta_sym = east_sym-west_sym
         delta_pos = east_pos-west_pos
         if (infeq(delta_sym,delta_pos)) then
            east = east_sym
            west = west_sym
         else
            east = east_pos
            west = west_pos
         end if

         ! Set corners
         lonlat_bnd(:,1) = (/west,south/)
         lonlat_bnd(:,2) = (/east,south/)
         lonlat_bnd(:,3) = (/east,north/)
         lonlat_bnd(:,4) = (/west,north/)
      end if
   case default
      call mpl%abort('${subr}$','wrong function space: '//afunctionspace%name())
   end select

   ! Enforce proper bounds
   do ib=1,4
      call lonlatmod(lonlat_bnd(1,ib),lonlat_bnd(2,ib))
   end do

   ! Transform to cartesian coordinates
   do ib=1,4
      call lonlat2xyz(mpl,lonlat_bnd(1,ib),lonlat_bnd(2,ib),vbnd(1,ib),vbnd(2,ib),vbnd(3,ib))
   end do

   ! Re-order corners to ensure the order of corners is circular
   call sphere_dist(lonlat_bnd(1,1),lonlat_bnd(2,1),lonlat_bnd(1,2),lonlat_bnd(2,2),dist_with_1(1))
   call sphere_dist(lonlat_bnd(1,1),lonlat_bnd(2,1),lonlat_bnd(1,3),lonlat_bnd(2,3),dist_with_1(2))
   call sphere_dist(lonlat_bnd(1,1),lonlat_bnd(2,1),lonlat_bnd(1,4),lonlat_bnd(2,4),dist_with_1(3))
   opposite_index = maxloc(dist_with_1)+1
   if (opposite_index(1)/=3) then
      ! Make sure oppsite corner is number 3
      v_tmp = vbnd(:,opposite_index(1))
      vbnd(:,opposite_index(1)) = vbnd(:,3)
      vbnd(:,3) = v_tmp
   end if
   
   ! Re-order corners to ensure the order of corners is positive
   v1 = vbnd(:,2)-vbnd(:,1)
   v2 = vbnd(:,3)-vbnd(:,1)
   call vector_product(v1,v2,cp)
   cd = (vbnd(:,1)+vbnd(:,2)+vbnd(:,3))/three
   if (inf(sum(cp*cd),zero)) then
      ! Switch corners 2 and 4
      v_tmp = vbnd(:,2)
      vbnd(:,2) = vbnd(:,4)
      vbnd(:,4) = v_tmp
   end if

   ! Transform back to spherical coordinates
   do ib=1,4
      call xyz2lonlat(mpl,vbnd(1,ib),vbnd(2,ib),vbnd(3,ib),lonlat_bnd(1,ib),lonlat_bnd(2,ib))
   end do

   ! Get domain center
   vbnd_cen = quarter*sum(vbnd,dim=2)
   vbnd_cen = vbnd_cen/sqrt(sum(vbnd_cen**2))
   call xyz2lonlat(mpl,vbnd_cen(1),vbnd_cen(2),vbnd_cen(3),geom%lon_center,geom%lat_center)

   ! Compute area as the sum of two spherical triangles
   call area(vbnd(:,1),vbnd(:,2),vbnd(:,4),area_124)
   call area(vbnd(:,2),vbnd(:,3),vbnd(:,4),area_234)
   geom%area = area_124+area_234

   ! Compute work grid

   ! Compute distance betweeen corner
   call sphere_dist(lonlat_bnd(1,1),lonlat_bnd(2,1),lonlat_bnd(1,2),lonlat_bnd(2,2),dist_12)
   call sphere_dist(lonlat_bnd(1,2),lonlat_bnd(2,2),lonlat_bnd(1,3),lonlat_bnd(2,3),dist_23)
   call sphere_dist(lonlat_bnd(1,3),lonlat_bnd(2,3),lonlat_bnd(1,4),lonlat_bnd(2,4),dist_34)
   call sphere_dist(lonlat_bnd(1,4),lonlat_bnd(2,4),lonlat_bnd(1,1),lonlat_bnd(2,1),dist_41)
   dist_12 = max(dist_12,dist_34)
   dist_23 = max(dist_23,dist_41)

   ! Initialization
   aconfig_work_grid = atlas_config()
   call aconfig_work_grid%set('type','regional')
   call aconfig_work_grid%set('nx',100)
   call aconfig_work_grid%set('ny',100)
   aconfig_work_proj = atlas_config()
   call aconfig_work_proj%set('type','rotated_lonlat')
   splon_min = -pi
   splon_max = pi
   splat_min = -half*pi
   splat_max = half*pi
   rota_min = -pi
   rota_max = pi

   ! Loop over zoom values
   dist_maxmin = huge_real
   do izoom=1,nzoom
      ! Zoom initialization 
      splon_delta = (splon_max-splon_min)/real(ntest-1,kind_real)
      splat_delta = (splat_max-splat_min)/real(ntest-1,kind_real)
      rota_delta = (rota_max-rota_min)/real(ntest-1,kind_real)

      do isplon=1,ntest
         ! Define test south pole longitude
         splon = splon_min+real(isplon-1,kind_real)*splon_delta

         do isplat=1,ntest
            ! Define test south pole latitude
            splat = splat_min+real(isplat-1,kind_real)*splat_delta

            do irota=1,ntest
               ! Define test rotation angle
               rota = rota_min+real(irota-1,kind_real)*rota_delta

               ! Reset projection configuration
               call aconfig_work_proj%set('south_pole',(/splon*rad2deg,splat*rad2deg/))
               call aconfig_work_proj%set('rotation_angle',rota*rad2deg)
               call aconfig_work_grid%set('projection',aconfig_work_proj)

               ! Loop over direction choices
               do idir=1,2
                  if (idir==1) then
                     delta_lon_work = half*dist_12
                     delta_lat_work = half*dist_23
                  else
                     delta_lon_work = half*dist_23
                     delta_lat_work = half*dist_12
                  end if
                  call aconfig_work_grid%set('north',delta_lat_work*rad2deg)
                  call aconfig_work_grid%set('south',-delta_lat_work*rad2deg)
                  call aconfig_work_grid%set('east',delta_lon_work*rad2deg)
                  call aconfig_work_grid%set('west',-delta_lon_work*rad2deg)

                  ! Create work grid
                  agrid_work = atlas_structuredgrid(aconfig_work_grid)

                  ! Loop over starting point
                  do istart=1,4
                     ! Find max distance between model and work grid for this starting corner
                     dist_max = 0.0
                     do ib=1,4
                        ! Get work grid corners
                        if (mod((ib+istart+1)/2,2)==0) then
                           ix = 1
                        else
                           ix = 100
                        end if
                        if (mod((ib+istart)/2,2)==0) then
                           iy = 1
                        else
                           iy = 100
                        end if
                        lonlat_bnd_test(:,ib) = agrid_work%lonlat(ix,iy)*deg2rad

                        ! Enforce proper bounds
                        call lonlatmod(lonlat_bnd_test(1,ib),lonlat_bnd_test(2,ib))

                        ! Compute distance
                        call sphere_dist(lonlat_bnd(1,ib),lonlat_bnd(2,ib),lonlat_bnd_test(1,ib),lonlat_bnd_test(2,ib),dist_test)
                        if (sup(dist_test,dist_max)) dist_max = dist_test
                     end do  

                     ! Check work grid accuracy
                     if (inf(dist_max,dist_maxmin)) then
                        dist_maxmin = dist_max
                        geom%aconfig_work_grid = atlas_config(atlas_json(aconfig_work_grid%json()))
                        geom%aproj_work = atlas_projection(aconfig_work_proj)
                        splon_opt = splon
                        splat_opt = splat
                        rota_opt = rota
                        lonlat_bnd_opt = lonlat_bnd_test
                     end if
                  end do
               end do
            end do
         end do
      end do

      ! Update search parameters
      splon_min = max(splon_min,splon_opt-two*splon_delta)
      splon_max = min(splon_max,splon_opt+two*splon_delta)
      splat_min = max(splat_min,splat_opt-two*splat_delta)
      splat_max = min(splat_max,splat_opt+two*splat_delta)
      rota_min = max(rota_min,rota_opt-two*rota_delta)
      rota_max = min(rota_max,rota_opt+two*rota_delta)
   end do

   ! Print results
   write(mpl%info,'(a7,a,e10.3,a)') '','Work regional grid accuracy: ',dist_maxmin*reqkm,' km'
   call mpl%flush
   do ib=1,4
      write(mpl%info,'(a10,a,i1.1,a,e10.3,a,e10.3,a,e10.3,a,e10.3,a)') '','Corner #',ib,': ', lonlat_bnd(1,ib)*rad2deg,' (', &
 & lonlat_bnd_opt(1,ib)*rad2deg,')  / ',lonlat_bnd(2,ib)*rad2deg,' (',lonlat_bnd_opt(2,ib)*rad2deg,')'
      call mpl%flush
   end do

   ! Extend work grid to make sure all points are included
   if (.not.geom%aconfig_work_grid%get('north',north)) call mpl%abort('${subr}$','missing north')
   if (.not.geom%aconfig_work_grid%get('south',south)) call mpl%abort('${subr}$','missing south')
   if (.not.geom%aconfig_work_grid%get('east',east)) call mpl%abort('${subr}$','missing east')
   if (.not.geom%aconfig_work_grid%get('west',west)) call mpl%abort('${subr}$','missing west')
   call geom%aconfig_work_grid%set('north',north+dist_maxmin*rad2deg)
   call geom%aconfig_work_grid%set('south',south-dist_maxmin*rad2deg)
   call geom%aconfig_work_grid%set('east',east+dist_maxmin*rad2deg)
   call geom%aconfig_work_grid%set('west',west-dist_maxmin*rad2deg)

   ! Get work grid domain
   agrid_work = atlas_structuredgrid(geom%aconfig_work_grid)
   aconfig_work_grid = agrid_work%spec()
   if (.not.aconfig_work_grid%get('domain',aconfig_domain)) call mpl%abort('${subr}$','missing domain')
   if (.not.aconfig_domain%get('type',domain_type)) call mpl%abort('${subr}$','missing domain type')
   if (trim(domain_type)/='rectangular') call mpl%abort('${subr}$','only rectangular domains allowed')
   if (.not.aconfig_domain%get('xmin',geom%xmin)) call mpl%abort('${subr}$','missing domain xmin')
   if (.not.aconfig_domain%get('xmax',geom%xmax)) call mpl%abort('${subr}$','missing domain xmax')
   if (.not.aconfig_domain%get('ymin',geom%ymin)) call mpl%abort('${subr}$','missing domain ymin')
   if (.not.aconfig_domain%get('ymax',geom%ymax)) call mpl%abort('${subr}$','missing domain ymax')
   geom%xmin = geom%xmin*deg2rad
   geom%xmax = geom%xmax*deg2rad
   geom%ymin = geom%ymin*deg2rad
   geom%ymax = geom%ymax*deg2rad
end if

! Probe out
@:probe_out()

end subroutine geom_from_atlas

!----------------------------------------------------------------------
! Subroutine: geom_setup_c0
!> Setup subset Sc0
!----------------------------------------------------------------------
subroutine geom_setup_c0(geom,mpl)

implicit none

! Passed variables
class(geom_type),intent(inout) :: geom !< Geometry
type(mpl_type),intent(inout) :: mpl    !< MPI data

! Local variables
integer :: iproc,imga,ic0a,ic0,diff_grid,il0
real(kind_real) :: norm_c0(geom%nl0),vert_coord_hor_c0(geom%nl0)

! Set name
@:set_name(geom_setup_c0)

! Probe in
@:probe_in()

write(mpl%info,'(a7,a)') '','Setup subset Sc0'
call mpl%flush

! Allocation
allocate(geom%proc_to_nc0a(mpl%nproc))

if (all(geom%owned_mga)) then
   ! No duplicated points (no halo)
   geom%nc0a = geom%nmga
else
   ! Duplicated points present (halo)
   geom%nc0a = count(geom%owned_mga)
end if

! Check grid similarity
if (geom%nc0a==geom%nmga) then
   diff_grid = 0
else
   diff_grid = 1
end if
call mpl%f_comm%allreduce(diff_grid,fckit_mpi_sum())
geom%same_grid = (diff_grid==0)

! Communication
call mpl%f_comm%allgather(geom%nc0a,geom%proc_to_nc0a)

! Subset Sc0 global size
geom%nc0 = sum(geom%proc_to_nc0a)

! Allocation
allocate(geom%proc_to_c0_offset(mpl%nproc))
allocate(geom%c0a_to_c0(geom%nc0a))
allocate(geom%c0a_to_mga(geom%nc0a))
allocate(geom%lon_c0a(geom%nc0a))
allocate(geom%lat_c0a(geom%nc0a))
allocate(geom%vert_coord_c0a(geom%nc0a,geom%nl0))
allocate(geom%gmask_c0a(geom%nc0a,geom%nl0))
allocate(geom%gmask_hor_c0a(geom%nc0a))
allocate(geom%nc0_gmask(0:geom%nl0))
allocate(geom%area_ver_c0(geom%nl0))
allocate(geom%vert_coordavg(geom%nl0))
allocate(geom%l0_to_l0i(geom%nl0))
allocate(geom%l0i_to_l0(geom%nl0))

! Subset Sc0 offset for halo A
geom%proc_to_c0_offset(1) = 0
do iproc=2,mpl%nproc
   geom%proc_to_c0_offset(iproc) = geom%proc_to_c0_offset(iproc-1)+geom%proc_to_nc0a(iproc-1)
end do

! Conversion
do ic0a=1,geom%nc0a
   ic0 = geom%proc_to_c0_offset(mpl%myproc)+ic0a
   geom%c0a_to_c0(ic0a) = ic0
end do
ic0a = 0
do imga=1,geom%nmga
   if (geom%owned_mga(imga,1)) then
      ic0a = ic0a+1
      geom%c0a_to_mga(ic0a) = imga
   end if
end do

if (geom%same_grid) then
   ! Copy fields
   geom%lon_c0a = geom%lon_mga
   geom%lat_c0a = geom%lat_mga
   geom%vert_coord_c0a = geom%vert_coord_mga
   geom%gmask_c0a = geom%gmask_mga
else
   ! Copy fields from model grid to subset Sc0 on halo A
   do ic0a=1,geom%nc0a
      imga = geom%c0a_to_mga(ic0a)
      geom%lon_c0a(ic0a) = geom%lon_mga(imga)
      geom%lat_c0a(ic0a) = geom%lat_mga(imga)
      geom%vert_coord_c0a(ic0a,:) = geom%vert_coord_mga(imga,:)
      geom%gmask_c0a(ic0a,:) = geom%gmask_mga(imga,:)
   end do
end if

! Release memory
deallocate(geom%lon_mga)
deallocate(geom%lat_mga)
deallocate(geom%vert_coord_mga)

! Related fields
if (geom%nc0a>0) geom%gmask_hor_c0a = any(geom%gmask_c0a,dim=2)
geom%nc0_gmask(0) = zss_count(geom%gmask_hor_c0a)
do il0=1,geom%nl0
   geom%nc0_gmask(il0) = zss_count(geom%gmask_c0a(:,il0))
end do
call mpl%f_comm%allreduce(geom%nc0_gmask,fckit_mpi_sum())
if (geom%nc0_gmask(0)>0) then
   geom%area_max_c0 = geom%area*real(count(geom%gmask_hor_c0a),kind_real)/real(geom%nc0,kind_real)
else
   geom%area_max_c0 = zero
end if
do il0=1,geom%nl0
   norm_c0(il0) = zss_count(geom%gmask_c0a(:,il0))
   if (norm_c0(il0)>0) then
      geom%area_ver_c0(il0) = geom%area*real(count(geom%gmask_c0a(:,il0)),kind_real)/real(geom%nc0,kind_real)
      vert_coord_hor_c0(il0) = zss_sum(geom%vert_coord_c0a(:,il0),mask=geom%gmask_c0a(:,il0))
   else
      geom%area_ver_c0(il0) = zero
      vert_coord_hor_c0(il0) = zero
   end if
end do
call mpl%f_comm%allreduce(norm_c0,fckit_mpi_sum())
call mpl%f_comm%allreduce(geom%area_max_c0,fckit_mpi_sum())
call mpl%f_comm%allreduce(geom%area_ver_c0,fckit_mpi_sum())
call mpl%f_comm%allreduce(vert_coord_hor_c0,fckit_mpi_sum())
do il0=1,geom%nl0
   if (norm_c0(il0)>0) then
      geom%vert_coordavg(il0) = vert_coord_hor_c0(il0)/real(norm_c0(il0),kind_real)
   else
      geom%vert_coordavg(il0) = mpl%msv%valr
   end if
end do

! Compute independent levels
write(mpl%test,'(a7,a)') '','Independent levels: '
call mpl%flush(newl=.false.)
call independent_levels(mpl,geom%nc0a,geom%nl0,geom%gmask_c0a,geom%nl0i,geom%l0_to_l0i,geom%l0i_to_l0)

! Probe out
@:probe_out()

end subroutine geom_setup_c0

!----------------------------------------------------------------------
! Subroutine: geom_setup_universe
!> Setup universe
!----------------------------------------------------------------------
subroutine geom_setup_universe(geom,mpl,rng,nam)

implicit none

! Passed variables
class(geom_type),intent(inout) :: geom !< Geometry
type(mpl_type),intent(inout) :: mpl    !< MPI data
type(rng_type),intent(inout) :: rng    !< Random number generator
type(nam_type),intent(in) :: nam       !< Namelist

! Local variables
integer :: iproc,ic0a,ic0u,ic0
integer :: proc_to_universe_size(mpl%nproc)
integer,allocatable :: order(:)
real(kind_real) :: dist,lon_avg,lat_avg,dist_max
real(kind_real) :: xyz(3),xyz_avg(3)
real(kind_real),allocatable :: proc_to_lon(:),proc_to_lat(:),proc_to_dist_max(:)

! Set name
@:set_name(geom_setup_universe)

! Probe in
@:probe_in()

write(mpl%info,'(a7,a)') '','Setup universe'
call mpl%flush

! Allocation
allocate(geom%myuniverse(mpl%nproc))

if (mpl%nproc==1) then
   ! Single-processors case
   geom%myuniverse = .true.
else
   ! Allocation
   allocate(proc_to_lon(mpl%nproc))
   allocate(proc_to_lat(mpl%nproc))
   allocate(proc_to_dist_max(mpl%nproc))

   ! Initialization
   xyz_avg = zero
   dist_max = zero

   ! Convert to cartesian coordinates and average
   do ic0a=1,geom%nc0a
      call lonlat2xyz(mpl,geom%lon_c0a(ic0a),geom%lat_c0a(ic0a),xyz(1),xyz(2),xyz(3))
      xyz_avg = xyz_avg+xyz
   end do
   if (any(abs(xyz_avg)>zero)) then
      ! Convert average back to lon/lat
      call xyz2lonlat(mpl,xyz_avg(1),xyz_avg(2),xyz_avg(3),lon_avg,lat_avg)

      ! Compute maximum distance to average
      do ic0a=1,geom%nc0a
         if (any(geom%gmask_c0a(ic0a,:))) then
            call sphere_dist(lon_avg,lat_avg,geom%lon_c0a(ic0a),geom%lat_c0a(ic0a),dist)
            if (sup(dist,dist_max)) dist_max = dist
         end if
      end do
   else
      ! Missing values
      lon_avg = mpl%msv%valr
      lat_avg = mpl%msv%valr
   end if

   ! Communication
   call mpl%f_comm%allgather(lon_avg,proc_to_lon)
   call mpl%f_comm%allgather(lat_avg,proc_to_lat)
   call mpl%f_comm%allgather(dist_max,proc_to_dist_max)

   ! Compute distances from sampling points to my processor to other sampling points
   geom%myuniverse = .false.
   do iproc=1,geom%nproc
      if (mpl%msv%isnot(lon_avg).and.mpl%msv%isnot(lat_avg) &
 & .and.mpl%msv%isnot(proc_to_lon(iproc)).and.mpl%msv%isnot(proc_to_lat(iproc))) then
         ! Compute distance
         call sphere_dist(lon_avg,lat_avg,proc_to_lon(iproc),proc_to_lat(iproc),dist)

         ! Check distance
         if (inf(dist,dist_max+proc_to_dist_max(iproc)+nam%universe_radius)) geom%myuniverse(iproc) = .true.
      end if
   end do

   ! Release memory
   deallocate(proc_to_lon)
   deallocate(proc_to_lat)
   deallocate(proc_to_dist_max)
end if

! Share universe size
call mpl%f_comm%allgather(count(geom%myuniverse),proc_to_universe_size)

! Print results
call mpl%flush
do iproc=1,mpl%nproc
   write(mpl%info,'(a10,a,i6,a,f6.2,a)') '','Task ',iproc,': ',hundred*real(proc_to_universe_size(iproc),kind_real) &
 & /real(count(geom%proc_to_nc0a > 0),kind_real),'%'
   call mpl%flush
end do

! Reset random seed if necessary
call rng%reseed

! Communicate data from halo A to universe on subset Sc0
write(mpl%info,'(a10,a)') '','Communicate data from halo A to universe on subset Sc0'
call mpl%flush

! Subset Sc0 universe size
geom%nc0u = sum(geom%proc_to_nc0a,mask=geom%myuniverse)

! Allocation
allocate(geom%proc_to_nc0u(mpl%nproc))

! Communication
call mpl%f_comm%allgather(geom%nc0u,geom%proc_to_nc0u)

! Check universe size
if ((geom%nc0a>0).and.(geom%nc0a<geom%nc0).and.(geom%nc0u==geom%nc0a)) &
 & call mpl%abort('${subr}$','universe is not larger than halo A')

! Allocation
allocate(geom%c0a_to_c0u(geom%nc0a))
allocate(geom%c0u_to_c0a(geom%nc0u))
allocate(geom%c0u_to_c0(geom%nc0u))
allocate(geom%lon_c0u(geom%nc0u))
allocate(geom%lat_c0u(geom%nc0u))
allocate(geom%vert_coord_c0u(geom%nc0u,geom%nl0))
allocate(geom%gmask_c0u(geom%nc0u,geom%nl0))
allocate(geom%gmask_hor_c0u(geom%nc0u))
allocate(order(geom%nc0u))

! Conversions
geom%c0u_to_c0a = mpl%msv%vali
ic0u = 0
do ic0=1,geom%nc0
   iproc = geom%c0_to_proc(ic0)
   if (geom%myuniverse(iproc)) then
      ic0u = ic0u+1
      if (iproc==mpl%myproc) then
         ic0a = geom%c0_to_c0a(ic0)
         geom%c0a_to_c0u(ic0a) = ic0u
         geom%c0u_to_c0a(ic0u) = ic0a
      end if
      geom%c0u_to_c0(ic0u) = ic0
   end if
end do

! Setup subset Sc0 communication, local to universe
call geom%com_AU%setup(mpl,'com_AU',geom%nc0a,geom%nc0u,geom%nc0,geom%c0a_to_c0,geom%c0u_to_c0)

! Extend fields from halo A to universe on subset Sc0
call geom%com_AU%ext(mpl,geom%lon_c0a,geom%lon_c0u)
call geom%com_AU%ext(mpl,geom%lat_c0a,geom%lat_c0u)
call geom%com_AU%ext(mpl,geom%vert_coord_c0a,geom%vert_coord_c0u)
call geom%com_AU%ext(mpl,geom%gmask_c0a,geom%gmask_c0u)
if (geom%nc0u>0) geom%gmask_hor_c0u = any(geom%gmask_c0u,dim=2)

! Check that Sc0 points in universe are not duplicated
write(mpl%info,'(a7,a)') '','Check that Sc0 points in universe are not duplicated'
call mpl%flush
call qsort(geom%nc0u,geom%lon_c0u,geom%lat_c0u,order,.false.)
do ic0u=2,geom%nc0u
   if (eq(geom%lon_c0u(order(ic0u)),geom%lon_c0u(order(ic0u-1))).and.eq(geom%lat_c0u(order(ic0u)),geom%lat_c0u(order(ic0u-1)))) &
 & call mpl%abort('${subr}$','duplicated points in Sc0 point on universe, check the universe')
end do

! Release memory
deallocate(order)

! Probe out
@:probe_out()

end subroutine geom_setup_universe

!----------------------------------------------------------------------
! Subroutine: geom_index_from_lonlat_r0
!> Get nearest neighbor index from longitude/latitude/level, scalar
!----------------------------------------------------------------------
subroutine geom_index_from_lonlat_r0(geom,mpl,lon,lat,il0,iproc,ic0a,gmask)

implicit none

! Passed variables
class(geom_type),intent(in) :: geom !< Geometry
type(mpl_type),intent(inout) :: mpl !< MPI data
real(kind_real),intent(in) :: lon   !< Longitude
real(kind_real),intent(in) :: lat   !< Latitude
integer,intent(in) :: il0           !< Level index
integer,intent(out) :: iproc        !< Task index
integer,intent(out) :: ic0a         !< Local index
logical,intent(out) :: gmask        !< Local mask

! Local variables
integer :: nn_index(1),ic0,nn_proc,proc_to_nn_proc(mpl%nproc),jproc,ic0u
real(kind_real) :: nn_dist(1),proc_to_nn_dist(mpl%nproc),dist_min
logical :: valid

! Set name
@:set_name(geom_index_from_lonlat_r0)

! Probe in
@:probe_in()

! Check if the point is inside the universe
call geom%hull_c0u%inside(mpl,lon,lat,valid)

if (valid.and.(geom%nc0u>0)) then
   ! Find nearest neighbor
   call geom%tree_c0u%find_nearest_neighbors(mpl,lon,lat,1,nn_index,nn_dist)
   ic0 = geom%c0u_to_c0(nn_index(1))
   nn_proc = geom%c0_to_proc(ic0)
else
   nn_dist = huge_real
   nn_proc = mpl%msv%vali
end if

! Communication
call mpl%f_comm%allgather(nn_dist(1),proc_to_nn_dist)
call mpl%f_comm%allgather(nn_proc,proc_to_nn_proc)

if (mpl%msv%isanynot(proc_to_nn_proc)) then
   ! The correct processor should handle its own nearest neighbor, with the minimum distance
   dist_min = minval(proc_to_nn_dist)
   iproc = mpl%msv%vali
   do jproc=1,mpl%nproc
      if ((proc_to_nn_proc(jproc)==jproc).and.eq(proc_to_nn_dist(jproc),dist_min)) iproc = jproc
   end do
   if (mpl%msv%is(iproc)) call mpl%abort('${subr}$','cannot find root processor: did you make sure rng is synchronized?')

   if (iproc==mpl%myproc) then
      ! Check whether the location is in the hull
      if (.not.valid) call mpl%abort('${subr}$','wrong processor')

      ! Local index
      ic0u = nn_index(1)
      ic0a = geom%c0u_to_c0a(ic0u)

      ! Check mask
      if (il0==0) then
         gmask = geom%gmask_hor_c0a(ic0a)
      else
         gmask = geom%gmask_c0a(ic0a,il0)
      end if
   end if

   ! Broadcast data
   call mpl%f_comm%broadcast(ic0a,iproc-1)
   call mpl%f_comm%broadcast(gmask,iproc-1)
else
   ! Missing values
   iproc = mpl%msv%vali
   ic0a = mpl%msv%vali
   gmask = .false.
end if

! Probe out
@:probe_out()

end subroutine geom_index_from_lonlat_r0

!----------------------------------------------------------------------
! Subroutine: geom_index_from_lonlat_r1
!> Get nearest neighbor index from longitude/latitude/level, vector
!----------------------------------------------------------------------
subroutine geom_index_from_lonlat_r1(geom,mpl,n,lon,lat,il0,iproc,ic0a,gmask)

implicit none

! Passed variables
class(geom_type),intent(in) :: geom  !< Geometry
type(mpl_type),intent(inout) :: mpl  !< MPI data
integer,intent(in) :: n              !< Vector size
real(kind_real),intent(in) :: lon(n) !< Longitudes
real(kind_real),intent(in) :: lat(n) !< Latitudes
integer,intent(in) :: il0(n)         !< Level indices
integer,intent(out) :: iproc(n)      !< Task indices
integer,intent(out) :: ic0a(n)       !< Local indices
logical,intent(out) :: gmask(n)      !< Local mask

! Local variables
integer :: i,nn_index(n),ic0,nn_proc(n),proc_to_nn_proc(n,mpl%nproc),jproc,ic0u,imask(n)
real(kind_real) :: nn_dist(n),proc_to_nn_dist(n,mpl%nproc),dist_min
logical :: valid(n)

! Set name
@:set_name(geom_index_from_lonlat_r1)

! Probe in
@:probe_in()

do i=1,n
   ! Check if the point is inside the universe
   call geom%hull_c0u%inside(mpl,lon(i),lat(i),valid(i))

   if (valid(i).and.(geom%nc0u>0)) then
      ! Find nearest neighbor
      call geom%tree_c0u%find_nearest_neighbors(mpl,lon(i),lat(i),1,nn_index(i:i),nn_dist(i:i))
      ic0 = geom%c0u_to_c0(nn_index(i))
      nn_proc(i) = geom%c0_to_proc(ic0)
   else
      nn_dist(i) = huge_real
      nn_proc(i) = mpl%msv%vali
   end if
end do

! Communication
call mpl%allgather(nn_dist,proc_to_nn_dist)
call mpl%allgather(nn_proc,proc_to_nn_proc)

! Initialization
iproc = mpl%msv%vali
ic0a = 0
imask = 0

do i=1,n
   if (mpl%msv%isanynot(proc_to_nn_proc(i,:))) then
      ! The correct processor should handle its own nearest neighbor, with the minimum distance
      dist_min = minval(proc_to_nn_dist(i,:))
      do jproc=1,mpl%nproc
         if ((proc_to_nn_proc(i,jproc)==jproc).and.eq(proc_to_nn_dist(i,jproc),dist_min)) iproc(i) = jproc
      end do
      if (mpl%msv%is(iproc(i))) call mpl%abort('${subr}$','cannot find root processor')

      if (iproc(i)==mpl%myproc) then
         ! Check whether the location is in the hull
         if (.not.valid(i)) call mpl%abort('${subr}$','wrong processor')

         ! Local index
         ic0u = nn_index(i)
         ic0a(i) = geom%c0u_to_c0a(ic0u)

         ! Check mask
         if (il0(i)==0) then
            call convert_l2i(geom%gmask_hor_c0a(ic0a(i)),imask(i))
         else
            call convert_l2i(geom%gmask_c0a(ic0a(i),il0(i)),imask(i))
         end if
      end if
   end if
end do

! Communication
call mpl%f_comm%allreduce(ic0a,fckit_mpi_sum())
call mpl%f_comm%allreduce(imask,fckit_mpi_sum())

! Final values
do i=1,n
   if (mpl%msv%is(iproc(i))) ic0a(i) = mpl%msv%vali
   call convert_i2l(mpl,imask(i),gmask(i))
end do

! Probe out
@:probe_out()

end subroutine geom_index_from_lonlat_r1

!----------------------------------------------------------------------
! Subroutine: geom_setup_dirac
!> Setup dirac indices
!----------------------------------------------------------------------
subroutine geom_setup_dirac(geom,mpl,nam)

implicit none

! Passed variables
class(geom_type),intent(inout) :: geom !< Geometry
type(mpl_type),intent(inout) :: mpl    !< MPI data
type(nam_type),intent(in) :: nam       !< Namelist

! Local variables
integer :: idir,il0,ic0a,idir_2d,ndir_2d,jl0
integer :: il0dir(nam%ndir),iprocdir(nam%ndir),ic0adir(nam%ndir)
integer,allocatable :: nn_index(:),order(:,:),inbdir(:),idir_2dto3d(:)
real(kind_real),allocatable :: distv(:),londir_2d(:),latdir_2d(:)
logical :: valid(nam%ndir)
type(tree_type) :: tree_dirac

! Set name
@:set_name(geom_setup_dirac)

! Probe in
@:probe_in()

! Allocation
allocate(geom%inbdir(geom%nc0a,geom%nl0))

! Initialization
geom%inbdir = mpl%msv%vali

if (nam%check_dirac.and.(nam%ndir>0)) then
   write(mpl%info,'(a7,a)') '','Setup Dirac parameters'
   call mpl%flush

   ! Find level
   do idir=1,nam%ndir
      il0dir(idir) = mpl%msv%vali
      do il0=1,geom%nl0
         if (il0==nam%levdir(idir)) il0dir(idir) = il0
      end do
      if (mpl%msv%is(il0dir(idir))) call mpl%abort('${subr}$','impossible to find the Dirac level')
   end do

   ! Index from lon/lat/level
   call geom%index_from_lonlat(mpl,nam%ndir,nam%londir,nam%latdir,il0dir,iprocdir,ic0adir,valid)

   ! Allocation
   geom%ndir = count(valid)
   if (geom%ndir==0) call mpl%abort('${subr}$','no valid dirac point')
   allocate(geom%londir(geom%ndir))
   allocate(geom%latdir(geom%ndir))
   allocate(geom%iprocdir(geom%ndir))
   allocate(geom%ic0adir(geom%ndir))
   allocate(geom%il0dir(geom%ndir))
   allocate(geom%ivdir(geom%ndir))

   ! Add valid dirac points
   geom%ndir = 0
   do idir=1,nam%ndir
      if (valid(idir)) then
         geom%ndir = geom%ndir+1
         geom%iprocdir(geom%ndir) = iprocdir(idir)
         geom%ic0adir(geom%ndir) = ic0adir(idir)
         geom%il0dir(geom%ndir) = il0dir(idir)
         geom%ivdir(geom%ndir) = nam%ivdir(idir)
      end if
   end do

   ! Get exact coordinates
   do idir=1,geom%ndir
      if (geom%iprocdir(idir)==mpl%myproc) then
         geom%londir(idir) = geom%lon_c0a(geom%ic0adir(idir))
         geom%latdir(idir) = geom%lat_c0a(geom%ic0adir(idir))
      else
         geom%londir(idir) = zero
         geom%latdir(idir) = zero
      end if
   end do
   call mpl%f_comm%allreduce(geom%londir,fckit_mpi_sum())
   call mpl%f_comm%allreduce(geom%latdir,fckit_mpi_sum())

   ! Horizontal affectation
   do il0=1,geom%nl0
      ! Get number of Dirac points for this level
      ndir_2d = count(geom%il0dir==il0)

      if (ndir_2d>0) then
         ! Allocation
         allocate(londir_2d(ndir_2d))
         allocate(latdir_2d(ndir_2d))
         allocate(nn_index(ndir_2d))
         allocate(idir_2dto3d(ndir_2d))

         ! Initialization
         idir_2d = 0
         do idir=1,geom%ndir
            if (geom%il0dir(idir)==il0) then
               idir_2d = idir_2d+1
               londir_2d(idir_2d) = geom%londir(idir)
               latdir_2d(idir_2d) = geom%latdir(idir)
               idir_2dto3d(idir_2d) = idir
            end if
         end do

         ! Setup tree
         call tree_dirac%init(ndir_2d,londir_2d,latdir_2d)

         ! Affect each horizontal point to a dirac point
         do ic0a=1,geom%nc0a
            call tree_dirac%find_nearest_neighbors(mpl,geom%lon_c0a(ic0a),geom%lat_c0a(ic0a),ndir_2d,nn_index)
            geom%inbdir(ic0a,il0) = idir_2dto3d(nn_index(1))
         end do

         ! Release memory
         deallocate(londir_2d)
         deallocate(latdir_2d)
         deallocate(nn_index)
         deallocate(idir_2dto3d)
         call tree_dirac%dealloc
      end if
   end do

   ! Allocation
   allocate(distv(geom%nl0))
   allocate(order(geom%nl0,geom%nl0))
   allocate(inbdir(geom%nl0))

   ! Compute vertical distances
   order = mpl%msv%vali
   do il0=1,geom%nl0
      if (all(geom%il0dir/=il0)) then
         do jl0=1,geom%nl0
            distv(jl0) = abs(geom%vert_coordavg(il0)-geom%vert_coordavg(jl0))
         end do
         call qsort(geom%nl0,distv,order(:,il0))
      end if
   end do

   ! Vertical affectation
   do ic0a=1,geom%nc0a
      ! Copy profile
      inbdir = geom%inbdir(ic0a,:)
      do il0=1,geom%nl0
         jl0 = 1
         do while(mpl%msv%is(geom%inbdir(ic0a,il0)))
            ! Affect point
            if (mpl%msv%isnot(inbdir(order(jl0,il0)))) geom%inbdir(ic0a,il0) = inbdir(order(jl0,il0))
            jl0 = jl0+1
         end do
      end do
   end do

   ! Release memory
   deallocate(distv)
   deallocate(order)
   deallocate(inbdir)
else
   ! No dirac
   geom%ndir = 0
end if

! Probe out
@:probe_out()

end subroutine geom_setup_dirac

#:for dtype in dtypes_irl
!----------------------------------------------------------------------
! Subroutine: geom_copy_c0a_to_mga_${dtype}$_single
!> Copy from subset Sc0 to model grid, halo A, single field
!----------------------------------------------------------------------
subroutine geom_copy_c0a_to_mga_${dtype}$_single(geom,mpl,fld_c0a,fld_mga)

implicit none

! Passed variables
class(geom_type),intent(in) :: geom                         !< Geometry
type(mpl_type),intent(inout) :: mpl                         !< MPI data
${ftype[dtype]}$,intent(in) :: fld_c0a(geom%nc0a,geom%nl0)  !< Field on subset Sc0, halo A
${ftype[dtype]}$,intent(out) :: fld_mga(geom%nmga,geom%nl0) !< Field on model grid, halo A

! Local variables
integer :: ic0a,imga,il0
${ftype[dtype]}$ :: fld_c0a_masked(geom%nc0a,geom%nl0)

! Set name
@:set_name(geom_copy_c0a_to_mga_${dtype}$_single)

! Probe in
@:probe_in()

! Set masked values at missing value
do il0=1,geom%nl0
   do ic0a=1,geom%nc0a
      if (geom%gmask_c0a(ic0a,il0)) then
         fld_c0a_masked(ic0a,il0) = fld_c0a(ic0a,il0)
      else
         fld_c0a_masked(ic0a,il0) = mpl%${msv[dtype]}$
      end if
   end do
end do

if (geom%same_grid) then
   ! Same grid
   fld_mga = fld_c0a_masked
else
   ! Initialization
   fld_mga = ${zero[dtype]}$

   ! Copy from subset Sc0 to model grid
   do il0=1,geom%nl0
      do ic0a=1,geom%nc0a
         imga = geom%c0a_to_mga(ic0a)
         fld_mga(imga,il0) = fld_c0a(ic0a,il0)
      end do
   end do
end if

! Probe out
@:probe_out()

end subroutine geom_copy_c0a_to_mga_${dtype}$_single

!----------------------------------------------------------------------
! Subroutine: geom_copy_c0a_to_mga_${dtype}$_all
!> Copy from subset Sc0 to model grid, halo A, all fields
!----------------------------------------------------------------------
subroutine geom_copy_c0a_to_mga_${dtype}$_all(geom,mpl,nam,fld_c0a,fld_mga)

implicit none

! Passed variables
class(geom_type),intent(in) :: geom                                !< Geometry
type(mpl_type),intent(inout) :: mpl                                !< MPI data
type(nam_type),intent(in) :: nam                                   !< Namelist
${ftype[dtype]}$,intent(in) :: fld_c0a(geom%nc0a,geom%nl0,nam%nv)  !< Field on subset Sc0, halo A
${ftype[dtype]}$,intent(out) :: fld_mga(geom%nmga,geom%nl0,nam%nv) !< Field on model grid, halo A

! Local variables
integer :: iv

! Set name
@:set_name(geom_copy_c0a_to_mga_${dtype}$_all)

! Probe in
@:probe_in()

do iv=1,nam%nv
   call geom%copy_c0a_to_mga(mpl,fld_c0a(:,:,iv),fld_mga(:,:,iv))
end do

! Probe out
@:probe_out()

end subroutine geom_copy_c0a_to_mga_${dtype}$_all

!----------------------------------------------------------------------
! Subroutine: geom_copy_mga_to_c0a_${dtype}$_single
!> Copy from model grid to subset Sc0, halo A, single field
!----------------------------------------------------------------------
subroutine geom_copy_mga_to_c0a_${dtype}$_single(geom,mpl,fld_mga,fld_c0a)

implicit none

! Passed variables
class(geom_type),intent(in) :: geom                         !< Geometry
type(mpl_type),intent(inout) :: mpl                         !< MPI data
${ftype[dtype]}$,intent(in) :: fld_mga(geom%nmga,geom%nl0)  !< Field on model grid, halo A
${ftype[dtype]}$,intent(out) :: fld_c0a(geom%nc0a,geom%nl0) !< Field on subset Sc0, halo A

! Local variables
integer :: ic0a,imga,il0

! Set name
@:set_name(geom_copy_mga_to_c0a_${dtype}$_single)

! Probe in
@:probe_in()

if (geom%same_grid) then
   ! Same grid
   fld_c0a = fld_mga
else
   ! Copy from model grid to subset Sc0
   do il0=1,geom%nl0
      do ic0a=1,geom%nc0a
         imga = geom%c0a_to_mga(ic0a)
         fld_c0a(ic0a,il0) = fld_mga(imga,il0)
      end do
   end do
end if

! Set masked values at missing value
do il0=1,geom%nl0
   do ic0a=1,geom%nc0a
      if (.not.geom%gmask_c0a(ic0a,il0)) fld_c0a(ic0a,il0) = mpl%${msv[dtype]}$
   end do
end do

! Probe out
@:probe_out()

end subroutine geom_copy_mga_to_c0a_${dtype}$_single

!----------------------------------------------------------------------
! Subroutine: geom_copy_mga_to_c0a_${dtype}$_all
!> Copy from model grid to subset Sc0, halo A, all fields
!----------------------------------------------------------------------
subroutine geom_copy_mga_to_c0a_${dtype}$_all(geom,mpl,nam,fld_c0a,fld_mga)

implicit none

! Passed variables
class(geom_type),intent(in) :: geom                                !< Geometry
type(mpl_type),intent(inout) :: mpl                                !< MPI data
type(nam_type),intent(in) :: nam                                   !< Namelist
${ftype[dtype]}$,intent(in) :: fld_mga(geom%nmga,geom%nl0,nam%nv)  !< Field on model grid, halo A
${ftype[dtype]}$,intent(out) :: fld_c0a(geom%nc0a,geom%nl0,nam%nv) !< Field on subset Sc0, halo A

! Local variables
integer :: iv

! Set name
@:set_name(geom_copy_mga_to_c0a_${dtype}$_all)

! Probe in
@:probe_in()

do iv=1,nam%nv
   call geom%copy_mga_to_c0a(mpl,fld_mga(:,:,iv),fld_c0a(:,:,iv))
end do

! Probe out
@:probe_out()

end subroutine geom_copy_mga_to_c0a_${dtype}$_all
#:endfor

!----------------------------------------------------------------------
! Subroutine: geom_fieldset_to_c0
!> Fieldset to Fortran array on subset Sc0
!----------------------------------------------------------------------
subroutine geom_fieldset_to_c0(geom,mpl,nam,fieldset,fld_c0a)

implicit none

! Passed variables
class(geom_type),intent(in) :: geom                               !< Geometry
type(mpl_type),intent(inout) :: mpl                               !< MPI data
type(nam_type),intent(in) :: nam                                  !< Namelist
type(fieldset_type),intent(in) :: fieldset                        !< Fieldset
real(kind_real),intent(out) :: fld_c0a(geom%nc0a,geom%nl0,nam%nv) !< Field on subset Sc0, halo A

! Local variables
real(kind_real) :: fld_mga(geom%nmga,geom%nl0,nam%nv)

! Set name
@:set_name(geom_fieldset_to_c0)

! Probe in
@:probe_in()

if (geom%same_grid) then
   ! Fieldset to Fortran array on subset Sc0
   call fieldset%to_array(mpl,fld_c0a)
else
   ! Fieldset to Fortran array on model grid
   call fieldset%to_array(mpl,fld_mga)

   ! Model grid to subset Sc0
   call geom%copy_mga_to_c0a(mpl,nam,fld_c0a,fld_mga)
end if

! Probe out
@:probe_out()

end subroutine geom_fieldset_to_c0

!----------------------------------------------------------------------
! Subroutine: geom_c0_to_fieldset
!> Fortran array on subset Sc0 to fieldset
!----------------------------------------------------------------------
subroutine geom_c0_to_fieldset(geom,mpl,nam,fld_c0a,fieldset)

implicit none

! Passed variables
class(geom_type),intent(in) :: geom                              !< Geometry
type(mpl_type),intent(inout) :: mpl                              !< MPI data
type(nam_type),intent(in) :: nam                                 !< Namelist
real(kind_real),intent(in) :: fld_c0a(geom%nc0a,geom%nl0,nam%nv) !< Field on subset Sc0, halo A
type(fieldset_type),intent(inout) :: fieldset                    !< Fieldset

! Local variables
real(kind_real),allocatable :: fld_mga(:,:,:)

! Set name
@:set_name(geom_c0_to_fieldset)

! Probe in
@:probe_in()

if (geom%same_grid) then
   ! Fortran array on subset Sc0 to fieldset
   call fieldset%from_array(mpl,fld_c0a)
else
   ! Allocation
   allocate(fld_mga(geom%nmga,geom%nl0,nam%nv))

   ! Subset Sc0 to model grid
   call geom%copy_c0a_to_mga(mpl,nam,fld_c0a,fld_mga)

   ! Fortran array on model grid to fieldset
   call fieldset%from_array(mpl,fld_mga)

   ! Release memory
   deallocate(fld_mga)
end if

! Probe out
@:probe_out()

end subroutine geom_c0_to_fieldset

!----------------------------------------------------------------------
! Subroutine: geom_rand_point
!> Select random valid point on the horizontal grid
!----------------------------------------------------------------------
subroutine geom_rand_point(geom,mpl,rng,il0,iproc,ic0a,nr)

implicit none

! Passed variables
class(geom_type),intent(in) :: geom !< Geometry
type(mpl_type),intent(inout) :: mpl !< MPI data
type(rng_type),intent(inout) :: rng !< Random number generator
integer,intent(in) :: il0           !< Level
integer,intent(out) :: iproc        !< Processor
integer,intent(out) :: ic0a         !< Local index
integer,intent(out),optional :: nr  !< Number of random tries

! Local variables
integer :: lnr
real(kind_real) :: lon,lat,x,y
logical :: valid

! Set name
@:set_name(geom_rand_point)

! Probe in
@:probe_in()

! Initialization
valid = .false.
lnr = 0

! Loop
do while (.not.valid)
   ! Generate random lon/lat
   if (geom%global) then
      call rng%rand(-pi,pi,lon)
      call rng%rand(-one,one,lat)
      lat = asin(lat)
   else
      call rng%rand(zero,one,x)
      call rng%rand(zero,one,y)
      x = geom%xmin+x*(geom%xmax-geom%xmin)
      y = geom%ymin+y*(geom%ymax-geom%ymin)
      call geom%aproj_work%xy2lonlat(x*rad2deg,y*rad2deg,lon,lat)
      lon = lon*deg2rad
      lat = lat*deg2rad
   end if

   ! Get index from lon/lat
   call geom%index_from_lonlat(mpl,lon,lat,il0,iproc,ic0a,valid)

   ! Update number of tries
   lnr = lnr+1
end do

! Set number of tries
if (present(nr)) nr = lnr

! Probe out
@:probe_out()

end subroutine geom_rand_point

!----------------------------------------------------------------------
! Subroutine: geom_initialize_sampling
!> Intialize sampling
!----------------------------------------------------------------------
subroutine geom_initialize_sampling(geom,mpl,rng,method,ncxa,lon_cxa,lat_cxa,mask_cxa,rh_cxa,cxa_to_cx,ncxu,cxu_to_cxa,tree_cxu, &
 & hull_cxu,ifmt,ns,s_to_cx)

implicit none

! Passed variables
class(geom_type),intent(in) :: geom         !< Geometry
type(mpl_type),intent(inout) :: mpl         !< MPI data
type(rng_type),intent(inout) :: rng         !< Random number generator
character(len=*),intent(in) :: method       !< Sampling method (potential or maxrandom)
integer,intent(in) :: ncxa                  !< Number of points (local)
real(kind_real),intent(in) :: lon_cxa(ncxa) !< Longitudes (local)
real(kind_real),intent(in) :: lat_cxa(ncxa) !< Latitudes (local)
logical,intent(in) :: mask_cxa(ncxa)        !< Mask (local)
real(kind_real),intent(in) :: rh_cxa(ncxa)  !< Horizontal support radius (local)
integer,intent(in) :: cxa_to_cx(ncxa)       !< Local to global index
integer,intent(in) :: ncxu                  !< Number of points (universe)
integer,intent(in) :: cxu_to_cxa(ncxu)      !< Universe to local index
type(tree_type),intent(in) :: tree_cxu      !< Universe KD-tree
type(hull_type),intent(in) :: hull_cxu      !< Universe hull
integer,intent(in) :: ifmt                  !< Format indentation
integer,intent(in) :: ns                    !< Number of samplings points (global)
integer,intent(out) :: s_to_cx(ns)          !< Horizontal sampling index (global)

! Local variables
integer :: ncxa_eff,ncx_eff,isa,icxa,is,icx,nfac,nssa,nss,issa,ix,iy,issamin,icxmin,iprocmin,nsa,nodemin,inode,hash,iss,iproc
integer :: nssa_val,irmax,irvalmax,itry,irval,ir,irep,is_min,js,nrep
integer :: nn_index(2),proc_to_ncxa(mpl%nproc),proc_to_cx_offset(mpl%nproc)
integer,allocatable :: proc_to_icxmin(:),ssa_to_cx(:),ssa_to_node(:),s_to_ssa(:),to_valid(:),order(:)
integer,allocatable :: proc_to_nodemin(:),sa_to_s(:),order_s(:),cxa_to_node(:)
integer,allocatable :: proc_to_nssa(:),ssa_to_ss(:),ss_to_cxa(:),ss_to_cx(:),ss_to_node(:)
real(kind_real) :: lonlat(2),valmin,xmin,ymin,zmin,chmin,dist,x_start,y_start,z_start,dist_max,d,nn_dist(2),dist_min,x,y,distx,disty
real(kind_real),allocatable :: rhc_cxa(:),proc_to_xmin(:),proc_to_ymin(:),proc_to_zmin(:),proc_to_chmin(:)
real(kind_real),allocatable :: x_ssa(:),y_ssa(:),z_ssa(:),ch_ssa(:),potential(:),lon_sa(:),lat_sa(:),lon_s(:),lat_s(:)
real(kind_real),allocatable :: lon_ssa(:),lat_ssa(:),rh_ssa(:),lon_rep(:),lat_rep(:),rh_rep(:),dist_rep(:)
real(kind_real),allocatable :: x_ss(:),y_ss(:),z_ss(:),ch_ss(:),lon_ss(:),lat_ss(:),rh_ss(:)
logical :: retry,valid
logical,allocatable :: lmask_cxa(:),lmask_ssa(:),indist_ssa(:),gmask_s(:),rmask(:)
character(len=1024) :: cfmt
type(atlas_structuredgrid) :: agrid
type(tree_type) :: tree

! Set name
@:set_name(geom_initialize_sampling)

! Probe in
@:probe_in()

! Check method
select case (method)
case ('potential','maxrandom')
case default
   call mpl%abort('${subr}$','wrong sampling method: '//trim(method))
end select

! Number of effective points
ncxa_eff = zss_count(mask_cxa)
call mpl%f_comm%allreduce(ncxa_eff,ncx_eff,fckit_mpi_sum())

! Check mask size
if (ncx_eff==0) then
   ! Empty mask
   call mpl%abort('${subr}$','empty mask in initialize sampling')
elseif (ns>nsmax) then
   ! Sampling is too large
   call mpl%abort('${subr}$','sampling size is too large')
else
   ! Sampling

   ! Allocation
   allocate(lmask_cxa(ncxa))
   allocate(cxa_to_node(ncxa))
   allocate(rhc_cxa(ncxa))

   ! First step: decimate the grid

   ! Initialization
   nfac = nfacmin
   retry = .true.
   write(cfmt,'(a,i2.2,a)') '(a',ifmt+3,',a,i8,a)'
   write(mpl%test,trim(cfmt)) '','Decimate full grid, at least ',ns,' points required, '
   if (ifmt>0) call mpl%flush(newl=.false.)

   ! Compute corrected length-scale
   if (geom%global) then
      rhc_cxa = rh_cxa
   else
      do icxa=1,ncxa
         ! Compute distances to the boundaries
         call geom%aproj_work%lonlat2xy(lon_cxa(icxa)*rad2deg,lat_cxa(icxa)*rad2deg,x,y)
         x = x*deg2rad
         y = y*deg2rad
         call lonlatmod(x,y)
         distx = two*min(abs(x-geom%xmin),abs(x-geom%xmax))/(geom%xmax-geom%xmin)
         disty = two*min(abs(y-geom%ymin),abs(y-geom%ymax))/(geom%ymax-geom%ymin)

         ! Apply empirical factor
         rhc_cxa(icxa) = rh_cxa(icxa)*(one-half*distx*disty)*(one+exp(-hundred*distx*disty))
      end do
   end if

   do while (retry)
      if (ncxa > 0) then
         ! Initialization
         lmask_cxa = .false.
         cxa_to_node = mpl%msv%vali

         ! Update nfac
         nfac = 2*nfac

         if (geom%global) then
            ! Global grid or regional grid with NodeColumns function space (sub-optimal)
            call get_grid(mpl,floor(real(nfac*ns,kind_real)*four*pi/geom%area_max_c0*(one+repro_th)),agrid,nss)
         else
            ! Regional grid
            call get_grid(mpl,nfac*ns,geom%aconfig_work_grid,geom%aproj_work,geom%xmin,geom%xmax,geom%ymin,geom%ymax,agrid,nss)
         end if

         ! Loop over grid points
         inode = 0
         do iy=1,int(agrid%ny(),kind_int)
            do ix=1,int(agrid%nx(iy),kind_int)
               ! Global index
               inode = inode+1

               ! Get longitude/latitude
               lonlat = agrid%lonlat(ix,iy)*deg2rad
               call lonlatmod(lonlat(1),lonlat(2))

               ! Check if point is inside the universe hull
               call hull_cxu%inside(mpl,lonlat(1),lonlat(2),valid)

               if (valid) then
                  ! Find nearest neighbor in universe
                  call tree_cxu%find_nearest_neighbors(mpl,lonlat(1),lonlat(2),1,nn_index(1:1))
                  icxa = cxu_to_cxa(nn_index(1))

                  ! Keep valid points on each processor
                  if (mpl%msv%isnot(icxa)) then
                     lmask_cxa(icxa) = mask_cxa(icxa)
                     cxa_to_node(icxa) = inode
                  end if
               end if
            end do
         end do

         ! Release memory
         call agrid%final()

         ! Local number of valid points
         nssa = zss_count(lmask_cxa)
      else
         ! Local number of valid points
         nssa = 0
      end if

      ! Global number of valid points
      call mpl%f_comm%allreduce(nssa,nss,fckit_mpi_sum())

      ! Print result
      write(mpl%test,'(i8,a)') nss,' valid points found'
      if (ifmt>0) call mpl%flush
      retry = (nss<ns)
   end do

   ! Second step: get data on effective local grid

   ! Allocation
   allocate(ssa_to_cx(nssa))
   allocate(ssa_to_node(nssa))
   if (method=='potential') then
      allocate(x_ssa(nssa))
      allocate(y_ssa(nssa))
      allocate(z_ssa(nssa))
      allocate(ch_ssa(nssa))
   elseif (method=='maxrandom') then
      allocate(lon_ssa(nssa))
      allocate(lat_ssa(nssa))
      allocate(rh_ssa(nssa))
   end if

   ! Initialization
   issa = 0
   do icxa=1,ncxa
      if (lmask_cxa(icxa)) then
         issa = issa+1
         icx = cxa_to_cx(icxa)
         ssa_to_cx(issa) = icx
         ssa_to_node(issa) = cxa_to_node(icxa)
         if (method=='potential') then
            call lonlat2xyz(mpl,lon_cxa(icxa),lat_cxa(icxa),x_ssa(issa),y_ssa(issa),z_ssa(issa))
            ch_ssa(issa) = two*sin(half*min(rhc_cxa(icxa),pi))
         elseif (method=='maxrandom') then
            lon_ssa(issa) = lon_cxa(icxa)
            lat_ssa(issa) = lat_cxa(icxa)
            rh_ssa(issa) = rhc_cxa(icxa)
         end if
      end if
   end do

   if (.not.parallel) then
      ! Allocation
      allocate(proc_to_nssa(mpl%nproc))
      allocate(ssa_to_ss(nssa))
      if (mpl%main) then
         allocate(ss_to_cxa(nss))
         allocate(ss_to_cx(nss))
         allocate(ss_to_node(nss))
         if (method=='potential') then
            allocate(x_ss(nss))
            allocate(y_ss(nss))
            allocate(z_ss(nss))
            allocate(ch_ss(nss))
         elseif (method=='maxrandom') then
            allocate(lon_ss(nss))
            allocate(lat_ss(nss))
            allocate(rh_ss(nss))
         end if
      else
         allocate(ss_to_cxa(0))
         allocate(ss_to_cx(0))
         allocate(ss_to_node(0))
         if (method=='potential') then
            allocate(x_ss(0))
            allocate(y_ss(0))
            allocate(z_ss(0))
            allocate(ch_ss(0))
         elseif (method=='maxrandom') then
            allocate(lon_ss(0))
            allocate(lat_ss(0))
            allocate(rh_ss(0))
         end if
      end if

      ! Initialization
      call mpl%f_comm%allgather(nssa,proc_to_nssa)
      iss = 0
      do iproc=1,mpl%nproc
         do issa=1,proc_to_nssa(iproc)
            iss = iss+1
            if (iproc==mpl%myproc) ssa_to_ss(issa) = iss
         end do
      end do

      ! Second step and a half: get data on effective global grid
      call mpl%loc_to_glb(nssa,nss,ssa_to_ss,ssa_to_cx,ss_to_cx)
      call mpl%loc_to_glb(nssa,nss,ssa_to_ss,ssa_to_node,ss_to_node)
      if (method=='potential') then
         call mpl%loc_to_glb(nssa,nss,ssa_to_ss,x_ssa,x_ss)
         call mpl%loc_to_glb(nssa,nss,ssa_to_ss,y_ssa,y_ss)
         call mpl%loc_to_glb(nssa,nss,ssa_to_ss,z_ssa,z_ss)
         call mpl%loc_to_glb(nssa,nss,ssa_to_ss,ch_ssa,ch_ss)
      elseif (method=='maxrandom') then
         call mpl%loc_to_glb(nssa,nss,ssa_to_ss,lon_ssa,lon_ss)
         call mpl%loc_to_glb(nssa,nss,ssa_to_ss,lat_ssa,lat_ss)
         call mpl%loc_to_glb(nssa,nss,ssa_to_ss,rh_ssa,rh_ss)
      end if

      if (mpl%main) then
         ! Mimick local variables
         nssa = nss

         ! Release memory
         deallocate(ssa_to_cx)
         deallocate(ssa_to_node)
         if (method=='potential') then
            deallocate(x_ssa)
            deallocate(y_ssa)
            deallocate(z_ssa)
            deallocate(ch_ssa)
         elseif (method=='maxrandom') then
            deallocate(lon_ssa)
            deallocate(lat_ssa)
            deallocate(rh_ssa)
         end if

         ! Allocation
         allocate(ssa_to_cx(nssa))
         allocate(ssa_to_node(nssa))
         if (method=='potential') then
            allocate(x_ssa(nssa))
            allocate(y_ssa(nssa))
            allocate(z_ssa(nssa))
            allocate(ch_ssa(nssa))
         elseif (method=='maxrandom') then
            allocate(lon_ssa(nssa))
            allocate(lat_ssa(nssa))
            allocate(rh_ssa(nssa))
         end if

         ! Copy
         ssa_to_cx = ss_to_cx
         ssa_to_node = ss_to_node
         if (method=='potential') then
            x_ssa = x_ss
            y_ssa = y_ss
            z_ssa = z_ss
            ch_ssa = ch_ss
         elseif (method=='maxrandom') then
            lon_ssa = lon_ss
            lat_ssa = lat_ss
            rh_ssa = rh_ss
         end if

         ! Release memory
         deallocate(ss_to_cxa)
         deallocate(ss_to_cx)
         deallocate(ss_to_node)
         if (method=='potential') then
            deallocate(x_ss)
            deallocate(y_ss)
            deallocate(z_ss)
            deallocate(ch_ss)
         elseif (method=='maxrandom') then
            deallocate(lon_ss)
            deallocate(lat_ss)
            deallocate(rh_ss)
         end if
      end if
   end if

   ! Initialization
   s_to_cx = mpl%msv%vali

   if (method=='potential') then
      ! Third step: electric potential method
      if (parallel.or.mpl%main) then
         write(cfmt,'(a,i2.2,a)') '(a',ifmt+3,',a)'
         write(mpl%info,trim(cfmt)) '','Potential method: '

         ! Allocation
         allocate(potential(nssa))
         allocate(lmask_ssa(nssa))
         allocate(indist_ssa(nssa))
         allocate(proc_to_nodemin(mpl%nproc))
         allocate(proc_to_xmin(mpl%nproc))
         allocate(proc_to_ymin(mpl%nproc))
         allocate(proc_to_zmin(mpl%nproc))
         allocate(proc_to_chmin(mpl%nproc))
         allocate(proc_to_icxmin(mpl%nproc))

         ! Initialization
         lmask_ssa = .true.
         if (ifmt>0) then
            call mpl%flush(newl=.false.)
            call mpl%prog_init(ns)
         end if

         ! Define starting point
         if (geom%global) then
            ! Global grid
            x_start = zero
            y_start = zero
            z_start = one
         else
            ! Regional grid
            call lonlat2xyz(mpl,geom%lon_center,geom%lat_center,x_start,y_start,z_start)
         end if

         ! Compute distance to the starting point
         is = 1

         ! Compute distance to point of coordinate (0,0)
         do issa=1,nssa
            call cart_dist(x_ssa(issa),y_ssa(issa),z_ssa(issa),x_start,y_start,z_start,potential(issa))
         end do

         ! Find minimum distance globally
         valmin = zss_minval(potential)
         if (parallel) call mpl%f_comm%allreduce(valmin,fckit_mpi_min())

         ! Check if minimum is indistinguishable
         do issa=1,nssa
            indist_ssa(issa) = indist(potential(issa),valmin)
         end do
         if (count(indist_ssa)<1) call mpl%abort('${subr}$','cannot find minimum')
         nodemin = mpl%msv%vali
         xmin = mpl%msv%valr
         ymin = mpl%msv%valr
         zmin = mpl%msv%valr
         chmin = mpl%msv%valr
         icxmin = mpl%msv%vali
         if (nssa>0) then
            if (any(indist_ssa)) then
               issamin = minloc(ssa_to_node,mask=indist_ssa,dim=1)
               nodemin = ssa_to_node(issamin)
               xmin = x_ssa(issamin)
               ymin = y_ssa(issamin)
               zmin = z_ssa(issamin)
               chmin = ch_ssa(issamin)
               icxmin = ssa_to_cx(issamin)
            end if
         end if

         if (parallel) then
            ! Communication
            call mpl%f_comm%allgather(nodemin,proc_to_nodemin)
            call mpl%f_comm%allgather(xmin,proc_to_xmin)
            call mpl%f_comm%allgather(ymin,proc_to_ymin)
            call mpl%f_comm%allgather(zmin,proc_to_zmin)
            call mpl%f_comm%allgather(chmin,proc_to_chmin)
            call mpl%f_comm%allgather(icxmin,proc_to_icxmin)

            ! Find processor handling the minimum distance
            iprocmin = minloc(proc_to_nodemin,mask=mpl%msv%isnot(proc_to_nodemin),dim=1)
         else
            ! Root proc only
            iprocmin = mpl%rootproc
            proc_to_nodemin(iprocmin) = nodemin
            proc_to_xmin(iprocmin) = xmin
            proc_to_ymin(iprocmin) = ymin
            proc_to_zmin(iprocmin) = zmin
            proc_to_chmin(iprocmin) = chmin
            proc_to_icxmin(iprocmin) = icxmin
         end if

         ! Reset potential
         potential = zero

         ! Update global sampling, local mask and local potential
         s_to_cx(is) = proc_to_icxmin(iprocmin)
         if (iprocmin==mpl%myproc) lmask_ssa(issamin) = .false.
         !$omp parallel do schedule(static) private(issa,dist)
         do issa=1,nssa
            if (lmask_ssa(issa)) then
               ! Cartesian distance
               call cart_dist(x_ssa(issa),y_ssa(issa),z_ssa(issa), &
 & proc_to_xmin(iprocmin),proc_to_ymin(iprocmin),proc_to_zmin(iprocmin),dist)

               ! Update potential
               potential(issa) = potential(issa)+proc_to_chmin(iprocmin)/dist
            end if
         end do
         !$omp end parallel do

         ! Update
         if (ifmt>0) call mpl%prog_print(is)

         ! Set other points where the potential is minimum
         do is=2,ns
            ! Find minimum distance globally
            valmin = huge_real
            if (nssa>0) then
               if (any(lmask_ssa)) valmin = zss_minval(potential,mask=lmask_ssa)
            end if
            if (parallel) call mpl%f_comm%allreduce(valmin,fckit_mpi_min())

            ! Check if minimum is indistinguishable
            indist_ssa = .false.
            do issa=1,nssa
               if (lmask_ssa(issa)) indist_ssa(issa) = indist(potential(issa),valmin)
            end do
            nodemin = mpl%msv%vali
            xmin = mpl%msv%valr
            ymin = mpl%msv%valr
            zmin = mpl%msv%valr
            chmin = mpl%msv%valr
            icxmin = mpl%msv%vali
            if (nssa>0) then
               if (any(indist_ssa)) then
                  issamin = minloc(ssa_to_node,mask=indist_ssa,dim=1)
                  nodemin = ssa_to_node(issamin)
                  xmin = x_ssa(issamin)
                  ymin = y_ssa(issamin)
                  zmin = z_ssa(issamin)
                  chmin = ch_ssa(issamin)
                  icxmin = ssa_to_cx(issamin)
               end if
            end if

            if (parallel) then
               ! Communication
               call mpl%f_comm%allgather(nodemin,proc_to_nodemin)
               call mpl%f_comm%allgather(xmin,proc_to_xmin)
               call mpl%f_comm%allgather(ymin,proc_to_ymin)
               call mpl%f_comm%allgather(zmin,proc_to_zmin)
               call mpl%f_comm%allgather(chmin,proc_to_chmin)
               call mpl%f_comm%allgather(icxmin,proc_to_icxmin)

               ! Find processor handling the minimum distance
               iprocmin = minloc(proc_to_nodemin,mask=mpl%msv%isnot(proc_to_nodemin),dim=1)
            else
               ! Root proc only
               iprocmin = mpl%rootproc
               proc_to_nodemin(iprocmin) = nodemin
               proc_to_xmin(iprocmin) = xmin
               proc_to_ymin(iprocmin) = ymin
               proc_to_zmin(iprocmin) = zmin
               proc_to_chmin(iprocmin) = chmin
               proc_to_icxmin(iprocmin) = icxmin
            end if

            ! Update global sampling, local mask and local potential
            s_to_cx(is) = proc_to_icxmin(iprocmin)
            if (iprocmin==mpl%myproc) lmask_ssa(issamin) = .false.
            !$omp parallel do schedule(static) private(issa,dist)
            do issa=1,nssa
               if (lmask_ssa(issa)) then
                  ! Cartesian distance
                  call cart_dist(x_ssa(issa),y_ssa(issa),z_ssa(issa), &
    & proc_to_xmin(iprocmin),proc_to_ymin(iprocmin),proc_to_zmin(iprocmin),dist)

                  ! Update potential
                  potential(issa) = potential(issa)+proc_to_chmin(iprocmin)/dist
               end if
            end do
            !$omp end parallel do

            ! Update
            if (ifmt>0) call mpl%prog_print(is)
         end do
         if (ifmt>0) call mpl%prog_final

         ! Release memory
         deallocate(potential)
         deallocate(lmask_ssa)
         deallocate(indist_ssa)
         deallocate(proc_to_xmin)
         deallocate(proc_to_ymin)
         deallocate(proc_to_zmin)
         deallocate(proc_to_chmin)
         deallocate(proc_to_nodemin)
         deallocate(proc_to_icxmin)
      end if

      ! Release memory
      deallocate(x_ssa)
      deallocate(y_ssa)
      deallocate(z_ssa)
      deallocate(ch_ssa)
   elseif (method=='maxrandom') then
      if (mpl%main) then
         write(cfmt,'(a,i2.2,a)') '(a',ifmt+3,',a)'
         write(mpl%info,trim(cfmt)) '','Random selection method: '

         ! Check consistency
         if (parallel) call mpl%abort('${subr}$','potential method required for parallel sampling initialization')

         ! Number of removed points
         nrep = int(frep*real(ns,kind_real))

         ! Allocation
         allocate(s_to_ssa(ns+nrep))
         allocate(lmask_ssa(nssa))
         allocate(to_valid(nssa))
         allocate(order(nssa))

         ! Initialization
         s_to_ssa = mpl%msv%vali
         if (ifmt>0) then
            call mpl%flush(newl=.false.)
            call mpl%prog_init(ns+nrep)
         end if
         lmask_ssa = .false.
         to_valid = mpl%msv%vali
         do issa=1,nssa
            to_valid(issa) = issa
         end do
         nssa_val = nssa

         ! Define points order
         call qsort(nssa,ssa_to_node,order)

         ! Reorder data
         ssa_to_cx = ssa_to_cx(order)
         lon_ssa = lon_ssa(order)
         lat_ssa = lat_ssa(order)
         rh_ssa = rh_ssa(order)

         ! Define sampling with a KD-tree
         do is=1,ns+nrep
            ! Setup tree
            if (is>2) call tree%init(nssa,lon_ssa,lat_ssa,lmask_ssa)

            ! Initialization
            dist_max = zero
            irmax = 0
            irvalmax = 0
            itry = 1

            ! Find a new point
            do itry=1,ntry
               ! Generate a random index among valid points
               call rng%rand(1,nssa_val,irval)
               ir = to_valid(irval)

               ! Check point validity
               if (is==1) then
                  ! Accept point
                  irvalmax = irval
                  irmax = ir
               else
                  if (is==2) then
                     ! Compute distance
                     nn_index(1) = s_to_ssa(1)
                     call sphere_dist(lon_ssa(ir),lat_ssa(ir),lon_ssa(nn_index(1)),lat_ssa(nn_index(1)),nn_dist(1))
                  else
                     ! Find nearest neighbor distance
                     call tree%find_nearest_neighbors(mpl,lon_ssa(ir),lat_ssa(ir),1,nn_index(1:1),nn_dist(1:1))
                  end if
                  d = nn_dist(1)**2/(rh_ssa(ir)**2+rh_ssa(nn_index(1))**2)

                  ! Check distance
                  if (sup(d,dist_max)) then
                     dist_max = d
                     irvalmax = irval
                     irmax = ir
                  end if
               end if
            end do

            ! Delete tree
            if (is>2) call tree%dealloc

            ! Add point to sampling
            if (irmax>0) then
               ! New sampling point
               s_to_ssa(is) = irmax
               lmask_ssa(irmax) = .true.

               ! Shift valid points array
               if (irvalmax<nssa_val) to_valid(irvalmax:nssa_val-1) = to_valid(irvalmax+1:nssa_val)
               nssa_val = nssa_val-1
            end if

            ! Update
            if (ifmt>0) call mpl%prog_print(is)
         end do
         if (ifmt>0) call mpl%prog_final

         ! Release memory
         deallocate(lmask_ssa)
         deallocate(to_valid)
         deallocate(order)

         if (nrep>0) then
            write(cfmt,'(a,i2.2,a)') '(a',ifmt+3,',a,i6,a)'
            write(mpl%info,trim(cfmt)) '','Remove ',nrep,' closest points:'

            ! Allocation
            allocate(rmask(ns+nrep))
            allocate(lon_rep(ns+nrep))
            allocate(lat_rep(ns+nrep))
            allocate(rh_rep(ns+nrep))
            allocate(dist_rep(ns+nrep))

            ! Initialization
            rmask = .true.
            do is=1,ns+nrep
               lon_rep(is) = lon_ssa(s_to_ssa(is))
               lat_rep(is) = lat_ssa(s_to_ssa(is))
               rh_rep(is) = rh_ssa(s_to_ssa(is))
            end do
            dist_rep = mpl%msv%valr
            if (ifmt>0) then
               call mpl%flush(newl=.false.)
               call mpl%prog_init(ns+nrep)
            end if

            ! Remove closest points
            do irep=1,nrep
               ! Setup tree
               call tree%init(ns+nrep,lon_rep,lat_rep,rmask)

               ! Get minimum distance
               do is=1,ns+nrep
                  if (rmask(is)) then
                     ! Find nearest neighbor distance
                     call tree%find_nearest_neighbors(mpl,lon_rep(is),lat_rep(is),2,nn_index,nn_dist)
                     if (nn_index(1)==is) then
                        dist_rep(is) = nn_dist(2)
                     elseif (nn_index(2)==is) then
                        dist_rep(is) = nn_dist(1)
                     else
                        call mpl%abort('${subr}$','wrong index in replacement')
                     end if
                     dist_rep(is) = dist_rep(is)**2/(rh_rep(nn_index(1))**2+rh_rep(nn_index(2))**2)
                  end if
               end do

               ! Delete tree
               call tree%dealloc

               ! Remove worst point
               dist_min = huge_real
               is_min = mpl%msv%vali
               do is=1,ns+nrep
                  if (rmask(is)) then
                     if (inf(dist_rep(is),dist_min)) then
                        is_min = is
                        dist_min = dist_rep(is)
                     end if
                  end if
               end do
               rmask(is_min) = .false.

                ! Update
               if (ifmt>0) call mpl%prog_print(irep)
            end do
            if (ifmt>0) call mpl%prog_final

            ! Check rmask size
            if (count(rmask)/=ns) call mpl%abort('${subr}$','wrong number of valid points in rmask')

            ! Get global sampling
            js = 0
            do is=1,ns+nrep
               if (rmask(is)) then
                  js = js+1
                  s_to_cx(js) = ssa_to_cx(s_to_ssa(is))
               end if
            end do

            ! Release memory
            deallocate(rmask)
            deallocate(lon_rep)
            deallocate(lat_rep)
            deallocate(rh_rep)
            deallocate(dist_rep)
         else
            ! Get global sampling
            s_to_cx = ssa_to_cx(s_to_ssa)
         end if

         ! Release memory
         deallocate(s_to_ssa)
      end if
   end if

   ! Release memory
   deallocate(rhc_cxa)
   deallocate(lmask_cxa)
   deallocate(cxa_to_node)
   deallocate(ssa_to_cx)
   deallocate(ssa_to_node)
end if

! Reorder points

! Broadcast
if (.not.parallel) call mpl%f_comm%broadcast(s_to_cx,mpl%rootproc-1)

! Offset
call mpl%f_comm%allgather(ncxa,proc_to_ncxa)
proc_to_cx_offset(1) = 0
do iproc=2,mpl%nproc
   proc_to_cx_offset(iproc) = proc_to_cx_offset(iproc-1)+proc_to_ncxa(iproc-1)
end do

! Allocation
nsa = 0
do is=1,ns
   icx = s_to_cx(is)
   iproc = cx_to_proc(geom%nproc,proc_to_cx_offset,icx)
   if (iproc==mpl%myproc) nsa = nsa+1
end do
allocate(sa_to_s(nsa))
allocate(lon_sa(nsa))
allocate(lat_sa(nsa))
allocate(lon_s(ns))
allocate(lat_s(ns))
allocate(order_s(ns))
allocate(gmask_s(ns))

! Initialization
isa = 0
do is=1,ns
   icx = s_to_cx(is)
   iproc = cx_to_proc(geom%nproc,proc_to_cx_offset,icx)
   if (iproc==mpl%myproc) then
      isa = isa+1
      icxa = cx_to_cxa(geom%nproc,proc_to_cx_offset,icx)
      sa_to_s(isa) = is
      lon_sa(isa) = lon_cxa(icxa)
      lat_sa(isa) = lat_cxa(icxa)
   end if
end do

! Communication
call mpl%loc_to_glb(nsa,ns,sa_to_s,lon_sa,lon_s,.true.)
call mpl%loc_to_glb(nsa,ns,sa_to_s,lat_sa,lat_s,.true.)

! Define points order
call qsort(ns,lon_s,lat_s,order_s)

! Reorder sampling
s_to_cx = s_to_cx(order_s)

! Grid hash
gmask_s = .true.
call grid_hash(ns,lon_s,lat_s,gmask_s,hash)

! Test grid hash
write(cfmt,'(a,i2.2,a)') '(a',ifmt+3,',a,i12)'
write(mpl%test,trim(cfmt)) '','Subgrid hash: ',hash
if (ifmt>0) call mpl%flush

! Release memory
deallocate(sa_to_s)
deallocate(lon_sa)
deallocate(lat_sa)
deallocate(lon_s)
deallocate(lat_s)
deallocate(order_s)
deallocate(gmask_s)

! Probe out
@:probe_out()

end subroutine geom_initialize_sampling

!----------------------------------------------------------------------
! Subroutine: geom_define_test_vectors
!> Define test vectors
!----------------------------------------------------------------------
subroutine geom_define_test_vectors(geom,mpl,rng,nam,ntest,fld)

! Passed variables
class(geom_type),intent(in) :: geom                                 !< Geometry
type(mpl_type),intent(inout) :: mpl                                 !< MPI data
type(rng_type),intent(inout) :: rng                                 !< Random number generator
type(nam_type),intent(in) :: nam                                    !< Namelist
integer,intent(in) :: ntest                                         !< Number of vectors
real(kind_real),intent(out) :: fld(geom%nc0a,geom%nl0,nam%nv,ntest) !< Field

! Local variables
integer :: itest
integer :: il0dir,iprocdir,ic0adir

! Set name
@:set_name(geom_define_test_vectors)

! Probe in
@:probe_in()

! Resynchronize random number generator
call rng%resync(mpl)

do itest=1,ntest
   ! Define random dirac location
   call rng%rand(1,geom%nl0,il0dir)
   call geom%rand_point(mpl,rng,il0dir,iprocdir,ic0adir)

   ! Define test vector
   fld(:,:,:,itest) = zero
   if (iprocdir==mpl%myproc) fld(ic0adir,il0dir,1,itest) = one
end do

! Desynchronize random number generator
call rng%desync(mpl)

! Reset random seed if necessary
call rng%reseed

! Probe out
@:probe_out()

end subroutine geom_define_test_vectors

!----------------------------------------------------------------------
! Function: geom_c0_to_c0a
!> Conversion from global to halo A on subset Sc0
!----------------------------------------------------------------------
function geom_c0_to_c0a(geom,ic0) result(ic0a)

implicit none

! Passed variables
class(geom_type),intent(in) :: geom !< Geometry
integer,intent(in) :: ic0           !< Global index

! Returned variable
integer :: ic0a

! Set name
@:set_name(geom_c0_to_c0a)

! Probe in
@:probe_in()

! Call generic function
ic0a = cx_to_cxa(geom%nproc,geom%proc_to_c0_offset,ic0)

! Probe out
@:probe_out()

end function geom_c0_to_c0a

!----------------------------------------------------------------------
! Function: geom_c0_to_proc
!> Conversion from global to processor on subset Sc0
!----------------------------------------------------------------------
function geom_c0_to_proc(geom,ic0) result(iproc)

implicit none

! Passed variables
class(geom_type),intent(in) :: geom !< Geometry
integer,intent(in) :: ic0           !< Global index

! Returned variable
integer :: iproc

! Set name
@:set_name(geom_c0_to_proc)

! Probe in
@:probe_in()

! Call generic function
iproc = cx_to_proc(geom%nproc,geom%proc_to_c0_offset,ic0)

! Probe out
@:probe_out()

end function geom_c0_to_proc

!----------------------------------------------------------------------
! Function: geom_c0_to_c0u
!> Conversion from global to universe on subset Sc0
!----------------------------------------------------------------------
function geom_c0_to_c0u(geom,ic0) result(ic0u)

implicit none

! Passed variables
class(geom_type),intent(in) :: geom !< Geometry
integer,intent(in) :: ic0           !< Global index

! Returned variable
integer :: ic0u

! Set name
@:set_name(geom_c0_to_c0u)

! Probe in
@:probe_in()

! Call generic function
ic0u = cx_to_cxu(geom%nproc,geom%proc_to_c0_offset,geom%proc_to_nc0a,geom%myuniverse,ic0)

! Probe out
@:probe_out()

end function geom_c0_to_c0u

end module type_geom
