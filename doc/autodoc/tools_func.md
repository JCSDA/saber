# Module tools_func

| Type | Name | Purpose | Arguments          |
| :--: | :--: | :------ | :----------------- |
| function | [fletcher32](https://github.com/JCSDA/saber/tree/develop/src/saber/bump/tools_func.F90#L50) | Fletcher-32 checksum algorithm | **var** :  Variable - real(kind_real) - in |
| subroutine | [lonlatmod](https://github.com/JCSDA/saber/tree/develop/src/saber/bump/tools_func.F90#L70) | set latitude between -pi/2 and pi/2 and longitude between -pi and pi | **lon** :  Longitude (radians) - real(kind_real) - inout<br>**lat** :  Latitude (radians) - real(kind_real) - inout |
| function | [lonlathash](https://github.com/JCSDA/saber/tree/develop/src/saber/bump/tools_func.F90#L101) | define a unique real from a lon/lat pair | **lon** :  Longitude (radians) - real(kind_real) - in<br>**lat** :  Latitude (radians) - real(kind_real) - in<br>**il** :  Level - integer - in |
| subroutine | [sphere_dist](https://github.com/JCSDA/saber/tree/develop/src/saber/bump/tools_func.F90#L133) | compute the great-circle distance between two points | **lon_i** :  Initial point longitude (radians) - real(kind_real) - in<br>**lat_i** :  Initial point latitude (radians) - real(kind_real) - in<br>**lon_f** :  Final point longitude (radians) - real(kind_real) - in<br>**lat_f** :  Final point longilatitudetude (radians) - real(kind_real) - in<br>**dist** :  Great-circle distance - real(kind_real) - out |
| subroutine | [reduce_arc](https://github.com/JCSDA/saber/tree/develop/src/saber/bump/tools_func.F90#L160) | reduce arc to a given distance | **lon_i** :  Initial point longitude (radians) - real(kind_real) - in<br>**lat_i** :  Initial point latitude (radians) - real(kind_real) - in<br>**lon_f** :  Final point longitude (radians) - real(kind_real) - inout<br>**lat_f** :  Final point latitude (radians) - real(kind_real) - inout<br>**maxdist** :  Maximum distance - real(kind_real) - in<br>**dist** :  Effective distance - real(kind_real) - out |
| subroutine | [lonlat2xyz](https://github.com/JCSDA/saber/tree/develop/src/saber/bump/tools_func.F90#L197) | convert longitude/latitude to cartesian coordinates | **mpl** :  MPI data - type(mpl_type) - inout<br>**lon** :  Longitude (radians) - real(kind_real) - in<br>**lat** :  Latitude (radians) - real(kind_real) - in<br>**x** :  X coordinate - real(kind_real) - out<br>**y** :  Y coordinate - real(kind_real) - out<br>**z** :  Z coordinate - real(kind_real) - out |
| subroutine | [xyz2lonlat](https://github.com/JCSDA/saber/tree/develop/src/saber/bump/tools_func.F90#L236) | convert longitude/latitude to cartesian coordinates | **mpl** :  MPI data - type(mpl_type) - in<br>**x** :  X coordinate - real(kind_real) - in<br>**y** :  Y coordinate - real(kind_real) - in<br>**z** :  Z coordinate - real(kind_real) - in<br>**lon** :  Longitude (radians) - real(kind_real) - out<br>**lat** :  Latitude (radians) - real(kind_real) - out |
| subroutine | [vector_product](https://github.com/JCSDA/saber/tree/develop/src/saber/bump/tools_func.F90#L270) | compute normalized vector product | **v1** :  First vector - real(kind_real) - in<br>**v2** :  Second vector - real(kind_real) - in<br>**vp** :  Vector product - real(kind_real) - out |
| subroutine | [vector_triple_product](https://github.com/JCSDA/saber/tree/develop/src/saber/bump/tools_func.F90#L299) | compute vector triple product | **v1** :  First vector - real(kind_real) - in<br>**v2** :  Second vector - real(kind_real) - in<br>**v3** :  Third vector - real(kind_real) - in<br>**p** :  Triple product - real(kind_real) - out<br>**cflag** :  Confidence flag - logical - out |
| subroutine | [add](https://github.com/JCSDA/saber/tree/develop/src/saber/bump/tools_func.F90#L337) | check if value missing and add if not missing | **mpl** :  MPI data - type(mpl_type) - in<br>**val** :  Value to add - real(kind_real) - in<br>**cumul** :  Cumul - real(kind_real) - inout<br>**num** :  Number of values - real(kind_real) - inout<br>**wgt** :  Weight - real(kind_real) - in |
| subroutine | [divide](https://github.com/JCSDA/saber/tree/develop/src/saber/bump/tools_func.F90#L365) | check if value missing and divide if not missing | **mpl** :  MPI data - type(mpl_type) - in<br>**val** :  Value to divide - real(kind_real) - inout<br>**num** :  Divider - real(kind_real) - in |
| subroutine | [fit_diag](https://github.com/JCSDA/saber/tree/develop/src/saber/bump/tools_func.F90#L395) | compute diagnostic fit function | **mpl** :  MPI data - type(mpl_type) - inout<br>**nc3** :  Number of classes - integer - in<br>**nl0r** :  Effective number of levels - integer - in<br>**nl0** :  Number of levels - integer - in<br>**l0rl0_to_l0** :  Effective level to level - integer - in<br>**disth** :  Horizontal distance - real(kind_real) - in<br>**distv** :  Vertical distance - real(kind_real) - in<br>**coef** :  Diagonal coefficient - real(kind_real) - in<br>**rh** :  Horizontal support radius - real(kind_real) - in<br>**rv** :  Vertical support radius - real(kind_real) - in<br>**fit** :  Fit - real(kind_real) - out |
| function | [gc99](https://github.com/JCSDA/saber/tree/develop/src/saber/bump/tools_func.F90#L562) | Gaspari and Cohn (1999) function, with the support radius as a parameter | **distnorm** :  Normalized distance - real(kind_real) - in |
| function | [fit_func](https://github.com/JCSDA/saber/tree/develop/src/saber/bump/tools_func.F90#L586) | fit_function | **mpl** :  MPI data - type(mpl_type) - inout<br>**distnorm** :  Normalized distance - real(kind_real) - in |
| subroutine | [fit_lct](https://github.com/JCSDA/saber/tree/develop/src/saber/bump/tools_func.F90#L625) | LCT fit | **mpl** :  MPI data - type(mpl_type) - inout<br>**nc** :  Number of classes - integer - in<br>**nl0** :  Number of levels - integer - in<br>**dxsq** :  Zonal separation squared - real(kind_real) - in<br>**dysq** :  Meridian separation squared - real(kind_real) - in<br>**dxdy** :  Zonal x meridian separations product - real(kind_real) - in<br>**dzsq** :  Vertical separation squared - real(kind_real) - in<br>**dmask** :  Mask - logical - in<br>**nscales** :  Number of LCT scales - integer - in<br>**D** :  LCT components - real(kind_real) - in<br>**coef** :  LCT coefficients - real(kind_real) - in<br>**fit** :  Fit - real(kind_real) - out |
| subroutine | [lct_d2h](https://github.com/JCSDA/saber/tree/develop/src/saber/bump/tools_func.F90#L693) | from D (Daley tensor) to H (local correlation tensor) | **mpl** :  MPI data - type(mpl_type) - inout<br>**D11** :  Daley tensor component 11 - real(kind_real) - in<br>**D22** :  Daley tensor component 22 - real(kind_real) - in<br>**D33** :  Daley tensor component 33 - real(kind_real) - in<br>**D12** :  Daley tensor component 12 - real(kind_real) - in<br>**H11** :  Local correlation tensor component 11 - real(kind_real) - out<br>**H22** :  Local correlation tensor component 22 - real(kind_real) - out<br>**H33** :  Local correlation tensor component 33 - real(kind_real) - out<br>**H12** :  Local correlation tensor component 12 - real(kind_real) - out |
| subroutine | [lct_h2r](https://github.com/JCSDA/saber/tree/develop/src/saber/bump/tools_func.F90#L733) | from H (local correlation tensor) to support radii | **mpl** :  MPI data - type(mpl_type) - inout<br>**H11** :  Local correlation tensor component 11 - real(kind_real) - in<br>**H22** :  Local correlation tensor component 22 - real(kind_real) - in<br>**H33** :  Local correlation tensor component 33 - real(kind_real) - in<br>**H12** :  Local correlation tensor component 12 - real(kind_real) - in<br>**rh** :  Horizontal support radius - real(kind_real) - out<br>**rv** :  Vertical support radius - real(kind_real) - out |
| subroutine | [lct_r2d](https://github.com/JCSDA/saber/tree/develop/src/saber/bump/tools_func.F90#L779) | from support radius to Daley tensor diagonal element | **r** :  Support radius - real(kind_real) - in<br>**D** :  Daley tensor diagonal element - real(kind_real) - out |
| subroutine | [check_cond](https://github.com/JCSDA/saber/tree/develop/src/saber/bump/tools_func.F90#L798) | check tensor conditioning | **d1** :  First diagonal coefficient - real(kind_real) - in<br>**d2** :  Second diagonal coefficient - real(kind_real) - in<br>**nod** :  Normalized off-diagonal coefficient - real(kind_real) - in<br>**valid** :  Conditioning validity - logical - out |
| function | [matern](https://github.com/JCSDA/saber/tree/develop/src/saber/bump/tools_func.F90#L838) | compute the normalized diffusion function from eq. (55) of Mirouze and Weaver (2013), for the 3d case (d = 3) | **mpl** :  MPI data - type(mpl_type) - inout<br>**M** :  Matern function order - integer - in<br>**x** :  Argument - real(kind_real) - in |
| subroutine | [cholesky](https://github.com/JCSDA/saber/tree/develop/src/saber/bump/tools_func.F90#L884) | compute cholesky decomposition | **mpl** :  MPI data - type(mpl_type) - inout<br>**n** :  Matrix rank - integer - in<br>**a** :  Matrix - real(kind_real) - in<br>**u** :  Matrix square-root - real(kind_real) - out<br>**ierr** :  Error status - integer - out |
| subroutine | [syminv](https://github.com/JCSDA/saber/tree/develop/src/saber/bump/tools_func.F90#L937) | compute inverse of a symmetric matrix | **mpl** :  MPI data - type(mpl_type) - inout<br>**n** :  Matrix rank - integer - in<br>**a** :  Matrix - real(kind_real) - in<br>**c** :  Matrix inverse - real(kind_real) - out<br>**ierr** :  Error status - integer - out |
| subroutine | [histogram](https://github.com/JCSDA/saber/tree/develop/src/saber/bump/tools_func.F90#L992) | compute bins and histogram from a list of values | **mpl** :  MPI data - type(mpl_type) - inout<br>**nlist** :  List size - integer - in<br>**list** :  List - real(kind_real) - in<br>**nbins** :  Number of bins - integer - in<br>**histmin** :  Histogram minimum - real(kind_real) - in<br>**histmax** :  Histogram maximum - real(kind_real) - in<br>**bins** :  Bins - real(kind_real) - out<br>**hist** :  Histogram - real(kind_real) - out |
